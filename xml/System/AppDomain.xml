<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="AppDomain.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c3ab234edad8a65f7b4b6688da32990c9642f79d.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c3ab234edad8a65f7b4b6688da32990c9642f79d</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Represents an application domain, which is an isolated environment where applications execute.</source>
          <target state="translated">Rappresenta un dominio applicazione, ossia un ambiente isolato nel quale vengono eseguite le applicazioni.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>This class cannot be inherited.</source>
          <target state="translated">Questa classe non può essere ereditata.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Application domains, which are represented by <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> objects, help provide isolation, unloading, and security boundaries for executing managed code.</source>
          <target state="translated">Domini applicazione, che sono rappresentati da <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> oggetti, forniscono i limiti di isolamento, scaricamento e sicurezza per l'esecuzione di codice gestito.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Use application domains to isolate tasks that might bring down a process.</source>
          <target state="translated">Utilizzare i domini applicazione per isolare le operazioni che potrebbero arrestare un processo.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>If the state of the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> that's executing a task becomes unstable, the <ph id="ph2">&lt;xref:System.AppDomain&gt;</ph> can be unloaded without affecting the process.</source>
          <target state="translated">Se lo stato del <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> che esegue un'attività diventa instabile, il <ph id="ph2">&lt;xref:System.AppDomain&gt;</ph> possono essere scaricati senza interferire con il processo.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>This is important when a process must run for long periods without restarting.</source>
          <target state="translated">Questo è importante quando è necessario eseguire un processo per lunghi periodi senza riavviare il computer.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>You can also use application domains to isolate tasks that should not share data.</source>
          <target state="translated">È anche possibile utilizzare domini applicazione per isolare le operazioni che non devono condividere dati.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>If an assembly is loaded into the default application domain, it cannot be unloaded from memory while the process is running.</source>
          <target state="translated">Se un assembly viene caricato nel dominio applicazione predefinito, non può essere scaricato dalla memoria mentre il processo è in esecuzione.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>However, if you open a second application domain to load and execute the assembly, the assembly is unloaded when that application domain is unloaded.</source>
          <target state="translated">Tuttavia, se si apre un secondo dominio di applicazione da caricare ed eseguire l'assembly, l'assembly viene scaricato quando tale dominio applicazione viene scaricato.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Use this technique to minimize the working set of long-running processes that occasionally use large DLLs.</source>
          <target state="translated">Utilizzare questa tecnica per ridurre al minimo il working set di processi a esecuzione prolungata che talvolta utilizzano DLL di grandi dimensioni.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Multiple application domains can run in a single process; however, there is not a one-to-one correlation between application domains and threads.</source>
          <target state="translated">Più domini applicazione è possono eseguire su un singolo processo. Tuttavia, non c'è un relazione uno a uno tra domini applicazione e thread.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Several threads can belong to a single application domain, and while a given thread is not confined to a single application domain, at any given time, a thread executes in a single application domain.</source>
          <target state="translated">Più thread può appartenere a un singolo dominio applicazione e durante un determinato thread non è limitato a un singolo dominio applicazione, in qualsiasi momento, un thread viene eseguito in un singolo dominio applicazione.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Application domains are created using the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> method.</source>
          <target state="translated">Domini applicazione vengono creati utilizzando il <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source><ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> instances are used to load and execute assemblies (<ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> le istanze vengono utilizzate per caricare ed eseguire assembly (<ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>When an <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> is no longer in use, it can be unloaded.</source>
          <target state="translated">Quando un <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> è non è più in uso, può essere scaricato.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> class implements a set of events that enable applications to respond when an assembly is loaded, when an application domain will be unloaded, or when an unhandled exception is thrown.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> implementa un set di eventi che consentono alle applicazioni di rispondere quando viene caricato un assembly, quando un dominio applicazione verrà scaricato o quando viene generata un'eccezione non gestita.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>For more information on using application domains, see <bpt id="p1">[</bpt>Application Domains<ept id="p1">](~/docs/framework/app-domains/application-domains.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sull'utilizzo dei domini applicazione, vedere <bpt id="p1">[</bpt>domini applicazione<ept id="p1">](~/docs/framework/app-domains/application-domains.md)</ept>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>This class implements the <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph>, <ph id="ph2">&lt;xref:System._AppDomain&gt;</ph>, and <ph id="ph3">&lt;xref:System.Security.IEvidenceFactory&gt;</ph> interfaces.</source>
          <target state="translated">Questa classe implementa il <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph>, <ph id="ph2">&lt;xref:System._AppDomain&gt;</ph>, e <ph id="ph3">&lt;xref:System.Security.IEvidenceFactory&gt;</ph> interfacce.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>You should never create a remotable wrapper for an <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> object.</source>
          <target state="translated">È consigliabile non creare mai un wrapper di utilizzabile in remoto per un <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Doing so could publish a remote reference to that <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, exposing methods such as <ph id="ph2">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> to remote access and effectively destroying code access security for that <ph id="ph3">&lt;xref:System.AppDomain&gt;</ph>.</source>
          <target state="translated">In questo modo è possibile pubblicare un riferimento a quello remoto <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, esporre metodi, ad esempio <ph id="ph2">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> accesso remoto e dell'oggetto sicurezza dall'accesso di codice che <ph id="ph3">&lt;xref:System.AppDomain&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Malicious clients connecting to the remoted <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> could obtain access to any resource the <ph id="ph2">&lt;xref:System.AppDomain&gt;</ph> itself has access to.</source>
          <target state="translated">Client non autorizzati di connessione per la modalità remota <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> è stato possibile accedere a qualsiasi risorsa di <ph id="ph2">&lt;xref:System.AppDomain&gt;</ph> a sua volta ha accesso a.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>Do not create remotable wrappers for any type that extends <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph> and that implements methods that could be used by malicious clients to bypass the security system.</source>
          <target state="translated">Non creare wrapper utilizzabile in remoto per qualsiasi tipo che estende <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph> e che implementa metodi che potrebbero essere utilizzati da client non autorizzati di ignorare il sistema di sicurezza.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>The default value for the <ph id="ph1">&lt;xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType&gt;</ph> property is <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Il valore predefinito per il <ph id="ph1">&lt;xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType&gt;</ph> proprietà <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>This setting is unsafe for services.</source>
          <target state="translated">Questa impostazione è sicura per i servizi.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>To prevent services from downloading partially trusted code, set this property to <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Per impedire a servizi di scaricare codice parzialmente attendibile, impostare questa proprietà su <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>This example shows how to create a new <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, instantiate a type in that new <ph id="ph2">&lt;xref:System.AppDomain&gt;</ph>, and communicate with that type’s object.</source>
          <target state="translated">In questo esempio viene illustrato come creare un nuovo <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>, creare un'istanza di un tipo nel nuovo <ph id="ph2">&lt;xref:System.AppDomain&gt;</ph>e comunicare con l'oggetto di quel tipo.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.AppDomain">
          <source>In addition, this example shows how to unload the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> causing the object to be garbage collected.</source>
          <target state="translated">Inoltre, in questo esempio viene illustrato come scaricare il <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> causando l'oggetto di garbage collection.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="P:System.AppDomain.ActivationContext">
          <source>Gets the activation context for the current application domain.</source>
          <target state="translated">Ottiene il contesto di attivazione del dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ActivationContext">
          <source>An object that represents the activation context for the current application domain, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the domain has no activation context.</source>
          <target state="translated">Oggetto che rappresenta il contesto di attivazione del dominio dell'applicazione corrente o <ph id="ph1">&lt;see langword="null" /&gt;</ph> se al dominio non è associato alcun contesto di attivazione.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ActivationContext">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ActivationContext">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>The name of the directory to be appended to the private path.</source>
          <target state="translated">Nome della directory da aggiungere al percorso privato.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>Appends the specified directory name to the private path list.</source>
          <target state="translated">Aggiunge il nome di directory specificato all'elenco di percorsi privati.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>The use of this property is not recommended, because it might change the probing path for assemblies after they have already been loaded.</source>
          <target state="translated">L'utilizzo di questa proprietà è sconsigliato, perché potrebbe modificare il percorso di sondaggio per gli assembly dopo che sono già stati caricati.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>Use the <ph id="ph1">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType&gt;</ph> property instead.</source>
          <target state="translated">In alternativa, usare la proprietà <ph id="ph1">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>The private path, or relative search path, is the path relative to the base directory where the assembly resolver probes for private assemblies.</source>
          <target state="translated">Il percorso privato o il percorso di ricerca relativo, è il percorso relativo alla directory di base in cui il resolver dell'assembly viene eseguita la ricerca degli assembly privati.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.AppendPrivatePath(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="P:System.AppDomain.ApplicationIdentity">
          <source>Gets the identity of the application in the application domain.</source>
          <target state="translated">Ottiene l'identità dell'applicazione nel dominio applicazione.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ApplicationIdentity">
          <source>An object that identifies the application in the application domain.</source>
          <target state="translated">Oggetto che identifica l'applicazione nel dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ApplicationIdentity">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ApplicationIdentity">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="P:System.AppDomain.ApplicationTrust">
          <source>Gets information describing permissions granted to an application and whether the application has a trust level that allows it to run.</source>
          <target state="translated">Ottiene informazioni che descrivono le autorizzazioni concesse a un'applicazione e che consentono di stabilire se all'applicazione è associato un livello di attendibilità che ne consente l'esecuzione.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ApplicationTrust">
          <source>An object that encapsulates permission and trust information for the application in the application domain.</source>
          <target state="translated">Oggetto che incapsula informazioni sulle autorizzazioni e sull'attendibilità relative all'applicazione nel dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ApplicationTrust">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ApplicationTrust">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ApplyPolicy(System.String)">
          <source>The assembly display name, in the form provided by the <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nome visualizzato dell'assembly, nel formato fornito dalla proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ApplyPolicy(System.String)">
          <source>Returns the assembly display name after policy has been applied.</source>
          <target state="translated">Restituisce il nome visualizzato dell'assembly dopo l'applicazione dei criteri.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ApplyPolicy(System.String)">
          <source>A string containing the assembly display name after policy has been applied.</source>
          <target state="translated">Stringa contenente il nome visualizzato dell'assembly dopo l'applicazione dei criteri.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ApplyPolicy(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ApplyPolicy%2A&gt;</ph> method takes an assembly display name and returns the post-policy display name.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.AppDomain.ApplyPolicy%2A&gt;</ph> visualizzati il nome di metodo richiede un assembly e restituisce il nome visualizzato di post-criteri.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ApplyPolicy(System.String)">
          <source>This is useful if you need to load an assembly using policy, because the reflection-only context does not apply policy.</source>
          <target state="translated">Ciò è utile se è necessario caricare un assembly mediante i criteri, in quanto il contesto reflection-only non applica i criteri.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="E:System.AppDomain.AssemblyLoad">
          <source>Occurs when an assembly is loaded.</source>
          <target state="translated">Si verifica al caricamento di un assembly.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>The <ph id="ph1">&lt;xref:System.AssemblyLoadEventHandler&gt;</ph> delegate for this event indicates what assembly was loaded.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.AssemblyLoadEventHandler&gt;</ph> delegato per questo evento indica quale assembly è stato caricato.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>To register an event handler for this event, you must have the required permissions, or a <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown.</source>
          <target state="translated">Per registrare un gestore eventi per questo evento, è necessario disporre delle autorizzazioni necessarie, o un <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla gestione degli eventi, vedere <bpt id="p1">[</bpt>gestione e generazione di eventi<ept id="p1">](~/docs/standard/events/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.AssemblyLoad&gt;</ph> event.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.AppDomain.AssemblyLoad&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Per informazioni su come ottenere il nome completo dell'assembly, vedere <bpt id="p1">[</bpt>i nomi degli Assembly<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyLoad">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="E:System.AppDomain.AssemblyResolve">
          <source>Occurs when the resolution of an assembly fails.</source>
          <target state="translated">Si verifica quando la risoluzione di un assembly ha esito negativo.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>It is the responsibility of the <ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph> for this event to return the assembly that is specified by the <ph id="ph2">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph> property, or to return null if the assembly is not recognized.</source>
          <target state="translated">È responsabilità del <ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph> per questo evento per l'assembly specificato dal <ph id="ph2">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph> , proprietà o per restituire null se l'assembly non è riconosciuto.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>The assembly must be loaded into an execution context; if it is loaded into the reflection-only context, the load that caused this event to be raised fails.</source>
          <target state="translated">L'assembly deve essere caricato in un contesto di esecuzione. Se viene caricato nel contesto reflection-only, il carico che ha causato l'evento da generare.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>For guidance on the use of this event, see <bpt id="p1">[</bpt>Resolving Assembly Loads<ept id="p1">](~/docs/framework/app-domains/resolve-assembly-loads.md)</ept>.</source>
          <target state="translated">Per istruzioni sull'utilizzo di questo evento, vedere <bpt id="p1">[</bpt>Risoluzione caricamenti Assembly<ept id="p1">](~/docs/framework/app-domains/resolve-assembly-loads.md)</ept>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph> property returns the assembly that requested the assembly load that could not be resolved.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, <ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph> proprietà restituisce l'assembly che ha richiesto il caricamento dell'assembly che non può essere risolto.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>For example, the loader might be unable to load a dependency of the requesting assembly because the requesting assembly and its dependency are not in the probing path.</source>
          <target state="translated">Ad esempio, il caricatore potrebbe essere in grado di caricare una dipendenza dell'assembly richiesta perché l'assembly richiedente e la relativa dipendenza non sono nel percorso di sondaggio.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>Knowing the identity of the requesting assembly might be useful in locating the dependency or in identifying the correct version, if more than one version of the dependency is available.</source>
          <target state="translated">Conoscere l'identità dell'assembly richiedente potrebbe essere utile individuare la dipendenza o identificare la versione corretta, se è disponibile più di una versione della dipendenza.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>For more information, see <ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.ResolveEventHandler&gt;</ph> event is raised for all assemblies, including resource assemblies.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, <ph id="ph2">&lt;xref:System.ResolveEventHandler&gt;</ph> evento viene generato per tutti gli assembly, inclusi gli assembly di risorse.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>In earlier versions, the event was not raised for resource assemblies.</source>
          <target state="translated">Nelle versioni precedenti, l'evento non è stato generato per gli assembly di risorse.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>If the operating system is localized, the handler might be called multiple times: once for each culture in the fallback chain.</source>
          <target state="translated">Se il sistema operativo localizzato, il gestore può essere chiamato più volte: una volta per ogni impostazione cultura nella catena di fallback.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>For this event, the <ph id="ph1">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph> property returns the assembly name before policy is applied.</source>
          <target state="translated">Per questo evento, il <ph id="ph1">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph> proprietà restituisce il nome dell'assembly prima di applicare criteri.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>If more than one event handler is registered for this event, the event handlersarecalled in order until an event handler returns a value that isn't <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Se più di un gestore dell'evento viene registrato per questo evento, l'evento handlersarecalled in ordine fino a quando un gestore eventi restituisce un valore che non è <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>Subsequent event handlers are ignored.</source>
          <target state="translated">Gestori di eventi successivi vengono ignorati.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla gestione degli eventi, vedere <bpt id="p1">[</bpt>gestione e generazione di eventi<ept id="p1">](~/docs/standard/events/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Per informazioni su come ottenere il nome completo dell'assembly, vedere <bpt id="p1">[</bpt>i nomi degli Assembly<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.AssemblyResolve">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="P:System.AppDomain.BaseDirectory">
          <source>Gets the base directory that the assembly resolver uses to probe for assemblies.</source>
          <target state="translated">Ottiene la directory di base usata dal resolver dell'assembly per verificare la presenza di assembly.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.BaseDirectory">
          <source>The base directory that the assembly resolver uses to probe for assemblies.</source>
          <target state="translated">Directory di base usata dal resolver dell'assembly per verificare la presenza di assembly.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.BaseDirectory">
          <source>This property corresponds to the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Questa proprietà corrisponde al <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.BaseDirectory">
          <source>It can also be retrieved using the <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method with the string "APPBASE".</source>
          <target state="translated">Può anche essere recuperato tramite il <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> (metodo) con la stringa "APPBASE".</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.BaseDirectory">
          <source>The following code example creates a new application domain, specifying a base directory to use when searching for assemblies to load into the domain.</source>
          <target state="translated">Esempio di codice seguente crea un nuovo dominio applicazione, specificare una directory di base da utilizzare per la ricerca degli assembly da caricare nel dominio.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.BaseDirectory">
          <source>The example then uses the <ph id="ph1">&lt;xref:System.AppDomain.BaseDirectory%2A&gt;</ph> property to obtain the base directory path, for display to the console.</source>
          <target state="translated">Nell'esempio viene utilizzata la <ph id="ph1">&lt;xref:System.AppDomain.BaseDirectory%2A&gt;</ph> proprietà per ottenere il percorso della directory di base per la visualizzazione nella console.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="P:System.AppDomain.BaseDirectory">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.BaseDirectory">
          <source>for access to the information in the path itself, including if the path is in the form "file://" or <ph id="ph1">\\</ph>\UNC\dir or "c:<ph id="ph2">\\</ph>".</source>
          <target state="translated">Per accedere alle informazioni presenti nel percorso stesso, inclusi il percorso è nel formato "file://" o <ph id="ph1">\\</ph>\UNC\dir o "c:<ph id="ph2">\\</ph>".</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.BaseDirectory">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ClearPrivatePath">
          <source>Resets the path that specifies the location of private assemblies to the empty string ("").</source>
          <target state="translated">Reimposta su stringa vuota ("") il percorso che specifica la posizione degli assembly privati.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearPrivatePath">
          <source>The private path is a path relative to the base directory that the common language runtime searches to locate private assemblies.</source>
          <target state="translated">Il percorso privato è un percorso relativo alla directory di base che common language runtime cerca gli assembly privati.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearPrivatePath">
          <source>For more information, see <ph id="ph1">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <ph id="ph1">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearPrivatePath">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.AppDomain.ClearPrivatePath%2A&gt;</ph> method to remove all entries from the list of private paths to search when assemblies are loaded.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.AppDomain.ClearPrivatePath%2A&gt;</ph> metodo per rimuovere tutte le voci dall'elenco di percorsi privati per la ricerca quando gli assembly vengono caricati.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearPrivatePath">
          <source>This method is now obsolete, and should not be used for new development.</source>
          <target state="translated">Questo metodo è obsoleto e non deve essere utilizzato per nuove attività di sviluppo.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ClearPrivatePath">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearPrivatePath">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearPrivatePath">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ClearShadowCopyPath">
          <source>Resets the list of directories containing shadow copied assemblies to the empty string ("").</source>
          <target state="translated">Reimposta su stringa vuota ("") l'elenco di directory contenenti assembly replicati mediante copia shadow.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearShadowCopyPath">
          <source>The shadow copy path is a list of directories where shadow copied assemblies are stored.</source>
          <target state="translated">Il percorso della copia shadow è un elenco di directory in cui replicati gli assembly vengono archiviati.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearShadowCopyPath">
          <source>For more information, see <ph id="ph1">&lt;xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType&gt;</ph> and <bpt id="p1">[</bpt>Shadow Copying Assemblies<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <ph id="ph1">&lt;xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType&gt;</ph> e <bpt id="p1">[</bpt>copie Shadow di assembly<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ClearShadowCopyPath">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearShadowCopyPath">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ClearShadowCopyPath">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Creates a new instance of a specified COM type.</source>
          <target state="translated">Crea una nuova istanza di un tipo COM specificato.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The name of a file containing an assembly that defines the requested type.</source>
          <target state="translated">Nome di un file contenente un assembly che definisce il tipo richiesto.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The name of the requested type.</source>
          <target state="translated">Nome del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>Creates a new instance of a specified COM type.</source>
          <target state="translated">Crea una nuova istanza di un tipo COM specificato.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</source>
          <target state="translated">I parametri specificano il nome di un file contenente un assembly che, a sua volta, contiene il tipo e il nome del tipo.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>An object that is a wrapper for the new instance specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">Oggetto che rappresenta un wrapper per la nuova istanza specificata da <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>Use this method to create objects remotely without having to load the type locally.</source>
          <target state="translated">Utilizzare questo metodo per creare oggetti in modalità remota senza dover caricare il tipo in locale.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The return value must to be unwrapped to access the real object.</source>
          <target state="translated">Il valore restituito deve per essere annullato il wrapping per accedere all'oggetto reale.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>A <ph id="ph1">&lt;xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType&gt;</ph> attribute with a value of <ph id="ph2">`true`</ph> must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph> is thrown.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType&gt;</ph> attributo con un valore di <ph id="ph2">`true`</ph> è necessario applicare in modo esplicito o per impostazione predefinita per il tipo COM per questo metodo per creare un'istanza di quel tipo; in caso contrario, <ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The following sample demonstrates</source>
          <target state="translated">Nell'esempio seguente viene illustrato</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> o <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The type cannot be loaded.</source>
          <target state="translated">Non è possibile caricare il tipo.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>No public parameterless constructor was found.</source>
          <target state="translated">Non è stato trovato alcun costruttore pubblico senza parametri.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non trovata.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is an abstract class.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> è una classe astratta.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>This member was invoked with a late-binding mechanism.</source>
          <target state="translated">Questo membro è stato richiamato con un meccanismo di associazione tardiva.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è una stringa vuota ("").</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>The COM object that is being referred to is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'oggetto COM cui viene fatto riferimento è <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Per poter leggere il file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The name of a file containing an assembly that defines the requested type.</source>
          <target state="translated">Nome di un file contenente un assembly che definisce il tipo richiesto.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The name of the requested type.</source>
          <target state="translated">Nome del tipo richiesto.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Represents the value of the computed hash code.</source>
          <target state="translated">Rappresenta il valore del codice hash calcolato.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Represents the hash algorithm used by the assembly manifest.</source>
          <target state="translated">Rappresenta l'algoritmo hash usato dal manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Creates a new instance of a specified COM type.</source>
          <target state="translated">Crea una nuova istanza di un tipo COM specificato.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</source>
          <target state="translated">I parametri specificano il nome di un file contenente un assembly che, a sua volta, contiene il tipo e il nome del tipo.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>An object that is a wrapper for the new instance specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">Oggetto che rappresenta un wrapper per la nuova istanza specificata da <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Use this method to create objects remotely without having to load the type locally.</source>
          <target state="translated">Utilizzare questo metodo per creare oggetti in modalità remota senza dover caricare il tipo in locale.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The return value must to be unwrapped to access the real object.</source>
          <target state="translated">Il valore restituito deve per essere annullato il wrapping per accedere all'oggetto reale.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>A <ph id="ph1">&lt;xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType&gt;</ph> attribute with a value of <ph id="ph2">`true`</ph> must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph> is thrown.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType&gt;</ph> attributo con un valore di <ph id="ph2">`true`</ph> è necessario applicare in modo esplicito o per impostazione predefinita per il tipo COM per questo metodo per creare un'istanza di quel tipo; in caso contrario, <ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> o <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The type cannot be loaded.</source>
          <target state="translated">Non è possibile caricare il tipo.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>No public parameterless constructor was found.</source>
          <target state="translated">Non è stato trovato alcun costruttore pubblico senza parametri.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non trovata.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is an abstract class.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> è una classe astratta.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This member was invoked with a late-binding mechanism.</source>
          <target state="translated">Questo membro è stato richiamato con un meccanismo di associazione tardiva.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is the empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è la stringa vuota ("").</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The COM object that is being referred to is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">L'oggetto COM cui viene fatto riferimento è <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Per poter leggere il file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Creates a new application domain.</source>
          <target state="translated">Crea un nuovo dominio applicazione.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>The friendly name of the domain.</source>
          <target state="translated">Nome descrittivo del dominio.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>Creates a new application domain with the specified name.</source>
          <target state="translated">Crea un nuovo dominio applicazione con il nome specificato.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>The newly created application domain.</source>
          <target state="translated">Dominio applicazione appena creato.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>The <ph id="ph1">`friendlyName`</ph> parameter is intended to identify the domain in a manner that is meaningful to humans.</source>
          <target state="translated">Il <ph id="ph1">`friendlyName`</ph> parametro ha lo scopo di identificare il dominio in modo significativo per gli utenti.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>This string should be suitable for display in user interfaces.</source>
          <target state="translated">Questa stringa deve essere adatta per la visualizzazione nelle interfacce utente.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>This method overload uses the <ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph> information from the default application domain.</source>
          <target state="translated">Questo overload del metodo utilizza il <ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph> informazioni dal dominio applicazione predefinito.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>The following sample demonstrates, in general, how to create a domain using one of the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> overloads.</source>
          <target state="translated">L'esempio seguente viene illustrato, in generale, come creare un dominio utilizzando uno del <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> overload.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>to provide evidence.</source>
          <target state="translated">per fornire l'evidenza.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>The friendly name of the domain.</source>
          <target state="translated">Nome descrittivo del dominio.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>This friendly name can be displayed in user interfaces to identify the domain.</source>
          <target state="translated">Questo nome descrittivo può essere visualizzato nelle interfacce utente per identificare il dominio.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>Evidence that establishes the identity of the code that runs in the application domain.</source>
          <target state="translated">Evidenza che stabilisce l'identità del codice che viene eseguito nel dominio applicazione.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>Pass <ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the evidence of the current application domain.</source>
          <target state="translated">Passare <ph id="ph1">&lt;see langword="null" /&gt;</ph> per usare l'evidenza del dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>Creates a new application domain with the given name using the supplied evidence.</source>
          <target state="translated">Crea un nuovo dominio applicazione con il nome specificato usando l'evidenza fornita.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>The newly created application domain.</source>
          <target state="translated">Dominio applicazione appena creato.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>This method overload uses the <ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph> information from the default application domain.</source>
          <target state="translated">Questo overload del metodo utilizza il <ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph> informazioni dal dominio applicazione predefinito.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>If <ph id="ph1">`securityInfo`</ph> is not supplied, the evidence from the current application domain is used.</source>
          <target state="translated">Se <ph id="ph1">`securityInfo`</ph> viene omesso, viene utilizzato l'evidenza del dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>Do not use this method overload to create sandboxed application domains.</source>
          <target state="translated">Non utilizzare questo overload del metodo per creare i domini di applicazione creato mediante sandbox.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the evidence that is supplied for <ph id="ph2">`securityInfo`</ph> no longer affects the grant set of the application domain.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, l'evidenza fornita per <ph id="ph2">`securityInfo`</ph> non influiscono più set di concessioni del dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>Use the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph> method overload to create sandboxed application domains.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph> overload del metodo per creare i domini di applicazione creato mediante sandbox.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>The following sample demonstrates, in general, how to create a domain using one of the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> overloads.</source>
          <target state="translated">L'esempio seguente viene illustrato, in generale, come creare un dominio utilizzando uno del <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> overload.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>to provide evidence.</source>
          <target state="translated">per fornire l'evidenza.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>The friendly name of the domain.</source>
          <target state="translated">Nome descrittivo del dominio.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>This friendly name can be displayed in user interfaces to identify the domain.</source>
          <target state="translated">Questo nome descrittivo può essere visualizzato nelle interfacce utente per identificare il dominio.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>Evidence that establishes the identity of the code that runs in the application domain.</source>
          <target state="translated">Evidenza che stabilisce l'identità del codice che viene eseguito nel dominio applicazione.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>Pass <ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the evidence of the current application domain.</source>
          <target state="translated">Passare <ph id="ph1">&lt;see langword="null" /&gt;</ph> per usare l'evidenza del dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>An object that contains application domain initialization information.</source>
          <target state="translated">Oggetto contenente informazioni relative all'inizializzazione del dominio applicazione.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>Creates a new application domain using the specified name, evidence, and application domain setup information.</source>
          <target state="translated">Crea un nuovo dominio applicazione usando il nome, l'evidenza e le informazioni di installazione del dominio applicazione specificati.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>The newly created application domain.</source>
          <target state="translated">Dominio applicazione appena creato.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>If <ph id="ph1">`info`</ph> is not supplied, this method overload uses the <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> information from the default application domain.</source>
          <target state="translated">Se <ph id="ph1">`info`</ph> viene omesso, viene utilizzato questo overload del metodo di <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> informazioni dal dominio applicazione predefinito.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>If <ph id="ph1">`securityInfo`</ph> is not supplied, the evidence from the current application domain is used.</source>
          <target state="translated">Se <ph id="ph1">`securityInfo`</ph> viene omesso, viene utilizzato l'evidenza del dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>Do not use this method overload to create sandboxed application domains.</source>
          <target state="translated">Non utilizzare questo overload del metodo per creare i domini di applicazione creato mediante sandbox.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the evidence that is supplied for <ph id="ph2">`securityInfo`</ph> no longer affects the grant set of the application domain.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, l'evidenza fornita per <ph id="ph2">`securityInfo`</ph> non influiscono più set di concessioni del dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>Use the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph> method overload to create sandboxed application domains.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph> overload del metodo per creare i domini di applicazione creato mediante sandbox.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>The following sample demonstrates, in general, how to create a domain using one of the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> overloads.</source>
          <target state="translated">L'esempio seguente viene illustrato, in generale, come creare un dominio utilizzando uno del <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> overload.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>to provide evidence.</source>
          <target state="translated">per fornire l'evidenza.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>The friendly name of the domain.</source>
          <target state="translated">Nome descrittivo del dominio.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>This friendly name can be displayed in user interfaces to identify the domain.</source>
          <target state="translated">Questo nome descrittivo può essere visualizzato nelle interfacce utente per identificare il dominio.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>For more information, see the description of <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</source>
          <target state="translated">Per altre informazioni, vedere la descrizione dell'oggetto <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>Evidence that establishes the identity of the code that runs in the application domain.</source>
          <target state="translated">Evidenza che stabilisce l'identità del codice che viene eseguito nel dominio applicazione.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>Pass <ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the evidence of the current application domain.</source>
          <target state="translated">Passare <ph id="ph1">&lt;see langword="null" /&gt;</ph> per usare l'evidenza del dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>An object that contains application domain initialization information.</source>
          <target state="translated">Oggetto contenente informazioni relative all'inizializzazione del dominio applicazione.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>A default permission set that is granted to all assemblies loaded into the new application domain that do not have specific grants.</source>
          <target state="translated">Set di autorizzazioni predefinito concesso a tutti gli assembly caricati nel nuovo dominio applicazione a cui non sono concesse autorizzazioni specifiche.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>An array of strong names representing assemblies to be considered fully trusted in the new application domain.</source>
          <target state="translated">Matrice di nomi sicuri che rappresentano gli assembly da considerare come completamente attendibili nel nuovo dominio applicazione.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>Creates a new application domain using the specified name, evidence, application domain setup information, default permission set, and array of fully trusted assemblies.</source>
          <target state="translated">Crea un nuovo dominio applicazione usando il nome, l'evidenza, le informazioni di impostazione del dominio applicazione, il set di autorizzazioni predefinito e la matrice di assembly completamente attendibili specificati.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>The newly created application domain.</source>
          <target state="translated">Dominio applicazione appena creato.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>You must set the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> object that you supply for <ph id="ph3">`info`</ph>.</source>
          <target state="translated">È necessario impostare il <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationBase%2A&gt;</ph> proprietà del <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> oggetto che viene fornito per <ph id="ph3">`info`</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>Otherwise, an exception is thrown.</source>
          <target state="translated">In caso contrario, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>If <ph id="ph1">`securityInfo`</ph> is not supplied, the evidence from the current application domain is used.</source>
          <target state="translated">Se <ph id="ph1">`securityInfo`</ph> viene omesso, viene utilizzato l'evidenza del dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>The information provided for <ph id="ph1">`grantSet`</ph> and <ph id="ph2">`fullTrustAssemblies`</ph> is used to create an <ph id="ph3">&lt;xref:System.Security.Policy.ApplicationTrust&gt;</ph> object for the new application domain.</source>
          <target state="translated">Le informazioni fornite per <ph id="ph1">`grantSet`</ph> e <ph id="ph2">`fullTrustAssemblies`</ph> viene utilizzato per creare un <ph id="ph3">&lt;xref:System.Security.Policy.ApplicationTrust&gt;</ph> oggetto per il nuovo dominio applicazione.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>The application domain is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il dominio applicazione è <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>The <ph id="ph1">&lt;see cref="P:System.AppDomainSetup.ApplicationBase" /&gt;</ph> property is not set on the <ph id="ph2">&lt;see cref="T:System.AppDomainSetup" /&gt;</ph> object that is supplied for <ph id="ph3">&lt;paramref name="info" /&gt;</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see cref="P:System.AppDomainSetup.ApplicationBase" /&gt;</ph> non è impostata sull'oggetto <ph id="ph2">&lt;see cref="T:System.AppDomainSetup" /&gt;</ph> fornito per <ph id="ph3">&lt;paramref name="info" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>for the ability to create and manipulate an application domain.</source>
          <target state="translated">Per poter creare e modificare un dominio applicazione.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Azione di sicurezza: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>The friendly name of the domain.</source>
          <target state="translated">Nome descrittivo del dominio.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>This friendly name can be displayed in user interfaces to identify the domain.</source>
          <target state="translated">Questo nome descrittivo può essere visualizzato nelle interfacce utente per identificare il dominio.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>Evidence that establishes the identity of the code that runs in the application domain.</source>
          <target state="translated">Evidenza che stabilisce l'identità del codice che viene eseguito nel dominio applicazione.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>Pass <ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the evidence of the current application domain.</source>
          <target state="translated">Passare <ph id="ph1">&lt;see langword="null" /&gt;</ph> per usare l'evidenza del dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>The base directory that the assembly resolver uses to probe for assemblies.</source>
          <target state="translated">Directory di base usata dal resolver dell'assembly per verificare la presenza di assembly.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.BaseDirectory" /&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <ph id="ph1">&lt;see cref="P:System.AppDomain.BaseDirectory" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>The path relative to the base directory where the assembly resolver should probe for private assemblies.</source>
          <target state="translated">Percorso relativo alla directory di base in cui deve essere verificata la presenza di assembly privati mediante il resolver degli assembly.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.RelativeSearchPath" /&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <ph id="ph1">&lt;see cref="P:System.AppDomain.RelativeSearchPath" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, a shadow copy of an assembly is loaded into this application domain.</source>
          <target state="translated">Se <ph id="ph1">&lt;see langword="true" /&gt;</ph>, nel dominio applicazione verrà caricata la copia shadow di un assembly.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</source>
          <target state="translated">Crea un nuovo dominio applicazione con il nome indicato mediante un'evidenza, un percorso base dell'applicazione, un percorso di ricerca relativo e un parametro che specifica se nel dominio applicazione deve essere caricata la copia shadow di un assembly.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>The newly created application domain.</source>
          <target state="translated">Dominio applicazione appena creato.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>If <ph id="ph1">`securityInfo`</ph> is not supplied, the evidence from the current application domain is used.</source>
          <target state="translated">Se <ph id="ph1">`securityInfo`</ph> viene omesso, viene utilizzato l'evidenza del dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>For more information about shadow copying, see <ph id="ph1">&lt;xref:System.AppDomain.ShadowCopyFiles%2A&gt;</ph> and <bpt id="p1">[</bpt>Shadow Copying Assemblies<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla creazione di copie shadow, vedere <ph id="ph1">&lt;xref:System.AppDomain.ShadowCopyFiles%2A&gt;</ph> e <bpt id="p1">[</bpt>copie Shadow di assembly<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>Do not use this method overload to create sandboxed application domains.</source>
          <target state="translated">Non utilizzare questo overload del metodo per creare i domini di applicazione creato mediante sandbox.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the evidence that is supplied for <ph id="ph2">`securityInfo`</ph> no longer affects the grant set of the application domain.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, l'evidenza fornita per <ph id="ph2">`securityInfo`</ph> non influiscono più set di concessioni del dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>Use the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph> method overload to create sandboxed application domains.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph> overload del metodo per creare i domini di applicazione creato mediante sandbox.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>The following sample demonstrates, in general, how to create a domain using one of the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> overloads.</source>
          <target state="translated">L'esempio seguente viene illustrato, in generale, come creare un dominio utilizzando uno del <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> overload.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>to provide evidence.</source>
          <target state="translated">per fornire l'evidenza.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>The friendly name of the domain.</source>
          <target state="translated">Nome descrittivo del dominio.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>This friendly name can be displayed in user interfaces to identify the domain.</source>
          <target state="translated">Questo nome descrittivo può essere visualizzato nelle interfacce utente per identificare il dominio.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <ph id="ph1">&lt;see cref="P:System.AppDomain.FriendlyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Evidence that establishes the identity of the code that runs in the application domain.</source>
          <target state="translated">Evidenza che stabilisce l'identità del codice che viene eseguito nel dominio applicazione.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Pass <ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the evidence of the current application domain.</source>
          <target state="translated">Passare <ph id="ph1">&lt;see langword="null" /&gt;</ph> per usare l'evidenza del dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>The base directory that the assembly resolver uses to probe for assemblies.</source>
          <target state="translated">Directory di base usata dal resolver dell'assembly per verificare la presenza di assembly.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.BaseDirectory" /&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <ph id="ph1">&lt;see cref="P:System.AppDomain.BaseDirectory" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>The path relative to the base directory where the assembly resolver should probe for private assemblies.</source>
          <target state="translated">Percorso relativo alla directory di base in cui deve essere verificata la presenza di assembly privati mediante il resolver degli assembly.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:System.AppDomain.RelativeSearchPath" /&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <ph id="ph1">&lt;see cref="P:System.AppDomain.RelativeSearchPath" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to load a shadow copy of an assembly into the application domain.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per caricare una copia shadow di un assembly nel dominio applicazione.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.AppDomainInitializer" /&gt;</ph> delegate that represents a callback method to invoke when the new <ph id="ph2">&lt;see cref="T:System.AppDomain" /&gt;</ph> object is initialized.</source>
          <target state="translated">Delegato <ph id="ph1">&lt;see cref="T:System.AppDomainInitializer" /&gt;</ph> che rappresenta un metodo di callback da richiamare quando viene inizializzato il nuovo oggetto <ph id="ph2">&lt;see cref="T:System.AppDomain" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>An array of string arguments to be passed to the callback represented by <bpt id="p1">&lt;c&gt;</bpt>adInit<ept id="p1">&lt;/c&gt;</ept>, when the new <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> object is initialized.</source>
          <target state="translated">Matrice di argomenti stringa da passare al metodo di callback rappresentato dal parametro <bpt id="p1">&lt;c&gt;</bpt>adInit<ept id="p1">&lt;/c&gt;</ept> quando viene inizializzato il nuovo oggetto <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</source>
          <target state="translated">Crea un nuovo dominio applicazione con il nome indicato mediante un'evidenza, un percorso base dell'applicazione, un percorso di ricerca relativo e un parametro che specifica se nel dominio applicazione deve essere caricata la copia shadow di un assembly.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Specifies a callback method that is invoked when the application domain is initialized, and an array of string arguments to pass the callback method.</source>
          <target state="translated">Specifica un metodo di callback che viene richiamato quando viene inizializzato il dominio applicazione e indica una matrice di argomenti stringa da passare al metodo di callback.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>The newly created application domain.</source>
          <target state="translated">Dominio applicazione appena creato.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>The method represented by <ph id="ph1">`adInit`</ph> is executed in the context of the newly created application domain.</source>
          <target state="translated">Il metodo rappresentato dal <ph id="ph1">`adInit`</ph> viene eseguito nel contesto del dominio applicazione appena creato.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>If <ph id="ph1">`securityInfo`</ph> is not supplied, the evidence from the current application domain is used.</source>
          <target state="translated">Se <ph id="ph1">`securityInfo`</ph> viene omesso, viene utilizzato l'evidenza del dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>For more information about shadow copying, see <ph id="ph1">&lt;xref:System.AppDomain.ShadowCopyFiles%2A&gt;</ph> and <bpt id="p1">[</bpt>Shadow Copying Assemblies<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla creazione di copie shadow, vedere <ph id="ph1">&lt;xref:System.AppDomain.ShadowCopyFiles%2A&gt;</ph> e <bpt id="p1">[</bpt>copie Shadow di assembly<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Do not use this method overload to create sandboxed application domains.</source>
          <target state="translated">Non utilizzare questo overload del metodo per creare i domini di applicazione creato mediante sandbox.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the evidence that is supplied for <ph id="ph2">`securityInfo`</ph> no longer affects the grant set of the application domain.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, l'evidenza fornita per <ph id="ph2">`securityInfo`</ph> non influiscono più set di concessioni del dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Use the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph> method overload to create sandboxed application domains.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29&gt;</ph> overload del metodo per creare i domini di applicazione creato mediante sandbox.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="friendlyName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>to provide evidence.</source>
          <target state="translated">per fornire l'evidenza.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Creates a new instance of a specified type defined in a specified assembly.</source>
          <target state="translated">Crea una nuova istanza di un tipo specificato definito in un assembly specificato.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>Creates a new instance of the specified type defined in the specified assembly.</source>
          <target state="translated">Crea una nuova istanza del tipo specificato definito nell'assembly specificato.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>An object that is a wrapper for the new instance specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">Oggetto che rappresenta un wrapper per la nuova istanza specificata da <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>This method calls the default constructor for <ph id="ph1">`typeName`</ph>.</source>
          <target state="translated">Questo metodo chiama il costruttore predefinito per <ph id="ph1">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> per il formato di <ph id="ph2">`assemblyName`</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</source>
          <target state="translated">Un tentativo di chiamare <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> una destinazione dominio dell'applicazione che non è il dominio applicazione corrente comporterà un caricamento ha esito positivo dell'assembly nel dominio dell'applicazione di destinazione.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>Since an <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is not <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, when this method attempts to return the <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</source>
          <target state="translated">Poiché un <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> non <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, quando questo metodo tenta di restituire il <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> per l'assembly caricato nel dominio applicazione corrente, common language runtime tenterà di caricare l'assembly nel dominio applicazione corrente e il potrebbe non riuscire.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</source>
          <target state="translated">L'assembly caricato nel dominio applicazione corrente potrebbe essere diverso dall'assembly è stato caricato prima di tutto se le impostazioni del percorso per i due domini applicazione sono diverse.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> o <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>No matching public constructor was found.</source>
          <target state="translated">Non è stato trovato alcun costruttore pubblico corrispondente.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">Non è possibile trovare <ph id="ph1">&lt;paramref name="typename" /&gt;</ph> in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Questa istanza è <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>for the ability to call unmanaged code when creating an instance of a delegate.</source>
          <target state="translated">Per poter chiamare codice non gestito durante la creazione di un'istanza di un delegato.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>The display name of the assembly.</source>
          <target state="translated">Nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Matrice di uno o più attributi che possono prendere parte all'attivazione.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">In genere, matrice che contiene un singolo oggetto <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> che specifica l'URL necessario per attivare un oggetto remoto.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Creates a new instance of the specified type defined in the specified assembly.</source>
          <target state="translated">Crea una nuova istanza del tipo specificato definito nell'assembly specificato.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>A parameter specifies an array of activation attributes.</source>
          <target state="translated">Un parametro specifica una matrice di attributi di attivazione.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>An object that is a wrapper for the new instance specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">Oggetto che rappresenta un wrapper per la nuova istanza specificata da <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>This method calls the default constructor for <ph id="ph1">`typeName`</ph>.</source>
          <target state="translated">Questo metodo chiama il costruttore predefinito per <ph id="ph1">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> per il formato di <ph id="ph2">`assemblyName`</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</source>
          <target state="translated">Un tentativo di chiamare <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> una destinazione dominio dell'applicazione che non è il dominio applicazione corrente comporterà un caricamento ha esito positivo dell'assembly nel dominio dell'applicazione di destinazione.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Since an <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is not <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, when this method attempts to return the <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</source>
          <target state="translated">Poiché un <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> non <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, quando questo metodo tenta di restituire il <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> per l'assembly caricato nel dominio applicazione corrente, common language runtime tenterà di caricare l'assembly nel dominio applicazione corrente e il potrebbe non riuscire.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</source>
          <target state="translated">L'assembly caricato nel dominio applicazione corrente potrebbe essere diverso dall'assembly è stato caricato prima di tutto se le impostazioni del percorso per i due domini applicazione sono diverse.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> o <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>No matching public constructor was found.</source>
          <target state="translated">Non è stato trovato alcun costruttore pubblico corrispondente.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">Non è possibile trovare <ph id="ph1">&lt;paramref name="typename" /&gt;</ph> in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Questa istanza è <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Per poter leggere il file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>for the ability to call unmanaged code when creating an instance of a delegate.</source>
          <target state="translated">Per poter chiamare codice non gestito durante la creazione di un'istanza di un delegato.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>for the ability to invoke operations on all type members.</source>
          <target state="translated">Per poter richiamare operazioni su tutti i membri di tipo.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The display name of the assembly.</source>
          <target state="translated">Nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">Oggetto che consente l'associazione, la coercizione dei tipi di argomento, la chiamata dei membri e il recupero di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> tramite reflection.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> è Null, verrà usato il binder predefinito.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">Argomenti da passare al costruttore.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">Per usare il costruttore predefinito, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> deve essere una matrice vuota o Null.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Culture-specific information that governs the coercion of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> to the formal types declared for the <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> ai tipi formali dichiarati per il costruttore <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, per il thread corrente verrà usato l'oggetto <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Matrice di uno o più attributi che possono prendere parte all'attivazione.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">In genere, matrice che contiene un singolo oggetto <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> che specifica l'URL necessario per attivare un oggetto remoto.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">Il parametro è correlato agli oggetti attivati dal client.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Creates a new instance of the specified type defined in the specified assembly.</source>
          <target state="translated">Crea una nuova istanza del tipo specificato definito nell'assembly specificato.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, and optional activation attributes.</source>
          <target state="translated">I parametri specificano uno strumento di associazione, i flag di associazione, gli argomenti del costruttore, le informazioni specifiche delle impostazioni cultura usate per interpretare gli argomenti e gli attributi di attivazione facoltativi.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An object that is a wrapper for the new instance specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">Oggetto che rappresenta un wrapper per la nuova istanza specificata da <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> per il formato di <ph id="ph2">`assemblyName`</ph>.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</source>
          <target state="translated">Un tentativo di chiamare <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> una destinazione dominio dell'applicazione che non è il dominio applicazione corrente comporterà un caricamento ha esito positivo dell'assembly nel dominio dell'applicazione di destinazione.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Since an <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is not <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, when this method attempts to return the <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</source>
          <target state="translated">Poiché un <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> non <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, quando questo metodo tenta di restituire il <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> per l'assembly caricato nel dominio applicazione corrente, common language runtime tenterà di caricare l'assembly nel dominio applicazione corrente e il potrebbe non riuscire.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</source>
          <target state="translated">L'assembly caricato nel dominio applicazione corrente potrebbe essere diverso dall'assembly è stato caricato prima di tutto se le impostazioni del percorso per i due domini applicazione sono diverse.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> o <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>No matching constructor was found.</source>
          <target state="translated">Non è stato trovato alcun costruttore corrispondente.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">Non è possibile trovare <ph id="ph1">&lt;paramref name="typename" /&gt;</ph> in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Questa istanza è <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Per poter leggere il file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to call unmanaged code when creating an instance of a delegate.</source>
          <target state="translated">Per poter chiamare codice non gestito durante la creazione di un'istanza di un delegato.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to invoke operations on all type members.</source>
          <target state="translated">Per poter richiamare operazioni su tutti i membri di tipo.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">Oggetto che consente l'associazione, la coercizione dei tipi di argomento, la chiamata dei membri e il recupero di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> tramite reflection.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> è Null, verrà usato il binder predefinito.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">Argomenti da passare al costruttore.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">Per usare il costruttore predefinito, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> deve essere una matrice vuota o Null.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Culture-specific information that governs the coercion of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> to the formal types declared for the <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> ai tipi formali dichiarati per il costruttore <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, per il thread corrente verrà usato l'oggetto <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Matrice di uno o più attributi che possono prendere parte all'attivazione.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">In genere, matrice che contiene un singolo oggetto <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> che specifica l'URL necessario per attivare un oggetto remoto.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Information used to authorize creation of <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Informazioni usate per autorizzare la creazione di <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Creates a new instance of the specified type defined in the specified assembly.</source>
          <target state="translated">Crea una nuova istanza del tipo specificato definito nell'assembly specificato.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, activation attributes, and authorization to create the type.</source>
          <target state="translated">I parametri specificano lo strumento di associazione, i flag di associazione, gli argomenti del costruttore, le informazioni specifiche delle impostazioni cultura usate per interpretare gli argomenti, gli attributi di attivazione e l'autorizzazione per la creazione del tipo.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An object that is a wrapper for the new instance specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">Oggetto che rappresenta un wrapper per la nuova istanza specificata da <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> per il formato di <ph id="ph2">`assemblyName`</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An attempt to call <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</source>
          <target state="translated">Un tentativo di chiamare <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> una destinazione dominio dell'applicazione che non è il dominio applicazione corrente comporterà un caricamento ha esito positivo dell'assembly nel dominio dell'applicazione di destinazione.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Since an <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is not <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, when this method attempts to return the <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</source>
          <target state="translated">Poiché un <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> non <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, quando questo metodo tenta di restituire il <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> per l'assembly caricato nel dominio applicazione corrente, common language runtime tenterà di caricare l'assembly nel dominio applicazione corrente e il potrebbe non riuscire.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</source>
          <target state="translated">L'assembly caricato nel dominio applicazione corrente potrebbe essere diverso dall'assembly è stato caricato prima di tutto se le impostazioni del percorso per i due domini applicazione sono diverse.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> o <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>No matching constructor was found.</source>
          <target state="translated">Non è stato trovato alcun costruttore corrispondente.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>When legacy CAS policy is not enabled, <ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> should be <ph id="ph2">&lt;see langword="null." /&gt;</ph></source>
          <target state="translated">Quando i criteri di protezione dall'accesso di codice legacy non sono abilitati, <ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> deve essere <ph id="ph2">&lt;see langword="null." /&gt;</ph></target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">Non è possibile trovare <ph id="ph1">&lt;paramref name="typename" /&gt;</ph> in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Questa istanza è <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Per poter leggere il file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>to provide evidence.</source>
          <target state="translated">per fornire l'evidenza.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to invoke operations on all type members.</source>
          <target state="translated">Per poter richiamare operazioni su tutti i membri di tipo.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Creates a new instance of a specified type.</source>
          <target state="translated">Crea una nuova istanza di un tipo specificato.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>Creates a new instance of the specified type.</source>
          <target state="translated">Crea una nuova istanza del tipo specificato.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>Parameters specify the assembly where the type is defined, and the name of the type.</source>
          <target state="translated">I parametri specificano l'assembly in cui è definito il tipo e il nome del tipo.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>An instance of the object specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">Istanza dell'oggetto specificato da <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si tratta di un metodo pratico che combina <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>This method calls the default constructor for <ph id="ph1">`typeName`</ph>.</source>
          <target state="translated">Questo metodo chiama il costruttore predefinito per <ph id="ph1">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> per il formato di <ph id="ph2">`assemblyName`</ph>.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>See the <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> property for the format of <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated">Vedere il <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> proprietà per il formato di <ph id="ph2">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>If you make an early-bound call to a method <ph id="ph1">`M`</ph> of an object of type <ph id="ph2">`T1`</ph> that was returned by <ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>, and that method makes an early-bound call to a method of an object of type <ph id="ph4">`T2`</ph> in an assembly <ph id="ph5">`C`</ph> other than the current assembly or the assembly containing <ph id="ph6">`T1`</ph>, assembly <ph id="ph7">`C`</ph> is loaded into the current application domain.</source>
          <target state="translated">Se si effettua una chiamata con associazione anticipata a un metodo <ph id="ph1">`M`</ph> di un oggetto di tipo <ph id="ph2">`T1`</ph> che è stato restituito da <ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>, e tale metodo effettua una chiamata con associazione anticipata a un metodo di un oggetto di tipo <ph id="ph4">`T2`</ph> in un assembly <ph id="ph5">`C`</ph> tranne il assembly corrente o l'assembly contenente <ph id="ph6">`T1`</ph>, assembly <ph id="ph7">`C`</ph> viene caricato nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>This loading occurs even if the early-bound call to <ph id="ph1">`T1.M()`</ph> was made in the body of a <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>, or in other dynamically generated code.</source>
          <target state="translated">Il caricamento si verifica anche se l'associazione anticipata chiamata a <ph id="ph1">`T1.M()`</ph> è stata effettuata nel corpo di un <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>, o in altro codice generato dinamicamente.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>If the current domain is the default domain, assembly <ph id="ph1">`C`</ph> cannot be unloaded until the process ends.</source>
          <target state="translated">Se il dominio corrente è il dominio predefinito, assembly <ph id="ph1">`C`</ph> non può essere scaricato finché non termina il processo.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>If the current domain later attempts to load assembly <ph id="ph1">`C`</ph>, the load might fail.</source>
          <target state="translated">Se il dominio corrente in un secondo momento tenta di caricare l'assembly <ph id="ph1">`C`</ph>, potrebbe non riuscire.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The following code example shows the simplest way to execute code in another application domain.</source>
          <target state="translated">Esempio di codice seguente viene illustrato il modo più semplice per eseguire codice in un altro dominio applicazione.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The example defines a class named <ph id="ph1">`Worker`</ph> that inherits from <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>.</source>
          <target state="translated">Nell'esempio viene definita una classe denominata <ph id="ph1">`Worker`</ph> che eredita da <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The <ph id="ph1">`Worker`</ph> class defines a method that displays the name of the application domain in which it is executing.</source>
          <target state="translated">La <ph id="ph1">`Worker`</ph> classe definisce un metodo che visualizza il nome del dominio dell'applicazione in cui è in esecuzione.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The example creates instances of <ph id="ph1">`Worker`</ph> in the default application domain and in a new application domain.</source>
          <target state="translated">L'esempio crea istanze di <ph id="ph1">`Worker`</ph> nel dominio applicazione predefinito in un nuovo dominio applicazione.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The assembly that contains <ph id="ph1">`Worker`</ph> must be loaded into both application domains, but it can load other assemblies that exist only in the new application domain.</source>
          <target state="translated">L'assembly che contiene <ph id="ph1">`Worker`</ph> deve essere caricato in entrambi i domini applicazione, ma può caricare altri assembly che esiste solo nel nuovo dominio applicazione.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> o <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>No matching public constructor was found.</source>
          <target state="translated">Non è stato trovato alcun costruttore pubblico corrispondente.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">Non è possibile trovare <ph id="ph1">&lt;paramref name="typename" /&gt;</ph> in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>for the ability to read the file containing the assembly manifest, or if you are creating a type from a module other than the manifest file.</source>
          <target state="translated">Per poter leggere il file contenente il manifesto dell'assembly, o se si sta creando un tipo da un modulo diverso dal file manifesto.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>The display name of the assembly.</source>
          <target state="translated">Nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Matrice di uno o più attributi che possono prendere parte all'attivazione.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">In genere, matrice che contiene un singolo oggetto <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> che specifica l'URL necessario per attivare un oggetto remoto.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Creates a new instance of the specified type.</source>
          <target state="translated">Crea una nuova istanza del tipo specificato.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Parameters specify the assembly where the type is defined, the name of the type, and an array of activation attributes.</source>
          <target state="translated">I parametri specificano l'assembly in cui è definito il tipo, il nome del tipo e una matrice di attributi di attivazione.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>An instance of the object specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">Istanza dell'oggetto specificato da <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si tratta di un metodo pratico che combina <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>This method calls the default constructor for <ph id="ph1">`typeName`</ph>.</source>
          <target state="translated">Questo metodo chiama il costruttore predefinito per <ph id="ph1">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> per il formato di <ph id="ph2">`assemblyName`</ph>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>See the <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> property for the format of <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated">Vedere il <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> proprietà per il formato di <ph id="ph2">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>If you make an early-bound call to a method <ph id="ph1">`M`</ph> of an object of type <ph id="ph2">`T1`</ph> that was returned by <ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>, and that method makes an early-bound call to a method of an object of type <ph id="ph4">`T2`</ph> in an assembly <ph id="ph5">`C`</ph> other than the current assembly or the assembly containing <ph id="ph6">`T1`</ph>, assembly <ph id="ph7">`C`</ph> is loaded into the current application domain.</source>
          <target state="translated">Se si effettua una chiamata con associazione anticipata a un metodo <ph id="ph1">`M`</ph> di un oggetto di tipo <ph id="ph2">`T1`</ph> che è stato restituito da <ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>, e tale metodo effettua una chiamata con associazione anticipata a un metodo di un oggetto di tipo <ph id="ph4">`T2`</ph> in un assembly <ph id="ph5">`C`</ph> tranne il assembly corrente o l'assembly contenente <ph id="ph6">`T1`</ph>, assembly <ph id="ph7">`C`</ph> viene caricato nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>This loading occurs even if the early-bound call to <ph id="ph1">`T1.M()`</ph> was made in the body of a <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>, or in other dynamically generated code.</source>
          <target state="translated">Il caricamento si verifica anche se l'associazione anticipata chiamata a <ph id="ph1">`T1.M()`</ph> è stata effettuata nel corpo di un <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>, o in altro codice generato dinamicamente.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>If the current domain is the default domain, assembly <ph id="ph1">`C`</ph> cannot be unloaded until the process ends.</source>
          <target state="translated">Se il dominio corrente è il dominio predefinito, assembly <ph id="ph1">`C`</ph> non può essere scaricato finché non termina il processo.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>If the current domain later attempts to load assembly <ph id="ph1">`C`</ph>, the load might fail.</source>
          <target state="translated">Se il dominio corrente in un secondo momento tenta di caricare l'assembly <ph id="ph1">`C`</ph>, potrebbe non riuscire.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> o <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>No matching public constructor was found.</source>
          <target state="translated">Non è stato trovato alcun costruttore pubblico corrispondente.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">Non è possibile trovare <ph id="ph1">&lt;paramref name="typename" /&gt;</ph> in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Per poter leggere il file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>for the ability to call unmanaged code when creating an instance of a delegate.</source>
          <target state="translated">Per poter chiamare codice non gestito durante la creazione di un'istanza di un delegato.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>for the ability to invoke operations on all type members.</source>
          <target state="translated">Per poter richiamare operazioni su tutti i membri di tipo.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The display name of the assembly.</source>
          <target state="translated">Nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">Oggetto che consente l'associazione, la coercizione dei tipi di argomento, la chiamata dei membri e il recupero di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> tramite reflection.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> è Null, verrà usato il binder predefinito.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">Argomenti da passare al costruttore.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">Per usare il costruttore predefinito, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> deve essere una matrice vuota o Null.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A culture-specific object used to govern the coercion of types.</source>
          <target state="translated">Oggetto specifico delle impostazioni cultura usato per regolare la coercizione dei tipi.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, per il thread corrente verrà usato l'oggetto <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Matrice di uno o più attributi che possono prendere parte all'attivazione.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object.</source>
          <target state="translated">In genere, corrisponde a una matrice che contiene un singolo oggetto <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">specifica l'URL necessario per attivare un oggetto remoto.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">Il parametro è correlato agli oggetti attivati dal client.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Creates a new instance of the specified type defined in the specified assembly, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</source>
          <target state="translated">Crea una nuova istanza del tipo specificato definito nell'assembly specificato, indicando se ignorare le maiuscole/minuscole del nome del tipo, gli attributi e lo strumento di associazione usati per selezionare il tipo da creare, gli argomenti del costruttore, le impostazioni cultura e gli attributi di attivazione.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An instance of the object specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">Istanza dell'oggetto specificato da <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si tratta di un metodo pratico che combina <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> per il formato di <ph id="ph2">`assemblyName`</ph>.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>See the <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> property for the format of <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated">Vedere il <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> proprietà per il formato di <ph id="ph2">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If you make an early-bound call to a method <ph id="ph1">`M`</ph> of an object of type <ph id="ph2">`T1`</ph> that was returned by <ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>, and that method makes an early-bound call to a method of an object of type <ph id="ph4">`T2`</ph> in an assembly <ph id="ph5">`C`</ph> other than the current assembly or the assembly containing <ph id="ph6">`T1`</ph>, assembly <ph id="ph7">`C`</ph> is loaded into the current application domain.</source>
          <target state="translated">Se si effettua una chiamata con associazione anticipata a un metodo <ph id="ph1">`M`</ph> di un oggetto di tipo <ph id="ph2">`T1`</ph> che è stato restituito da <ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>, e tale metodo effettua una chiamata con associazione anticipata a un metodo di un oggetto di tipo <ph id="ph4">`T2`</ph> in un assembly <ph id="ph5">`C`</ph> tranne il assembly corrente o l'assembly contenente <ph id="ph6">`T1`</ph>, assembly <ph id="ph7">`C`</ph> viene caricato nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This loading occurs even if the early-bound call to <ph id="ph1">`T1.M()`</ph> was made in the body of a <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>, or in other dynamically generated code.</source>
          <target state="translated">Il caricamento si verifica anche se l'associazione anticipata chiamata a <ph id="ph1">`T1.M()`</ph> è stata effettuata nel corpo di un <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>, o in altro codice generato dinamicamente.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the current domain is the default domain, assembly <ph id="ph1">`C`</ph> cannot be unloaded until the process ends.</source>
          <target state="translated">Se il dominio corrente è il dominio predefinito, assembly <ph id="ph1">`C`</ph> non può essere scaricato finché non termina il processo.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the current domain later attempts to load assembly <ph id="ph1">`C`</ph>, the load might fail.</source>
          <target state="translated">Se il dominio corrente in un secondo momento tenta di caricare l'assembly <ph id="ph1">`C`</ph>, potrebbe non riuscire.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The following sample demonstrates the use of the <ph id="ph1">`ignoreCase`</ph> parameter.</source>
          <target state="translated">L'esempio seguente viene illustrato l'utilizzo del <ph id="ph1">`ignoreCase`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> o <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>No matching constructor was found.</source>
          <target state="translated">Non è stato trovato alcun costruttore corrispondente.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">Non è possibile trovare <ph id="ph1">&lt;paramref name="typename" /&gt;</ph> in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Per poter leggere il file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to call unmanaged code when creating an instance of a delegate.</source>
          <target state="translated">Per poter chiamare codice non gestito durante la creazione di un'istanza di un delegato.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to invoke operations on all type members.</source>
          <target state="translated">Per poter richiamare operazioni su tutti i membri di tipo.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">Oggetto che consente l'associazione, la coercizione dei tipi di argomento, la chiamata dei membri e il recupero di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> tramite reflection.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> è Null, verrà usato il binder predefinito.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">Argomenti da passare al costruttore.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">Per usare il costruttore predefinito, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> deve essere una matrice vuota o Null.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A culture-specific object used to govern the coercion of types.</source>
          <target state="translated">Oggetto specifico delle impostazioni cultura usato per regolare la coercizione dei tipi.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, per il thread corrente verrà usato l'oggetto <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Matrice di uno o più attributi che possono prendere parte all'attivazione.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">In genere, matrice che contiene un singolo oggetto <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> che specifica l'URL necessario per attivare un oggetto remoto.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">Il parametro è correlato agli oggetti attivati dal client.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Information used to authorize creation of <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Informazioni usate per autorizzare la creazione di <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Creates a new instance of the specified type.</source>
          <target state="translated">Crea una nuova istanza del tipo specificato.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Parameters specify the name of the type, and how it is found and created.</source>
          <target state="translated">I parametri specificano il nome del tipo e le relative modalità di individuazione e creazione.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An instance of the object specified by <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</source>
          <target state="translated">Istanza dell'oggetto specificato da <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si tratta di un metodo pratico che combina <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for the format of <ph id="ph2">`assemblyName`</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> per il formato di <ph id="ph2">`assemblyName`</ph>.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>See the <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> property for the format of <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated">Vedere il <ph id="ph1">&lt;xref:System.Type.FullName%2A?displayProperty=nameWithType&gt;</ph> proprietà per il formato di <ph id="ph2">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If you make an early-bound call to a method <ph id="ph1">`M`</ph> of an object of type <ph id="ph2">`T1`</ph> that was returned by <ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>, and that method makes an early-bound call to a method of an object of type <ph id="ph4">`T2`</ph> in an assembly <ph id="ph5">`C`</ph> other than the current assembly or the assembly containing <ph id="ph6">`T1`</ph>, assembly <ph id="ph7">`C`</ph> is loaded into the current application domain.</source>
          <target state="translated">Se si effettua una chiamata con associazione anticipata a un metodo <ph id="ph1">`M`</ph> di un oggetto di tipo <ph id="ph2">`T1`</ph> che è stato restituito da <ph id="ph3">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>, e tale metodo effettua una chiamata con associazione anticipata a un metodo di un oggetto di tipo <ph id="ph4">`T2`</ph> in un assembly <ph id="ph5">`C`</ph> tranne il assembly corrente o l'assembly contenente <ph id="ph6">`T1`</ph>, assembly <ph id="ph7">`C`</ph> viene caricato nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This loading occurs even if the early-bound call to <ph id="ph1">`T1.M()`</ph> was made in the body of a <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>, or in other dynamically generated code.</source>
          <target state="translated">Il caricamento si verifica anche se l'associazione anticipata chiamata a <ph id="ph1">`T1.M()`</ph> è stata effettuata nel corpo di un <ph id="ph2">&lt;xref:System.Reflection.Emit.DynamicMethod&gt;</ph>, o in altro codice generato dinamicamente.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If the current domain is the default domain, assembly <ph id="ph1">`C`</ph> cannot be unloaded until the process ends.</source>
          <target state="translated">Se il dominio corrente è il dominio predefinito, assembly <ph id="ph1">`C`</ph> non può essere scaricato finché non termina il processo.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If the current domain later attempts to load assembly <ph id="ph1">`C`</ph>, the load might fail.</source>
          <target state="translated">Se il dominio corrente in un secondo momento tenta di caricare l'assembly <ph id="ph1">`C`</ph>, potrebbe non riuscire.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The following sample demonstrates the use of the <ph id="ph1">`ignoreCase`</ph> parameter.</source>
          <target state="translated">L'esempio seguente viene illustrato l'utilizzo del <ph id="ph1">`ignoreCase`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> or <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> o <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>No matching constructor was found.</source>
          <target state="translated">Non è stato trovato alcun costruttore corrispondente.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="typename" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">Non è possibile trovare <ph id="ph1">&lt;paramref name="typename" /&gt;</ph> in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller does not have permission to call this constructor.</source>
          <target state="translated">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Per poter leggere il file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to invoke operations on all type members.</source>
          <target state="translated">Per poter richiamare operazioni su tutti i membri di tipo.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Creates a new instance of a specified type defined in the specified assembly file.</source>
          <target state="translated">Crea una nuova istanza di un tipo specificato definito nel file di assembly specificato.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The name, including the path, of a file that contains an assembly that defines the requested type.</source>
          <target state="translated">Nome di un file, comprensivo di percorso, contenente un assembly in cui viene definito il tipo richiesto.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The assembly is loaded using the <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph> method.</source>
          <target state="translated">L'assembly viene caricato utilizzando il metodo <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>Creates a new instance of the specified type defined in the specified assembly file.</source>
          <target state="translated">Crea una nuova istanza del tipo specificato definito nel file di assembly specificato.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>An object that is a wrapper for the new instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">Wrapper per la nuova istanza oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph> se <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> non viene trovato.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The default constructor for <ph id="ph1">`typeName`</ph> is invoked.</source>
          <target state="translated">Il costruttore predefinito per <ph id="ph1">`typeName`</ph> viene richiamato.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Per altre informazioni, vedere il metodo <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>When the <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</source>
          <target state="translated">Quando il <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> metodo viene utilizzato per creare un'istanza in un dominio di applicazione di destinazione diverso dal dominio di applicazione da cui viene effettuata la chiamata, l'assembly viene caricato nel dominio dell'applicazione di destinazione.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</source>
          <target state="translated">Tuttavia, se l'istanza è annullato il wrapping nel dominio dell'applicazione chiamante, utilizzando l'istanza annullato il wrapping in determinati modi può causare l'assembly nel dominio applicazione chiamante deve essere caricata.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</source>
          <target state="translated">Ad esempio, dopo che l'istanza è annullato il wrapping, potrebbero richiedere le informazioni sul tipo, per chiamare i metodi ad associazione tardiva.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>When the assembly is loaded into the calling application domain, exceptions can occur.</source>
          <target state="translated">Quando l'assembly viene caricato nel dominio applicazione chiamante, possono verificarsi eccezioni.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> can occur.</source>
          <target state="translated">Se un'altra versione dello stesso assembly in precedenza è stata caricata nel dominio applicazione chiamante oppure se il percorso di caricamento del dominio applicazione chiamante è diverso da quello del dominio dell'applicazione di destinazione, le eccezioni, ad esempio <ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> possono verificarsi.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>If the calling application domain makes early-bound calls to the instance type, <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> can be thrown when an attempt is made to cast the instance.</source>
          <target state="translated">Se il dominio applicazione chiamante effettua chiamate ad associazione anticipata per il tipo di istanza <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> può essere generata quando viene effettuato un tentativo di cast dell'istanza.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29&gt;</ph> method overload to create an instance of an object in a target application domain and call its methods.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29&gt;</ph> overload del metodo per creare un'istanza di un oggetto in un dominio di applicazione di destinazione e chiamarne i metodi.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The example defines the <ph id="ph1">`MarshallableExample`</ph> class, which can be marshaled across application domain boundaries.</source>
          <target state="translated">Nell'esempio viene definita la <ph id="ph1">`MarshallableExample`</ph> classe, che può essere sottoposto a marshalling attraverso i limiti del dominio applicazione.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The example builds a path to the currently executing assembly, creates a target application domain, and uses the <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29&gt;</ph> method overload to load the example assembly into the target application domain and create an instance of <ph id="ph2">`MarshallableExample`</ph>.</source>
          <target state="translated">Nell'esempio viene compilato un percorso per l'assembly attualmente in esecuzione, crea un dominio di applicazione di destinazione e utilizza il <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29&gt;</ph> overload del metodo per caricare l'assembly di esempio nel dominio applicazione di destinazione e creare un'istanza di <ph id="ph2">`MarshallableExample`</ph>.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The path is absolute in this example, but a relative path would also work because the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType&gt;</ph> method is used to load the assembly.</source>
          <target state="translated">Il percorso è assoluto in questo esempio, ma un percorso relativo funzionerà anche perché il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType&gt;</ph> metodo viene utilizzato per caricare l'assembly.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>After unwrapping the object handle, the example demonstrates three ways to use an object in a target application domain:</source>
          <target state="translated">Dopo l'annullamento del wrapping l'handle di oggetto, l'esempio illustra tre modi per utilizzare un oggetto in un dominio di applicazione di destinazione:</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>Invoking a method with late binding, using reflection.</source>
          <target state="translated">Richiama un metodo con associazione tardiva, tramite reflection.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>This requires type information, which causes the assembly to be loaded into the application domain of the caller.</source>
          <target state="translated">Ciò richiede informazioni sul tipo, determinando l'assembly da caricare nel dominio applicazione del chiamante.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>(In this example, it is already loaded.)</source>
          <target state="translated">(In questo esempio, è già caricato.)</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>Casting the object to an interface known to both the caller and the callee.</source>
          <target state="translated">Il cast dell'oggetto a un'interfaccia definita per il chiamante e chiamato.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>If the interface is defined in the calling assembly or in a third assembly referenced by both the caller and the callee, the called assembly is not loaded into the application domain of the caller.</source>
          <target state="translated">Se l'interfaccia è definita nell'assembly chiamante o in un terzo assembly a cui fa riferimento il chiamante e chiamato, l'assembly chiamato non è caricato nel dominio applicazione del chiamante.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>Using the object directly when its type is known to the caller.</source>
          <target state="translated">Utilizzo dell'oggetto direttamente quando il relativo tipo è noto al chiamante.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The assembly must be loaded into the application domain of the caller.</source>
          <target state="translated">L'assembly deve essere caricato nel dominio applicazione del chiamante.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>Another way to avoid loading the called assembly into the application domain of the caller is for the caller to derive from the <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph> class and to define a method that can be run in the target application domain.</source>
          <target state="translated">È possibile evitare di caricare l'assembly chiamato nel dominio applicazione del chiamante per il chiamante da cui derivare la <ph id="ph1">&lt;xref:System.MarshalByRefObject&gt;</ph> classe e per definire un metodo che può essere eseguito nel dominio dell'applicazione di destinazione.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>That method can use reflection to examine a target assembly, because the target assembly is already loaded into the target application domain.</source>
          <target state="translated">Tale metodo può usare la reflection per esaminare un assembly di destinazione, perché l'assembly di destinazione è già caricato nel dominio applicazione di destinazione.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>See the example for the <ph id="ph1">&lt;xref:System.AppDomain.DynamicDirectory%2A&gt;</ph> property.</source>
          <target state="translated">Vedere l'esempio per la <ph id="ph1">&lt;xref:System.AppDomain.DynamicDirectory%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was not found.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph>.</source>
          <target state="translated">Non è possibile trovare <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> in <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>No parameterless public constructor was found.</source>
          <target state="translated">Non è stato trovato alcun costruttore pubblico senza parametri.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Questa istanza è <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Per poter leggere il file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The name, including the path, of a file that contains an assembly that defines the requested type.</source>
          <target state="translated">Nome di un file, comprensivo di percorso, contenente un assembly in cui viene definito il tipo richiesto.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The assembly is loaded using the <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph> method.</source>
          <target state="translated">L'assembly viene caricato utilizzando il metodo <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Matrice di uno o più attributi che possono prendere parte all'attivazione.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">In genere, matrice che contiene un singolo oggetto <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> che specifica l'URL necessario per attivare un oggetto remoto.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>Creates a new instance of the specified type defined in the specified assembly file.</source>
          <target state="translated">Crea una nuova istanza del tipo specificato definito nel file di assembly specificato.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>An object that is a wrapper for the new instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">Wrapper per la nuova istanza oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph> se <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> non viene trovato.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The default constructor for <ph id="ph1">`typeName`</ph> is invoked.</source>
          <target state="translated">Il costruttore predefinito per <ph id="ph1">`typeName`</ph> viene richiamato.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>For more information about this method, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Per ulteriori informazioni su questo metodo, vedere il <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>When the <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</source>
          <target state="translated">Quando il <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> metodo viene utilizzato per creare un'istanza in un dominio di applicazione di destinazione diverso dal dominio di applicazione da cui viene effettuata la chiamata, l'assembly viene caricato nel dominio dell'applicazione di destinazione.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</source>
          <target state="translated">Tuttavia, se l'istanza è annullato il wrapping nel dominio dell'applicazione chiamante, utilizzando l'istanza annullato il wrapping in determinati modi può causare l'assembly nel dominio applicazione chiamante deve essere caricata.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</source>
          <target state="translated">Ad esempio, dopo che l'istanza è annullato il wrapping, potrebbero richiedere le informazioni sul tipo, per chiamare i metodi ad associazione tardiva.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>When the assembly is loaded into the calling application domain, exceptions can occur.</source>
          <target state="translated">Quando l'assembly viene caricato nel dominio applicazione chiamante, possono verificarsi eccezioni.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> can occur.</source>
          <target state="translated">Se un'altra versione dello stesso assembly in precedenza è stata caricata nel dominio applicazione chiamante oppure se il percorso di caricamento del dominio applicazione chiamante è diverso da quello del dominio dell'applicazione di destinazione, le eccezioni, ad esempio <ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> possono verificarsi.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>If the calling application domain makes early-bound calls to the instance type, <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> can be thrown when an attempt is made to cast the instance.</source>
          <target state="translated">Se il dominio applicazione chiamante effettua chiamate ad associazione anticipata per il tipo di istanza <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> può essere generata quando viene effettuato un tentativo di cast dell'istanza.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was not found.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph>.</source>
          <target state="translated">Non è possibile trovare <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> in <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>No matching public constructor was found.</source>
          <target state="translated">Non è stato trovato alcun costruttore pubblico corrispondente.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Questa istanza è <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Per poter leggere il file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The name, including the path, of a file that contains an assembly that defines the requested type.</source>
          <target state="translated">Nome di un file, comprensivo di percorso, contenente un assembly in cui viene definito il tipo richiesto.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The assembly is loaded using the <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph> method.</source>
          <target state="translated">L'assembly viene caricato utilizzando il metodo <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects through reflection.</source>
          <target state="translated">Oggetto che consente l'associazione, la coercizione di tipi di argomento, la chiamata di membri e il recupero di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> tramite la reflection.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> è Null, verrà usato il binder predefinito.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">Argomenti da passare al costruttore.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">Per usare il costruttore predefinito, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> deve essere una matrice vuota o Null.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Culture-specific information that governs the coercion of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> to the formal types declared for the <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> ai tipi formali dichiarati per il costruttore <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, per il thread corrente verrà usato l'oggetto <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Matrice di uno o più attributi che possono prendere parte all'attivazione.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">In genere, matrice che contiene un singolo oggetto <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> che specifica l'URL necessario per attivare un oggetto remoto.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">Il parametro è correlato agli oggetti attivati dal client.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Creates a new instance of the specified type defined in the specified assembly file.</source>
          <target state="translated">Crea una nuova istanza del tipo specificato definito nel file di assembly specificato.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An object that is a wrapper for the new instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">Wrapper per la nuova istanza oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph> se <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> non viene trovato.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Per altre informazioni, vedere il metodo <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>When the <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</source>
          <target state="translated">Quando il <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> metodo viene utilizzato per creare un'istanza in un dominio di applicazione di destinazione diverso dal dominio di applicazione da cui viene effettuata la chiamata, l'assembly viene caricato nel dominio dell'applicazione di destinazione.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</source>
          <target state="translated">Tuttavia, se l'istanza è annullato il wrapping nel dominio dell'applicazione chiamante, utilizzando l'istanza annullato il wrapping in determinati modi può causare l'assembly nel dominio applicazione chiamante deve essere caricata.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</source>
          <target state="translated">Ad esempio, dopo che l'istanza è annullato il wrapping, potrebbero richiedere le informazioni sul tipo, per chiamare i metodi ad associazione tardiva.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>When the assembly is loaded into the calling application domain, exceptions can occur.</source>
          <target state="translated">Quando l'assembly viene caricato nel dominio applicazione chiamante, possono verificarsi eccezioni.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> can occur.</source>
          <target state="translated">Se un'altra versione dello stesso assembly in precedenza è stata caricata nel dominio applicazione chiamante oppure se il percorso di caricamento del dominio applicazione chiamante è diverso da quello del dominio dell'applicazione di destinazione, le eccezioni, ad esempio <ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> possono verificarsi.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the calling application domain makes early-bound calls to the instance type, <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> can be thrown when an attempt is made to cast the instance.</source>
          <target state="translated">Se il dominio applicazione chiamante effettua chiamate ad associazione anticipata per il tipo di istanza <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> può essere generata quando viene effettuato un tentativo di cast dell'istanza.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was not found.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph>.</source>
          <target state="translated">Non è possibile trovare <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> in <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>No matching public constructor was found.</source>
          <target state="translated">Non è stato trovato alcun costruttore pubblico corrispondente.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Questa istanza è <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Per poter leggere il file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The name, including the path, of a file that contains an assembly that defines the requested type.</source>
          <target state="translated">Nome di un file, comprensivo di percorso, contenente un assembly in cui viene definito il tipo richiesto.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The assembly is loaded using the <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph> method.</source>
          <target state="translated">L'assembly viene caricato utilizzando il metodo <ph id="ph1">&lt;see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects through reflection.</source>
          <target state="translated">Oggetto che consente l'associazione, la coercizione di tipi di argomento, la chiamata di membri e il recupero di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> tramite la reflection.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> è Null, verrà usato il binder predefinito.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">Argomenti da passare al costruttore.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">Per usare il costruttore predefinito, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> deve essere una matrice vuota o Null.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Culture-specific information that governs the coercion of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> to the formal types declared for the <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> ai tipi formali dichiarati per il costruttore <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, per il thread corrente verrà usato l'oggetto <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Matrice di uno o più attributi che possono prendere parte all'attivazione.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">In genere, matrice che contiene un singolo oggetto <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> che specifica l'URL necessario per attivare un oggetto remoto.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">Il parametro è correlato agli oggetti attivati dal client.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Information used to authorize creation of <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Informazioni usate per autorizzare la creazione di <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Creates a new instance of the specified type defined in the specified assembly file.</source>
          <target state="translated">Crea una nuova istanza del tipo specificato definito nel file di assembly specificato.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An object that is a wrapper for the new instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">Wrapper per la nuova istanza oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph> se <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> non viene trovato.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The return value needs to be unwrapped to access the real object.</source>
          <target state="translated">Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>For more information about this method, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Per ulteriori informazioni su questo metodo, vedere il <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>When the <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</source>
          <target state="translated">Quando il <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> metodo viene utilizzato per creare un'istanza in un dominio di applicazione di destinazione diverso dal dominio di applicazione da cui viene effettuata la chiamata, l'assembly viene caricato nel dominio dell'applicazione di destinazione.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</source>
          <target state="translated">Tuttavia, se l'istanza è annullato il wrapping nel dominio dell'applicazione chiamante, utilizzando l'istanza annullato il wrapping in determinati modi può causare l'assembly nel dominio applicazione chiamante deve essere caricata.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</source>
          <target state="translated">Ad esempio, dopo che l'istanza è annullato il wrapping, potrebbero richiedere le informazioni sul tipo, per chiamare i metodi ad associazione tardiva.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>When the assembly is loaded into the calling application domain, exceptions can occur.</source>
          <target state="translated">Quando l'assembly viene caricato nel dominio applicazione chiamante, possono verificarsi eccezioni.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> can occur.</source>
          <target state="translated">Se un'altra versione dello stesso assembly in precedenza è stata caricata nel dominio applicazione chiamante oppure se il percorso di caricamento del dominio applicazione chiamante è diverso da quello del dominio dell'applicazione di destinazione, le eccezioni, ad esempio <ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> possono verificarsi.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If the calling application domain makes early-bound calls to the instance type, <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> can be thrown when an attempt is made to cast the instance.</source>
          <target state="translated">Se il dominio applicazione chiamante effettua chiamate ad associazione anticipata per il tipo di istanza <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> può essere generata quando viene effettuato un tentativo di cast dell'istanza.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>When legacy CAS policy is not enabled, <ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> should be <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Quando i criteri di sicurezza dall'accesso di codice legacy non sono abilitati, <ph id="ph1">&lt;paramref name="securityAttributes" /&gt;</ph> deve essere <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was not found.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph>.</source>
          <target state="translated">Non è possibile trovare <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> in <ph id="ph2">&lt;paramref name="assemblyFile" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>No matching public constructor was found.</source>
          <target state="translated">Non è stato trovato alcun costruttore pubblico corrispondente.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This instance is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Questa istanza è <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Per poter leggere il file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>to provide evidence.</source>
          <target state="translated">per fornire l'evidenza.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Creates a new instance of a specified type defined in the specified assembly file.</source>
          <target state="translated">Crea una nuova istanza di un tipo specificato definito nel file di assembly specificato.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>The file name and path of the assembly that defines the requested type.</source>
          <target state="translated">Nome e percorso del file dell'assembly in cui viene definito il tipo richiesto.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>Creates a new instance of the specified type defined in the specified assembly file.</source>
          <target state="translated">Crea una nuova istanza del tipo specificato definito nel file di assembly specificato.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>The requested object, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">Oggetto richiesto o <ph id="ph1">&lt;see langword="null" /&gt;</ph> se <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si tratta di un metodo pratico che combina <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>This method calls the default constructor for <ph id="ph1">`typeName`</ph>.</source>
          <target state="translated">Questo metodo chiama il costruttore predefinito per <ph id="ph1">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Per altre informazioni, vedere il metodo <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">Non è possibile trovare <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>No parameterless public constructor was found.</source>
          <target state="translated">Non è stato trovato alcun costruttore pubblico senza parametri.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Per poter leggere il file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>The file name and path of the assembly that defines the requested type.</source>
          <target state="translated">Nome e percorso del file dell'assembly in cui viene definito il tipo richiesto.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly (see the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property).</source>
          <target state="translated">Nome completo del tipo richiesto, incluso lo spazio dei nomi ma non l'assembly (vedere la proprietà <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Matrice di uno o più attributi che possono prendere parte all'attivazione.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">In genere, matrice che contiene un singolo oggetto <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> che specifica l'URL necessario per attivare un oggetto remoto.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>Creates a new instance of the specified type defined in the specified assembly file.</source>
          <target state="translated">Crea una nuova istanza del tipo specificato definito nel file di assembly specificato.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>The requested object, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">Oggetto richiesto o <ph id="ph1">&lt;see langword="null" /&gt;</ph> se <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si tratta di un metodo pratico che combina <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>This method calls the default constructor for <ph id="ph1">`typeName`</ph>.</source>
          <target state="translated">Questo metodo chiama il costruttore predefinito per <ph id="ph1">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>For more information about this method, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Per ulteriori informazioni su questo metodo, vedere il <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">Non è possibile trovare <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>No parameterless public constructor was found.</source>
          <target state="translated">Non è stato trovato alcun costruttore pubblico senza parametri.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Per poter leggere il file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The file name and path of the assembly that defines the requested type.</source>
          <target state="translated">Nome e percorso del file dell'assembly in cui viene definito il tipo richiesto.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects through reflection.</source>
          <target state="translated">Oggetto che consente l'associazione, la coercizione di tipi di argomento, la chiamata di membri e il recupero di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> tramite la reflection.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> è Null, verrà usato il binder predefinito.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">Argomenti da passare al costruttore.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">Per usare il costruttore predefinito, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> deve essere una matrice vuota o Null.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Culture-specific information that governs the coercion of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> to the formal types declared for the <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> ai tipi formali dichiarati per il costruttore <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, per il thread corrente verrà usato l'oggetto <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Matrice di uno o più attributi che possono prendere parte all'attivazione.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">In genere, matrice che contiene un singolo oggetto <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> che specifica l'URL necessario per attivare un oggetto remoto.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">Il parametro è correlato agli oggetti attivati dal client.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Creates a new instance of the specified type defined in the specified assembly file, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</source>
          <target state="translated">Crea una nuova istanza del tipo specificato definito nel file di assembly specificato, indicando se ignorare le maiuscole/minuscole del nome del tipo, gli attributi e lo strumento di associazione usati per selezionare il tipo da creare, gli argomenti del costruttore, le impostazioni cultura e gli attributi di attivazione.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The requested object, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">Oggetto richiesto o <ph id="ph1">&lt;see langword="null" /&gt;</ph> se <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si tratta di un metodo pratico che combina <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>For more information about this method, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Per ulteriori informazioni su questo metodo, vedere il <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">Non è possibile trovare <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>No matching public constructor was found.</source>
          <target state="translated">Non è stato trovato alcun costruttore pubblico corrispondente.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version of the common language runtime that the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Per poter leggere il file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The file name and path of the assembly that defines the requested type.</source>
          <target state="translated">Nome e percorso del file dell'assembly in cui viene definito il tipo richiesto.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph> property.</source>
          <target state="translated">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <ph id="ph1">&lt;see cref="P:System.Type.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A Boolean value specifying whether to perform a case-sensitive search or not.</source>
          <target state="translated">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>A combination of zero or more bit flags that affect the search for the <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> is zero, a case-sensitive search for public constructors is conducted.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>bindingAttr<ept id="p1">&lt;/c&gt;</ept> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects through reflection.</source>
          <target state="translated">Oggetto che consente l'associazione, la coercizione di tipi di argomento, la chiamata di membri e il recupero di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> tramite la reflection.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is null, the default binder is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> è Null, verrà usato il binder predefinito.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The arguments to pass to the constructor.</source>
          <target state="translated">Argomenti da passare al costruttore.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</source>
          <target state="translated">La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If the default constructor is preferred, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> must be an empty array or null.</source>
          <target state="translated">Per usare il costruttore predefinito, <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> deve essere una matrice vuota o Null.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Culture-specific information that governs the coercion of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> to the formal types declared for the <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> constructor.</source>
          <target state="translated">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> ai tipi formali dichiarati per il costruttore <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, per il thread corrente verrà usato l'oggetto <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An array of one or more attributes that can participate in activation.</source>
          <target state="translated">Matrice di uno o più attributi che possono prendere parte all'attivazione.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Typically, an array that contains a single <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> object that specifies the URL that is required to activate a remote object.</source>
          <target state="translated">In genere, matrice che contiene un singolo oggetto <ph id="ph1">&lt;see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /&gt;</ph> che specifica l'URL necessario per attivare un oggetto remoto.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This parameter is related to client-activated objects.</source>
          <target state="translated">Il parametro è correlato agli oggetti attivati dal client.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</source>
          <target state="translated">L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Distributed applications should instead use Windows Communication Foundation.</source>
          <target state="translated">Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Information used to authorize creation of <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Informazioni usate per autorizzare la creazione di <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Creates a new instance of the specified type defined in the specified assembly file.</source>
          <target state="translated">Crea una nuova istanza del tipo specificato definito nel file di assembly specificato.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The requested object, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> is not found.</source>
          <target state="translated">Oggetto richiesto o <ph id="ph1">&lt;see langword="null" /&gt;</ph> se <ph id="ph2">&lt;paramref name="typeName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>This is a convenience method that combines <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si tratta di un metodo pratico che combina <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceFrom%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>For more information about this method, see the <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Per ulteriori informazioni su questo metodo, vedere il <ph id="ph1">&lt;xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller cannot provide activation attributes for an object that does not inherit from <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</source>
          <target state="translated">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <ph id="ph1">&lt;see cref="T:System.MarshalByRefObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was not found.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> was not found in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</source>
          <target state="translated">Non è possibile trovare <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> in <ph id="ph2">&lt;paramref name="assemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>No matching public constructor was found.</source>
          <target state="translated">Non è stato trovato alcun costruttore pubblico corrispondente.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>The caller does not have sufficient permission to call this constructor.</source>
          <target state="translated">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to read the file containing the assembly manifest.</source>
          <target state="translated">Per poter leggere il file che contiene il manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" uid="P:System.AppDomain.CurrentDomain">
          <source>Gets the current application domain for the current <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph>.</source>
          <target state="translated">Ottiene il dominio applicazione corrente per l'oggetto <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.CurrentDomain">
          <source>The current application domain.</source>
          <target state="translated">Dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.CurrentDomain">
          <source>The following code example creates a new application domain.</source>
          <target state="translated">Nell'esempio di codice riportato di seguito viene creato un nuovo dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.CurrentDomain">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.CurrentDomain%2A&gt;</ph> property is used to obtain an <ph id="ph2">&lt;xref:System.AppDomain&gt;</ph> object that represents the current application domain.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;xref:System.AppDomain.CurrentDomain%2A&gt;</ph> viene utilizzata per ottenere un oggetto <ph id="ph2">&lt;xref:System.AppDomain&gt;</ph> che rappresenta il dominio dell'applicazione corrente.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.CurrentDomain">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.FriendlyName%2A&gt;</ph> property provides the name of the current application domain, which is then displayed at the command line.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.AppDomain.FriendlyName%2A&gt;</ph> proprietà fornisce il nome del dominio applicazione corrente, che viene quindi visualizzato nella riga di comando.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Defines a dynamic assembly in the current application domain.</source>
          <target state="translated">Definisce un assembly dinamico nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identità univoca dell'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>The access mode for the dynamic assembly.</source>
          <target state="translated">Modalità di accesso per l'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>Defines a dynamic assembly with the specified name and access mode.</source>
          <target state="translated">Definisce un assembly dinamico con nome e modalità di accesso specificati.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>A dynamic assembly with the specified name and access mode.</source>
          <target state="translated">Assembly dinamico con il nome e la modalità di accesso specificati.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Per ulteriori informazioni, vedere il <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</source>
          <target state="translated">Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile utilizzare un overload di <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> metodo che specifica l'evidenza e le autorizzazioni, fornire l'evidenza l'assembly dinamico e includere <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">Tra cui <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> nel <ph id="ph2">`refusedPermissions`</ph> parametro assicura che il codice MSIL viene verificato.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">Una limitazione di questa tecnica è che fa in modo <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> quando usato con il codice che richiede l'attendibilità totale.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> (metodo) e <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Per informazioni su come ottenere il nome completo dell'assembly, vedere <bpt id="p1">[</bpt>i nomi degli Assembly<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identità univoca dell'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The access mode for the dynamic assembly.</source>
          <target state="translated">Modalità di accesso per l'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>An enumerable list of attributes to be applied to the assembly, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if there are no attributes.</source>
          <target state="translated">Elenco enumerabile di attributi da applicare all'assembly oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph> se non sono presenti attributi.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Defines a dynamic assembly with the specified name, access mode, and custom attributes.</source>
          <target state="translated">Definisce un assembly dinamico con il nome, la modalità di accesso e gli attributi personalizzati specificati.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dinamico con nome e funzionalità specificati.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</source>
          <target state="translated">Utilizzare questo overload del metodo per specificare gli attributi che non funzionano correttamente a meno che non vengono applicate quando viene creato un assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>For example, security attributes such as <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> do not work correctly if they are added after a dynamic assembly has been created.</source>
          <target state="translated">Ad esempio, attributi di sicurezza, ad esempio <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph> e <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> non funzionano correttamente se vengono aggiunti dopo aver creato un assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>This method should be used only to define a dynamic assembly in the current application domain.</source>
          <target state="translated">Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>For more information about this restriction, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Per ulteriori informazioni su questa restrizione, vedere il <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>This method overload is introduced in the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph>.</source>
          <target state="translated">Questo overload del metodo è stato introdotto nel <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The following code sample shows how to create a dynamic assembly that has the <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph>.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come creare un assembly dinamico con il <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The attribute must be specified as an element of an array of <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> objects.</source>
          <target state="translated">L'attributo deve essere specificato come elemento di una matrice di <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> oggetti.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The first step in creating the <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> is to obtain a constructor for the attribute.</source>
          <target state="translated">Il primo passaggio nella creazione di <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> consiste nell'ottenere un costruttore per l'attributo.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The constructor has no parameters, so the <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> method is called with an empty array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects to represent the types of the parameters.</source>
          <target state="translated">Il costruttore non ha parametri, pertanto la <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph> metodo viene chiamato con una matrice vuota di <ph id="ph2">&lt;xref:System.Type&gt;</ph> oggetti per rappresentare i tipi dei parametri.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The second step is to pass the resulting <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object to the constructor for the <ph id="ph2">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> class, together with an empty array of type <ph id="ph3">&lt;xref:System.Object&gt;</ph> to represent the arguments.</source>
          <target state="translated">Il secondo passaggio consiste nel passare il valore risultante <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> oggetto per il costruttore di <ph id="ph2">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> (classe), insieme a una matrice vuota di tipo <ph id="ph3">&lt;xref:System.Object&gt;</ph> per rappresentare gli argomenti.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The resulting <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> is then passed to the <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method as the only element of an array.</source>
          <target state="translated">Il valore risultante <ph id="ph1">&lt;xref:System.Reflection.Emit.CustomAttributeBuilder&gt;</ph> viene quindi passato al <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> metodo come l'unico elemento di matrice.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The example code defines a module and a type in the new dynamic assembly, and then displays the assembly's attributes.</source>
          <target state="translated">Nell'esempio di codice definisce un modulo e un tipo nell'assembly dinamico nuovo e quindi Visualizza gli attributi dell'assembly.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> starts with white space, or contains a forward or backward slash.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> inizia con uno spazio vuoto oppure contiene una barra o una barra rovesciata.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identità univoca dell'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">Modalità mediante cui si accederà all'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The evidence supplied for the dynamic assembly.</source>
          <target state="translated">Evidenza fornita per l'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The evidence is used unaltered as the final set of evidence used for policy resolution.</source>
          <target state="translated">L'evidenza viene usata senza modifiche come il set di evidenza finale impiegato per la risoluzione dei criteri.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>Defines a dynamic assembly using the specified name, access mode, and evidence.</source>
          <target state="translated">Definisce un assembly dinamico tramite il nome, la modalità di accesso e l'evidenza specificati.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dinamico con nome e funzionalità specificati.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>Only fully trusted callers can supply their <ph id="ph1">`evidence`</ph> when defining a dynamic <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>.</source>
          <target state="translated">Solo completamente attendibili i chiamanti possono fornire loro <ph id="ph1">`evidence`</ph> quando si definisce un dinamico <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The runtime will map the <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> through the security policy to determine the granted permissions.</source>
          <target state="translated">Il runtime eseguirà il mapping di <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> tramite i criteri di sicurezza per determinare le autorizzazioni concesse.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>Partially trusted callers must supply a null <ph id="ph1">`evidence`</ph>.</source>
          <target state="translated">Chiamanti parzialmente attendibili devono fornire un valore null <ph id="ph1">`evidence`</ph>.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>If <ph id="ph1">`evidence`</ph> is <ph id="ph2">`null`</ph>, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> to the dynamic <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> being defined and marks policy as resolved.</source>
          <target state="translated">Se <ph id="ph1">`evidence`</ph> è <ph id="ph2">`null`</ph>, il runtime copierà i set di autorizzazioni, vale a dire corrente concedere e negare set, da parte del chiamante <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> per dinamica <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> viene definito e contrassegna i criteri come risolti.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>If the dynamic <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> was saved.</source>
          <target state="translated">Se dinamica <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> viene salvato su disco, caricamenti successivi verranno concesse in base ai criteri associati al percorso in cui il <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> è stato salvato.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Per ulteriori informazioni, vedere il <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</source>
          <target state="translated">Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile utilizzare un overload di <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> metodo che specifica l'evidenza e le autorizzazioni, fornire l'evidenza l'assembly dinamico e includere <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">Tra cui <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> nel <ph id="ph2">`refusedPermissions`</ph> parametro assicura che il codice MSIL viene verificato.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">Una limitazione di questa tecnica è che fa in modo <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> quando usato con il codice che richiede l'attendibilità totale.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> (metodo) e <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>First, the code example tries to create an instance of <ph id="ph1">`MyDynamicType`</ph> by calling the <ph id="ph2">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> method with an invalid assembly name, and catches the resulting exception.</source>
          <target state="translated">In primo luogo, l'esempio di codice tenta di creare un'istanza di <ph id="ph1">`MyDynamicType`</ph> chiamando il <ph id="ph2">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> metodo con un nome di assembly non valido e rileva l'eccezione risulta.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The code example then adds an event handler for the <ph id="ph1">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event, and again tries to create an instance of<ph id="ph2">`MyDynamicType`</ph>.</source>
          <target state="translated">L'esempio di codice aggiunge quindi un gestore eventi per il <ph id="ph1">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> evento e si tenta nuovamente di creare un'istanza di<ph id="ph2">`MyDynamicType`</ph>.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>During the call to <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event is raised for the invalid assembly.</source>
          <target state="translated">Durante la chiamata a <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> evento viene generato per l'assembly non valido.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The event handler creates a dynamic assembly that contains a type named <ph id="ph1">`MyDynamicType`</ph>, gives the type a parameterless constructor, and returns the new dynamic assembly.</source>
          <target state="translated">Il gestore eventi crea un assembly dinamico che contiene un tipo denominato <ph id="ph1">`MyDynamicType`</ph>, fornisce il tipo di un costruttore senza parametri e restituisce il nuovo assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The call to <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> then finishes successfully, and the constructor for <ph id="ph2">`MyDynamicType`</ph> displays a message at the console.</source>
          <target state="translated">La chiamata a <ph id="ph1">&lt;xref:System.AppDomain.CreateInstance%2A&gt;</ph> quindi completata correttamente e il costruttore per <ph id="ph2">`MyDynamicType`</ph> Visualizza un messaggio nella console.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identità univoca dell'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">Modalità mediante cui si accederà all'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>The name of the directory where the assembly will be saved.</source>
          <target state="translated">Nome della directory nella quale verrà salvato l'assembly.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the directory defaults to the current directory.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, la directory predefinita sarà la directory corrente.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>Defines a dynamic assembly using the specified name, access mode, and storage directory.</source>
          <target state="translated">Definisce un assembly dinamico usando il nome, la modalità di accesso e la directory di archiviazione specificati.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dinamico con nome e funzionalità specificati.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Per ulteriori informazioni, vedere il <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</source>
          <target state="translated">Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile utilizzare un overload di <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> metodo che specifica l'evidenza e le autorizzazioni, fornire l'evidenza l'assembly dinamico e includere <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">Tra cui <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> nel <ph id="ph2">`refusedPermissions`</ph> parametro assicura che il codice MSIL viene verificato.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">Una limitazione di questa tecnica è che fa in modo <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> quando usato con il codice che richiede l'attendibilità totale.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> (metodo) e <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Per informazioni su come ottenere il nome completo dell'assembly, vedere <bpt id="p1">[</bpt>i nomi degli Assembly<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identità univoca dell'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>The access mode for the dynamic assembly.</source>
          <target state="translated">Modalità di accesso per l'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>An enumerable list of attributes to be applied to the assembly, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if there are no attributes.</source>
          <target state="translated">Elenco enumerabile di attributi da applicare all'assembly oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph> se non sono presenti attributi.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>The source of the security context.</source>
          <target state="translated">Origine del contesto di sicurezza.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>Defines a dynamic assembly with the specified name, access mode, and custom attributes, and using the specified source for its security context.</source>
          <target state="translated">Definisce un assembly dinamico con il nome, la modalità di accesso e gli attributi personalizzati specificati e usando il database di origine specificato per il contesto di sicurezza.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dinamico con nome e funzionalità specificati.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</source>
          <target state="translated">Utilizzare questo overload del metodo per specificare gli attributi che non funzionano correttamente a meno che non vengono applicate quando viene creato un assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>For example, security attributes such as <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> do not work correctly if they are added after a dynamic assembly has been created.</source>
          <target state="translated">Ad esempio, attributi di sicurezza, ad esempio <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph> e <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> non funzionano correttamente se vengono aggiunti dopo aver creato un assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>This method should be used only to define a dynamic assembly in the current application domain.</source>
          <target state="translated">Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>For more information about this restriction, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Per ulteriori informazioni su questa restrizione, vedere il <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> starts with white space, or contains a forward or backward slash.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> inizia con uno spazio vuoto oppure contiene una barra o una barra rovesciata.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)">
          <source>The value of <ph id="ph1">&lt;paramref name="securityContextSource" /&gt;</ph> was not one of the enumeration values.</source>
          <target state="translated">Il valore di <ph id="ph1">&lt;paramref name="securityContextSource" /&gt;</ph> non è uno dei valori di enumerazione.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identità univoca dell'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">Modalità mediante cui si accederà all'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The name of the directory where the assembly will be saved.</source>
          <target state="translated">Nome della directory nella quale verrà salvato l'assembly.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the directory defaults to the current directory.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, la directory predefinita sarà la directory corrente.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The evidence supplied for the dynamic assembly.</source>
          <target state="translated">Evidenza fornita per l'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The evidence is used unaltered as the final set of evidence used for policy resolution.</source>
          <target state="translated">L'evidenza viene usata senza modifiche come il set di evidenza finale impiegato per la risoluzione dei criteri.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>Defines a dynamic assembly using the specified name, access mode, storage directory, and evidence.</source>
          <target state="translated">Definisce un assembly dinamico mediante il nome, la modalità di accesso, la directory di archiviazione e l'evidenza specificati.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dinamico con nome e funzionalità specificati.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>Only fully trusted callers can supply their <ph id="ph1">`evidence`</ph> when defining a dynamic <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>.</source>
          <target state="translated">Solo completamente attendibili i chiamanti possono fornire loro <ph id="ph1">`evidence`</ph> quando si definisce un dinamico <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The runtime will map the <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> through the security policy to determine the granted permissions.</source>
          <target state="translated">Il runtime eseguirà il mapping di <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> tramite i criteri di sicurezza per determinare le autorizzazioni concesse.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>Partially trusted callers must supply a null <ph id="ph1">`evidence`</ph>.</source>
          <target state="translated">Chiamanti parzialmente attendibili devono fornire un valore null <ph id="ph1">`evidence`</ph>.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>If <ph id="ph1">`evidence`</ph> is <ph id="ph2">`null`</ph>, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> to the dynamic <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> being defined and marks policy as resolved.</source>
          <target state="translated">Se <ph id="ph1">`evidence`</ph> è <ph id="ph2">`null`</ph>, il runtime copierà i set di autorizzazioni, vale a dire corrente concedere e negare set, da parte del chiamante <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> per dinamica <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> viene definito e contrassegna i criteri come risolti.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>If the dynamic <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> was saved.</source>
          <target state="translated">Se dinamica <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> viene salvato su disco, caricamenti successivi verranno concesse in base ai criteri associati al percorso in cui il <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> è stato salvato.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Per ulteriori informazioni, vedere il <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</source>
          <target state="translated">Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile utilizzare un overload di <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> metodo che specifica l'evidenza e le autorizzazioni, fornire l'evidenza l'assembly dinamico e includere <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">Tra cui <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> nel <ph id="ph2">`refusedPermissions`</ph> parametro assicura che il codice MSIL viene verificato.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">Una limitazione di questa tecnica è che fa in modo <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> quando usato con il codice che richiede l'attendibilità totale.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> (metodo) e <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Per informazioni su come ottenere il nome completo dell'assembly, vedere <bpt id="p1">[</bpt>i nomi degli Assembly<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identità univoca dell'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">Modalità mediante cui si accederà all'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The required permissions request.</source>
          <target state="translated">Richiesta di autorizzazioni obbligatoria.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The optional permissions request.</source>
          <target state="translated">Richiesta di autorizzazioni facoltativa.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The refused permissions request.</source>
          <target state="translated">Richiesta di autorizzazioni rifiutata.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Defines a dynamic assembly using the specified name, access mode, and permission requests.</source>
          <target state="translated">Definisce un assembly dinamico usando il nome, la modalità di accesso e le richieste di autorizzazione specificati.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dinamico con nome e funzionalità specificati.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The permission requests specified for <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, and <ph id="ph3">`refusedPermissions`</ph> are not used unless the dynamic assembly has been saved and reloaded into memory.</source>
          <target state="translated">Le richieste di autorizzazione specificate per <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, e <ph id="ph3">`refusedPermissions`</ph> non vengono utilizzate, a meno che l'assembly dinamico è stato salvato e ricaricato in memoria.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence as well as requested permissions, and supply an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> object.</source>
          <target state="translated">Per specificare le richieste di autorizzazione per un assembly temporaneo che non viene mai salvato su disco, utilizzare l'overload del metodo di <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> metodo che specifica l'evidenza anche come richiesto e autorizzazioni, fornire un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</source>
          <target state="translated">Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile utilizzare un overload di <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> metodo che specifica l'evidenza e le autorizzazioni, fornire l'evidenza l'assembly dinamico e includere <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">Tra cui <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> nel <ph id="ph2">`refusedPermissions`</ph> parametro assicura che il codice MSIL viene verificato.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">Una limitazione di questa tecnica è che fa in modo <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> quando usato con il codice che richiede l'attendibilità totale.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload .</source>
          <target state="translated">Per ulteriori informazioni, vedere il <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> (metodo) e <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Per informazioni su come ottenere il nome completo dell'assembly, vedere <bpt id="p1">[</bpt>i nomi degli Assembly<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identità univoca dell'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">Modalità mediante cui si accederà all'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The name of the directory where the dynamic assembly will be saved.</source>
          <target state="translated">Nome della directory nella quale verrà salvato l'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the current directory is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, viene usata la directory corrente.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per sincronizzare la creazione di moduli, tipi e membri nell'assembly dinamico; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>An enumerable list of attributes to be applied to the assembly, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if there are no attributes.</source>
          <target state="translated">Elenco enumerabile di attributi da applicare all'assembly oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph> se non sono presenti attributi.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Defines a dynamic assembly using the specified name, access mode, storage directory, and synchronization option.</source>
          <target state="translated">Definisce un assembly dinamico usando il nome, la modalità di accesso, la directory di archiviazione e l'opzione di sincronizzazione specificati.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dinamico con nome e funzionalità specificati.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</source>
          <target state="translated">Utilizzare questo overload del metodo per specificare gli attributi che non funzionano correttamente a meno che non vengono applicate quando viene creato un assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>For example, security attributes such as <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> do not work correctly if they are added after a dynamic assembly has been created.</source>
          <target state="translated">Ad esempio, attributi di sicurezza, ad esempio <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph> e <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> non funzionano correttamente se vengono aggiunti dopo aver creato un assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If <ph id="ph1">`isSynchronized`</ph> is <ph id="ph2">`true`</ph>, the following methods of the resulting <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> will be synchronized: <ph id="ph4">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph>, and <ph id="ph9">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`isSynchronized`</ph> è <ph id="ph2">`true`</ph>, i metodi seguenti dell'oggetto risultante <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> verranno sincronizzati: <ph id="ph4">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph>, e <ph id="ph9">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If two of these methods are called on different threads, one will block until the other is completed.</source>
          <target state="translated">Se due di questi metodi vengono chiamati in thread diversi, uno verrà bloccata fino al completamento di altri.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> starts with white space, or contains a forward or backward slash.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> inizia con uno spazio vuoto oppure contiene una barra o una barra rovesciata.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identità univoca dell'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">Modalità mediante cui si accederà all'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The evidence supplied for the dynamic assembly.</source>
          <target state="translated">Evidenza fornita per l'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The evidence is used unaltered as the final set of evidence used for policy resolution.</source>
          <target state="translated">L'evidenza viene usata senza modifiche come il set di evidenza finale impiegato per la risoluzione dei criteri.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The required permissions request.</source>
          <target state="translated">Richiesta di autorizzazioni obbligatoria.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The optional permissions request.</source>
          <target state="translated">Richiesta di autorizzazioni facoltativa.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The refused permissions request.</source>
          <target state="translated">Richiesta di autorizzazioni rifiutata.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Defines a dynamic assembly using the specified name, access mode, evidence, and permission requests.</source>
          <target state="translated">Definisce un assembly dinamico usando il nome, la modalità di accesso, l'evidenza e le richieste di autorizzazione specificati.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dinamico con nome e funzionalità specificati.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The permission requests specified for <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, and <ph id="ph3">`refusedPermissions`</ph> are used only if <ph id="ph4">`evidence`</ph> is also supplied, or if the dynamic assembly is saved and reloaded into memory.</source>
          <target state="translated">Le richieste di autorizzazione specificate per <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, e <ph id="ph3">`refusedPermissions`</ph> vengono utilizzate solo se <ph id="ph4">`evidence`</ph> viene anche fornito, o se l'assembly dinamico viene salvato e ricaricato in memoria.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you include <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph2">`refusedPermissions`</ph>.</source>
          <target state="translated">Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile includere <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph2">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">Tra cui <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> nel <ph id="ph2">`refusedPermissions`</ph> parametro assicura che il codice MSIL viene verificato.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">Una limitazione di questa tecnica è che fa in modo <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> quando usato con il codice che richiede l'attendibilità totale.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Only fully trusted callers can supply their <ph id="ph1">`evidence`</ph> when defining a dynamic <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>.</source>
          <target state="translated">Solo completamente attendibili i chiamanti possono fornire loro <ph id="ph1">`evidence`</ph> quando si definisce un dinamico <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The runtime will map the <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> through the security policy to determine the granted permissions.</source>
          <target state="translated">Il runtime eseguirà il mapping di <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> tramite i criteri di sicurezza per determinare le autorizzazioni concesse.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Partially trusted callers must supply a null <ph id="ph1">`evidence`</ph>.</source>
          <target state="translated">Chiamanti parzialmente attendibili devono fornire un valore null <ph id="ph1">`evidence`</ph>.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>If <ph id="ph1">`evidence`</ph> is <ph id="ph2">`null`</ph>, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> to the dynamic <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> being defined and marks policy as resolved.</source>
          <target state="translated">Se <ph id="ph1">`evidence`</ph> è <ph id="ph2">`null`</ph>, il runtime copierà i set di autorizzazioni, vale a dire corrente concedere e negare set, da parte del chiamante <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> per dinamica <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> viene definito e contrassegna i criteri come risolti.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>If the dynamic <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> was saved.</source>
          <target state="translated">Se dinamica <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> viene salvato su disco, caricamenti successivi verranno concesse in base ai criteri associati al percorso in cui il <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> è stato salvato.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Per ulteriori informazioni, vedere il <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> (metodo) e <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Per informazioni su come ottenere il nome completo dell'assembly, vedere <bpt id="p1">[</bpt>i nomi degli Assembly<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identità univoca dell'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">Modalità mediante cui si accederà all'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The name of the directory where the assembly will be saved.</source>
          <target state="translated">Nome della directory nella quale verrà salvato l'assembly.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the directory defaults to the current directory.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, la directory predefinita sarà la directory corrente.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The required permissions request.</source>
          <target state="translated">Richiesta di autorizzazioni obbligatoria.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The optional permissions request.</source>
          <target state="translated">Richiesta di autorizzazioni facoltativa.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The refused permissions request.</source>
          <target state="translated">Richiesta di autorizzazioni rifiutata.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Defines a dynamic assembly using the specified name, access mode, storage directory, and permission requests.</source>
          <target state="translated">Definisce un assembly dinamico usando il nome, la modalità di accesso, la directory di archiviazione e le richieste di autorizzazione specificati.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dinamico con nome e funzionalità specificati.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The permission requests specified for <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, and <ph id="ph3">`refusedPermissions`</ph> are not used unless the dynamic assembly has been saved and reloaded into memory.</source>
          <target state="translated">Le richieste di autorizzazione specificate per <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, e <ph id="ph3">`refusedPermissions`</ph> non vengono utilizzate, a meno che l'assembly dinamico è stato salvato e ricaricato in memoria.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence as well as requested permissions, and supply an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> object.</source>
          <target state="translated">Per specificare le richieste di autorizzazione per un assembly temporaneo che non viene mai salvato su disco, utilizzare l'overload del metodo di <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> metodo che specifica l'evidenza anche come richiesto e autorizzazioni, fornire un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</source>
          <target state="translated">Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile utilizzare un overload di <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> metodo che specifica l'evidenza e le autorizzazioni, fornire l'evidenza l'assembly dinamico e includere <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph3">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">Tra cui <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> nel <ph id="ph2">`refusedPermissions`</ph> parametro assicura che il codice MSIL viene verificato.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">Una limitazione di questa tecnica è che fa in modo <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> quando usato con il codice che richiede l'attendibilità totale.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Per ulteriori informazioni, vedere il <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> (metodo) e <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Per informazioni su come ottenere il nome completo dell'assembly, vedere <bpt id="p1">[</bpt>i nomi degli Assembly<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identità univoca dell'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">Modalità mediante cui si accederà all'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The name of the directory where the assembly will be saved.</source>
          <target state="translated">Nome della directory nella quale verrà salvato l'assembly.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the directory defaults to the current directory.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, la directory predefinita sarà la directory corrente.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The evidence supplied for the dynamic assembly.</source>
          <target state="translated">Evidenza fornita per l'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The evidence is used unaltered as the final set of evidence used for policy resolution.</source>
          <target state="translated">L'evidenza viene usata senza modifiche come il set di evidenza finale impiegato per la risoluzione dei criteri.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The required permissions request.</source>
          <target state="translated">Richiesta di autorizzazioni obbligatoria.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The optional permissions request.</source>
          <target state="translated">Richiesta di autorizzazioni facoltativa.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The refused permissions request.</source>
          <target state="translated">Richiesta di autorizzazioni rifiutata.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, and permission requests.</source>
          <target state="translated">Definisce un assembly dinamico usando il nome, la modalità di accesso, la directory di archiviazione, l'evidenza e le richieste di autorizzazione specificati.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dinamico con nome e funzionalità specificati.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The permission requests specified for <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, and <ph id="ph3">`refusedPermissions`</ph> are used only if <ph id="ph4">`evidence`</ph> is also supplied, or if the dynamic assembly is saved and reloaded into memory.</source>
          <target state="translated">Le richieste di autorizzazione specificate per <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, e <ph id="ph3">`refusedPermissions`</ph> vengono utilizzate solo se <ph id="ph4">`evidence`</ph> viene anche fornito, o se l'assembly dinamico viene salvato e ricaricato in memoria.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you include <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph2">`refusedPermissions`</ph>.</source>
          <target state="translated">Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile includere <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph2">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">Tra cui <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> nel <ph id="ph2">`refusedPermissions`</ph> parametro assicura che il codice MSIL viene verificato.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">Una limitazione di questa tecnica è che fa in modo <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> quando usato con il codice che richiede l'attendibilità totale.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Only fully trusted callers can supply their <ph id="ph1">`evidence`</ph> when defining a dynamic <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>.</source>
          <target state="translated">Solo completamente attendibili i chiamanti possono fornire loro <ph id="ph1">`evidence`</ph> quando si definisce un dinamico <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The runtime will map the <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> through the security policy to determine the granted permissions.</source>
          <target state="translated">Il runtime eseguirà il mapping di <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> tramite i criteri di sicurezza per determinare le autorizzazioni concesse.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Partially trusted callers must supply a null <ph id="ph1">`evidence`</ph>.</source>
          <target state="translated">Chiamanti parzialmente attendibili devono fornire un valore null <ph id="ph1">`evidence`</ph>.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>If <ph id="ph1">`evidence`</ph> is <ph id="ph2">`null`</ph>, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> to the dynamic <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> being defined and marks policy as resolved.</source>
          <target state="translated">Se <ph id="ph1">`evidence`</ph> è <ph id="ph2">`null`</ph>, il runtime copierà i set di autorizzazioni, vale a dire corrente concedere e negare set, da parte del chiamante <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> per dinamica <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> viene definito e contrassegna i criteri come risolti.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>If the dynamic <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> was saved.</source>
          <target state="translated">Se dinamica <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> viene salvato su disco, caricamenti successivi verranno concesse in base ai criteri associati al percorso in cui il <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> è stato salvato.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>This method should only be used to define a dynamic assembly in the current application domain.</source>
          <target state="translated">Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Per ulteriori informazioni, vedere il <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> (metodo) e <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Per informazioni su come ottenere il nome completo dell'assembly, vedere <bpt id="p1">[</bpt>i nomi degli Assembly<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identità univoca dell'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">Modalità mediante cui si accederà all'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The name of the directory where the dynamic assembly will be saved.</source>
          <target state="translated">Nome della directory nella quale verrà salvato l'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the directory defaults to the current directory.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, la directory predefinita sarà la directory corrente.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The evidence supplied for the dynamic assembly.</source>
          <target state="translated">Evidenza fornita per l'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The evidence is used unaltered as the final set of evidence used for policy resolution.</source>
          <target state="translated">L'evidenza viene usata senza modifiche come il set di evidenza finale impiegato per la risoluzione dei criteri.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The required permissions request.</source>
          <target state="translated">Richiesta di autorizzazioni obbligatoria.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The optional permissions request.</source>
          <target state="translated">Richiesta di autorizzazioni facoltativa.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The refused permissions request.</source>
          <target state="translated">Richiesta di autorizzazioni rifiutata.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per sincronizzare la creazione di moduli, tipi e membri nell'assembly dinamico; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, permission requests, and synchronization option.</source>
          <target state="translated">Definisce un assembly dinamico usando il nome, la modalità di accesso, la directory di archiviazione, l'evidenza, le richieste di autorizzazione e l'opzione di sincronizzazione specificati.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dinamico con nome e funzionalità specificati.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The permission requests specified for <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, and <ph id="ph3">`refusedPermissions`</ph> are used only if <ph id="ph4">`evidence`</ph> is also supplied, or if the dynamic assembly is saved and reloaded into memory.</source>
          <target state="translated">Le richieste di autorizzazione specificate per <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, e <ph id="ph3">`refusedPermissions`</ph> vengono utilizzate solo se <ph id="ph4">`evidence`</ph> viene anche fornito, o se l'assembly dinamico viene salvato e ricaricato in memoria.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>During the development of code that emits dynamic assemblies, it is recommended that you include <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph2">`refusedPermissions`</ph>.</source>
          <target state="translated">Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile includere <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> in <ph id="ph2">`refusedPermissions`</ph>.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>Including <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> in the <ph id="ph2">`refusedPermissions`</ph> parameter ensures that the MSIL is verified.</source>
          <target state="translated">Tra cui <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification&gt;</ph> nel <ph id="ph2">`refusedPermissions`</ph> parametro assicura che il codice MSIL viene verificato.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when used with code that demands full trust.</source>
          <target state="translated">Una limitazione di questa tecnica è che fa in modo <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> quando usato con il codice che richiede l'attendibilità totale.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>Only fully trusted callers can supply their evidence when defining a dynamic <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>.</source>
          <target state="translated">Solo i chiamanti completamente attendibili possono fornire loro evidenza quando si definisce un dinamico <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The runtime will map the <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> through the security policy to determine the granted permissions.</source>
          <target state="translated">Il runtime eseguirà il mapping di <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> tramite i criteri di sicurezza per determinare le autorizzazioni concesse.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>Partially trusted callers must supply <ph id="ph1">`null`</ph> for the <ph id="ph2">`evidence`</ph> parameter.</source>
          <target state="translated">Chiamanti parzialmente attendibili devono fornire <ph id="ph1">`null`</ph> per il <ph id="ph2">`evidence`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>If <ph id="ph1">`evidence`</ph> is <ph id="ph2">`null`</ph>, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> to the dynamic <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> being defined and marks policy as resolved.</source>
          <target state="translated">Se <ph id="ph1">`evidence`</ph> è <ph id="ph2">`null`</ph>, il runtime copierà i set di autorizzazioni, vale a dire corrente concedere e negare set, da parte del chiamante <ph id="ph3">&lt;xref:System.Reflection.Assembly&gt;</ph> per dinamica <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> viene definito e contrassegna i criteri come risolti.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>If the dynamic <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> was saved.</source>
          <target state="translated">Se dinamica <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> viene salvato su disco, caricamenti successivi verranno concesse in base ai criteri associati al percorso in cui il <ph id="ph2">&lt;xref:System.Reflection.Assembly&gt;</ph> è stato salvato.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>If <ph id="ph1">`isSynchronized`</ph> is <ph id="ph2">`true`</ph>, the following methods of the resulting <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> will be synchronized: <ph id="ph4">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph>, and <ph id="ph9">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`isSynchronized`</ph> è <ph id="ph2">`true`</ph>, i metodi seguenti dell'oggetto risultante <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> verranno sincronizzati: <ph id="ph4">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph>, e <ph id="ph9">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>If two of these methods are called on different threads, one will block until the other completes.</source>
          <target state="translated">Se due di questi metodi vengono chiamati in thread diversi, uno verrà bloccata fino a quando il loro completamento.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> method and <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> event.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%2A&gt;</ph> (metodo) e <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Per informazioni su come ottenere il nome completo dell'assembly, vedere <bpt id="p1">[</bpt>i nomi degli Assembly<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> begins with white space, or contains a forward or backward slash.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The unique identity of the dynamic assembly.</source>
          <target state="translated">Identità univoca dell'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The mode in which the dynamic assembly will be accessed.</source>
          <target state="translated">Modalità mediante cui si accederà all'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The name of the directory where the dynamic assembly will be saved.</source>
          <target state="translated">Nome della directory nella quale verrà salvato l'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the current directory is used.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>dir<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, viene usata la directory corrente.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The evidence that is supplied for the dynamic assembly.</source>
          <target state="translated">Evidenza fornita per l'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The evidence is used unaltered as the final set of evidence used for policy resolution.</source>
          <target state="translated">L'evidenza viene usata senza modifiche come il set di evidenza finale impiegato per la risoluzione dei criteri.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The required permissions request.</source>
          <target state="translated">Richiesta di autorizzazioni obbligatoria.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The optional permissions request.</source>
          <target state="translated">Richiesta di autorizzazioni facoltativa.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The refused permissions request.</source>
          <target state="translated">Richiesta di autorizzazioni rifiutata.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> per sincronizzare la creazione di moduli, tipi e membri nell'assembly dinamico; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>An enumerable list of attributes to be applied to the assembly, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if there are no attributes.</source>
          <target state="translated">Elenco enumerabile di attributi da applicare all'assembly oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph> se non sono presenti attributi.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Defines a dynamic assembly with the specified name, access mode, storage directory, evidence, permission requests, synchronization option, and custom attributes.</source>
          <target state="translated">Definisce un assembly dinamico con il nome, la modalità di accesso, la directory di archiviazione, l'evidenza, le richieste di autorizzazione, l'opzione di sincronizzazione e gli attributi personalizzati specificati.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>A dynamic assembly with the specified name and features.</source>
          <target state="translated">Assembly dinamico con nome e funzionalità specificati.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</source>
          <target state="translated">Utilizzare questo overload del metodo per specificare gli attributi che non funzionano correttamente a meno che non vengono applicate quando viene creato un assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>For example, security attributes such as <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph> and <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> do not work correctly if they are added after a dynamic assembly has been created.</source>
          <target state="translated">Ad esempio, attributi di sicurezza, ad esempio <ph id="ph1">&lt;xref:System.Security.SecurityTransparentAttribute&gt;</ph> e <ph id="ph2">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph> non funzionano correttamente se vengono aggiunti dopo aver creato un assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The permission requests specified for the <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, and <ph id="ph3">`refusedPermissions`</ph> parameters are used only if the <ph id="ph4">`evidence`</ph> parameter is also supplied, or if the dynamic assembly is saved and reloaded into memory.</source>
          <target state="translated">Le richieste di autorizzazione specificate per il <ph id="ph1">`requiredPermissions`</ph>, <ph id="ph2">`optionalPermissions`</ph>, e <ph id="ph3">`refusedPermissions`</ph> parametri vengono utilizzati solo se il <ph id="ph4">`evidence`</ph> anche viene fornito alcun parametro, o se l'assembly dinamico viene salvato e ricaricato in memoria.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>When you develop code that emits dynamic assemblies, we recommend that you include the <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> flag in the <ph id="ph2">`refusedPermissions`</ph> parameter.</source>
          <target state="translated">Quando si sviluppa codice che genera gli assembly dinamici, si consiglia di includere il <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType&gt;</ph> flag nel <ph id="ph2">`refusedPermissions`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The inclusion of this flag ensures that the Microsoft intermediate language (MSIL) will be verified.</source>
          <target state="translated">L'inclusione di questo flag garantisce che il Microsoft intermediate language (MSIL) verrà verificata.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>This technique will detect the unintentional generation of unverifiable code, which otherwise is very difficult to detect.</source>
          <target state="translated">Questa tecnica rileverà la generazione di codice non verificabile, che in caso contrario è molto difficili da rilevare non intenzionale.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>A limitation of this technique is that it also causes <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> to be thrown when it is used with code that demands full trust.</source>
          <target state="translated">Una limitazione di questa tecnica è che fa in modo <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> viene generata quando viene utilizzato con il codice che richiede l'attendibilità totale.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Only fully trusted callers can supply evidence when defining a dynamic <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>.</source>
          <target state="translated">Solo i chiamanti completamente attendibili possono fornire l'evidenza quando si definisce un dinamico <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The runtime maps the <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> through the security policy to determine the granted permissions.</source>
          <target state="translated">Il runtime esegue il mapping di <ph id="ph1">&lt;xref:System.Security.Policy.Evidence&gt;</ph> tramite i criteri di sicurezza per determinare le autorizzazioni concesse.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Partially trusted callers must supply <ph id="ph1">`null`</ph> for the <ph id="ph2">`evidence`</ph> parameter.</source>
          <target state="translated">Chiamanti parzialmente attendibili devono fornire <ph id="ph1">`null`</ph> per il <ph id="ph2">`evidence`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If <ph id="ph1">`evidence`</ph> is <ph id="ph2">`null`</ph>, the runtime copies the permission sets (that is, the current grant and deny sets) from the caller's assembly to the dynamic assembly that is being defined, and marks the policy as resolved.</source>
          <target state="translated">Se <ph id="ph1">`evidence`</ph> è <ph id="ph2">`null`</ph>, il runtime copierà i set di autorizzazioni (ovvero, il correnti concesse e negate) dall'assembly del chiamante all'assembly dinamico che viene definito, contrassegnando i criteri come risolti.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If the dynamic assembly is saved to disk, subsequent loads will get grants based on policies that are associated with the location where the dynamic assembly was saved.</source>
          <target state="translated">Se l'assembly dinamico viene salvato su disco, successivi caricamenti verranno concesse autorizzazioni in base ai criteri associati al percorso in cui è stato salvato l'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If <ph id="ph1">`isSynchronized`</ph> is <ph id="ph2">`true`</ph>, the following methods of the resulting <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> will be synchronized: <ph id="ph4">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph>, and <ph id="ph9">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`isSynchronized`</ph> è <ph id="ph2">`true`</ph>, i metodi seguenti dell'oggetto risultante <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilder&gt;</ph> verranno sincronizzati: <ph id="ph4">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A&gt;</ph>, e <ph id="ph9">&lt;xref:System.Reflection.Emit.AssemblyBuilder.Save%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>If two of these methods are called on different threads, one will block until the other is completed.</source>
          <target state="translated">Se due di questi metodi vengono chiamati in thread diversi, uno verrà bloccata fino al completamento di altri.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>This method overload is introduced in the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph>.</source>
          <target state="translated">Questo overload del metodo è stato introdotto nel <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The <ph id="ph1">&lt;see langword="Name" /&gt;</ph> property of <ph id="ph2">&lt;paramref name="name" /&gt;</ph> starts with white space, or contains a forward or backward slash.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="Name" /&gt;</ph> di <ph id="ph2">&lt;paramref name="name" /&gt;</ph> inizia con uno spazio vuoto oppure contiene una barra o una barra rovesciata.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
          <source>A delegate that specifies a method to call.</source>
          <target state="translated">Delegato con cui viene specificato un metodo da chiamare.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
          <source>Executes the code in another application domain that is identified by the specified delegate.</source>
          <target state="translated">Esegue il codice in un altro dominio applicazione, identificato dal delegato specificato.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
          <source><ph id="ph1">`callBackDelegate`</ph> can specify a marshal-by-value, <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, or <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`callBackDelegate`</ph> specificare un marshalling dal valore, <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, o <ph id="ph3">&lt;xref:System.ContextBoundObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
          <source>The following sample demonstrates using a static <ph id="ph1">&lt;xref:System.AppDomain.DoCallBack%2A&gt;</ph> method.</source>
          <target state="translated">L'esempio seguente viene illustrato come utilizzare un valore statico <ph id="ph1">&lt;xref:System.AppDomain.DoCallBack%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
          <source>The following sample demonstrates using the <ph id="ph1">&lt;xref:System.AppDomain.DoCallBack%2A&gt;</ph> method by value.</source>
          <target state="translated">L'esempio seguente viene illustrato l'utilizzo di <ph id="ph1">&lt;xref:System.AppDomain.DoCallBack%2A&gt;</ph> metodo per valore.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
          <source>The following sample demonstrates using the <ph id="ph1">&lt;xref:System.AppDomain.DoCallBack%2A&gt;</ph> method by reference.</source>
          <target state="translated">L'esempio seguente viene illustrato l'utilizzo di <ph id="ph1">&lt;xref:System.AppDomain.DoCallBack%2A&gt;</ph> metodo per riferimento.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)">
          <source><ph id="ph1">&lt;paramref name="callBackDelegate" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="callBackDelegate" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="P:System.AppDomain.DomainManager">
          <source>Gets the domain manager that was provided by the host when the application domain was initialized.</source>
          <target state="translated">Ottiene il gestore di dominio fornito dall'host al momento dell'inizializzazione del dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DomainManager">
          <source>An object that represents the domain manager provided by the host when the application domain was initialized, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no domain manager was provided.</source>
          <target state="translated">Oggetto che rappresenta il gestore di dominio fornito dall'host quando è stato inizializzato il dominio dell'applicazione o <ph id="ph1">&lt;see langword="null" /&gt;</ph> se non è stato fornito alcun gestore di dominio.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DomainManager">
          <source>An unmanaged host of the common language runtime (CLR) can provide a domain manager.</source>
          <target state="translated">Un host non gestito di common language runtime (CLR) è possibile fornire un gestore di dominio.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DomainManager">
          <source>The domain manager can participate in initializing the new application domain and supply other managers, such as a <ph id="ph1">&lt;xref:System.Security.HostSecurityManager&gt;</ph>, that participate in the operations of the application domain.</source>
          <target state="translated">Il gestore di dominio può partecipare all'inizializzazione del nuovo dominio applicazione e fornire altri gestori, come ad esempio un <ph id="ph1">&lt;xref:System.Security.HostSecurityManager&gt;</ph>, che partecipano alle operazioni del dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DomainManager">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DomainManager">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" uid="E:System.AppDomain.DomainUnload">
          <source>Occurs when an <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> is about to be unloaded.</source>
          <target state="translated">Si verifica quando un oggetto <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> sta per essere scaricato.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.DomainUnload">
          <source>The <ph id="ph1">&lt;xref:System.EventHandler&gt;</ph> delegate for this event can perform any termination activities before the application domain is unloaded.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.EventHandler&gt;</ph> delegato per questo evento è possibile eseguire qualsiasi attività di chiusura prima che venga scaricato il dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.DomainUnload">
          <source>Each application domain that needs to perform processing when it is unloaded should register an event handler for this event.</source>
          <target state="translated">Ogni dominio applicazione che deve essere eseguita l'elaborazione quando viene scaricato deve registrare un gestore eventi per questo evento.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.DomainUnload">
          <source>A shared event handler should not be used, because the <ph id="ph1">&lt;xref:System.EventHandler&gt;</ph> delegate does not identify the domain that is being unloaded.</source>
          <target state="translated">Un gestore eventi condiviso non deve essere utilizzato, in quanto il <ph id="ph1">&lt;xref:System.EventHandler&gt;</ph> delegato identifica il dominio che sta per essere scaricato.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.DomainUnload">
          <source>This event is never raised in the default application domain.</source>
          <target state="translated">Questo evento non viene mai generato nel dominio applicazione predefinito.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.DomainUnload">
          <source>Do not make assumptions about the thread the event is raised on.</source>
          <target state="translated">Non basarsi su presupposti sul thread che in cui viene generato l'evento.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.DomainUnload">
          <source>The event can be raised on a different thread than the one that called the <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph> method.</source>
          <target state="translated">L'evento può essere generato in un thread diverso da quello che ha chiamato la <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.DomainUnload">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla gestione degli eventi, vedere <bpt id="p1">[</bpt>gestione e generazione di eventi<ept id="p1">](~/docs/standard/events/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" uid="P:System.AppDomain.DynamicDirectory">
          <source>Gets the directory that the assembly resolver uses to probe for dynamically created assemblies.</source>
          <target state="translated">Ottiene la directory usata dal resolver dell'assembly per verificare la presenza di assembly creati dinamicamente.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The directory that the assembly resolver uses to probe for dynamically created assemblies.</source>
          <target state="translated">Directory usata dal resolver dell'assembly per verificare la presenza di assembly creati dinamicamente.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>To set the dynamic directory, assign a base directory path to the <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType&gt;</ph> property of the <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> object that will be used to create the new application domain.</source>
          <target state="translated">Per impostare la directory dinamica, assegnare un percorso di directory di base per il <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType&gt;</ph> proprietà del <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> oggetto che verrà utilizzato per creare un nuovo dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The base directory path you assign to the property is modified by the addition of a subdirectory whose simple name is the hash code of the string you assign to the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType&gt;</ph> property, so the format of the base directory is <bpt id="p1">*</bpt>original path<ept id="p1">*</ept><ph id="ph2">\\</ph><bpt id="p2">*</bpt>hash code<ept id="p2">*</ept>.</source>
          <target state="translated">Il percorso della directory base assegnare alla proprietà viene modificato mediante l'aggiunta di una sottodirectory il cui nome semplice è il codice hash della stringa di cui si assegna al <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType&gt;</ph> proprietà, pertanto è il formato della directory base <bpt id="p1">*</bpt>percorso originale<ept id="p1">*</ept> <ph id="ph2">\\</ph> <bpt id="p2">*</bpt>il codice hash<ept id="p2">*</ept>.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The dynamic directory is a subdirectory of this base directory.</source>
          <target state="translated">La directory dinamica è una sottodirectory della directory di base.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>Its simple name is the value of the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType&gt;</ph> property, so its format is <bpt id="p1">*</bpt>original path<ept id="p1">*</ept><ph id="ph2">\\</ph><bpt id="p2">*</bpt>hash code<ept id="p2">*</ept><ph id="ph3">\\</ph><bpt id="p3">*</bpt>application name<ept id="p3">*</ept>.</source>
          <target state="translated">Il nome semplice è il valore della <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType&gt;</ph> proprietà, pertanto il formato è <bpt id="p1">*</bpt>percorso originale<ept id="p1">*</ept><ph id="ph2">\\</ph><bpt id="p2">*</bpt>il codice hash<ept id="p2">*</ept><ph id="ph3">\\</ph><bpt id="p3">*</bpt>nome applicazione<ept id="p3">*</ept>.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The following example creates an application domain with a directory for dynamic assemblies, emits a dynamic assembly and stores it in the dynamic directory, and then loads the assembly into the new application domain and uses it.</source>
          <target state="translated">Nell'esempio seguente crea un dominio applicazione con una directory per gli assembly dinamici, genera un assembly dinamico e archiviarlo nella directory dinamica, carica l'assembly nel nuovo dominio applicazione e viene utilizzato.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The example creates an <ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph> object and sets its <ph id="ph2">&lt;xref:System.AppDomainSetup.ApplicationName%2A&gt;</ph> property to "Example" and its <ph id="ph3">&lt;xref:System.AppDomainSetup.DynamicBase%2A&gt;</ph> property to "C:\DynamicAssemblyDir".</source>
          <target state="translated">Nell'esempio viene creato un <ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph> oggetto e imposta il relativo <ph id="ph2">&lt;xref:System.AppDomainSetup.ApplicationName%2A&gt;</ph> proprietà su "Esempio" e il relativo <ph id="ph3">&lt;xref:System.AppDomainSetup.DynamicBase%2A&gt;</ph> proprietà su "C:\DynamicAssemblyDir".</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The example then displays the <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A&gt;</ph> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.</source>
          <target state="translated">Nell'esempio viene quindi visualizzato il <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A&gt;</ph> proprietà, per mostrare che il codice hash del nome dell'applicazione è stato aggiunto come una sottodirectory del percorso a cui è stato originariamente assegnato.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The base directory in this example is intended to be outside the probing path for the example application.</source>
          <target state="translated">La directory di base in questo esempio deve essere utilizzata all'esterno del percorso di sondaggio per l'applicazione di esempio.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>Be sure to compile the example in a different location.</source>
          <target state="translated">Assicurarsi di compilare l'esempio in un percorso diverso.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>Delete the base directory and all its subdirectories each time you run the example.</source>
          <target state="translated">Eliminare la directory di base e tutte le relative sottodirectory ogni volta che si esegue l'esempio.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The example creates a new application domain, using the <ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph> object.</source>
          <target state="translated">Nell'esempio viene creato un nuovo dominio applicazione, utilizzando il <ph id="ph1">&lt;xref:System.AppDomainSetup&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The example uses the <ph id="ph1">&lt;xref:System.AppDomain.DynamicDirectory%2A&gt;</ph> property to retrieve the name of the directory, so it can create the directory.</source>
          <target state="translated">Nell'esempio viene utilizzata la <ph id="ph1">&lt;xref:System.AppDomain.DynamicDirectory%2A&gt;</ph> proprietà per recuperare il nome della directory, così da poter creare la directory.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>(The example could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.)</source>
          <target state="translated">(L'esempio può creare facilmente la directory in anticipo concatenando il percorso originale, il codice hash di nome dell'applicazione e il nome dell'applicazione.)</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The example has a <ph id="ph1">`GenerateDynamicAssembly`</ph> method that emits an assembly named <ph id="ph2">`DynamicHelloWorld.dll`</ph> and stores it in the new application domain's dynamic directory.</source>
          <target state="translated">L'esempio include una <ph id="ph1">`GenerateDynamicAssembly`</ph> metodo che genera un assembly denominato <ph id="ph2">`DynamicHelloWorld.dll`</ph> e lo archivia nella directory dinamica del nuovo dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The dynamic assembly contains one type, <ph id="ph1">`HelloWorld`</ph>, that has a static method (<ph id="ph2">`Shared`</ph> method in Visual Basic) named <ph id="ph3">`HelloFromAD`</ph>.</source>
          <target state="translated">L'assembly dinamico contiene un solo tipo, <ph id="ph1">`HelloWorld`</ph>, che dispone di un metodo statico (<ph id="ph2">`Shared`</ph> metodo in Visual Basic) denominata <ph id="ph3">`HelloFromAD`</ph>.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>Calling this method displays the name of the application domain.</source>
          <target state="translated">Chiamare questo metodo visualizza il nome del dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The <ph id="ph1">`Example`</ph> class derives from <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, so the example can create an instance of the class in the new application domain and call its <ph id="ph3">`Test`</ph> method.</source>
          <target state="translated">Il <ph id="ph1">`Example`</ph> deriva dalla classe <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, pertanto l'esempio è possibile creare un'istanza della classe in cui il nuovo dominio applicazione e chiamare il relativo <ph id="ph3">`Test`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The <ph id="ph1">`Test`</ph> method loads the dynamic assembly by its display name and calls the static <ph id="ph2">`HelloFromAD`</ph> method.</source>
          <target state="translated">Il <ph id="ph1">`Test`</ph> metodo carica l'assembly dinamico con il nome visualizzato e chiama il metodo statico <ph id="ph2">`HelloFromAD`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named <ph id="ph1">`DynamicHelloWorld.dll`</ph> and compiling it in the same directory as this example.</source>
          <target state="translated">È possibile mostrare che viene eseguita la ricerca di directory dinamica dopo i percorsi di sondaggio normale scrivendo il codice per un assembly denominato <ph id="ph1">`DynamicHelloWorld.dll`</ph> e compilarlo nella stessa directory in questo esempio.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The assembly must have a class named <ph id="ph1">`HelloWorld`</ph> with a static method named <ph id="ph2">`HelloFromAD`</ph>.</source>
          <target state="translated">L'assembly deve avere una classe denominata <ph id="ph1">`HelloWorld`</ph> con un metodo statico denominato <ph id="ph2">`HelloFromAD`</ph>.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>This method does not have to have the same functionality as the one in the example; it can simply display a string to the console.</source>
          <target state="translated">Questo metodo non è necessario avere la stessa funzionalità come quello nell'esempio; può visualizzare semplicemente una stringa sulla console.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>The assembly must also have an <ph id="ph1">&lt;xref:System.Reflection.AssemblyVersionAttribute&gt;</ph> attribute that sets its version to 1.0.0.0.</source>
          <target state="translated">L'assembly deve avere anche un <ph id="ph1">&lt;xref:System.Reflection.AssemblyVersionAttribute&gt;</ph> attributo che imposta la versione 1.0.0.0.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.</source>
          <target state="translated">Quando si esegue l'esempio, si trova l'assembly che è stato compilato nella directory corrente prima che la directory dinamica viene eseguita la ricerca.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="P:System.AppDomain.DynamicDirectory">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>for access to the path information.</source>
          <target state="translated">Per accedere alle informazioni sul percorso.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.DynamicDirectory">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="P:System.AppDomain.Evidence">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Security.Policy.Evidence" /&gt;</ph> associated with this application domain.</source>
          <target state="translated">Ottiene l'oggetto <ph id="ph1">&lt;see cref="T:System.Security.Policy.Evidence" /&gt;</ph> associato al dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.Evidence">
          <source>The evidence associated with this application domain.</source>
          <target state="translated">Evidenza associata al dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" uid="P:System.AppDomain.Evidence">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.Evidence">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.Evidence">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.Evidence">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Azione di sicurezza: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Executes the assembly contained in the specified file.</source>
          <target state="translated">Esegue l'assembly contenuto nel file specificato.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>The name of the file that contains the assembly to execute.</source>
          <target state="translated">Nome del file contenente l'assembly da eseguire.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>Executes the assembly contained in the specified file.</source>
          <target state="translated">Esegue l'assembly contenuto nel file specificato.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">Valore restituito dal punto di ingresso dell'assembly.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>This method loads assemblies using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Questo metodo carica l'assembly utilizzando il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>You can also execute assemblies using the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method, which loads assemblies using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">È anche possibile eseguire assembly utilizzando il <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> (metodo), che carica l'assembly utilizzando il <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>To create the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> to load and execute, use the <ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> method.</source>
          <target state="translated">Per creare il <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> per caricare ed eseguire, utilizzare il <ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>The following sample demonstrates using one of the overloads of <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> on two different domains.</source>
          <target state="translated">L'esempio seguente viene illustrato come utilizzare uno degli overload di <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> in due domini diversi.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non trovata.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L'assembly specificato non ha alcun punto di ingresso.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">per la lettura di un URI che iniziano con "file://".</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>to execute a console application.</source>
          <target state="translated">Per eseguire un'applicazione console.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>The name of the file that contains the assembly to execute.</source>
          <target state="translated">Nome del file contenente l'assembly da eseguire.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Evidenza per il caricamento dell'assembly.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>Executes the assembly contained in the specified file, using the specified evidence.</source>
          <target state="translated">Esegue l'assembly contenuto nel file specificato usando l'evidenza specificata.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">Valore restituito dal punto di ingresso dell'assembly.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> metodo crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>This method loads assemblies using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Questo metodo carica l'assembly utilizzando il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>You can also execute assemblies using the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method, which loads assemblies using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">È anche possibile eseguire assembly utilizzando il <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> (metodo), che carica l'assembly utilizzando il <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>The following sample demonstrates using one of the overloads of <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> on two different domains.</source>
          <target state="translated">L'esempio seguente viene illustrato come utilizzare uno degli overload di <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> in due domini diversi.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non trovata.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L'assembly specificato non ha alcun punto di ingresso.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">per la lettura di un URI che iniziano con "file://".</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>to execute a console application.</source>
          <target state="translated">Per eseguire un'applicazione console.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>The name of the file that contains the assembly to execute.</source>
          <target state="translated">Nome del file contenente l'assembly da eseguire.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>The arguments to the entry point of the assembly.</source>
          <target state="translated">Argomenti per il punto di ingresso dell'assembly.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>Executes the assembly contained in the specified file, using the specified arguments.</source>
          <target state="translated">Esegue l'assembly contenuto nel file specificato, usando gli argomenti specificati.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>The value that is returned by the entry point of the assembly.</source>
          <target state="translated">Valore restituito dal punto di ingresso dell'assembly.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>This method loads assemblies using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Questo metodo carica l'assembly utilizzando il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>You can also execute assemblies using the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method, which loads assemblies using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">È anche possibile eseguire assembly utilizzando il <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> (metodo), che carica l'assembly utilizzando il <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>The following sample demonstrates using one of the overloads of <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> on two different domains.</source>
          <target state="translated">L'esempio seguente viene illustrato come utilizzare uno degli overload di <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> in due domini diversi.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non trovata.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L'assembly specificato non ha alcun punto di ingresso.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">per la lettura di un URI che iniziano con "file://".</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>to execute a console application.</source>
          <target state="translated">Per eseguire un'applicazione console.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The name of the file that contains the assembly to execute.</source>
          <target state="translated">Nome del file contenente l'assembly da eseguire.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The supplied evidence for the assembly.</source>
          <target state="translated">Evidenza fornita per l'assembly.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The arguments to the entry point of the assembly.</source>
          <target state="translated">Argomenti per il punto di ingresso dell'assembly.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Executes the assembly contained in the specified file, using the specified evidence and arguments.</source>
          <target state="translated">Esegue l'assembly contenuto nel file specificato usando l'evidenza e gli argomenti specificati.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">Valore restituito dal punto di ingresso dell'assembly.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>This method loads assemblies using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Questo metodo carica l'assembly utilizzando il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>You can also execute assemblies using the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method, which loads assemblies using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">È anche possibile eseguire assembly utilizzando il <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> (metodo), che carica l'assembly utilizzando il <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The following sample demonstrates using one of the overloads of <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> on two different domains.</source>
          <target state="translated">L'esempio seguente viene illustrato come utilizzare uno degli overload di <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> in due domini diversi.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non trovata.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>When legacy CAS policy is not enabled, <ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> should be <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Quando i criteri di sicurezza dall'accesso di codice legacy non sono abilitati, <ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> deve essere <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L'assembly specificato non ha alcun punto di ingresso.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">per la lettura di un URI che iniziano con "file://".</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>to execute a console application.</source>
          <target state="translated">Per eseguire un'applicazione console.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The name of the file that contains the assembly to execute.</source>
          <target state="translated">Nome del file contenente l'assembly da eseguire.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The arguments to the entry point of the assembly.</source>
          <target state="translated">Argomenti per il punto di ingresso dell'assembly.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Represents the value of the computed hash code.</source>
          <target state="translated">Rappresenta il valore del codice hash calcolato.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Represents the hash algorithm used by the assembly manifest.</source>
          <target state="translated">Rappresenta l'algoritmo hash usato dal manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Executes the assembly contained in the specified file, using the specified arguments, hash value, and hash algorithm.</source>
          <target state="translated">Esegue l'assembly contenuto nel file specificato, usando gli argomenti, il valore hash e l'algoritmo hash specificati.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The value that is returned by the entry point of the assembly.</source>
          <target state="translated">Valore restituito dal punto di ingresso dell'assembly.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This method loads assemblies using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Questo metodo carica l'assembly utilizzando il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>You can also execute assemblies using the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method, which loads assemblies using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">È anche possibile eseguire assembly utilizzando il <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> (metodo), che carica l'assembly utilizzando il <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The following sample demonstrates using one of the overloads of <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> on two different domains.</source>
          <target state="translated">L'esempio seguente viene illustrato come utilizzare uno degli overload di <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> in due domini diversi.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non trovata.</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L'assembly specificato non ha alcun punto di ingresso.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">per la lettura di un URI che iniziano con "file://".</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>to execute a console application.</source>
          <target state="translated">Per eseguire un'applicazione console.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The name of the file that contains the assembly to execute.</source>
          <target state="translated">Nome del file contenente l'assembly da eseguire.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The supplied evidence for the assembly.</source>
          <target state="translated">Evidenza fornita per l'assembly.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The arguments to the entry point of the assembly.</source>
          <target state="translated">Argomenti per il punto di ingresso dell'assembly.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Represents the value of the computed hash code.</source>
          <target state="translated">Rappresenta il valore del codice hash calcolato.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Represents the hash algorithm used by the assembly manifest.</source>
          <target state="translated">Rappresenta l'algoritmo hash usato dal manifesto dell'assembly.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Executes the assembly contained in the specified file, using the specified evidence, arguments, hash value, and hash algorithm.</source>
          <target state="translated">Esegue l'assembly contenuto nel file specificato, usando l'evidenza, gli argomenti, il valore hash e l'algoritmo hash specificati.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">Valore restituito dal punto di ingresso dell'assembly.</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>This method loads assemblies using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Questo metodo carica l'assembly utilizzando il <ph id="ph1">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>You can also execute assemblies using the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method, which loads assemblies using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">È anche possibile eseguire assembly utilizzando il <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> (metodo), che carica l'assembly utilizzando il <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Thefollowing sample demonstrates using one of the overloads of <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> on two different domains.</source>
          <target state="translated">Thefollowing esempio viene illustrato come utilizzare uno degli overload di <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> in due domini diversi.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non trovata.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <ph id="ph1">&lt;paramref name="assemblyFile" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>When legacy CAS policy is not enabled, <ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> should be <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Quando i criteri di sicurezza dall'accesso di codice legacy non sono abilitati, <ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> deve essere <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L'assembly specificato non ha alcun punto di ingresso.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">per la lettura di un URI che iniziano con "file://".</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>to execute a console application.</source>
          <target state="translated">Per eseguire un'applicazione console.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Executes an assembly.</source>
          <target state="translated">Esegue un assembly.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>Executes an assembly given its display name.</source>
          <target state="translated">Esegue un assembly in base al nome visualizzato.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">Valore restituito dal punto di ingresso dell'assembly.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method provides similar functionality to the <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> method, but specifies the assembly by display name or <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> rather than by file location.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> metodo fornisce funzionalità simili a quelle di <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> (metodo), ma specifica l'assembly con nome visualizzato o <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> anziché dal percorso del file.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>Therefore, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> loads assemblies with the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method rather than with the <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Di conseguenza, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> carica gli assembly con il <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo anziché con il <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>To create the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> to load and execute, use the <ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> method.</source>
          <target state="translated">Per creare il <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> per caricare ed eseguire, utilizzare il <ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not found.</source>
          <target state="translated">L'assembly specificato da <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated">L'assembly specificato da <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was found, but could not be loaded.</source>
          <target state="translated">L'assembly specificato da <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato trovato, ma non è stato possibile caricarlo.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L'assembly specificato non ha alcun punto di ingresso.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</source>
          <target state="translated">per l'accesso in lettura da un file o directory, per accedere alle informazioni presenti nel percorso stesso e per il reindirizzamento a un percorso di un nome visualizzato.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>for access to a Web site, when a display name is redirected to a URL.</source>
          <target state="translated">per l'accesso a un sito Web, quando un nome visualizzato viene reindirizzato a un URL.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>to execute a console application.</source>
          <target state="translated">Per eseguire un'applicazione console.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object representing the name of the assembly.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> che rappresenta il nome dell'assembly.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>Command-line arguments to pass when starting the process.</source>
          <target state="translated">Argomenti della riga di comando da passare all'avvio del processo.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>Executes the assembly given an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>, using the specified arguments.</source>
          <target state="translated">Esegue l'assembly in base a un oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>, usando gli argomenti specificati.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The value that is returned by the entry point of the assembly.</source>
          <target state="translated">Valore restituito dal punto di ingresso dell'assembly.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method provides similar functionality to the <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> method, but specifies the assembly by display name or <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> rather than by file location.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> metodo fornisce funzionalità simili a quelle di <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> (metodo), ma specifica l'assembly con nome visualizzato o <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> anziché dal percorso del file.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>Therefore, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> loads assemblies with the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method rather than with the <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Di conseguenza, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> carica gli assembly con il <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo anziché con il <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not found.</source>
          <target state="translated">L'assembly specificato da <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was found, but could not be loaded.</source>
          <target state="translated">L'assembly specificato da <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato trovato, ma non è stato possibile caricarlo.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated">L'assembly specificato da <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L'assembly specificato non ha alcun punto di ingresso.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</source>
          <target state="translated">per l'accesso in lettura da un file o directory, per accedere alle informazioni presenti nel percorso stesso e per il reindirizzamento a un percorso di un nome visualizzato.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>for access to a Web site, when a display name is redirected to a URL.</source>
          <target state="translated">per l'accesso a un sito Web, quando un nome visualizzato viene reindirizzato a un URL.</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>to execute a console application.</source>
          <target state="translated">Per eseguire un'applicazione console.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Evidenza per il caricamento dell'assembly.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Executes an assembly given its display name, using the specified evidence.</source>
          <target state="translated">Esegue un assembly in base al nome visualizzato, usando l'evidenza specificata.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">Valore restituito dal punto di ingresso dell'assembly.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method provides similar functionality to the <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> method, but specifies the assembly by display name or <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> rather than by file location.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> metodo fornisce funzionalità simili a quelle di <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> (metodo), ma specifica l'assembly con nome visualizzato o <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> anziché dal percorso del file.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Therefore, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> loads assemblies with the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method rather than with the <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Di conseguenza, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> carica gli assembly con il <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo anziché con il <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> metodo crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>When you use the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">Quando si utilizza il <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> metodo con un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parametro evidenze vengono uniti.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">Evidenze fornito come argomento per il <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> metodo sostituiscono quelle di evidenza fornita dal caricatore.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not found.</source>
          <target state="translated">L'assembly specificato da <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was found, but could not be loaded.</source>
          <target state="translated">L'assembly specificato da <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato trovato, ma non è stato possibile caricarlo.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated">L'assembly specificato da <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L'assembly specificato non ha alcun punto di ingresso.</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</source>
          <target state="translated">per l'accesso in lettura da un file o directory, per accedere alle informazioni presenti nel percorso stesso e per il reindirizzamento a un percorso di un nome visualizzato.</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>for access to a Web site, when a display name is redirected to a URL.</source>
          <target state="translated">per l'accesso a un sito Web, quando un nome visualizzato viene reindirizzato a un URL.</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>to execute a console application.</source>
          <target state="translated">Per eseguire un'applicazione console.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The display name of the assembly.</source>
          <target state="translated">Nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>Command-line arguments to pass when starting the process.</source>
          <target state="translated">Argomenti della riga di comando da passare all'avvio del processo.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>Executes the assembly given its display name, using the specified arguments.</source>
          <target state="translated">Esegue l'assembly in base al nome visualizzato, usando gli argomenti specificati.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The value that is returned by the entry point of the assembly.</source>
          <target state="translated">Valore restituito dal punto di ingresso dell'assembly.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method provides similar functionality to the <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> method, but specifies the assembly by display name or <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> rather than by file location.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> metodo fornisce funzionalità simili a quelle di <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> (metodo), ma specifica l'assembly con nome visualizzato o <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> anziché dal percorso del file.</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>Therefore, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> loads assemblies with the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method rather than with the <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Di conseguenza, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> carica gli assembly con il <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo anziché con il <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not found.</source>
          <target state="translated">L'assembly specificato da <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was found, but could not be loaded.</source>
          <target state="translated">L'assembly specificato da <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato trovato, ma non è stato possibile caricarlo.</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated">L'assembly specificato da <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L'assembly specificato non ha alcun punto di ingresso.</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</source>
          <target state="translated">per l'accesso in lettura da un file o directory, per accedere alle informazioni presenti nel percorso stesso e per il reindirizzamento a un percorso di un nome visualizzato.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>for access to a Web site, when a display name is redirected to a URL.</source>
          <target state="translated">per l'accesso a un sito Web, quando un nome visualizzato viene reindirizzato a un URL.</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>to execute a console application.</source>
          <target state="translated">Per eseguire un'applicazione console.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object representing the name of the assembly.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> che rappresenta il nome dell'assembly.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Evidenza per il caricamento dell'assembly.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Command-line arguments to pass when starting the process.</source>
          <target state="translated">Argomenti della riga di comando da passare all'avvio del processo.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Executes the assembly given an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>, using the specified evidence and arguments.</source>
          <target state="translated">Esegue l'assembly in base a un dato oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>, usando l'evidenza e gli argomenti specificati.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">Valore restituito dal punto di ingresso dell'assembly.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method provides similar functionality to the <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> method, but specifies the assembly by display name or <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> rather than by file location.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> metodo fornisce funzionalità simili a quelle di <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> (metodo), ma specifica l'assembly con nome visualizzato o <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> anziché dal percorso del file.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Therefore, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> loads assemblies with the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method rather than with the <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Di conseguenza, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> carica gli assembly con il <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo anziché con il <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>When you use the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">Quando si utilizza il <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> metodo con un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parametro evidenze vengono uniti.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">Evidenze fornito come argomento per il <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> metodo sostituiscono quelle di evidenza fornita dal caricatore.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not found.</source>
          <target state="translated">L'assembly specificato da <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was found, but could not be loaded.</source>
          <target state="translated">L'assembly specificato da <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato trovato, ma non è stato possibile caricarlo.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated">L'assembly specificato da <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>When legacy CAS policy is not enabled, <ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> should be <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Quando i criteri di sicurezza dall'accesso di codice legacy non sono abilitati, <ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> deve essere <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L'assembly specificato non ha alcun punto di ingresso.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</source>
          <target state="translated">per l'accesso in lettura da un file o directory, per accedere alle informazioni presenti nel percorso stesso e per il reindirizzamento a un percorso di un nome visualizzato.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>for access to a Web site, when a display name is redirected to a URL.</source>
          <target state="translated">per l'accesso a un sito Web, quando un nome visualizzato viene reindirizzato a un URL.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>to execute a console application.</source>
          <target state="translated">Per eseguire un'applicazione console.</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The display name of the assembly.</source>
          <target state="translated">Nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Evidenza per il caricamento dell'assembly.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Command-line arguments to pass when starting the process.</source>
          <target state="translated">Argomenti della riga di comando da passare all'avvio del processo.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Executes the assembly given its display name, using the specified evidence and arguments.</source>
          <target state="translated">Esegue l'assembly in base al nome visualizzato, usando l'evidenza e gli argomenti specificati.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The value returned by the entry point of the assembly.</source>
          <target state="translated">Valore restituito dal punto di ingresso dell'assembly.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method provides similar functionality to the <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> method, but specifies the assembly by display name or <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> rather than by file location.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> metodo fornisce funzionalità simili a quelle di <ph id="ph2">&lt;xref:System.AppDomain.ExecuteAssembly%2A&gt;</ph> (metodo), ma specifica l'assembly con nome visualizzato o <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> anziché dal percorso del file.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Therefore, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> loads assemblies with the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method rather than with the <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> method.</source>
          <target state="translated">Di conseguenza, <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> carica gli assembly con il <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> metodo anziché con il <ph id="ph3">&lt;xref:System.Reflection.Assembly.LoadFile%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly begins executing at the entry point specified in the .NET Framework header.</source>
          <target state="translated">L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</source>
          <target state="translated">Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>When you use the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parameter, pieces of evidence are merged.</source>
          <target state="translated">Quando si utilizza il <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> metodo con un <ph id="ph2">&lt;xref:System.Security.Policy.Evidence&gt;</ph> parametro evidenze vengono uniti.</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Pieces of evidence supplied as an argument to the <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> method supersede pieces of evidence supplied by the loader.</source>
          <target state="translated">Evidenze fornito come argomento per il <ph id="ph1">&lt;xref:System.AppDomain.ExecuteAssemblyByName%2A&gt;</ph> metodo sostituiscono quelle di evidenza fornita dal caricatore.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not found.</source>
          <target state="translated">L'assembly specificato da <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è stato trovato.</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was found, but could not be loaded.</source>
          <target state="translated">L'assembly specificato da <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato trovato, ma non è stato possibile caricarlo.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The assembly specified by <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated">L'assembly specificato da <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <ph id="ph1">&lt;paramref name="assemblyName" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>When legacy CAS policy is not enabled, <ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> should be <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Quando i criteri di sicurezza dall'accesso di codice legacy non sono abilitati, <ph id="ph1">&lt;paramref name="assemblySecurity" /&gt;</ph> deve essere <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>The specified assembly has no entry point.</source>
          <target state="translated">L'assembly specificato non ha alcun punto di ingresso.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</source>
          <target state="translated">per l'accesso in lettura da un file o directory, per accedere alle informazioni presenti nel percorso stesso e per il reindirizzamento a un percorso di un nome visualizzato.</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>for access to a Web site, when a display name is redirected to a URL.</source>
          <target state="translated">per l'accesso a un sito Web, quando un nome visualizzato viene reindirizzato a un URL.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>to execute a console application.</source>
          <target state="translated">Per eseguire un'applicazione console.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" uid="E:System.AppDomain.FirstChanceException">
          <source>Occurs when an exception is thrown in managed code, before the runtime searches the call stack for an exception handler in the application domain.</source>
          <target state="translated">Si verifica quando un'eccezione viene generata in codice gestito prima che il runtime cerchi un gestore di eccezioni nello stack di chiamate del dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>This event is only a notification.</source>
          <target state="translated">Questo evento è solo una notifica.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>Handling this event does not handle the exception or affect subsequent exception handling in any way.</source>
          <target state="translated">Gestione di questo evento non gestire l'eccezione, né altera successive eccezioni in alcun modo.</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>After the event has been raised and event handlers have been invoked, the common language runtime (CLR) begins to search for a handler for the exception.</source>
          <target state="translated">Dopo che è stato generato l'evento e i gestori eventi siano stati richiamati, common language runtime (CLR) inizia la ricerca di un gestore per l'eccezione.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source><ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> provides the application domain with a first chance to examine any managed exception.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> fornisce il dominio applicazione con una prima opportunità per esaminare qualsiasi eccezione gestita.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>The event can be handled per application domain.</source>
          <target state="translated">L'evento può essere gestito per ogni dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>If a thread passes through multiple application domains while executing a call, the event is raised in each application domain that has registered an event handler, before the CLR begins searching for a matching exception handler in that application domain.</source>
          <target state="translated">Se un thread passa attraverso più domini applicazione durante l'esecuzione di una chiamata, l'evento viene generato in ogni dominio applicazione che ha registrato un gestore di evento, prima di CLR inizia la ricerca per un gestore eccezioni corrispondente nel dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>After the event has been handled, a search is made for a matching exception handler in that application domain.</source>
          <target state="translated">Dopo l'evento è stata gestita, viene eseguita una ricerca per un gestore eccezioni corrispondente nel dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>If none is found, the event is raised in the next application domain.</source>
          <target state="translated">Se non viene trovato, viene generato l'evento nel dominio dell'applicazione successivo.</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>You must handle all exceptions that occur in the event handler for the <ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> event.</source>
          <target state="translated">È necessario gestire tutte le eccezioni che si verificano nel gestore per il <ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>Otherwise, <ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> is raised recursively.</source>
          <target state="translated">In caso contrario, <ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> viene generato in modo ricorsivo.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>This could result in a stack overflow and termination of the application.</source>
          <target state="translated">Ciò potrebbe causare un overflow dello stack e la chiusura dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>We recommend that you implement event handlers for this event as constrained execution regions (CERs), to keep infrastructure-related exceptions such as out-of-memory or stack overflow from affecting the virtual machine while the exception notification is being processed.</source>
          <target state="translated">È consigliabile implementare i gestori eventi per questo evento come aree a esecuzione vincolata (CER), per evitare che le eccezioni correlate all'infrastruttura, ad esempio di memoria insufficiente o overflow dello stack di influire sulla macchina virtuale durante l'elaborazione della notifica dell'eccezione.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>This event is not raised for exceptions that indicate corruption of process state, such as access violations, unless the event handler is security-critical and has the <ph id="ph1">&lt;xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute&gt;</ph> attribute.</source>
          <target state="translated">Questo evento non viene generato per le eccezioni che indicano il danneggiamento dello stato del processo, ad esempio le violazioni di accesso, a meno che il gestore dell'evento è critico per la sicurezza e ha il <ph id="ph1">&lt;xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute&gt;</ph> attributo.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>The common language runtime suspends thread aborts while this notification event is being handled.</source>
          <target state="translated">Common language runtime sospende le interruzioni di thread, mentre viene gestito l'evento di notifica.</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>The following example creates a series of application domains named <ph id="ph1">`AD0`</ph> through <ph id="ph2">`AD3`</ph>, with a <ph id="ph3">`Worker`</ph> object in each application domain.</source>
          <target state="translated">Nell'esempio seguente crea una serie di domini di applicazione denominato <ph id="ph1">`AD0`</ph> tramite <ph id="ph2">`AD3`</ph>, con un <ph id="ph3">`Worker`</ph> oggetto in ogni dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>Each <ph id="ph1">`Worker`</ph> object has a reference to the <ph id="ph2">`Worker`</ph> object in the next application domain, except for the <ph id="ph3">`Worker`</ph> in the last application domain.</source>
          <target state="translated">Ogni <ph id="ph1">`Worker`</ph> oggetto ha un riferimento al <ph id="ph2">`Worker`</ph> dell'oggetto nel dominio dell'applicazione Avanti, fatta eccezione per il <ph id="ph3">`Worker`</ph> nell'ultimo dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> event is handled in all application domains except <ph id="ph2">`AD1`</ph>.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> evento viene gestito in tutti i domini applicazione, ad eccezione <ph id="ph2">`AD1`</ph>.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>In addition to this example, which demonstrates first-chance exception notifications in multiple application domains, you can find simple use cases in <bpt id="p1">[</bpt>How to: Receive First-Chance Exception Notifications<ept id="p1">](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md)</ept>.</source>
          <target state="translated">Oltre a questo esempio, che dimostra le notifiche di eccezioni first-chance in più domini applicazione, è possibile trovare casi di utilizzo semplice <bpt id="p1">[</bpt>procedura: ricevere notifiche di eccezioni First-Chance<ept id="p1">](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>When the application domains have been created, the default application domain calls the <ph id="ph1">`TestException`</ph> method for the first application domain.</source>
          <target state="translated">Quando sono stati creati i domini applicazione, il dominio applicazione predefinito chiama il <ph id="ph1">`TestException`</ph> metodo per il primo dominio di applicazione.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>Each <ph id="ph1">`Worker`</ph> object calls the <ph id="ph2">`TestException`</ph> method for the next application domain, until the last <ph id="ph3">`Worker`</ph> throws an exception that is either handled or unhandled.</source>
          <target state="translated">Ogni <ph id="ph1">`Worker`</ph> chiama il <ph id="ph2">`TestException`</ph> metodo per il dominio di applicazione successivo, fino a quando l'ultimo <ph id="ph3">`Worker`</ph> genera un'eccezione che è o non gestita.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>Thus, the current thread passes through all the application domains, and <ph id="ph1">`TestException`</ph> is added to the stack in each application domain.</source>
          <target state="translated">Di conseguenza, il thread corrente attraversa tutti i domini applicazione, e <ph id="ph1">`TestException`</ph> viene aggiunto allo stack in ogni dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>When the last <ph id="ph1">`Worker`</ph> object handles the exception, the <ph id="ph2">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> event is raised only in the last application domain.</source>
          <target state="translated">Quando l'ultimo <ph id="ph1">`Worker`</ph> oggetto gestisce l'eccezione, il <ph id="ph2">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> evento viene generato solo nell'ultimo dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>The other application domains never get a chance to handle the exception, so the event is not raised.</source>
          <target state="translated">Gli altri domini applicazione mai la possibilità di gestire l'eccezione, pertanto non viene generato l'evento.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>When the last <ph id="ph1">`Worker`</ph> object does not handle the exception, the <ph id="ph2">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> event is raised in each application domain that has an event handler.</source>
          <target state="translated">Quando l'ultimo <ph id="ph1">`Worker`</ph> oggetto non gestisce l'eccezione, il <ph id="ph2">&lt;xref:System.AppDomain.FirstChanceException&gt;</ph> in ogni dominio applicazione che dispone di un gestore di evento viene generato l'evento.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>After each event handler has finished, the stack continues to unwind until the exception is caught by the default application domain.</source>
          <target state="translated">Al termine di ogni gestore dell'evento, lo stack continua la rimozione fino a quando l'eccezione viene intercettata dal dominio applicazione predefinito.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>To see how the stack display grows as the event is raised closer and closer to the default application domain, change <ph id="ph1">`e.Exception.Message`</ph> to <ph id="ph2">`e.Exception`</ph> in the <ph id="ph3">`FirstChanceHandler`</ph> event handlers.</source>
          <target state="translated">Per visualizzare la modalità di visualizzazione dello stack aumenta man mano che viene generato l'evento più vicino e verso il dominio applicazione predefinito, modificare <ph id="ph1">`e.Exception.Message`</ph> a <ph id="ph2">`e.Exception`</ph> nel <ph id="ph3">`FirstChanceHandler`</ph> gestori eventi.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>Notice that when <ph id="ph1">`TestException`</ph> is called across application domain boundaries, it appears twice: once for the proxy and once for the stub.</source>
          <target state="translated">Si noti che quando <ph id="ph1">`TestException`</ph> viene chiamato attraverso i limiti del dominio applicazione, viene visualizzato due volte: una volta per il proxy e una volta per lo stub.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.FirstChanceException">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" uid="P:System.AppDomain.FriendlyName">
          <source>Gets the friendly name of this application domain.</source>
          <target state="translated">Ottiene il nome descrittivo del dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.FriendlyName">
          <source>The friendly name of this application domain.</source>
          <target state="translated">Nome descrittivo del dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.FriendlyName">
          <source>The friendly name of the default application domain is the file name of the process executable.</source>
          <target state="translated">Il nome descrittivo del dominio applicazione predefinito è il nome del file dell'eseguibile del processo.</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.FriendlyName">
          <source>For example, if the executable used to start the process is <ph id="ph1">`"c:\MyAppDirectory\MyAssembly.exe"`</ph>, the friendly name of the default application domain is <ph id="ph2">`"MyAssembly.exe"`</ph>.</source>
          <target state="translated">Ad esempio, se l'eseguibile usato per avviare il processo è <ph id="ph1">`"c:\MyAppDirectory\MyAssembly.exe"`</ph>, il nome descrittivo del dominio applicazione predefinito è <ph id="ph2">`"MyAssembly.exe"`</ph>.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.FriendlyName">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.AppDomain.FriendlyName%2A&gt;</ph> property to get the friendly name of the current application domain.</source>
          <target state="translated">Nell'esempio di codice viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.AppDomain.FriendlyName%2A&gt;</ph> proprietà da ottenere il nome descrittivo del dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.FriendlyName">
          <source>For the default application domain, the friendly name is the name of the application's executable file.</source>
          <target state="translated">Per il dominio applicazione predefinito, il nome descrittivo è il nome del file eseguibile dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.FriendlyName">
          <source>The code example also displays additional information about the application domain.</source>
          <target state="translated">L'esempio di codice visualizza anche informazioni aggiuntive sul dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" uid="P:System.AppDomain.FriendlyName">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetAssemblies">
          <source>Gets the assemblies that have been loaded into the execution context of this application domain.</source>
          <target state="translated">Ottiene gli assembly caricati nel contesto di esecuzione del dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetAssemblies">
          <source>An array of assemblies in this application domain.</source>
          <target state="translated">Matrice di assembly nel dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetAssemblies">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph> method to get a list of all assemblies that have been loaded into the application domain.</source>
          <target state="translated">Nell'esempio di codice viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph> metodo per ottenere un elenco di tutti gli assembly che sono stati caricati nel dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetAssemblies">
          <source>The assemblies are then displayed to the console.</source>
          <target state="translated">Gli assembly vengono quindi visualizzati nella console.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetAssemblies">
          <source>To run this code example, you need to create an assembly named <ph id="ph1">`CustomLibrary.dll`</ph>, or change the assembly name that is passed to the <ph id="ph2">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph> method.</source>
          <target state="translated">Per eseguire questo esempio di codice, è necessario creare un assembly denominato <ph id="ph1">`CustomLibrary.dll`</ph>, o modificare il nome dell'assembly che viene passato per il <ph id="ph2">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetAssemblies">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetCurrentThreadId">
          <source>Gets the current thread identifier.</source>
          <target state="translated">Ottiene l'identificatore del thread attuale.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetCurrentThreadId">
          <source>A 32-bit signed integer that is the identifier of the current thread.</source>
          <target state="translated">Intero con segno a 32 bit che rappresenta l'identificatore del thread attuale.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetCurrentThreadId">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType&gt;</ph> property, which is stable even when the .NET Framework is hosted by an environment that supports fibers (that is, lightweight threads).</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType&gt;</ph> proprietà, che rimane stabile anche quando .NET Framework è ospitato da un ambiente che supporta i fiber (vale a dire il thread lightweight).</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetCurrentThreadId">
          <source>to call this method.</source>
          <target state="translated">chiamare questo metodo.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetCurrentThreadId">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetCurrentThreadId">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Azione di sicurezza: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetData(System.String)">
          <source>The name of a predefined application domain property, or the name of an application domain property you have defined.</source>
          <target state="translated">Nome di una proprietà del dominio applicazione predefinita o nome della proprietà di un dominio applicazione definito.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetData(System.String)">
          <source>Gets the value stored in the current application domain for the specified name.</source>
          <target state="translated">Ottiene il valore archiviato nel dominio applicazione attuale per il nome specificato.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetData(System.String)">
          <source>The value of the <ph id="ph1">&lt;paramref name="name" /&gt;</ph> property, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the property does not exist.</source>
          <target state="translated">Valore della proprietà <ph id="ph1">&lt;paramref name="name" /&gt;</ph> oppure <ph id="ph2">&lt;see langword="null" /&gt;</ph> se la proprietà non esiste.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>Use this method to retrieve the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>.</source>
          <target state="translated">Utilizzare questo metodo per recuperare il valore di una voce in una cache interna di coppie nome / dati che descrivono le proprietà di questa istanza di <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>Note that the comparison of <ph id="ph1">`name`</ph> with the name of key-value pairs is case-sensitive.</source>
          <target state="translated">Si noti che il confronto di <ph id="ph1">`name`</ph> con il nome di coppie chiave-valore è tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>The cache automatically contains predefined system entries that are inserted when the application domain is created.</source>
          <target state="translated">La cache contiene automaticamente le voci di sistema predefiniti che vengono inserite quando viene creato il dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>You can inspect their values with the <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method, or the equivalent <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> properties.</source>
          <target state="translated">È possibile controllare i valori mediante la <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> metodo o l'equivalente <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>You can insert or modify your own user defined name-data pairs with the <ph id="ph1">&lt;xref:System.AppDomain.SetData%2A&gt;</ph> method and inspect their values with the <ph id="ph2">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method.</source>
          <target state="translated">È possibile inserire o modificare la propria coppie nome / dati definiti dall'utente con il <ph id="ph1">&lt;xref:System.AppDomain.SetData%2A&gt;</ph> metodo ed esaminare i valori mediante la <ph id="ph2">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>The following table describes the <ph id="ph1">`name`</ph> of each predefined system entry and its corresponding <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> property.</source>
          <target state="translated">Nella tabella seguente vengono descritti il <ph id="ph1">`name`</ph> di ogni voce nel sistema e predefiniti corrispondente <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>Value of 'name'</source>
          <target state="translated">Valore della proprietà 'name'</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>Property</source>
          <target state="translated">Proprietà</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"APPBASE"</source>
          <target state="translated">"APPBASE"</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"APP_CONFIG_FILE"</source>
          <target state="translated">"APP_CONFIG_FILE"</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"APP_LAUNCH_URL"</source>
          <target state="translated">"APP_LAUNCH_URL"</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>(no property)</source>
          <target state="translated">(nessuna proprietà)</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"APP_LAUNCH_URL" represents the URL originally requested by the user, before any redirection.</source>
          <target state="translated">"APP_LAUNCH_URL" rappresenta l'URL richiesto originariamente dall'utente, prima di qualsiasi reindirizzamento.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>It is available only when the application has been launched with a browser such as Internet Explorer.</source>
          <target state="translated">È disponibile solo quando l'applicazione è stata avviata con un browser quale Internet Explorer.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>Not all browsers provide this value.</source>
          <target state="translated">Non tutti i browser forniscono questo valore.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"APP_NAME"</source>
          <target state="translated">"APP_NAME"</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"BINPATH_PROBE_ONLY"</source>
          <target state="translated">"BINPATH_PROBE_ONLY"</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"CACHE_BASE"</source>
          <target state="translated">"CACHE_BASE"</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"CODE_DOWNLOAD_DISABLED"</source>
          <target state="translated">"CODE_DOWNLOAD_DISABLED"</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"DEV_PATH"</source>
          <target state="translated">"DEV_PATH"</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>(no property)</source>
          <target state="translated">(nessuna proprietà)</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"DISALLOW_APP"</source>
          <target state="translated">"DISALLOW_APP"</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"DISALLOW_APP_BASE_PROBING"</source>
          <target state="translated">"DISALLOW_APP_BASE_PROBING"</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"DISALLOW_APP_REDIRECTS"</source>
          <target state="translated">"DISALLOW_APP_REDIRECTS"</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"DYNAMIC_BASE"</source>
          <target state="translated">"DYNAMIC_BASE"</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"FORCE_CACHE_INSTALL"</source>
          <target state="translated">"FORCE_CACHE_INSTALL"</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"LICENSE_FILE", or an application-specific string</source>
          <target state="translated">"LICENSE_FILE" o una stringa specifica dell'applicazione</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"LOADER_OPTIMIZATION"</source>
          <target state="translated">"LOADER_OPTIMIZATION"</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"LOCATION_URI"</source>
          <target state="translated">"LOCATION_URI"</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>(no property)</source>
          <target state="translated">(nessuna proprietà)</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"PRIVATE_BINPATH"</source>
          <target state="translated">"PRIVATE_BINPATH"</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"REGEX_DEFAULT_MATCH_TIMEOUT"</source>
          <target state="translated">"REGEX_DEFAULT_MATCH_TIMEOUT"</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"REGEX_DEFAULT_MATCH_TIMEOUT" is not a system entry, and its value can be set by calling the <ph id="ph1">&lt;xref:System.AppDomain.SetData%2A&gt;</ph> method.</source>
          <target state="translated">"REGEX_DEFAULT_MATCH_TIMEOUT" non è una voce di sistema e il relativo valore può essere impostato tramite la chiamata di <ph id="ph1">&lt;xref:System.AppDomain.SetData%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>"SHADOW_COPY_DIRS"</source>
          <target state="translated">"SHADOW_COPY_DIRS"</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>The following example creates a new application domain, sets a system-provided value for the domain, and adds a new value pair for the domain.</source>
          <target state="translated">Nell'esempio seguente crea un nuovo dominio applicazione, imposta un valore fornito dal sistema per il dominio e aggiunge una nuova coppia di valore per il dominio.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>The example then demonstrates how to use the <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method to retrieve the data from these value pairs and display them to the console.</source>
          <target state="translated">Nell'esempio viene quindi illustrato come utilizzare il <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> metodo per recuperare i dati da queste coppie di valori e visualizzarli nella console.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetData(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetData(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>for access to the information in the path itself, if the property applies to a path.</source>
          <target state="translated">Per accedere alle informazioni presenti nel percorso stesso, se la proprietà si applica a un percorso.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.GetData(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetType">
          <source>Gets the type of the current instance.</source>
          <target state="translated">Ottiene il tipo dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" uid="M:System.AppDomain.GetType">
          <source>The type of the current instance.</source>
          <target state="translated">Tipo dell'istanza corrente.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" uid="P:System.AppDomain.Id">
          <source>Gets an integer that uniquely identifies the application domain within the process.</source>
          <target state="translated">Ottiene un intero che identifica in modo univoco il dominio applicazione all'interno del processo.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.Id">
          <source>An integer that identifies the application domain.</source>
          <target state="translated">Intero che identifica il dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.Id">
          <source>The following code example creates a second application domain and displays information about the default domain and the new domain.</source>
          <target state="translated">Esempio di codice seguente crea un secondo dominio di applicazione e visualizza le informazioni del dominio predefinito e il nuovo dominio.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" uid="M:System.AppDomain.InitializeLifetimeService">
          <source>Gives the <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> an infinite lifetime by preventing a lease from being created.</source>
          <target state="translated">Fornisce all'oggetto <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> una durata infinita impedendo la creazione di lease.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" uid="M:System.AppDomain.InitializeLifetimeService">
          <source>Always <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Sempre <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" uid="M:System.AppDomain.InitializeLifetimeService">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.InitializeLifetimeService">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.InitializeLifetimeService">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>The compatibility switch to test.</source>
          <target state="translated">Opzione di compatibilità da testare.</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>Gets a nullable Boolean value that indicates whether any compatibility switches are set, and if so, whether the specified compatibility switch is set.</source>
          <target state="translated">Ottiene un valore booleano che ammette valori Null, indica se sono impostate opzioni di compatibilità e, in tal caso, se è impostata l'opzione di compatibilità specificata.</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) if no compatibility switches are set; otherwise, a Boolean value that indicates whether the compatibility switch that is specified by <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is set.</source>
          <target state="translated">Riferimento Null (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) se non è impostata alcuna opzione di compatibilità; in caso contrario, un valore booleano che indica se l'opzione di compatibilità specificata da <ph id="ph2">&lt;paramref name="value" /&gt;</ph> è impostata.</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>This method tests whether the specified compatibility switch has been set for the current application domain.</source>
          <target state="translated">Questo metodo verifica se l'opzione di compatibilità specificata è stata impostata per il dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>Compatibility switches typically restore a behavior (such as the way strings are sorted) that was changed between versions of the .NET Framework.</source>
          <target state="translated">Le opzioni di compatibilità in genere ripristino un comportamento (ad esempio le stringhe di modalità vengono ordinate) che è stato modificato tra le versioni di .NET Framework.</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>They are set by calling the <ph id="ph1">&lt;xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType&gt;</ph> method before creating an application domain.</source>
          <target state="translated">Vengono impostate da una chiamata di <ph id="ph1">&lt;xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType&gt;</ph> metodo prima di creare un dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.</source>
          <target state="translated">Nella tabella seguente vengono forniti esempi di opzioni di compatibilità che è possibile impostare per ripristinare il comportamento delle versioni precedenti di .NET Framework.</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>Switch</source>
          <target state="translated">Opzione</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>Meaning</source>
          <target state="translated">Significato</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>"NetFx40_LegacySecurityPolicy"</source>
          <target state="translated">"NetFx40_LegacySecurityPolicy"</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>Code access security (CAS) for the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> is enabled in this application domain.</source>
          <target state="translated">Codice di accesso di sicurezza per il <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> è abilitato in questo dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>See <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>NetFx40_LegacySecurityPolicy<ph id="ph2">&amp;gt;</ph> Element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)</ept>.</source>
          <target state="translated">Vedere <bpt id="p1">[</bpt> <ph id="ph1">&amp;lt;</ph>NetFx40_LegacySecurityPolicy<ph id="ph2">&amp;gt;</ph> elemento<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>"NetFx40_Legacy20SortingBehavior"</source>
          <target state="translated">"NetFx40_Legacy20SortingBehavior"</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>String sorting defaults for the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> are enabled in this application domain.</source>
          <target state="translated">Stringa di ordinamento dei valori predefiniti per il <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> sono abilitate nel dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>Its success requires sort00001000.dll to be installed.</source>
          <target state="translated">Il suo successo richiede sort00001000.dll da installare.</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>See <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>CompatSortNLSVersion<ph id="ph2">&amp;gt;</ph> Element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)</ept>.</source>
          <target state="translated">Vedere <bpt id="p1">[</bpt> <ph id="ph1">&amp;lt;</ph>CompatSortNLSVersion<ph id="ph2">&amp;gt;</ph> elemento<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>"NetFx40_Legacy40SortingBehavior"</source>
          <target state="translated">"NetFx40_Legacy40SortingBehavior"</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>String sorting defaults for the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>and Unicode 5.0 are enabled in this application domain.</source>
          <target state="translated">Stringa di ordinamento dei valori predefiniti per il <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>e Unicode 5.0 sono abilitate nel dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>Its success requires sort00060101.dll to be installed.</source>
          <target state="translated">Il suo successo richiede sort00060101.dll da installare.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>"NetFx40_TimeSpanLegacyFormatMode"</source>
          <target state="translated">"NetFx40_TimeSpanLegacyFormatMode"</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source><ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> formatting behavior for the <ph id="ph2">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> is enabled in this application domain.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> il comportamento di formattazione di <ph id="ph2">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> è abilitato in questo dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>See <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>TimeSpan_LegacyFormatMode<ph id="ph2">&amp;gt;</ph> Element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md)</ept> and the "Restoring Legacy TimeSpan Formatting" section of the <ph id="ph3">&lt;xref:System.TimeSpan&gt;</ph> topic.</source>
          <target state="translated">Vedere <bpt id="p1">[</bpt> <ph id="ph1">&amp;lt;</ph>TimeSpan_LegacyFormatMode<ph id="ph2">&amp;gt;</ph> elemento<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md)</ept> e la sezione "Ripristino Legacy TimeSpan formattazione" del <ph id="ph3">&lt;xref:System.TimeSpan&gt;</ph> argomento.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>"UseRandomizedStringHashAlgorithm"</source>
          <target state="translated">"UseRandomizedStringHashAlgorithm"</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains.</source>
          <target state="translated">Il runtime calcola i codici hash per le stringhe in una base di dominio dell'applicazione anziché un solo algoritmo hash che genera un codice hash coerente tra domini dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)">
          <source>See <bpt id="p1">[</bpt><ph id="ph1">&amp;lt;</ph>UseRandomizedStringHashAlgorithm<ph id="ph2">&amp;gt;</ph> Element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept>.</source>
          <target state="translated">Vedere <bpt id="p1">[</bpt> <ph id="ph1">&amp;lt;</ph>UseRandomizedStringHashAlgorithm<ph id="ph2">&amp;gt;</ph> elemento<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" uid="M:System.AppDomain.IsDefaultAppDomain">
          <source>Returns a value that indicates whether the application domain is the default application domain for the process.</source>
          <target state="translated">Restituisce un valore che indica se il dominio applicazione è quello predefinito per il processo.</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="M:System.AppDomain.IsDefaultAppDomain">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.AppDomain" /&gt;</ph> object represents the default application domain for the process; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'oggetto <ph id="ph2">&lt;see cref="T:System.AppDomain" /&gt;</ph> corrente rappresenta il dominio applicazione predefinito per il processo. In caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsDefaultAppDomain">
          <source>Every managed process has a default application domain.</source>
          <target state="translated">Ogni processo gestito dispone di un dominio applicazione predefinito.</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsDefaultAppDomain">
          <source>Execution begins in the default domain.</source>
          <target state="translated">L'esecuzione inizia nel dominio predefinito.</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsDefaultAppDomain">
          <source>The following code example creates a second application domain and displays information about the default domain and the new domain.</source>
          <target state="translated">Esempio di codice seguente crea un secondo dominio di applicazione e visualizza le informazioni del dominio predefinito e il nuovo dominio.</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>Indicates whether this application domain is unloading, and the objects it contains are being finalized by the common language runtime.</source>
          <target state="translated">Indica se è in corso lo scaricamento del dominio applicazione e se il completamento degli oggetti in esso contenuti è stato avviato in Common Language Runtime.</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this application domain is unloading and the common language runtime has started invoking finalizers; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se è in corso lo scaricamento del dominio applicazione ed è stato avviato il richiamo dei finalizzatori in Common Language Runtime. In caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>The finalization method for an object provides you an opportunity to perform any necessary cleanup operations before the object is garbage collected.</source>
          <target state="translated">Il metodo di finalizzazione per un oggetto si offre l'opportunità di eseguire eventuali operazioni di pulizia prima che l'oggetto è sottoposto a garbage collection.</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>After finalization, the object is accessible but in an invalid state and therefore unusable.</source>
          <target state="translated">Dopo la finalizzazione, l'oggetto è accessibile ma in uno stato non valido ed è pertanto inutilizzabile.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>Eventually, garbage collection completes and reclaims the object.</source>
          <target state="translated">Infine, la garbage collection completa e viene recuperato l'oggetto.</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>An object's finalization method is called in one of the following situations: during garbage collection, when the common language runtime is shutting down, or when the application domain that contains the object is unloaded.</source>
          <target state="translated">Viene chiamato il metodo di finalizzazione dell'oggetto in una delle situazioni seguenti: durante l'operazione di garbage collection, quando common language runtime è in corso l'arresto o quando viene scaricato il dominio applicazione che contiene l'oggetto.</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.IsFinalizingForUnload%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> only in the last case; it does not return <ph id="ph3">`true`</ph> if finalization results from routine garbage collection or from CLR shutdown.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.AppDomain.IsFinalizingForUnload%2A&gt;</ph> restituisce <ph id="ph2">`true`</ph> solo nell'ultimo caso; non restituisce <ph id="ph3">`true`</ph> se dà come risultato la finalizzazione da routine di garbage collection o dall'arresto CLR.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>To determine whether finalization is due to CLR shutdown, use the <ph id="ph1">&lt;xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Per determinare se la finalizzazione a causa dell'arresto CLR, utilizzare il <ph id="ph1">&lt;xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>It returns <ph id="ph1">`true`</ph> if finalization is due to an application domain being unloaded or to the CLR shutting down.</source>
          <target state="translated">Restituisce <ph id="ph1">`true`</ph> se la finalizzazione è dovuto a un dominio applicazione in corso lo scaricamento o all'arresto di CLR.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>While executing in your finalization method during domain unloading, you might want to access another object that is referenced by a static field and has a finalization method.</source>
          <target state="translated">Durante l'esecuzione del metodo di finalizzazione durante lo scaricamento del dominio, è necessario per accedere a un altro oggetto che fa riferimento un campo statico e dispone di un metodo di finalizzazione.</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>However, you cannot reliably do so because the accessed object might already have been finalized.</source>
          <target state="translated">Tuttavia, non è possibile in modo affidabile avviene perché l'oggetto a cui si accede potrebbe essere già stato completato.</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>An exception to this rule is the <ph id="ph1">&lt;xref:System.Console&gt;</ph> class, which contains static fields that reference stream objects, but is implemented specially so you can always write to the system console, even during domain unloading or system shutdown.</source>
          <target state="translated">Un'eccezione a questa regola è la <ph id="ph1">&lt;xref:System.Console&gt;</ph> (classe), che contiene i campi statici che fanno riferimento a oggetti di flusso, ma viene implementato in modo tale è sempre possibile scrivere nella console di sistema, anche durante l'arresto del sistema o lo scaricamento di dominio.</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>Use this method in an object's finalization method to determine whether the application domain that contains the object is unloading.</source>
          <target state="translated">Utilizzare questo metodo nel metodo di finalizzazione dell'oggetto per determinare se il dominio applicazione che contiene l'oggetto di scaricamento.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.IsFinalizingForUnload">
          <source>If that is the case, you cannot reliably access any object that has a finalization method and is referenced by a static field.</source>
          <target state="translated">Se è questo il caso, è possibile accedere in modo affidabile qualsiasi oggetto che dispone di un metodo di finalizzazione e fa riferimento a un campo statico.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="P:System.AppDomain.IsFullyTrusted">
          <source>Gets a value that indicates whether assemblies that are loaded into the current application domain execute with full trust.</source>
          <target state="translated">Ottiene un valore che indica se gli assembly caricati nel dominio applicazione corrente vengono eseguiti con attendibilità totale.</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if assemblies that are loaded into the current application domain execute with full trust; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se gli assembly caricati nel dominio dell'applicazione corrente vengono eseguiti con attendibilità totale; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>This method always returns <ph id="ph1">`true`</ph> for the default application domain of an application that runs on the desktop.</source>
          <target state="translated">Questo metodo restituisce sempre <ph id="ph1">`true`</ph> per il dominio applicazione predefinito di un'applicazione che viene eseguito sul desktop.</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>It returns <ph id="ph1">`false`</ph> for a sandboxed application domain that was created by using the <ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> method overload, unless the permissions that are granted to the application domain are equivalent to full trust.</source>
          <target state="translated">Restituisce <ph id="ph1">`false`</ph> per un dominio applicazione creato mediante sandbox è stato creato utilizzando il <ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> overload del metodo, a meno che le autorizzazioni concesse al dominio dell'applicazione sono equivalenti all'attendibilità.</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.IsFullyTrusted%2A&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> property with fully trusted and partially trusted application domains.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.AppDomain.IsFullyTrusted%2A&gt;</ph> proprietà e <ph id="ph2">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> proprietà con i domini applicazione completamente o parzialmente attendibile.</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>The fully trusted application domain is the default application domain for the application.</source>
          <target state="translated">Il dominio applicazione con attendibilità totale è il dominio applicazione predefinito per l'applicazione.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>The partially trusted application domain is created by using the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Il dominio applicazione parzialmente attendibile viene creato utilizzando il <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>The example uses a <ph id="ph1">`Worker`</ph> class that derives from <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, so it can be marshaled across application domain boundaries.</source>
          <target state="translated">Nell'esempio viene utilizzato un <ph id="ph1">`Worker`</ph> classe che deriva da <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, che può essere sottoposto a marshalling attraverso i limiti del dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>The example creates a <ph id="ph1">`Worker`</ph> object in the default application domain.</source>
          <target state="translated">Nell'esempio viene creato un <ph id="ph1">`Worker`</ph> oggetto nel dominio applicazione predefinito.</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>It then calls the <ph id="ph1">`TestIsFullyTrusted`</ph> method to display the property value for the application domain and for two assemblies that are loaded into the application domain: mscorlib, which is part of the .NET Framework, and the example assembly.</source>
          <target state="translated">Chiama quindi il <ph id="ph1">`TestIsFullyTrusted`</ph> metodo per visualizzare il valore della proprietà per il dominio applicazione e per due assembly caricati nel dominio dell'applicazione: mscorlib, che fa parte di .NET Framework e l'assembly di esempio.</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>The application domain is fully trusted, so both assemblies are fully trusted.</source>
          <target state="translated">Il dominio applicazione è completamente attendibile, in modo entrambi gli assembly sono completamente attendibili.</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>The example creates another <ph id="ph1">`Worker`</ph> object in a sandboxed application domain and again calls the <ph id="ph2">`TestIsFullyTrusted`</ph> method.</source>
          <target state="translated">Nell'esempio viene creato un altro <ph id="ph1">`Worker`</ph> oggetto in un dominio applicazione creato mediante sandbox e chiamate di nuovo il <ph id="ph2">`TestIsFullyTrusted`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsFullyTrusted">
          <source>Mscorlib is always trusted, even in a partially trusted application domain, but the example assembly is partially trusted.</source>
          <target state="translated">Mscorlib è sempre attendibile, anche in un dominio applicazione parzialmente attendibile, ma l'assembly di esempio è parzialmente attendibile.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" uid="P:System.AppDomain.IsHomogenous">
          <source>Gets a value that indicates whether the current application domain has a set of permissions that is granted to all assemblies that are loaded into the application domain.</source>
          <target state="translated">Ottiene un valore che indica se il dominio applicazione corrente dispone di un set di autorizzazioni concesso a tutti gli assembly caricati nel dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsHomogenous">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current application domain has a homogenous set of permissions; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il dominio applicazione corrente dispone di un set omogeneo di autorizzazioni; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsHomogenous">
          <source>This property returns <ph id="ph1">`true`</ph> for sandboxed application domains that were created by using the <ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Questa proprietà restituisce <ph id="ph1">`true`</ph> per i domini di applicazione creato mediante sandbox che sono stati creati tramite il <ph id="ph2">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsHomogenous">
          <source>Sandboxed application domains have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain.</source>
          <target state="translated">Domini di applicazione creato mediante sandbox dispongono di un set omogeneo di autorizzazioni. vale a dire lo stesso set di autorizzazioni viene concessa a tutti gli assembly parzialmente attendibili che vengono caricati nel dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsHomogenous">
          <source>A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</source>
          <target state="translated">Facoltativamente, un dominio applicazione sandboxed include un elenco di assembly con nome sicuro che non sono interessati da questo set di autorizzazioni e vengono invece eseguiti con attendibilità totale.</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsHomogenous">
          <source>Fully trusted code can use the <ph id="ph1">&lt;xref:System.AppDomain.PermissionSet%2A&gt;</ph> property to determine the homogenous grant set of a sandboxed application domain.</source>
          <target state="translated">È considerato completamente attendibile il codice può utilizzare il <ph id="ph1">&lt;xref:System.AppDomain.PermissionSet%2A&gt;</ph> proprietà per determinare il set di concessioni omogeneo di un dominio applicazione creato mediante sandbox.</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.IsHomogenous">
          <source>This property also returns <ph id="ph1">`true`</ph> for the default application domain of a desktop application, because that application domain grants full trust to all assemblies.</source>
          <target state="translated">Questa proprietà restituisce inoltre <ph id="ph1">`true`</ph> per il dominio applicazione predefinito di un'applicazione desktop, perché tale dominio applicazione concede l'attendibilità totale per tutti gli assembly.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Loads an <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> into this application domain.</source>
          <target state="translated">Carica <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> nel dominio applicazione.</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see langword="byte" /&gt;</ph> that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated">Matrice di tipo <ph id="ph1">&lt;see langword="byte" /&gt;</ph> costituita da un'immagine in formato COFF contenente un assembly generato.</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>Loads the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> with a common object file format (COFF) based image containing an emitted <ph id="ph2">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</source>
          <target state="translated">Carica l'oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> con un'immagine in formato COFF (Common Object File Format) contenente un oggetto <ph id="ph2">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> generato.</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, il livello di attendibilità di un assembly caricato dall'utilizzo di questo metodo è lo stesso livello di attendibilità del dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>This method should be used only to load an assembly into the current application domain.</source>
          <target state="translated">Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>This method is provided as a convenience for interoperability callers who cannot call the static <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Questo metodo viene fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>To load assemblies into other application domains, use a method such as <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</source>
          <target state="translated">Per caricare gli assembly in altri domini applicazione, utilizzare un metodo, ad esempio <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>For information that is common to all overloads of this method, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Per informazioni comuni a tutti gli overload di questo metodo, vedere il <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>The following sample demonstrates the use of loading a raw assembly.</source>
          <target state="translated">L'esempio seguente viene illustrato l'utilizzo del caricamento di un assembly non elaborato.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Per informazioni su come ottenere il nome completo dell'assembly, vedere <bpt id="p1">[</bpt>i nomi degli Assembly<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso.</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>An object that describes the assembly to load.</source>
          <target state="translated">Oggetto che descrive l'assembly da caricare.</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>Loads an <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> given its <ph id="ph2">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</source>
          <target state="translated">Carica <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>, dato il relativo <ph id="ph2">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>This method should be used only to load an assembly into the current application domain.</source>
          <target state="translated">Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>This method is provided as a convenience for interoperability callers who cannot call the static <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Questo metodo viene fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>To load assemblies into other application domains, use a method such as <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</source>
          <target state="translated">Per caricare gli assembly in altri domini applicazione, utilizzare un metodo, ad esempio <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>If a version of the requested assembly is already loaded, this method returns the loaded assembly, even if a different version is requested.</source>
          <target state="translated">Se è già caricata una versione dell'assembly richiesto, questo metodo restituisce l'assembly caricato, anche se non è necessaria una versione diversa.</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>Supplying a partial assembly name for <ph id="ph1">`assemblyRef`</ph> is not recommended.</source>
          <target state="translated">Specificare un nome di assembly parziali per <ph id="ph1">`assemblyRef`</ph> non è consigliata.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>(A partial name omits one or more of culture, version, or public key token.</source>
          <target state="translated">(Un nome parziale omette una o più delle impostazioni cultura, versione o token di chiave pubblica.</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>For overloads that take a string instead of an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object, "MyAssembly, Version=1.0.0.0" is an example of a partial name and "MyAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=18ab3442da84b47" is an example of a full name.) Using partial names has a negative effect on performance.</source>
          <target state="translated">Di overload che accettano una stringa anziché un <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> oggetto, "MyAssembly, Version = 1.0.0.0" è un esempio di un nome parziale e "MyAssembly, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = 18ab3442da84b47" è riportato un esempio di un nome completo.) Utilizzo di nomi parziali ha un effetto negativo sulle prestazioni.</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>In addition, a partial assembly name can load an assembly from the global assembly cache only if there is an exact copy of the assembly in the application base directory (<ph id="ph1">&lt;xref:System.AppDomain.BaseDirectory%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Inoltre, un nome di assembly parziali possa caricare un assembly dalla global assembly cache solo se è disponibile una copia esatta dell'assembly nella directory base dell'applicazione (<ph id="ph1">&lt;xref:System.AppDomain.BaseDirectory%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>If the current <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> object represents application domain <ph id="ph2">`A`</ph>, and the <ph id="ph3">&lt;xref:System.AppDomain.Load%2A&gt;</ph> method is called from application domain <ph id="ph4">`B`</ph>, the assembly is loaded into both application domains.</source>
          <target state="translated">Se l'oggetto corrente <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> oggetto rappresenta il dominio applicazione <ph id="ph2">`A`</ph>e <ph id="ph3">&lt;xref:System.AppDomain.Load%2A&gt;</ph> metodo viene chiamato dal dominio applicazione <ph id="ph4">`B`</ph>, l'assembly viene caricato in entrambi i domini applicazione.</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>For example, the following code loads <ph id="ph1">`MyAssembly`</ph> into the new application domain <ph id="ph2">`ChildDomain`</ph> and also into the application domain where the code executes:</source>
          <target state="translated">Ad esempio, il codice seguente carica <ph id="ph1">`MyAssembly`</ph> nel nuovo dominio applicazione <ph id="ph2">`ChildDomain`</ph> e anche nel dominio applicazione in cui viene eseguito il codice:</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>The assembly is loaded into both domains because <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> does not derive from <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>, and therefore the return value of the <ph id="ph3">&lt;xref:System.AppDomain.Load%2A&gt;</ph> method cannot be marshaled.</source>
          <target state="translated">L'assembly viene caricato in entrambi i domini perché <ph id="ph1">&lt;xref:System.Reflection.Assembly&gt;</ph> non deriva da <ph id="ph2">&lt;xref:System.MarshalByRefObject&gt;</ph>e pertanto il valore restituito di <ph id="ph3">&lt;xref:System.AppDomain.Load%2A&gt;</ph> metodo Impossibile effettuare il marshalling.</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>Instead, the common language runtime tries to load the assembly into the calling application domain.</source>
          <target state="translated">In alternativa, common language runtime tenta di caricare l'assembly nel dominio applicazione chiamante.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>The assemblies that are loaded into the two application domains might be different if the path settings for the two application domains are different.</source>
          <target state="translated">Gli assembly caricati in due domini applicazione potrebbero essere diversi se le impostazioni del percorso per i due domini applicazione sono diverse.</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>If both the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType&gt;</ph> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <ph id="ph3">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> property).</source>
          <target state="translated">Se entrambi i <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType&gt;</ph> proprietà e <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType&gt;</ph> proprietà sono impostate, il primo tentativo di caricare l'assembly viene utilizzato il nome visualizzato (compreso versione, impostazioni cultura e così via, restituito dal <ph id="ph3">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> proprietà).</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>If the file is not found, the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> property is used to search for the assembly.</source>
          <target state="translated">Se il file non viene trovato, il <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph> proprietà viene utilizzata per cercare l'assembly.</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>If the assembly is found using <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>, the display name is matched against the assembly.</source>
          <target state="translated">Se l'assembly viene trovato tramite <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.CodeBase%2A&gt;</ph>, il nome visualizzato viene confrontato con l'assembly.</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>If the match fails, a <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown.</source>
          <target state="translated">Se la corrispondenza ha esito negativo, un <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> non trovata.</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso.</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>Loads an <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> given its display name.</source>
          <target state="translated">Carica <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>, dato il nome visualizzato.</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String)">
          <source>This method should be used only to load an assembly into the current application domain.</source>
          <target state="translated">Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String)">
          <source>This method is provided as a convenience for interoperability callers who cannot call the static <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Questo metodo viene fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String)">
          <source>To load assemblies into other application domains, use a method such as <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</source>
          <target state="translated">Per caricare gli assembly in altri domini applicazione, utilizzare un metodo, ad esempio <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String)">
          <source>For information that is common to all overloads of this method, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Per informazioni comuni a tutti gli overload di questo metodo, vedere il <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> non trovata.</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso.</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String)">
          <source>for the ability to access the location of the assembly if the assembly is not local.</source>
          <target state="translated">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see langword="byte" /&gt;</ph> that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated">Matrice di tipo <ph id="ph1">&lt;see langword="byte" /&gt;</ph> costituita da un'immagine in formato COFF contenente un assembly generato.</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see langword="byte" /&gt;</ph> containing the raw bytes representing the symbols for the assembly.</source>
          <target state="translated">Matrice di tipo <ph id="ph1">&lt;see langword="byte" /&gt;</ph> contenente i byte non elaborati che rappresentano i simboli per l'assembly.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>Loads the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> with a common object file format (COFF) based image containing an emitted <ph id="ph2">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</source>
          <target state="translated">Carica l'oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> con un'immagine in formato COFF (Common Object File Format) contenente un oggetto <ph id="ph2">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> generato.</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>The raw bytes representing the symbols for the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> are also loaded.</source>
          <target state="translated">Vengono caricati anche i byte non elaborati che rappresentano i simboli per l'oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, il livello di attendibilità di un assembly caricato dall'utilizzo di questo metodo è lo stesso livello di attendibilità del dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>This method should be used only to load an assembly into the current application domain.</source>
          <target state="translated">Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>This method is provided as a convenience for interoperability callers who cannot call the static <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Questo metodo viene fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>To load assemblies into other application domains, use a method such as <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</source>
          <target state="translated">Per caricare gli assembly in altri domini applicazione, utilizzare un metodo, ad esempio <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>For information that is common to all overloads of this method, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Per informazioni comuni a tutti gli overload di questo metodo, vedere il <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>The following sample demonstrates the use of loading a raw assembly.</source>
          <target state="translated">L'esempio seguente viene illustrato l'utilizzo del caricamento di un assembly non elaborato.</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly.</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Per informazioni su come ottenere il nome completo dell'assembly, vedere <bpt id="p1">[</bpt>i nomi degli Assembly<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>for reading a URI that does not begin with "file://".</source>
          <target state="translated">per la lettura di un URI che iniziano con "file://".</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso.</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[])">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>An object that describes the assembly to load.</source>
          <target state="translated">Oggetto che descrive l'assembly da caricare.</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Evidenza per il caricamento dell'assembly.</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Loads an <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> given its <ph id="ph2">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</source>
          <target state="translated">Carica <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>, dato il relativo <ph id="ph2">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>This method should be used only to load an assembly into the current application domain.</source>
          <target state="translated">Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>This method is provided as a convenience for interoperability callers who cannot call the static <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Questo metodo viene fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>To load assemblies into other application domains, use a method such as <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</source>
          <target state="translated">Per caricare gli assembly in altri domini applicazione, utilizzare un metodo, ad esempio <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>For information that is common to all overloads of this method, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Per informazioni comuni a tutti gli overload di questo metodo, vedere il <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> non trovata.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <ph id="ph1">&lt;paramref name="assemblyRef" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)">
          <source>for reading a path that is not in the form "file://" or "<ph id="ph1">\\</ph>\UNC\dir<ph id="ph2">\\</ph>" or "c:<ph id="ph3">\\</ph>".</source>
          <target state="translated">per la lettura di un percorso che non è nel formato "file://" o "<ph id="ph1">\\</ph>\UNC\dir<ph id="ph2">\\</ph>" o "c:<ph id="ph3">\\</ph>".</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>The display name of the assembly.</source>
          <target state="translated">Nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;see cref="P:System.Reflection.Assembly.FullName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Evidenza per il caricamento dell'assembly.</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>Loads an <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> given its display name.</source>
          <target state="translated">Carica <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>, dato il nome visualizzato.</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>This method should be used only to load an assembly into the current application domain.</source>
          <target state="translated">Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>This method is provided as a convenience for interoperability callers who cannot call the static <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Questo metodo viene fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>To load assemblies into other application domains, use a method such as <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</source>
          <target state="translated">Per caricare gli assembly in altri domini applicazione, utilizzare un metodo, ad esempio <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>For information that is common to all overloads of this method, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Per informazioni comuni a tutti gli overload di questo metodo, vedere il <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> non trovata.</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <ph id="ph1">&lt;paramref name="assemblyString" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>to load an assembly with evidence.</source>
          <target state="translated">per caricare un assembly con l'evidenza.</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso.</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)">
          <source>for reading a path that is not in the form "file://" or "<ph id="ph1">\\</ph>\UNC\dir<ph id="ph2">\\</ph>" or "c:<ph id="ph3">\\</ph>".</source>
          <target state="translated">per la lettura di un percorso che non è nel formato "file://" o "<ph id="ph1">\\</ph>\UNC\dir<ph id="ph2">\\</ph>" o "c:<ph id="ph3">\\</ph>".</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>An array of type <ph id="ph1">&lt;see langword="byte" /&gt;</ph> that is a COFF-based image containing an emitted assembly.</source>
          <target state="translated">Matrice di tipo <ph id="ph1">&lt;see langword="byte" /&gt;</ph> costituita da un'immagine in formato COFF contenente un assembly generato.</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>An array of type <ph id="ph1">&lt;see langword="byte" /&gt;</ph> containing the raw bytes representing the symbols for the assembly.</source>
          <target state="translated">Matrice di tipo <ph id="ph1">&lt;see langword="byte" /&gt;</ph> contenente i byte non elaborati che rappresentano i simboli per l'assembly.</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Evidence for loading the assembly.</source>
          <target state="translated">Evidenza per il caricamento dell'assembly.</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Loads the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> with a common object file format (COFF) based image containing an emitted <ph id="ph2">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</source>
          <target state="translated">Carica l'oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> con un'immagine in formato COFF (Common Object File Format) contenente un oggetto <ph id="ph2">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> generato.</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The raw bytes representing the symbols for the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> are also loaded.</source>
          <target state="translated">Vengono caricati anche i byte non elaborati che rappresentano i simboli per l'oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The loaded assembly.</source>
          <target state="translated">Assembly caricato.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, il livello di attendibilità di un assembly caricato dall'utilizzo di questo metodo è lo stesso livello di attendibilità del dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>This method should be used only to load an assembly into the current application domain.</source>
          <target state="translated">Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>This method is provided as a convenience for interoperability callers who cannot call the static <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Questo metodo viene fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>To load assemblies into other application domains, use a method such as <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</source>
          <target state="translated">Per caricare gli assembly in altri domini applicazione, utilizzare un metodo, ad esempio <ph id="ph1">&lt;xref:System.AppDomain.CreateInstanceAndUnwrap%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>For information that is common to all overloads of this method, see the <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> method overload.</source>
          <target state="translated">Per informazioni comuni a tutti gli overload di questo metodo, vedere il <ph id="ph1">&lt;xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The following sample demonstrates the use of loading a raw assembly.</source>
          <target state="translated">L'esempio seguente viene illustrato l'utilizzo del caricamento di un assembly non elaborato.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly.</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Per informazioni su come ottenere il nome completo dell'assembly, vedere <bpt id="p1">[</bpt>i nomi degli Assembly<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> is not a valid assembly.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> non è un assembly valido.</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Version 2.0 or later of the common language runtime is currently loaded and <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> was compiled with a later version.</source>
          <target state="translated">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <ph id="ph1">&lt;paramref name="rawAssembly" /&gt;</ph> è stato compilato con una versione successiva.</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>An assembly or module was loaded twice with two different evidences.</source>
          <target state="translated">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> non è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>When legacy CAS policy is not enabled, <ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> should be <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Quando i criteri di sicurezza dall'accesso di codice legacy non sono abilitati, <ph id="ph1">&lt;paramref name="securityEvidence" /&gt;</ph> deve essere <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>to provide evidence.</source>
          <target state="translated">per fornire l'evidenza.</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Azione di sicurezza: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>for access to read from a file or directory, and for access to the information in the path itself.</source>
          <target state="translated">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso.</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazioni associate: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)">
          <source>for reading a path that is not in the form "file://" or "<ph id="ph1">\\</ph>\UNC\dir<ph id="ph2">\\</ph>" or "c:<ph id="ph3">\\</ph>".</source>
          <target state="translated">per la lettura di un percorso che non è nel formato "file://" o "<ph id="ph1">\\</ph>\UNC\dir<ph id="ph2">\\</ph>" o "c:<ph id="ph3">\\</ph>".</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>Gets or sets a value that indicates whether CPU and memory monitoring of application domains is enabled for the current process.</source>
          <target state="translated">Ottiene o imposta un valore che indica se il monitoraggio della memoria e della CPU dei domini applicazione è abilitato per il processo corrente.</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>Once monitoring is enabled for a process, it cannot be disabled.</source>
          <target state="translated">Una volta abilitato per un processo, il monitoraggio non può più essere disabilitato.</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if monitoring is enabled; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il monitoraggio è abilitato; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>This <ph id="ph1">`static`</ph> property (<ph id="ph2">`Shared`</ph> property in Visual Basic) controls CPU and memory monitoring of all the application domains in the process.</source>
          <target state="translated">Questo <ph id="ph1">`static`</ph> proprietà (<ph id="ph2">`Shared`</ph> proprietà in Visual Basic) controlla la CPU e il monitoraggio della memoria di tutti i domini applicazione nel processo.</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>If you attempt to set this property to <ph id="ph1">`false`</ph>, a <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> exception is thrown, even if the current value of the property is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Se si tenta di impostare questa proprietà su <ph id="ph1">`false`</ph>, <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> viene generata l'eccezione, anche se il valore corrente della proprietà è <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>Once monitoring is enabled, you can use the <ph id="ph1">&lt;xref:System.AppDomain.MonitoringSurvivedMemorySize%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.AppDomain.MonitoringTotalProcessorTime%2A&gt;</ph> instance properties to monitor CPU and memory use of individual application domains.</source>
          <target state="translated">Il monitoraggio è abilitato, è possibile utilizzare il <ph id="ph1">&lt;xref:System.AppDomain.MonitoringSurvivedMemorySize%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A&gt;</ph>, e <ph id="ph4">&lt;xref:System.AppDomain.MonitoringTotalProcessorTime%2A&gt;</ph> delle proprietà per monitorare l'utilizzo della CPU e memoria dei singoli domini applicazione dell'istanza.</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>The current process attempted to assign the value <ph id="ph1">&lt;see langword="false" /&gt;</ph> to this property.</source>
          <target state="translated">Il processo corrente ha tentato di assegnare il valore <ph id="ph1">&lt;see langword="false" /&gt;</ph> a questa proprietà.</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringIsEnabled">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>Gets the number of bytes that survived the last collection and that are known to be referenced by the current application domain.</source>
          <target state="translated">Ottiene il numero di byte esclusi dall'ultima raccolta e a cui fa riferimento il dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>The number of surviving bytes.</source>
          <target state="translated">Numero di byte esclusi.</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>The statistics are updated with each garbage collection.</source>
          <target state="translated">Le statistiche vengono aggiornate con ogni operazione di garbage collection.</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>However, they are guaranteed to be accurate only after a full, blocking collection; that is, a collection that includes all generations and that stops the application while collection occurs.</source>
          <target state="translated">Tuttavia, essi sono sicuramente accurata solo dopo una procedura completa di Garbage collection; bloccante ovvero, si verifica una raccolta che include tutte le generazioni e che interrompe l'applicazione durante la raccolta.</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>For example, the <ph id="ph1">&lt;xref:System.GC.Collect?displayProperty=nameWithType&gt;</ph> method overload performs a full, blocking collection.</source>
          <target state="translated">Ad esempio, il <ph id="ph1">&lt;xref:System.GC.Collect?displayProperty=nameWithType&gt;</ph> overload del metodo esegue una procedura completa di Garbage collection bloccante.</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>(Concurrent collection occurs in the background and does not block the application.)</source>
          <target state="translated">(Raccolta simultanea avviene in background e non blocca l'applicazione).</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>The <ph id="ph1">&lt;see langword="static" /&gt;</ph> (<ph id="ph2">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) <ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> property is set to <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="static" /&gt;</ph> (<ph id="ph2">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) <ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> è impostata su <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedMemorySize">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>Gets the total bytes that survived from the last collection for all application domains in the process.</source>
          <target state="translated">Ottiene i byte totali esclusi dall'ultima raccolta per tutti i domini applicazione nel processo.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>The total number of surviving bytes for the process.</source>
          <target state="translated">Numero totale di byte esclusi per il processo.</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>After a full, blocking collection, this number represents the number of bytes currently held live on managed heaps.</source>
          <target state="translated">Dopo una raccolta completa di, questo numero rappresenta il numero di byte attualmente mantenuti attivi in gestiti heap.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>It should be close to the number reported by the <ph id="ph1">&lt;xref:System.GC.GetTotalMemory%2A&gt;</ph> method.</source>
          <target state="translated">Dovrebbe essere simile al numero segnalato dal <ph id="ph1">&lt;xref:System.GC.GetTotalMemory%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>After an ephemeral collection, this number represents the number of bytes currently held live in ephemeral generations.</source>
          <target state="translated">Dopo una raccolta temporanea, questo numero rappresenta il numero di byte attualmente mantenuti attivo in generazioni temporanee.</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>The <ph id="ph1">&lt;see langword="static" /&gt;</ph> (<ph id="ph2">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) <ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> property is set to <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="static" /&gt;</ph> (<ph id="ph2">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) <ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> è impostata su <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringSurvivedProcessMemorySize">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringTotalAllocatedMemorySize">
          <source>Gets the total size, in bytes, of all memory allocations that have been made by the application domain since it was created, without subtracting memory that has been collected.</source>
          <target state="translated">Ottiene le dimensioni totali, in byte, di tutte le allocazioni di memoria effettuate dal dominio applicazione da quando è stato creato, senza sottrarre la memoria che è stata raccolta.</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalAllocatedMemorySize">
          <source>The total size of all memory allocations.</source>
          <target state="translated">Dimensioni totali, in byte, di tutte le allocazioni di memoria.</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringTotalAllocatedMemorySize">
          <source>The <ph id="ph1">&lt;see langword="static" /&gt;</ph> (<ph id="ph2">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) <ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> property is set to <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="static" /&gt;</ph> (<ph id="ph2">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) <ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> è impostata su <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalAllocatedMemorySize">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalAllocatedMemorySize">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>Gets the total processor time that has been used by all threads while executing in the current application domain, since the process started.</source>
          <target state="translated">Ottiene il tempo del processore totale usato da tutti i thread durante l'esecuzione nel dominio applicazione corrente, da quando il processo è stato avviato.</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>Total processor time for the current application domain.</source>
          <target state="translated">Tempo del processore totale per il dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>The total time that is reported for an application domain includes the time each thread in the process spent executing in that application domain.</source>
          <target state="translated">Il tempo totale, viene restituito per un dominio applicazione include il tempo impiegato da ogni thread nel processo di esecuzione nel dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>A thread that calls into unmanaged code is still associated with an application domain, and the processor time spent executing the unmanaged code is reported for the application domain where the call was made.</source>
          <target state="translated">Un thread che chiama codice non gestito è ancora associato a un dominio applicazione e il tempo del processore impiegato per l'esecuzione di che codice non gestito viene segnalato per il dominio applicazione in cui è stata effettuata la chiamata.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>When a thread is blocked or sleeping, it does not consume processor time.</source>
          <target state="translated">Quando un thread è bloccato o inattivo, non utilizzare il tempo del processore.</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>The <ph id="ph1">&lt;see langword="static" /&gt;</ph> (<ph id="ph2">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) <ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> property is set to <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see langword="static" /&gt;</ph> (<ph id="ph2">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) <ph id="ph3">&lt;see cref="P:System.AppDomain.MonitoringIsEnabled" /&gt;</ph> è impostata su <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.MonitoringTotalProcessorTime">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" uid="P:System.AppDomain.PermissionSet">
          <source>Gets the permission set of a sandboxed application domain.</source>
          <target state="translated">Ottiene il set di autorizzazioni di un dominio applicazione creato mediante sandbox.</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.PermissionSet">
          <source>The permission set of the sandboxed application domain.</source>
          <target state="translated">Set di autorizzazioni di un dominio applicazione creato mediante sandbox.</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.PermissionSet">
          <source>Sandboxed application domains that were created by using the <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> method overload have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain.</source>
          <target state="translated">Domini applicazione creata mediante sandbox che sono stati creati tramite il <ph id="ph1">&lt;xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType&gt;</ph> overload del metodo dispone di un set omogeneo di autorizzazioni, vale a dire lo stesso set di autorizzazioni viene concesso a tutti gli assembly parzialmente attendibili che vengono caricati nel dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.PermissionSet">
          <source>A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</source>
          <target state="translated">Facoltativamente, un dominio applicazione sandboxed include un elenco di assembly con nome sicuro che non sono interessati da questo set di autorizzazioni e vengono invece eseguiti con attendibilità totale.</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.PermissionSet">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.PermissionSet">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" uid="E:System.AppDomain.ProcessExit">
          <source>Occurs when the default application domain's parent process exits.</source>
          <target state="translated">Si verifica alla chiusura del processo padre del dominio applicazione predefinito.</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>The <ph id="ph1">&lt;xref:System.EventHandler&gt;</ph> for this event can perform termination activities, such as closing files, releasing storage and so on, before the process ends.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.EventHandler&gt;</ph> per questo evento è possibile eseguire le attività di chiusura, ad esempio la chiusura di file, il rilascio di archiviazione e così via, prima della fine del processo.</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>Beginning with the .NET Framework version 2.0, this event is raised in each application domain that registers an event handler.</source>
          <target state="translated">A partire da .NET Framework versione 2.0, questo evento viene generato in ogni dominio applicazione che registra un gestore dell'evento.</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>The total execution time of all <ph id="ph1">&lt;xref:System.AppDomain.ProcessExit&gt;</ph> event handlers is limited, just as the total execution time of all finalizers is limited at process shutdown.</source>
          <target state="translated">Il tempo di esecuzione totale di tutti <ph id="ph1">&lt;xref:System.AppDomain.ProcessExit&gt;</ph> gestori eventi è limitato, esattamente come il tempo di esecuzione totale di tutti i finalizzatori è limitato all'arresto del processo.</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>The default is two seconds.</source>
          <target state="translated">Il valore predefinito è di due secondi.</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>An unmanaged host can change this execution time by calling the <bpt id="p1">[</bpt>ICLRPolicyManager::SetTimeout<ept id="p1">](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md)</ept> method with the <bpt id="p2">[</bpt>OPR_ProcessExit<ept id="p2">](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md)</ept> enumeration value.</source>
          <target state="translated">Un host non gestito può modificare il tempo di esecuzione chiamando il <bpt id="p1">[</bpt>ICLRPolicyManager:: SetTimeout<ept id="p1">](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md)</ept> metodo con il <bpt id="p2">[</bpt>OPR_ProcessExit<ept id="p2">](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md)</ept> valore di enumerazione.</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>In the .NET Framework versions 1.0 and 1.1, this event is raised only in the default application domain, and only if an event handler is registered in the default application domain.</source>
          <target state="translated">Nelle versioni di .NET Framework 1.0 e 1.1, questo evento viene generato solo nel dominio applicazione predefinito e solo se un gestore eventi è registrato nel dominio applicazione predefinito.</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>To register an event handler for this event, you must have the required permissions, or a <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown.</source>
          <target state="translated">Per registrare un gestore eventi per questo evento, è necessario disporre delle autorizzazioni necessarie, o un <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ProcessExit">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla gestione degli eventi, vedere <bpt id="p1">[</bpt>gestione e generazione di eventi<ept id="p1">](~/docs/standard/events/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>Occurs when the resolution of an assembly fails in the reflection-only context.</source>
          <target state="translated">Si verifica quando la risoluzione di un assembly ha esito negativo nel contesto ReflectionOnly.</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>In the reflection-only context, dependencies are not resolved automatically.</source>
          <target state="translated">Nel contesto reflection-only, le dipendenze non vengono risolti automaticamente.</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>They must be preloaded or returned by the handler for this event.</source>
          <target state="translated">Devono essere precaricati o restituiti dal gestore per questo evento.</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>This event is raised when an assembly has a dependency that is not already loaded into the reflection-only context.</source>
          <target state="translated">Questo evento viene generato quando un assembly ha una dipendenza che non è già caricata nel contesto reflection-only.</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>The missing dependency is specified by the <ph id="ph1">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">La dipendenza mancante è specificata per il <ph id="ph1">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>The <ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph> for this event must return an assembly that satisfies the dependency.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph> per questo evento deve restituire un assembly che soddisfa la dipendenza.</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>The assembly that is returned must be loaded into the reflection-only context.</source>
          <target state="translated">L'assembly restituito deve essere caricato nel contesto reflection-only.</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>This event is raised only for missing dependencies of the assembly that you are loading into the reflection-only context (for example, by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType&gt;</ph> method).</source>
          <target state="translated">Questo evento viene generato solo per le dipendenze mancanti dell'assembly che si sta caricando nel contesto reflection-only (ad esempio, tramite il <ph id="ph1">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType&gt;</ph> (metodo)).</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>It is not raised if the assembly that you are loading cannot be found.</source>
          <target state="translated">Non viene generato se l'assembly che si sta caricando non viene trovato.</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph> property returns the assembly that requested the assembly load that could not be resolved.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, <ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph> proprietà restituisce l'assembly che ha richiesto il caricamento dell'assembly che non può essere risolto.</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>Knowing the identity of the requesting assembly might be useful in identifying the correct version of the dependency, if more than one version is available.</source>
          <target state="translated">Conoscere l'identità dell'assembly richiesta potrebbe essere utile per identificare la versione corretta della dipendenza, se è disponibile più di una versione.</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>For more information, see <ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>For this event, the <ph id="ph1">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph> property returns the assembly name before policy is applied.</source>
          <target state="translated">Per questo evento, il <ph id="ph1">&lt;xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType&gt;</ph> proprietà restituisce il nome dell'assembly prima di applicare criteri.</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla gestione degli eventi, vedere <bpt id="p1">[</bpt>gestione e generazione di eventi<ept id="p1">](~/docs/standard/events/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ReflectionOnlyAssemblyResolve">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ReflectionOnlyGetAssemblies">
          <source>Returns the assemblies that have been loaded into the reflection-only context of the application domain.</source>
          <target state="translated">Restituisce gli assembly caricati nel contesto ReflectionOnly del dominio applicazione.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ReflectionOnlyGetAssemblies">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> objects that represent the assemblies loaded into the reflection-only context of the application domain.</source>
          <target state="translated">Matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> che rappresentano gli assembly caricati nel contesto ReflectionOnly del dominio applicazione.</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ReflectionOnlyGetAssemblies">
          <source>This method returns the assemblies that have been loaded into the reflection-only context.</source>
          <target state="translated">Questo metodo restituisce gli assembly caricati nel contesto reflection-only.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ReflectionOnlyGetAssemblies">
          <source>To get the assemblies that have been loaded for execution, use the <ph id="ph1">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph> method.</source>
          <target state="translated">Per ottenere gli assembly che sono stati caricati per l'esecuzione, utilizzare il <ph id="ph1">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ReflectionOnlyGetAssemblies">
          <source>The following code example loads the System.dll assembly into the execution context and then into the reflection-only context.</source>
          <target state="translated">Esempio di codice seguente carica l'assembly System. dll nel contesto di esecuzione, quindi nel contesto reflection-only.</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ReflectionOnlyGetAssemblies">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A&gt;</ph> methods are used to display the assemblies loaded into each context.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.AppDomain.GetAssemblies%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A&gt;</ph> vengono utilizzati metodi per visualizzare gli assembly caricati in ogni contesto.</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ReflectionOnlyGetAssemblies">
          <source>An operation is attempted on an unloaded application domain.</source>
          <target state="translated">Si è tentato di effettuare un'operazione su un dominio applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" uid="P:System.AppDomain.RelativeSearchPath">
          <source>Gets the path under the base directory where the assembly resolver should probe for private assemblies.</source>
          <target state="translated">Ottiene il percorso nella directory di base in cui deve essere verificata la presenza di assembly privati mediante il resolver dell'assembly.</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.RelativeSearchPath">
          <source>The path under the base directory where the assembly resolver should probe for private assemblies.</source>
          <target state="translated">Percorso nella directory di base in cui deve essere verificata la presenza di assembly privati mediante il resolver dell'assembly.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.RelativeSearchPath">
          <source>Private assemblies are deployed in the same directory structure as the application.</source>
          <target state="translated">Assembly privati vengono distribuiti nella stessa struttura di directory dell'applicazione.</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.RelativeSearchPath">
          <source>If the path specified by the <ph id="ph1">&lt;xref:System.AppDomain.RelativeSearchPath%2A&gt;</ph> property is not under <ph id="ph2">&lt;xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType&gt;</ph>, it is ignored.</source>
          <target state="translated">Se il percorso specificato per il <ph id="ph1">&lt;xref:System.AppDomain.RelativeSearchPath%2A&gt;</ph> proprietà non è gestito da <ph id="ph2">&lt;xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType&gt;</ph>, viene ignorato.</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.RelativeSearchPath">
          <source>This property returns the value set using <ph id="ph1">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questa proprietà restituisce il valore impostato utilizzando <ph id="ph1">&lt;xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" uid="P:System.AppDomain.RelativeSearchPath">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.RelativeSearchPath">
          <source>for access to the path information.</source>
          <target state="translated">Per accedere alle informazioni sul percorso.</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.RelativeSearchPath">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" uid="E:System.AppDomain.ResourceResolve">
          <source>Occurs when the resolution of a resource fails because the resource is not a valid linked or embedded resource in the assembly.</source>
          <target state="translated">Si verifica quando la risoluzione di una risorsa ha esito negativo in quanto la risorsa stessa non è una risorsa collegata valida o non è incorporata nell'assembly.</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>The <ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph> for this event can attempt to locate the assembly containing the resource and return it.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph> per questo evento può tentare di individuare l'assembly contenente la risorsa e restituirlo.</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>This event is not raised if resolution fails because no file can be found for a valid linked resource.</source>
          <target state="translated">Questo evento non viene generato se la risoluzione non riesce perché può essere trovato alcun file per una risorsa collegata valida.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>It is raised if a manifest resource stream cannot be found, but it is not raised if an individual resource key cannot be found.</source>
          <target state="translated">Viene generato se un flusso di risorsa di manifesto non è stato trovato, ma non viene generato se non viene trovata una chiave singola risorsa.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph> property contains the assembly that requested the resource.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, <ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph> proprietà contiene l'assembly che ha richiesto la risorsa.</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>For more information, see <ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>To register an event handler for this event, you must have the required permissions, or a <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown.</source>
          <target state="translated">Per registrare un gestore eventi per questo evento, è necessario disporre delle autorizzazioni necessarie, o un <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla gestione degli eventi, vedere <bpt id="p1">[</bpt>gestione e generazione di eventi<ept id="p1">](~/docs/standard/events/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.ResourceResolve">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>The security policy level.</source>
          <target state="translated">Livello dei criteri di sicurezza.</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>Establishes the security policy level for this application domain.</source>
          <target state="translated">Imposta il livello dei criteri di sicurezza per il dominio applicazione.</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>Call this method before an assembly is loaded into the <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> in order for the security policy to have effect.</source>
          <target state="translated">Chiamare questo metodo prima del caricamento in un assembly di <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> affinché i criteri di sicurezza ha effetto.</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.AppDomain.SetAppDomainPolicy%2A&gt;</ph> method to set the security policy level of an application domain.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.AppDomain.SetAppDomainPolicy%2A&gt;</ph> per impostare il livello di criteri di sicurezza di un dominio applicazione.</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source><ph id="ph1">&lt;paramref name="domainPolicy" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="domainPolicy" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>The security policy level has already been set.</source>
          <target state="translated">Il livello dei criteri di sicurezza è già stato impostato.</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>The fully qualified path to the shadow copy location.</source>
          <target state="translated">Percorso completo delle copie shadow.</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>Establishes the specified directory path as the location where assemblies are shadow copied.</source>
          <target state="translated">Imposta il percorso di directory specificato come percorso in cui vengono replicati gli assembly mediante copia shadow.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>The cache path is ignored if the <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationName%2A&gt;</ph> property is not set.</source>
          <target state="translated">Il percorso della cache viene ignorato se il <ph id="ph1">&lt;xref:System.AppDomainSetup.ApplicationName%2A&gt;</ph> non è impostata.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>See the <ph id="ph1">&lt;xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Vedere la proprietà <ph id="ph1">&lt;xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>For more information on shadow copying see <bpt id="p1">[</bpt>Shadow Copying Assemblies<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla creazione di copie shadow vedere <bpt id="p1">[</bpt>copie Shadow di assembly<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetCachePath(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" uid="T:System.AppDomain">
          <source>Assigns a value to an application domain property.</source>
          <target state="translated">Assegna un valore a una proprietà del dominio applicazione.</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>The name of a user-defined application domain property to create or change.</source>
          <target state="translated">Nome della proprietà del dominio applicazione definito dall'utente da creare o modificare.</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>The value of the property.</source>
          <target state="translated">Valore della proprietà.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>Assigns the specified value to the specified application domain property.</source>
          <target state="translated">Assegna il valore specificato alla proprietà specificata del dominio applicazione.</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>Use this method to insert an entry, or modify the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>.</source>
          <target state="translated">Utilizzare questo metodo per inserire una voce o modificare il valore di una voce in una cache interna di coppie nome / dati che descrivono le proprietà di questa istanza di <ph id="ph1">&lt;xref:System.AppDomain&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>The cache automatically contains predefined system entries that are inserted when the application domain is created.</source>
          <target state="translated">La cache contiene automaticamente le voci di sistema predefiniti che vengono inserite quando viene creato il dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>You cannot insert or modify system entries with this method.</source>
          <target state="translated">È possibile inserire o modificare voci di sistema con questo metodo.</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>A method call that attempts to modify a system entry has no effect; the method does not throw an exception.</source>
          <target state="translated">Una chiamata al metodo che tenta di modificare una voce nel sistema non ha effetto. il metodo non genera un'eccezione.</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>You can inspect the values of system entries with the <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method, or the equivalent <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> properties described in <ph id="ph3">&lt;xref:System.AppDomain.GetData%2A&gt;</ph>.</source>
          <target state="translated">È possibile controllare i valori delle voci di sistema con il <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> metodo o l'equivalente <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> descritte le proprietà <ph id="ph3">&lt;xref:System.AppDomain.GetData%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>You can call this method to set the value of the default timeout interval for evaluating regular expression patterns by supply "REGEX_DEFAULT_MATCH_TIMEOUT" as the value of the <ph id="ph1">`name`</ph> argument and a <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> value that represents the timeout interval as the value of the <ph id="ph3">`data`</ph> argument.</source>
          <target state="translated">È possibile chiamare questo metodo per impostare il valore dell'intervallo di timeout predefinito per la valutazione di modelli di espressione regolare per fornire "REGEX_DEFAULT_MATCH_TIMEOUT" come valore della <ph id="ph1">`name`</ph> argomento e un <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> valore che rappresenta il timeout il valore di intervallo di <ph id="ph3">`data`</ph> argomento.</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>You can also insert or modify your own user defined name-data pairs with this method and inspect their values with the <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method.</source>
          <target state="translated">È anche possibile inserire o modificare la propria coppie nome / dati definiti dall'utente con questo metodo e verificarne i valori con il <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29&gt;</ph> method to create a new value pair.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29&gt;</ph> metodo per creare una nuova coppia di valori.</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>The example then uses the <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method to retrieve the value, and displays it to the console.</source>
          <target state="translated">Nell'esempio viene utilizzata la <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> metodo per recuperare il valore e lo visualizza nella console.</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>The name of a user-defined application domain property to create or change.</source>
          <target state="translated">Nome della proprietà del dominio applicazione definito dall'utente da creare o modificare.</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>The value of the property.</source>
          <target state="translated">Valore della proprietà.</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>The permission to demand of the caller when the property is retrieved.</source>
          <target state="translated">Autorizzazione di richiesta del chiamante quando viene recuperata la proprietà.</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>Assigns the specified value to the specified application domain property, with a specified permission to demand of the caller when the property is retrieved.</source>
          <target state="translated">Assegna il valore specificato alla proprietà del dominio applicazione indicata, con una determinata autorizzazione di richiesta del chiamante quando viene recuperata la proprietà.</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>Use this method to insert or modify your own user-defined entries in an internal cache of name/data pairs that describe properties of the application domain.</source>
          <target state="translated">Utilizzare questo metodo per inserire o modificare voci personalizzate definite dall'utente in una cache interna di coppie nome/dati che descrivono le proprietà del dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>When you insert an entry, you can specify a permission demand to enforce when the entry is retrieved.In addition, you can call this method to set the value of the default timeout interval for evaluating regular expression patterns by supply "REGEX_DEFAULT_MATCH_TIMEOUT" as the value of the <ph id="ph1">`name`</ph> argument and a <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> value that represents the timeout interval as the value of the <ph id="ph3">`data`</ph> argument.</source>
          <target state="translated">Quando si inserisce una voce, è possibile specificare una richiesta di autorizzazione da applicare quando viene recuperata la voce. Inoltre, è possibile chiamare questo metodo per impostare il valore dell'intervallo di timeout predefinito per la valutazione di modelli di espressione regolare per fornire "REGEX_DEFAULT_MATCH_TIMEOUT" come valore del <ph id="ph1">`name`</ph> argomento e un <ph id="ph2">&lt;xref:System.TimeSpan&gt;</ph> valore che rappresenta il uguale al valore dell'intervallo di timeout di <ph id="ph3">`data`</ph> argomento.</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>You cannot use this method to assign a security demand to a system-defined property string.</source>
          <target state="translated">È possibile usare questo metodo per assegnare una richiesta di sicurezza in una stringa di proprietà definita dal sistema.</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>The cache automatically contains predefined system entries that are inserted when the application domain is created.</source>
          <target state="translated">La cache contiene automaticamente le voci di sistema predefiniti che vengono inserite quando viene creato il dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>You cannot insert or modify system entries with this method.</source>
          <target state="translated">È possibile inserire o modificare voci di sistema con questo metodo.</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>A method call that attempts to modify a system entry has no effect; the method does not throw an exception.</source>
          <target state="translated">Una chiamata al metodo che tenta di modificare una voce nel sistema non ha effetto. il metodo non genera un'eccezione.</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>You can inspect the values of system entries with the <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method or the equivalent <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> properties described in the Remarks section for the <ph id="ph3">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> method.</source>
          <target state="translated">È possibile controllare i valori delle voci di sistema con il <ph id="ph1">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> metodo o l'equivalente <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> proprietà descritte nella sezione Osservazioni per il <ph id="ph3">&lt;xref:System.AppDomain.GetData%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> specifies a system-defined property string and <ph id="ph2">&lt;paramref name="permission" /&gt;</ph> is not <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> specifica una stringa di proprietà definita dal sistema e il parametro <ph id="ph2">&lt;paramref name="permission" /&gt;</ph> non è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>The fully qualified path that is the base directory for subdirectories where dynamic assemblies are stored.</source>
          <target state="translated">Percorso completo che costituisce la directory di base per le sottodirectory in cui sono archiviati gli assembly dinamici.</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>Establishes the specified directory path as the base directory for subdirectories where dynamically generated files are stored and accessed.</source>
          <target state="translated">Imposta il percorso di directory specificato come directory di base per sottodirectory in cui vengono archiviati i file generati dinamicamente e tramite cui si accede a questi ultimi.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>This method sets the <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A&gt;</ph> property of the internal <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> associated with this instance.</source>
          <target state="translated">Questo metodo imposta la <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A&gt;</ph> proprietà dell'oggetto interno <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> associata a questa istanza.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>This method is now obsolete, and should not be used for new development.</source>
          <target state="translated">Questo metodo è obsoleto e non deve essere utilizzato per nuove attività di sviluppo.</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>The following example shows how to use the non-obsolete alternative, the <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare l'alternativa non obsoleta, la <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>For an explanation of this example, see the <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType&gt;</ph> property or the <ph id="ph2">&lt;xref:System.AppDomain.DynamicDirectory%2A&gt;</ph> property.</source>
          <target state="translated">Per una spiegazione di questo esempio, vedere il <ph id="ph1">&lt;xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType&gt;</ph> proprietà o <ph id="ph2">&lt;xref:System.AppDomain.DynamicDirectory%2A&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetDynamicBase(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Security.Principal.PrincipalPolicy" /&gt;</ph> values that specifies the type of the principal object to attach to threads.</source>
          <target state="translated">Uno dei valori dell'enumerazione <ph id="ph1">&lt;see cref="T:System.Security.Principal.PrincipalPolicy" /&gt;</ph> che specifica il tipo dell'oggetto Principal da associare ai thread.</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>Specifies how principal and identity objects should be attached to a thread if the thread attempts to bind to a principal while executing in this application domain.</source>
          <target state="translated">Specifica come collegare oggetti Principal e Identity a un thread se si tenta di associare il thread a un Principal durante l'esecuzione nel dominio applicazione.</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>Setting this value will only be effective if you set it before using the <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Impostando questo valore saranno effettiva solo se si imposta la proprietà prima di utilizzare il <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>For example, if you set <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType&gt;</ph> to a given principal (for example, a generic principal) and then use the <ph id="ph2">&lt;xref:System.AppDomain.SetPrincipalPolicy%2A&gt;</ph> method to set the <ph id="ph3">&lt;xref:System.Security.Principal.PrincipalPolicy&gt;</ph> to <ph id="ph4">&lt;xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal&gt;</ph>, the current principal will remain the generic principal.</source>
          <target state="translated">Ad esempio, se si imposta <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType&gt;</ph> a una determinata entità (ad esempio, un'entità generica) e quindi utilizzare il <ph id="ph2">&lt;xref:System.AppDomain.SetPrincipalPolicy%2A&gt;</ph> per impostare il <ph id="ph3">&lt;xref:System.Security.Principal.PrincipalPolicy&gt;</ph> a <ph id="ph4">&lt;xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal&gt;</ph>, l'entità corrente rimarrà entità generica.</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>The following example shows the effect on threads of using the <ph id="ph1">&lt;xref:System.AppDomain.SetPrincipalPolicy%2A&gt;</ph> method to change the principal policy of the application domain.</source>
          <target state="translated">Nell'esempio seguente viene illustrato l'effetto sui thread dell'utilizzo di <ph id="ph1">&lt;xref:System.AppDomain.SetPrincipalPolicy%2A&gt;</ph> metodo per modificare i criteri del dominio dell'applicazione principali.</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>It also shows the effect of using the <ph id="ph1">&lt;xref:System.AppDomain.SetThreadPrincipal%2A&gt;</ph> method to change the principal that is available for attaching to threads in the application domain.</source>
          <target state="translated">Viene inoltre illustrato l'effetto dell'uso di <ph id="ph1">&lt;xref:System.AppDomain.SetThreadPrincipal%2A&gt;</ph> metodo per modificare l'entità che è disponibile per la connessione ai thread nel dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>for ability to manipulate the principal object.</source>
          <target state="translated">Per modificare l'oggetto principal.</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Azione di sicurezza: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetShadowCopyFiles">
          <source>Turns on shadow copying.</source>
          <target state="translated">Attiva la replica tramite copia shadow.</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyFiles">
          <source>For more information on shadow copying, see <bpt id="p1">[</bpt>Shadow Copying Assemblies<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla creazione di copie shadow, vedere <bpt id="p1">[</bpt>copie Shadow di assembly<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyFiles">
          <source>This method is now obsolete, and should not be used for new development.</source>
          <target state="translated">Questo metodo è obsoleto e non deve essere utilizzato per nuove attività di sviluppo.</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetShadowCopyFiles">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyFiles">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyFiles">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>A list of directory names, where each name is separated by a semicolon.</source>
          <target state="translated">Elenco di nomi di directory in cui i nomi sono separati da un punto e virgola.</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>Establishes the specified directory path as the location of assemblies to be shadow copied.</source>
          <target state="translated">Imposta il percorso di directory specificato come percorso degli assembly da replicare mediante copia shadow.</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>By default, a shadow copy includes all assemblies found through probing.</source>
          <target state="translated">Per impostazione predefinita, una copia shadow include tutti gli assembly trovati durante il rilevamento.</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.SetShadowCopyPath%2A&gt;</ph> method restricts the shadow copy to the assemblies in the directories specified by <ph id="ph2">`path`</ph>.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.AppDomain.SetShadowCopyPath%2A&gt;</ph> metodo limita la copia shadow agli assembly nella directory specificata da <ph id="ph2">`path`</ph>.</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.SetShadowCopyPath%2A&gt;</ph> method does not specify additional directories to be searched for assemblies.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.AppDomain.SetShadowCopyPath%2A&gt;</ph> (metodo) non specifica directory aggiuntive in cui cercare gli assembly.</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>Assemblies to be shadow-copied must already be located in the search path, for example under <ph id="ph1">&lt;xref:System.AppDomain.BaseDirectory%2A&gt;</ph>.</source>
          <target state="translated">Assembly da una copia shadow deve già trovarsi nel percorso di ricerca, ad esempio in <ph id="ph1">&lt;xref:System.AppDomain.BaseDirectory%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.SetShadowCopyPath%2A&gt;</ph> method specifies which search paths are eligible to be shadow-copied.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.AppDomain.SetShadowCopyPath%2A&gt;</ph> metodo specifica quali percorsi di ricerca sono idonei per l'esecuzione della copia shadow.</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>This method sets the <ph id="ph1">&lt;xref:System.AppDomainSetup.ShadowCopyDirectories%2A&gt;</ph> property of the internal <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> associated with this instance.</source>
          <target state="translated">Questo metodo imposta la <ph id="ph1">&lt;xref:System.AppDomainSetup.ShadowCopyDirectories%2A&gt;</ph> proprietà dell'oggetto interno <ph id="ph2">&lt;xref:System.AppDomainSetup&gt;</ph> associata a questa istanza.</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>For more information on shadow copying, see <bpt id="p1">[</bpt>Shadow Copying Assemblies<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla creazione di copie shadow, vedere <bpt id="p1">[</bpt>copie Shadow di assembly<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>This method is now obsolete, and should not be used for new development.</source>
          <target state="translated">Questo metodo è obsoleto e non deve essere utilizzato per nuove attività di sviluppo.</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetShadowCopyPath(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>The principal object to attach to threads.</source>
          <target state="translated">Oggetto Principal da collegare ai thread.</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>Sets the default principal object to be attached to threads if they attempt to bind to a principal while executing in this application domain.</source>
          <target state="translated">Imposta l'oggetto Principal predefinito da collegare ai thread se si tenta di associare questi ultimi a un oggetto Principal durante l'esecuzione nel dominio applicazione.</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>The following example shows the effect of using the <ph id="ph1">&lt;xref:System.AppDomain.SetThreadPrincipal%2A&gt;</ph> method to change the principal that is available for attaching to threads that are executing in the application domain.</source>
          <target state="translated">Nell'esempio seguente viene illustrato l'effetto dell'uso di <ph id="ph1">&lt;xref:System.AppDomain.SetThreadPrincipal%2A&gt;</ph> metodo per modificare l'entità che è disponibile per la connessione ai thread sono in esecuzione nel dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>It also shows the effect on threads of using the <ph id="ph1">&lt;xref:System.AppDomain.SetPrincipalPolicy%2A&gt;</ph> method to change the principal policy of the application domain.</source>
          <target state="translated">Viene inoltre illustrato l'effetto sui thread dell'utilizzo di <ph id="ph1">&lt;xref:System.AppDomain.SetPrincipalPolicy%2A&gt;</ph> metodo per modificare i criteri del dominio dell'applicazione principali.</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source><ph id="ph1">&lt;paramref name="principal" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="principal" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>The thread principal has already been set.</source>
          <target state="translated">L'oggetto Principal del thread è già stato impostato.</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>for ability to manipulate the principal object.</source>
          <target state="translated">Per modificare l'oggetto principal.</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Azione di sicurezza: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" uid="P:System.AppDomain.SetupInformation">
          <source>Gets the application domain configuration information for this instance.</source>
          <target state="translated">Ottiene le informazioni sulla configurazione del dominio applicazione per l'istanza.</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.SetupInformation">
          <source>The application domain initialization information.</source>
          <target state="translated">Informazioni sull'inizializzazione del dominio applicazione.</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" uid="P:System.AppDomain.SetupInformation">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" uid="P:System.AppDomain.ShadowCopyFiles">
          <source>Gets an indication whether the application domain is configured to shadow copy files.</source>
          <target state="translated">Indica se il dominio applicazione è configurato per eseguire la copia shadow di file.</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ShadowCopyFiles">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the application domain is configured to shadow copy files; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il dominio applicazione è configurato per eseguire la copia shadow di file; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.AppDomain.ShadowCopyFiles">
          <source>For more information, see <ph id="ph1">&lt;xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType&gt;</ph> and <bpt id="p1">[</bpt>Shadow Copying Assemblies<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <ph id="ph1">&lt;xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType&gt;</ph> e <bpt id="p1">[</bpt>copie Shadow di assembly<ept id="p1">](~/docs/framework/app-domains/shadow-copy-assemblies.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" uid="P:System.AppDomain.ShadowCopyFiles">
          <source>The operation is attempted on an unloaded application domain.</source>
          <target state="translated">L'operazione viene tentata in un dominio dell'applicazione non caricato.</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Riservato per utilizzi futuri.</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve essere IID_NULL.</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Matrice di nomi passata di cui eseguire il mapping.</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Conteggio dei nomi di cui eseguire il mapping.</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Contesto delle impostazioni locali in cui interpretare i nomi.</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Matrice allocata dal chiamante che riceve gli ID corrispondenti ai nomi.</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Esegue il mapping di un set di nomi a un set corrispondente di ID dispatch.</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, vedere MSDN Library.</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L'accesso ad associazione tardiva usando l'interfaccia COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> non è supportato.</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Informazioni sul tipo da restituire.</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Identificatore delle impostazioni locali per le informazioni sul tipo.</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Riceve un puntatore all'oggetto relativo alle informazioni sul tipo richiesto.</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Recupera le informazioni sul tipo relative a un oggetto che può quindi essere usato per ottenere informazioni sul tipo relative a un'interfaccia.</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, vedere MSDN Library.</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L'accesso ad associazione tardiva usando l'interfaccia COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> non è supportato.</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Punta a una posizione che riceve il numero di interfacce di informazioni sul tipo fornite dall'oggetto.</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Recupera il numero delle interfacce di informazioni sul tipo fornite da un oggetto (0 o 1).</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, vedere MSDN Library.</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L'accesso ad associazione tardiva usando l'interfaccia COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> non è supportato.</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Identifica il membro.</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Riservato per utilizzi futuri.</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve essere IID_NULL.</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Contesto di impostazioni locali all'interno del quale devono essere interpretati gli argomenti.</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Flag che descrivono il contesto della chiamata.</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Puntatore a una struttura contenente una matrice di argomenti, una matrice di DISPID per argomenti denominati e i conteggi del numero di elementi nelle matrici.</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Puntatore alla posizione in cui deve essere archiviato il risultato.</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Puntatore a una struttura contenente informazioni sull'eccezione.</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Indice del primo argomento che contiene un errore.</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Fornisce l'accesso a proprietà e metodi esposti da un oggetto.</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`IDispatch::Invoke`</ph>, vedere MSDN Library.</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" uid="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L'accesso ad associazione tardiva usando l'interfaccia COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> non è supportato.</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ToString">
          <source>Obtains a string representation that includes the friendly name of the application domain and any context policies.</source>
          <target state="translated">Ottiene una rappresentazione di stringa che comprende il nome descrittivo del dominio applicazione e qualsiasi criterio di contesto.</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ToString">
          <source>A string formed by concatenating the literal string "Name:", the friendly name of the application domain, and either string representations of the context policies or the string "There are no context policies."</source>
          <target state="translated">Stringa formata concatenando la rappresentazione formale di stringa "Name:", il nome descrittivo del dominio applicazione e le rappresentazioni di stringa dei criteri di contesto o la stringa "There are no context policies".</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.ToString">
          <source>The following code example displays the return value of the <ph id="ph1">&lt;xref:System.AppDomain.ToString%2A&gt;</ph> method.</source>
          <target state="translated">Esempio di codice seguente consente di visualizzare il valore restituito di <ph id="ph1">&lt;xref:System.AppDomain.ToString%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" uid="M:System.AppDomain.ToString">
          <source>The application domain represented by the current <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> has been unloaded.</source>
          <target state="translated">Il dominio applicazione rappresentato dall'oggetto <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> corrente è stato scaricato.</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" uid="E:System.AppDomain.TypeResolve">
          <source>Occurs when the resolution of a type fails.</source>
          <target state="translated">Si verifica quando la risoluzione di un tipo non riesce.</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> event occurs when the common language runtime is unable to determine the assembly that can create the requested type.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> evento si verifica quando in common language runtime è in grado di determinare l'assembly che è possibile creare il tipo richiesto.</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>This can occur if the type is defined in a dynamic assembly, or the type is not defined in a dynamic assembly but the runtime does not know which assembly the type is defined in.</source>
          <target state="translated">Ciò può verificarsi se il tipo è definito in un assembly dinamico, o il tipo non è definito in un assembly dinamico ma il runtime non conosce il tipo è definito nell'assembly.</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>The latter situation can occur when <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> is called with a type name that is not qualified with the assembly name.</source>
          <target state="translated">La seconda situazione può verificarsi quando <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> viene chiamato con un nome di tipo che non è qualificato con il nome dell'assembly.</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>The <ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph> for this event can attempt to locate and create the type.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.ResolveEventHandler&gt;</ph> per questo evento può tentare di individuare e creare il tipo.</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>However, the <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> event does not occur if the runtime knows it is not possible to find a type in certain assemblies.</source>
          <target state="translated">Tuttavia, il <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> evento non viene eseguito se il runtime è in grado non è possibile trovare un tipo in determinati assembly.</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>For example, this event does not occur if the type is not found in a static assembly because the runtime knows types cannot be added dynamically to static assemblies.</source>
          <target state="translated">Ad esempio, questo evento non si verifica se il tipo non viene trovato in un assembly statico perché il runtime è in grado di tipi non possono essere aggiunte dinamicamente per gli assembly statici.</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph> property contains the assembly that requested the type.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, <ph id="ph2">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph> proprietà contiene l'assembly che ha richiesto il tipo.</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>For more information, see <ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <ph id="ph1">&lt;xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>To register an event handler for this event, you must have the required permissions, or a <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown.</source>
          <target state="translated">Per registrare un gestore eventi per questo evento, è necessario disporre delle autorizzazioni necessarie, o un <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla gestione degli eventi, vedere <bpt id="p1">[</bpt>gestione e generazione di eventi<ept id="p1">](~/docs/standard/events/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>The following sample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> event.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>For this code example to run, you must provide the fully qualified assembly name.</source>
          <target state="translated">Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly.</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>For information about how to obtain the fully qualified assembly name, see <bpt id="p1">[</bpt>Assembly Names<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</source>
          <target state="translated">Per informazioni su come ottenere il nome completo dell'assembly, vedere <bpt id="p1">[</bpt>i nomi degli Assembly<ept id="p1">](~/docs/framework/app-domains/assembly-names.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.TypeResolve">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" uid="E:System.AppDomain.UnhandledException">
          <source>Occurs when an exception is not caught.</source>
          <target state="translated">Si verifica quando non viene intercettata un'eccezione.</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>This event provides notification of uncaught exceptions.</source>
          <target state="translated">Questo evento di notifica delle eccezioni non rilevate.</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>It allows the application to log information about the exception before the system default handler reports the exception to the user and terminates the application.</source>
          <target state="translated">Consente all'applicazione di registrare informazioni sull'eccezione prima che il gestore di sistema predefinito segnala l'eccezione all'utente e termina l'applicazione.</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If sufficient information about the state of the application is available, other actions may be undertaken — such as saving program data for later recovery.</source>
          <target state="translated">Se sono disponibili sufficienti informazioni sullo stato dell'applicazione, si possono intraprendere altre azioni, quali il salvataggio di dati del programma per il ripristino di versioni successive.</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>Caution is advised, because program data can become corrupted when exceptions are not handled.</source>
          <target state="translated">È consigliabile prestare attenzione, perché i dati del programma possono risultare danneggiati quando le eccezioni non gestite.</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>In the .NET Framework versions 1.0 and 1.1, application termination and debugging options are reported to the user before this event is raised, rather than after.</source>
          <target state="translated">Nelle versioni di .NET Framework 1.0 e 1.1, la terminazione dell'applicazione e le opzioni di debug vengono segnalati all'utente prima di questo evento viene generato, anziché dopo.</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>This event can be handled in any application domain.</source>
          <target state="translated">Questo evento può essere gestito in qualsiasi dominio applicazione.</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>However, the event is not necessarily raised in the application domain where the exception occurred.</source>
          <target state="translated">Tuttavia, l'evento non viene necessariamente generato nel dominio dell'applicazione in cui si è verificata l'eccezione.</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>An exception is unhandled only if the entire stack for the thread has been unwound without finding an applicable exception handler, so the first place the event can be raised is in the application domain where the thread originated.</source>
          <target state="translated">Un'eccezione viene gestita solo se l'intero stack per il thread è stato rimosso senza trovare un gestore di eccezioni applicabile, pertanto il primo elemento che può essere generato l'evento è nel dominio dell'applicazione in cui il thread ha avuto origine.</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>In the .NET Framework versions 1.0 and 1.1, this event occurs only for the default application domain that is created by the system when an application is started.</source>
          <target state="translated">Nelle versioni di .NET Framework 1.0 e 1.1, questo evento si verifica solo per il dominio applicazione predefinito creato dal sistema quando viene avviata un'applicazione.</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If an application creates additional application domains, specifying a delegate for this event in those applications domains has no effect.</source>
          <target state="translated">Se un'applicazione crea domini applicazione aggiuntivi, specificando un delegato per questo evento in tali domini applicazioni non ha alcun effetto.</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event is handled in the default application domain, it is raised there for any unhandled exception in any thread, no matter what application domain the thread started in.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> evento viene gestito nel dominio applicazione predefinito, viene generato in per qualsiasi eccezione non gestita in qualsiasi thread, indipendentemente dal dominio applicazione avviato il thread.</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If the thread started in an application domain that has an event handler for <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph>, the event is raised in that application domain.</source>
          <target state="translated">Se il thread avviato in un dominio applicazione che dispone di un gestore eventi per <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph>, l'evento viene generato nel dominio dell'applicazione.</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If that application domain is not the default application domain, and there is also an event handler in the default application domain, the event is raised in both application domains.</source>
          <target state="translated">Dominio dell'applicazione non è il dominio applicazione predefinito, se non vi è un gestore dell'evento nel dominio applicazione predefinito, viene generato l'evento in entrambi i domini applicazione.</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>For example, suppose a thread starts in application domain "AD1", calls a method in application domain "AD2", and from there calls a method in application domain "AD3", where it throws an exception.</source>
          <target state="translated">Ad esempio, si supponga che un thread viene avviato in dominio applicazione "AD1", chiama un metodo nel dominio applicazione "AD2" e da lì chiama un metodo nel dominio applicazione "AD3", in cui viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>The first application domain in which the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event can be raised is "AD1".</source>
          <target state="translated">Il primo dominio di applicazione in cui il <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> può essere generato l'evento è "AD1".</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If that application domain is not the default application domain, the event can also be raised in the default application domain.</source>
          <target state="translated">Se il dominio dell'applicazione non è il dominio applicazione predefinito, l'evento può essere generato anche nel dominio applicazione predefinito.</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>The common language runtime suspends thread aborts while event handlers for the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event are executing.</source>
          <target state="translated">Common language runtime sospende le interruzioni dei thread durante i gestori eventi per il <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> evento sono in esecuzione.</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If the event handler has a <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attribute with the appropriate flags, the event handler is treated as a constrained execution region.</source>
          <target state="translated">Se il gestore di evento include un <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attributo con il flag appropriati, il gestore dell'evento viene considerato come un'area a esecuzione vincolata.</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, this event is not raised for exceptions that corrupt the state of the process, such as stack overflows or access violations, unless the event handler is security-critical and has the <ph id="ph2">&lt;xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute&gt;</ph> attribute.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, questo evento non viene generato per le eccezioni che danneggiano lo stato del processo, ad esempio overflow dello stack o violazioni di accesso, a meno che il gestore dell'evento è critico per la sicurezza e ha il <ph id="ph2">&lt;xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute&gt;</ph> attributo.</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>In the .NET Framework versions 1.0 and 1.1, an unhandled exception that occurs in a thread other than the main application thread is caught by the runtime and therefore does not cause the application to terminate.</source>
          <target state="translated">Nelle versioni di .NET Framework 1.0 e 1.1, un'eccezione non gestita che si verifica in un thread diverso dal thread principale dell'applicazione viene intercettata dal runtime e pertanto non causa l'interruzione dell'applicazione.</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>Thus, it is possible for the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event to be raised without the application terminating.</source>
          <target state="translated">Di conseguenza, è possibile che il <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> dell'evento senza che l'applicazione termini.</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>Starting with the .NET Framework version 2.0, this backstop for unhandled exceptions in child threads was removed, because the cumulative effect of such silent failures included performance degradation, corrupted data, and lockups, all of which were difficult to debug.</source>
          <target state="translated">A partire da .NET Framework versione 2.0, questo trasparenti comprendeva per le eccezioni non gestite nei thread figlio è stato rimosso, poiché l'effetto cumulativo di tali errori invisibile all'utente un calo delle prestazioni, dati danneggiati e blocchi, ognuno dei quali sono stati difficile eseguire il debug.</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>For more information, including a list of cases in which the runtime does not terminate, see <bpt id="p1">[</bpt>Exceptions in Managed Threads<ept id="p1">](~/docs/standard/threading/exceptions-in-managed-threads.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni, incluso un elenco di casi in cui il runtime non viene terminato, vedere <bpt id="p1">[</bpt>eccezioni in thread gestiti<ept id="p1">](~/docs/standard/threading/exceptions-in-managed-threads.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>To register an event handler for this event, you must have the required permissions, or a <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown.</source>
          <target state="translated">Per registrare un gestore eventi per questo evento, è necessario disporre delle autorizzazioni necessarie, o un <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>For more information about handling events, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla gestione degli eventi, vedere <bpt id="p1">[</bpt>gestione e generazione di eventi<ept id="p1">](~/docs/standard/events/index.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>Other Events for Unhandled Exceptions</source>
          <target state="translated">Altri eventi per le eccezioni non gestite</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>For certain application models, the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event can be preempted by other events if the unhandled exception occurs in the main application thread.</source>
          <target state="translated">Per determinati modelli di applicazione, il <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> evento può essere superato da altri eventi se si verifica l'eccezione non gestita nel thread principale dell'applicazione.</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>In applications that use Windows Forms, unhandled exceptions in the main application thread cause the <ph id="ph1">&lt;xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType&gt;</ph> event to be raised.</source>
          <target state="translated">Nelle applicazioni che usano Windows Form, eccezioni non gestite nella causa del thread principale dell'applicazione di <ph id="ph1">&lt;xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType&gt;</ph> dell'evento.</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>If this event is handled, the default behavior is that the unhandled exception does not terminate the application, although the application is left in an unknown state.</source>
          <target state="translated">Se questo evento viene gestito, il comportamento predefinito prevede che l'eccezione non gestita non termina l'applicazione, anche se l'applicazione viene lasciato in uno stato sconosciuto.</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>In that case, the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event is not raised.</source>
          <target state="translated">In tal caso, il <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> non viene generato l'evento.</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>This behavior can be changed by using the application configuration file, or by using the <ph id="ph1">&lt;xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType&gt;</ph> method to change the mode to <ph id="ph2">&lt;xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType&gt;</ph> before the <ph id="ph3">&lt;xref:System.Windows.Forms.Application.ThreadException&gt;</ph> event handler is hooked up.</source>
          <target state="translated">Questo comportamento può essere modificato utilizzando il file di configurazione dell'applicazione o tramite il <ph id="ph1">&lt;xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType&gt;</ph> metodo per modificare la modalità di <ph id="ph2">&lt;xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType&gt;</ph> prima di <ph id="ph3">&lt;xref:System.Windows.Forms.Application.ThreadException&gt;</ph> gestore di evento è associato.</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>This applies only to the main application thread.</source>
          <target state="translated">Questo vale solo per il thread principale dell'applicazione.</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>The <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event is raised for unhandled exceptions thrown in other threads.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> evento viene generato per le eccezioni non gestite generate in altri thread.</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>Starting with Microsoft Visual Studio 2005, the Visual Basic application framework provides another event for unhandled exceptions in the main application thread.</source>
          <target state="translated">A partire da Microsoft Visual Studio 2005, il framework dell'applicazione Visual Basic fornisce un altro evento per le eccezioni non gestite nel thread principale dell'applicazione.</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>See the <ph id="ph1">&lt;xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Vedere il <ph id="ph1">&lt;xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>This event has an event arguments object with the same name as the event arguments object used by <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException?displayProperty=nameWithType&gt;</ph>, but with different properties.</source>
          <target state="translated">Questo evento è un oggetto di argomenti di eventi con lo stesso nome dell'oggetto di argomenti di evento utilizzato da <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException?displayProperty=nameWithType&gt;</ph>, ma con proprietà diverse.</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>In particular, this event arguments object has an <ph id="ph1">&lt;xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A&gt;</ph> property that allows the application to continue running, ignoring the unhandled exception (and leaving the application in an unknown state).</source>
          <target state="translated">In particolare, questo oggetto di argomenti di evento include un <ph id="ph1">&lt;xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A&gt;</ph> proprietà che consente all'applicazione di continuare l'esecuzione, ignorando l'eccezione non gestita (e lasciando l'applicazione in uno stato sconosciuto).</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>In that case, the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException?displayProperty=nameWithType&gt;</ph> event is not raised.</source>
          <target state="translated">In tal caso, il <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException?displayProperty=nameWithType&gt;</ph> non viene generato l'evento.</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>The followingexample demonstrates the <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> event.</source>
          <target state="translated">L'esempio seguente viene illustrato il <ph id="ph1">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>It defines an event handler, <ph id="ph1">`MyHandler`</ph>, that is invoked whenever an unhandled exception is thrown in the default application domain.</source>
          <target state="translated">Definisce un gestore eventi, <ph id="ph1">`MyHandler`</ph>, che viene richiamato ogni volta che viene generata un'eccezione non gestita nel dominio applicazione predefinito.</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>It then throws two exceptions.</source>
          <target state="translated">Genera quindi due eccezioni.</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>The first is handled by a <bpt id="p1">**</bpt>try/catch<ept id="p1">**</ept> block.</source>
          <target state="translated">Il primo viene gestito da un <bpt id="p1">**</bpt>try/catch<ept id="p1">**</ept> blocco.</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>The second is unhandled and invokes the <ph id="ph1">`MyHandle`</ph> routine before the application terminates.</source>
          <target state="translated">Il secondo viene gestito e richiama il <ph id="ph1">`MyHandle`</ph> routine prima della chiusura dell'applicazione.</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">richiede l'attendibilità totale per il chiamante immediato.</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.AppDomain.UnhandledException">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>An application domain to unload.</source>
          <target state="translated">Dominio applicazione da scaricare.</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>Unloads the specified application domain.</source>
          <target state="translated">Scarica il dominio applicazione corrente.</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>In the .NET Framework version 2.0 there is a thread dedicated to unloading application domains.</source>
          <target state="translated">In .NET Framework versione 2.0 è un thread dedicato di scaricamento di domini applicazione.</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>This improves reliability, especially when the .NET Framework is hosted.</source>
          <target state="translated">Ciò migliora l'affidabilità, soprattutto quando è ospitato in .NET Framework.</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>When a thread calls <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>, the target domain is marked for unloading.</source>
          <target state="translated">Quando un thread chiama <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>, il dominio di destinazione è contrassegnato per lo scaricamento.</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>The dedicated thread attempts to unload the domain, and all threads in the domain are aborted.</source>
          <target state="translated">Il thread dedicato tenta di scaricare il dominio e tutti i thread nel dominio sono state interrotte.</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>If a thread does not abort, for example because it is executing unmanaged code, or because it is executing a <ph id="ph1">`finally`</ph> block, then after a period of time a <ph id="ph2">&lt;xref:System.CannotUnloadAppDomainException&gt;</ph> is thrown in the thread that originally called <ph id="ph3">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>.</source>
          <target state="translated">Se un thread viene interrotto, ad esempio perché è in esecuzione il codice non gestito o perché è in esecuzione un <ph id="ph1">`finally`</ph> blocco, quindi dopo un periodo di tempo un <ph id="ph2">&lt;xref:System.CannotUnloadAppDomainException&gt;</ph> viene generata nel thread che ha originariamente chiamato <ph id="ph3">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>If the thread that could not be aborted eventually ends, the target domain is not unloaded.</source>
          <target state="translated">Se il thread che non venga interrotto infine termina, il dominio di destinazione non viene scaricato.</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>Thus, in the .NET Framework version 2.0 <ph id="ph1">`domain`</ph> is not guaranteed to unload, because it might not be possible to terminate executing threads.</source>
          <target state="translated">Pertanto, in .NET Framework versione 2.0 <ph id="ph1">`domain`</ph> non è garantita per essere scaricato, perché potrebbe non essere possibile terminare l'esecuzione di thread.</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>In some cases, calling <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph> causes an immediate <ph id="ph2">&lt;xref:System.CannotUnloadAppDomainException&gt;</ph>, for example if it is called in a finalizer.</source>
          <target state="translated">In alcuni casi, la chiamata <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph> genera un'eccezione immediata <ph id="ph2">&lt;xref:System.CannotUnloadAppDomainException&gt;</ph>, ad esempio se viene chiamato in un finalizzatore.</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>The threads in <ph id="ph1">`domain`</ph> are terminated using the <ph id="ph2">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> method, which throws a <ph id="ph3">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> in the thread.</source>
          <target state="translated">I thread nel <ph id="ph1">`domain`</ph> vengono terminati mediante il <ph id="ph2">&lt;xref:System.Threading.Thread.Abort%2A&gt;</ph> metodo, che genera un <ph id="ph3">&lt;xref:System.Threading.ThreadAbortException&gt;</ph> nel thread.</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>Although the thread should terminate promptly, it can continue executing for an unpredictable amount of time in a <ph id="ph1">`finally`</ph> clause.</source>
          <target state="translated">Anche se il thread viene terminato immediatamente, può continuare l'esecuzione per un periodo di tempo in imprevedibile un <ph id="ph1">`finally`</ph> clausola.</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>Version Compatibility</source>
          <target state="translated">Compatibilità tra versioni</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>In the .NET Framework version 1.0 and 1.1 if the thread that calls <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph> is running in <ph id="ph2">`domain`</ph>, another thread is started to perform the unload operation.</source>
          <target state="translated">In .NET Framework versioni 1.0 e 1.1, se il thread che chiama <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph> è in esecuzione in <ph id="ph2">`domain`</ph>, viene avviato un altro thread per eseguire l'operazione di scaricamento.</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>If <ph id="ph1">`domain`</ph> cannot be unloaded, a <ph id="ph2">&lt;xref:System.CannotUnloadAppDomainException&gt;</ph> is thrown in that thread, not in the original thread that called <ph id="ph3">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>.</source>
          <target state="translated">Se <ph id="ph1">`domain`</ph> non può essere scaricato, un <ph id="ph2">&lt;xref:System.CannotUnloadAppDomainException&gt;</ph> viene generata in tale thread, non nel thread originale che ha chiamato <ph id="ph3">&lt;xref:System.AppDomain.Unload%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>However, if the thread that calls <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph> is running outside <ph id="ph2">`domain`</ph>, that thread receives the exception.</source>
          <target state="translated">Tuttavia, se il thread che chiama <ph id="ph1">&lt;xref:System.AppDomain.Unload%2A&gt;</ph> è in esecuzione all'esterno di <ph id="ph2">`domain`</ph>, che i thread riceve l'eccezione.</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>The following code example shows how to unload an application domain.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come scaricare un dominio applicazione.</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source><ph id="ph1">&lt;paramref name="domain" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="domain" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source><ph id="ph1">&lt;paramref name="domain" /&gt;</ph> could not be unloaded.</source>
          <target state="translated">Impossibile scaricare <ph id="ph1">&lt;paramref name="domain" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>An error occurred during the unload process.</source>
          <target state="translated">Si è verificato un errore durante il processo di scaricamento.</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>to add an event handler for this event.</source>
          <target state="translated">Per aggiungere un gestore eventi per questo evento.</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.AppDomain.Unload(System.AppDomain)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</source>
          <target state="translated">Azione di sicurezza: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.Demand" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>