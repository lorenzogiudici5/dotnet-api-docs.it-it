<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e0c6cd93db10995b051b068ce1439987f93a2699" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39902761" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type AppDomain = class&#xA;    inherit MarshalByRefObject&#xA;    interface _AppDomain&#xA;    interface IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un dominio applicazione, ossia un ambiente isolato nel quale vengono eseguite le applicazioni. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domini applicazione, che sono rappresentati da <xref:System.AppDomain> oggetti, forniscono i limiti di isolamento, lo scaricamento e sicurezza per l'esecuzione di codice gestito.  
  
-   Usare i domini applicazione per isolare le attività che potrebbero arrestare un processo. Se lo stato del <xref:System.AppDomain> che è in esecuzione un'attività diventa instabile, la <xref:System.AppDomain> possono essere scaricati senza interferire con il processo. Questo è importante quando un processo deve essere eseguito per lunghi periodi senza riavviare il computer. È anche possibile usare domini dell'applicazione per isolare le attività che non devono condividere i dati.  
  
-   Se un assembly viene caricato nel dominio dell'applicazione predefinito, non può essere scaricata dalla memoria mentre il processo è in esecuzione. Tuttavia, se si apre un secondo dominio dell'applicazione per caricare ed eseguire l'assembly, l'assembly viene scaricato quando tale dominio dell'applicazione viene scaricato. Usare questa tecnica per ridurre al minimo il working set di processi a esecuzione prolungata che occasionalmente usano DLL di grandi dimensioni.  
  
 Più domini dell'applicazione possono eseguire su un singolo processo. Tuttavia, non esiste un relazione uno a uno tra domini applicazione e thread. Più thread possono appartenere a un solo dominio applicazione e anche se un determinato thread non è confinato a un solo dominio applicazione, in qualsiasi momento, un thread viene eseguito in un solo dominio applicazione.  
  
 Domini applicazione vengono creati utilizzando il <xref:System.AppDomain.CreateDomain%2A> (metodo). <xref:System.AppDomain> le istanze vengono utilizzate per caricare ed eseguire assembly (<xref:System.Reflection.Assembly>). Quando un <xref:System.AppDomain> è non è più in uso, può essere scaricato.  
  
 Il <xref:System.AppDomain> classe implementa un set di eventi che consentono alle applicazioni di rispondere quando viene caricato un assembly, quando verrà scaricato un dominio dell'applicazione o quando viene generata un'eccezione non gestita.  
  
 Per altre informazioni sull'uso di domini applicazione, vedere [domini applicazione](~/docs/framework/app-domains/application-domains.md).  
  
 Questa classe implementa il <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, e <xref:System.Security.IEvidenceFactory> interfacce.  
  
 È consigliabile non creare mai un wrapper utilizzabile in remoto per un <xref:System.AppDomain> oggetto. In questo modo è possibile pubblicare un riferimento remoto a quella <xref:System.AppDomain>, che espone i metodi, ad esempio <xref:System.AppDomain.CreateInstance%2A> per l'accesso remoto e l'eliminazione definitiva in modo efficace di sicurezza dall'accesso di codice per tale <xref:System.AppDomain>. Client dannoso che si connettono per i nodi <xref:System.AppDomain> è stato possibile ottenere l'accesso a qualsiasi risorsa il <xref:System.AppDomain> stesso può accedere a. Non creare wrapper utilizzabile in remoto per qualsiasi tipo che estende <xref:System.MarshalByRefObject> e che implementa metodi che possono essere usati da client non autorizzati per aggirare il sistema di sicurezza.  
  
> [!CAUTION]
>  Il valore predefinito per il <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> è di proprietà `false`. Questa impostazione non è sicura per i servizi. Per impedire a servizi di download di codice parzialmente attendibile, impostare questa proprietà su `true`.  
  
   
  
## Examples  
 Questo esempio viene illustrato come creare una nuova <xref:System.AppDomain>, creare un'istanza di un tipo nel nuovo <xref:System.AppDomain>e comunicare con l'oggetto del tipo specificato. Inoltre, in questo esempio viene illustrato come scaricare il <xref:System.AppDomain> causando l'oggetto venga sottoposto a garbage collection.  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActivationContext : ActivationContext" Usage="System.AppDomain.ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il contesto di attivazione del dominio applicazione corrente.</summary>
        <value>Oggetto che rappresenta il contesto di attivazione del dominio dell'applicazione corrente o <see langword="null" /> se al dominio non è associato alcun contesto di attivazione.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member AppendPrivatePath : string -&gt; unit&#xA;override this.AppendPrivatePath : string -&gt; unit" Usage="appDomain.AppendPrivatePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nome della directory da aggiungere al percorso privato.</param>
        <summary>Aggiunge il nome di directory specificato all'elenco di percorsi privati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'uso di questa proprietà non è consigliabile, perché potrebbe modificare il percorso di sondaggio per assembly dopo che sono già stati caricati. In alternativa, usare la proprietà <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
 Il percorso privato o il percorso di ricerca relativo, è il percorso relativo della directory base dal resolver dell'assembly in cui vengono cercate assembly privati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationIdentity : ApplicationIdentity" Usage="System.AppDomain.ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'identità dell'applicazione nel dominio applicazione.</summary>
        <value>Oggetto che identifica l'applicazione nel dominio dell'applicazione.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust" Usage="System.AppDomain.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene informazioni che descrivono le autorizzazioni concesse a un'applicazione e che consentono di stabilire se all'applicazione è associato un livello di attendibilità che ne consente l'esecuzione.</summary>
        <value>Oggetto che incapsula informazioni sulle autorizzazioni e sull'attendibilità relative all'applicazione nel dominio dell'applicazione.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ApplyPolicy : string -&gt; string" Usage="appDomain.ApplyPolicy assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly, nel formato fornito dalla proprietà <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Restituisce il nome visualizzato dell'assembly dopo l'applicazione dei criteri.</summary>
        <returns>Stringa contenente il nome visualizzato dell'assembly dopo l'applicazione dei criteri.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AppDomain.ApplyPolicy%2A> visualizzati il nome di metodo accetta un assembly e restituisce il nome visualizzato di post-criteri. Ciò è utile se è necessario caricare un assembly usando criteri, perché il contesto reflection-only non applica i criteri.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberSignature Language="F#" Value="member this.AssemblyLoad : AssemblyLoadEventHandler " Usage="member this.AssemblyLoad : System.AssemblyLoadEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica al caricamento di un assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AssemblyLoadEventHandler> delegato per questo evento indica quali assembly è stato caricato.  
  
 Per registrare un gestore eventi per questo evento, è necessario disporre delle autorizzazioni necessarie, o un <xref:System.Security.SecurityException> viene generata un'eccezione.  
  
 Per ulteriori informazioni sulla gestione degli eventi, consultare [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.AssemblyLoad> evento.  
  
 Per questo esempio di codice per l'esecuzione, è necessario specificare il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.AssemblyResolve : ResolveEventHandler " Usage="member this.AssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando la risoluzione di un assembly ha esito negativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È responsabilità del <xref:System.ResolveEventHandler> per questo evento restituire l'assembly specificato da di <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> proprietà o per restituire null se l'assembly non viene riconosciuto. L'assembly deve essere caricato in un contesto di esecuzione; Se viene caricato nel contesto reflection-only, il carico che ha causato la generazione dell'evento ha esito negativo.  
  
 Per indicazioni sull'uso di questo evento, vedere [Risoluzione caricamenti Assembly](~/docs/framework/app-domains/resolve-assembly-loads.md).  
  
 Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> proprietà restituisce l'assembly che ha richiesto il caricamento dell'assembly che non può essere risolto. Ad esempio, il caricatore potrebbe essere Impossibile caricare una dipendenza di assembly richiedente, perché l'assembly richiedente e la relativa dipendenza non sono nel percorso di sondaggio. Conoscere l'identità dell'assembly richiesta potrebbe essere utile nell'individuazione della dipendenza o identificare la versione corretta, se è disponibile più di una versione della dipendenza. Per ulteriori informazioni, vedere <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
> [!IMPORTANT]
>  Inizia con la [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], il <xref:System.ResolveEventHandler> evento viene generato per tutti gli assembly, inclusi gli assembly di risorse. Nelle versioni precedenti, per gli assembly di risorse non è stato generato l'evento. Se il sistema operativo localizzato, il gestore può essere chiamato più volte: una volta per ogni impostazione cultura nella catena di fallback.  
  
 Per questo evento, il <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> proprietà restituisce il nome dell'assembly prima di applicare dei criteri.  
  
> [!IMPORTANT]
>  Se più di un gestore eventi è registrato per questo evento, l'evento handlersarecalled in ordine fino a quando un gestore eventi restituisce un valore che non è `null`. Gestori di eventi successivi vengono ignorati.  
  
 Per ulteriori informazioni sulla gestione degli eventi, consultare [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.AssemblyResolve> evento.  
  
 Per questo esempio di codice per l'esecuzione, è necessario specificare il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseDirectory : string" Usage="System.AppDomain.BaseDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la directory di base usata dal resolver dell'assembly per verificare la presenza di assembly.</summary>
        <value>Directory di base usata dal resolver dell'assembly per verificare la presenza di assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà corrisponde al <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> proprietà. Può anche essere recuperato tramite il <xref:System.AppDomain.GetData%2A> metodo con la stringa "APPBASE".  
  
   
  
## Examples  
 Esempio di codice seguente crea un nuovo dominio applicazione, specificando una directory di base da utilizzare durante la ricerca degli assembly da caricare nel dominio. L'esempio Usa quindi il <xref:System.AppDomain.BaseDirectory%2A> proprietà per ottenere il percorso della directory base per la visualizzazione nella console.  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni presenti nel percorso stesso, inclusi se il percorso è nel formato "file://" o \\\UNC\dir o "c:\\". Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberSignature Language="F#" Value="abstract member ClearPrivatePath : unit -&gt; unit&#xA;override this.ClearPrivatePath : unit -&gt; unit" Usage="appDomain.ClearPrivatePath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta su stringa vuota ("") il percorso che specifica la posizione degli assembly privati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il percorso privato è un percorso relativo alla directory di base che common language runtime cerca per individuare gli assembly privati.  
  
 Per ulteriori informazioni, vedere <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.AppDomain.ClearPrivatePath%2A> metodo per rimuovere tutte le voci dall'elenco di percorsi privati per la ricerca quando gli assembly vengono caricati.  
  
 Questo metodo è obsoleto e non deve essere utilizzato per nuove attività di sviluppo.  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberSignature Language="F#" Value="abstract member ClearShadowCopyPath : unit -&gt; unit&#xA;override this.ClearShadowCopyPath : unit -&gt; unit" Usage="appDomain.ClearShadowCopyPath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta su stringa vuota ("") l'elenco di directory contenenti assembly replicati mediante copia shadow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il percorso della copia shadow è un elenco di directory assembly di copia shadow in cui sono archiviati.  
  
 Per altre informazioni, vedere <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> e [copie replicate di assembly](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nuova istanza di un tipo COM specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome di un file contenente un assembly che definisce il tipo richiesto.</param>
        <param name="typeName">Nome del tipo richiesto.</param>
        <summary>Crea una nuova istanza di un tipo COM specificato. I parametri specificano il nome di un file contenente un assembly che, a sua volta, contiene il tipo e il nome del tipo.</summary>
        <returns>Oggetto che rappresenta un wrapper per la nuova istanza specificata da <paramref name="typeName" />. Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per creare oggetti in modalità remota senza dover caricare il tipo in locale.  
  
 Il valore restituito deve per essere annullato il wrapping per accedere all'oggetto reale.  
  
 Oggetto <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attributo con il valore `true` deve essere applicato in modo esplicito o per impostazione predefinita per il tipo COM per questo metodo per creare un'istanza di quel tipo; in caso contrario, <xref:System.TypeLoadException> viene generata un'eccezione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile caricare il tipo.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico senza parametri.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> non trovata.</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> è una classe astratta.  
  
oppure 
Questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.NullReferenceException">L'oggetto COM cui viene fatto riferimento è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">la possibilità di leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyFile, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome di un file contenente un assembly che definisce il tipo richiesto.</param>
        <param name="typeName">Nome del tipo richiesto.</param>
        <param name="hashValue">Rappresenta il valore del codice hash calcolato.</param>
        <param name="hashAlgorithm">Rappresenta l'algoritmo hash usato dal manifesto dell'assembly.</param>
        <summary>Crea una nuova istanza di un tipo COM specificato. I parametri specificano il nome di un file contenente un assembly che, a sua volta, contiene il tipo e il nome del tipo.</summary>
        <returns>Oggetto che rappresenta un wrapper per la nuova istanza specificata da <paramref name="typeName" />. Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per creare oggetti in modalità remota senza dover caricare il tipo in locale.  
  
 Il valore restituito deve per essere annullato il wrapping per accedere all'oggetto reale.  
  
 Oggetto <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attributo con il valore `true` deve essere applicato in modo esplicito o per impostazione predefinita per il tipo COM per questo metodo per creare un'istanza di quel tipo; in caso contrario, <xref:System.TypeLoadException> viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile caricare il tipo.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico senza parametri.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non trovata.</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> è una classe astratta.  
  
oppure 
Questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> è la stringa vuota ("").</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.NullReferenceException">L'oggetto COM cui viene fatto riferimento è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">la possibilità di leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo dominio applicazione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string -&gt; AppDomain" Usage="System.AppDomain.CreateDomain friendlyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Nome descrittivo del dominio.</param>
        <summary>Crea un nuovo dominio applicazione con il nome specificato.</summary>
        <returns>Dominio applicazione appena creato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `friendlyName` parametro ha lo scopo di identificare il dominio in modo significativo per gli utenti. Questa stringa deve essere appropriata per la visualizzazione nelle interfacce utente.  
  
 Questo overload del metodo Usa il <xref:System.AppDomainSetup> informazioni dal dominio applicazione predefinito.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato, in generale, come creare un dominio usando uno del <xref:System.AppDomain.CreateDomain%2A> overload.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Nome descrittivo del dominio. Questo nome descrittivo può essere visualizzato nelle interfacce utente per identificare il dominio. Per ulteriori informazioni, vedere <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidenza che stabilisce l'identità del codice che viene eseguito nel dominio applicazione. Passare <see langword="null" /> per usare l'evidenza del dominio applicazione corrente.</param>
        <summary>Crea un nuovo dominio applicazione con il nome specificato usando l'evidenza fornita.</summary>
        <returns>Dominio applicazione appena creato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del metodo Usa il <xref:System.AppDomainSetup> informazioni dal dominio applicazione predefinito.  
  
 Se `securityInfo` viene omesso, viene utilizzato l'evidenza del dominio applicazione corrente.  
  
> [!IMPORTANT]
>  Non utilizzare questo overload del metodo per creare domini dell'applicazione sandbox. Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], l'evidenza fornita per `securityInfo` non influisce sul set di concessioni del dominio dell'applicazione. Usare il <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> overload del metodo per creare domini dell'applicazione sandbox.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato, in generale, come creare un dominio usando uno del <xref:System.AppDomain.CreateDomain%2A> overload.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Nome descrittivo del dominio. Questo nome descrittivo può essere visualizzato nelle interfacce utente per identificare il dominio. Per ulteriori informazioni, vedere <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidenza che stabilisce l'identità del codice che viene eseguito nel dominio applicazione. Passare <see langword="null" /> per usare l'evidenza del dominio applicazione corrente.</param>
        <param name="info">Oggetto contenente informazioni relative all'inizializzazione del dominio applicazione.</param>
        <summary>Crea un nuovo dominio applicazione usando il nome, l'evidenza e le informazioni di installazione del dominio applicazione specificati.</summary>
        <returns>Dominio applicazione appena creato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `info` viene omesso, viene utilizzato questo overload del metodo di <xref:System.AppDomainSetup> informazioni dal dominio applicazione predefinito.  
  
 Se `securityInfo` viene omesso, viene utilizzato l'evidenza del dominio applicazione corrente.  
  
> [!IMPORTANT]
>  Non utilizzare questo overload del metodo per creare domini dell'applicazione sandbox. Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], l'evidenza fornita per `securityInfo` non influisce sul set di concessioni del dominio dell'applicazione. Usare il <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> overload del metodo per creare domini dell'applicazione sandbox.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato, in generale, come creare un dominio usando uno del <xref:System.AppDomain.CreateDomain%2A> overload.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup * System.Security.PermissionSet * System.Security.Policy.StrongName[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info, grantSet, fullTrustAssemblies)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName">Nome descrittivo del dominio. Questo nome descrittivo può essere visualizzato nelle interfacce utente per identificare il dominio. Per altre informazioni, vedere la descrizione dell'oggetto <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidenza che stabilisce l'identità del codice che viene eseguito nel dominio applicazione. Passare <see langword="null" /> per usare l'evidenza del dominio applicazione corrente.</param>
        <param name="info">Oggetto contenente informazioni relative all'inizializzazione del dominio applicazione.</param>
        <param name="grantSet">Set di autorizzazioni predefinito concesso a tutti gli assembly caricati nel nuovo dominio applicazione a cui non sono concesse autorizzazioni specifiche.</param>
        <param name="fullTrustAssemblies">Matrice di nomi sicuri che rappresentano gli assembly da considerare come completamente attendibili nel nuovo dominio applicazione.</param>
        <summary>Crea un nuovo dominio applicazione usando il nome, l'evidenza, le informazioni di impostazione del dominio applicazione, il set di autorizzazioni predefinito e la matrice di assembly completamente attendibili specificati.</summary>
        <returns>Dominio applicazione appena creato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario impostare il <xref:System.AppDomainSetup.ApplicationBase%2A> proprietà del <xref:System.AppDomainSetup> oggetto che viene fornito per `info`. In caso contrario, viene generata un'eccezione.  
  
 Se `securityInfo` viene omesso, viene utilizzato l'evidenza del dominio applicazione corrente.  
  
 Le informazioni previste `grantSet` e `fullTrustAssemblies` viene usato per creare un <xref:System.Security.Policy.ApplicationTrust> oggetto per il nuovo dominio applicazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il dominio applicazione è <see langword="null" />.  
  
oppure 
La proprietà <see cref="P:System.AppDomainSetup.ApplicationBase" /> non è impostata sull'oggetto <see cref="T:System.AppDomainSetup" /> fornito per <paramref name="info" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per la possibilità di creare e modificare un dominio dell'applicazione. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Nome descrittivo del dominio. Questo nome descrittivo può essere visualizzato nelle interfacce utente per identificare il dominio. Per ulteriori informazioni, vedere <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidenza che stabilisce l'identità del codice che viene eseguito nel dominio applicazione. Passare <see langword="null" /> per usare l'evidenza del dominio applicazione corrente.</param>
        <param name="appBasePath">Directory di base usata dal resolver dell'assembly per verificare la presenza di assembly. Per ulteriori informazioni, vedere <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Percorso relativo alla directory di base in cui deve essere verificata la presenza di assembly privati mediante il resolver degli assembly. Per ulteriori informazioni, vedere <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">Se <see langword="true" />, nel dominio applicazione verrà caricata la copia shadow di un assembly.</param>
        <summary>Crea un nuovo dominio applicazione con il nome indicato mediante un'evidenza, un percorso base dell'applicazione, un percorso di ricerca relativo e un parametro che specifica se nel dominio applicazione deve essere caricata la copia shadow di un assembly.</summary>
        <returns>Dominio applicazione appena creato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `securityInfo` viene omesso, viene utilizzato l'evidenza del dominio applicazione corrente.  
  
 Per altre informazioni sulla creazione di copie shadow, vedere <xref:System.AppDomain.ShadowCopyFiles%2A> e [copie replicate di assembly](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  Non utilizzare questo overload del metodo per creare domini dell'applicazione sandbox. Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], l'evidenza fornita per `securityInfo` non influisce sul set di concessioni del dominio dell'applicazione. Usare il <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> overload del metodo per creare domini dell'applicazione sandbox.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato, in generale, come creare un dominio usando uno del <xref:System.AppDomain.CreateDomain%2A> overload.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool * AppDomainInitializer * string[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles, adInit, adInitArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" />
        <Parameter Name="adInitArgs" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Nome descrittivo del dominio. Questo nome descrittivo può essere visualizzato nelle interfacce utente per identificare il dominio. Per ulteriori informazioni, vedere <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidenza che stabilisce l'identità del codice che viene eseguito nel dominio applicazione. Passare <see langword="null" /> per usare l'evidenza del dominio applicazione corrente.</param>
        <param name="appBasePath">Directory di base usata dal resolver dell'assembly per verificare la presenza di assembly. Per ulteriori informazioni, vedere <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Percorso relativo alla directory di base in cui deve essere verificata la presenza di assembly privati mediante il resolver degli assembly. Per ulteriori informazioni, vedere <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">
          <see langword="true" /> per caricare una copia shadow di un assembly nel dominio applicazione.</param>
        <param name="adInit">Delegato <see cref="T:System.AppDomainInitializer" /> che rappresenta un metodo di callback da richiamare quando viene inizializzato il nuovo oggetto <see cref="T:System.AppDomain" />.</param>
        <param name="adInitArgs">Matrice di argomenti stringa da passare al metodo di callback rappresentato dal parametro <c>adInit</c> quando viene inizializzato il nuovo oggetto <see cref="T:System.AppDomain" />.</param>
        <summary>Crea un nuovo dominio applicazione con il nome indicato mediante un'evidenza, un percorso base dell'applicazione, un percorso di ricerca relativo e un parametro che specifica se nel dominio applicazione deve essere caricata la copia shadow di un assembly. Specifica un metodo di callback che viene richiamato quando viene inizializzato il dominio applicazione e indica una matrice di argomenti stringa da passare al metodo di callback.</summary>
        <returns>Dominio applicazione appena creato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo rappresentato da `adInit` viene eseguita nel contesto del dominio applicazione appena creata.  
  
 Se `securityInfo` viene omesso, viene utilizzato l'evidenza del dominio applicazione corrente.  
  
 Per altre informazioni sulla creazione di copie shadow, vedere <xref:System.AppDomain.ShadowCopyFiles%2A> e [copie replicate di assembly](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  Non utilizzare questo overload del metodo per creare domini dell'applicazione sandbox. Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], l'evidenza fornita per `securityInfo` non influisce sul set di concessioni del dominio dell'applicazione. Usare il <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> overload del metodo per creare domini dell'applicazione sandbox.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nuova istanza di un tipo specificato definito in un assembly specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nell'assembly specificato.</summary>
        <returns>Oggetto che rappresenta un wrapper per la nuova istanza specificata da <paramref name="typeName" />. Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo chiama il costruttore predefinito per `typeName`.  
  
 Visualizzare <xref:System.Reflection.AssemblyName> per il formato di `assemblyName`.  
  
 Un tentativo di chiamare <xref:System.AppDomain.CreateInstance%2A> una destinazione dominio dell'applicazione che non è il dominio applicazione corrente comporterà un caricamento corretto dell'assembly nel dominio dell'applicazione di destinazione. Poiché un' <xref:System.Reflection.Assembly> non è <xref:System.MarshalByRefObject>, quando questo metodo tenta di restituire il <xref:System.Reflection.Assembly> per l'assembly caricato nel dominio applicazione corrente, common language runtime proverà a caricare l'assembly nel dominio applicazione corrente e il carico potrebbe non riuscire. L'assembly caricato nel dominio applicazione corrente potrebbe essere diverso dall'assembly che è stato caricato prima di tutto se le impostazioni del percorso per i due domini applicazione sono diverse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">Questa istanza è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nell'assembly specificato. Un parametro specifica una matrice di attributi di attivazione.</summary>
        <returns>Oggetto che rappresenta un wrapper per la nuova istanza specificata da <paramref name="typeName" />. Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo chiama il costruttore predefinito per `typeName`.  
  
 Visualizzare <xref:System.Reflection.AssemblyName> per il formato di `assemblyName`.  
  
 Un tentativo di chiamare <xref:System.AppDomain.CreateInstance%2A> una destinazione dominio dell'applicazione che non è il dominio applicazione corrente comporterà un caricamento corretto dell'assembly nel dominio dell'applicazione di destinazione. Poiché un' <xref:System.Reflection.Assembly> non è <xref:System.MarshalByRefObject>, quando questo metodo tenta di restituire il <xref:System.Reflection.Assembly> per l'assembly caricato nel dominio applicazione corrente, common language runtime proverà a caricare l'assembly nel dominio applicazione corrente e il carico potrebbe non riuscire. L'assembly caricato nel dominio applicazione corrente potrebbe essere diverso dall'assembly che è stato caricato prima di tutto se le impostazioni del percorso per i due domini applicazione sono diverse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">Questa istanza è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">la possibilità di leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">la possibilità di richiamare le operazioni su tutti i membri di tipo. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che consente l'associazione, la coercizione dei tipi di argomento, la chiamata dei membri e il recupero di oggetti <see cref="T:System.Reflection.MemberInfo" /> tramite reflection. Se <c>binder</c> è Null, verrà usato il binder predefinito.</param>
        <param name="args">Argomenti da passare al costruttore. La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo. Per usare il costruttore predefinito, <c>args</c> deve essere una matrice vuota o Null.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>typeName</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nell'assembly specificato. I parametri specificano uno strumento di associazione, i flag di associazione, gli argomenti del costruttore, le informazioni specifiche delle impostazioni cultura usate per interpretare gli argomenti e gli attributi di attivazione facoltativi.</summary>
        <returns>Oggetto che rappresenta un wrapper per la nuova istanza specificata da <paramref name="typeName" />. Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visualizzare <xref:System.Reflection.AssemblyName> per il formato di `assemblyName`.  
  
 Un tentativo di chiamare <xref:System.AppDomain.CreateInstance%2A> una destinazione dominio dell'applicazione che non è il dominio applicazione corrente comporterà un caricamento corretto dell'assembly nel dominio dell'applicazione di destinazione. Poiché un' <xref:System.Reflection.Assembly> non è <xref:System.MarshalByRefObject>, quando questo metodo tenta di restituire il <xref:System.Reflection.Assembly> per l'assembly caricato nel dominio applicazione corrente, common language runtime proverà a caricare l'assembly nel dominio applicazione corrente e il carico potrebbe non riuscire. L'assembly caricato nel dominio applicazione corrente potrebbe essere diverso dall'assembly che è stato caricato prima di tutto se le impostazioni del percorso per i due domini applicazione sono diverse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
 <paramref name="assemblyName" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">Questa istanza è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">la possibilità di leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">la possibilità di richiamare le operazioni su tutti i membri di tipo. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che consente l'associazione, la coercizione dei tipi di argomento, la chiamata dei membri e il recupero di oggetti <see cref="T:System.Reflection.MemberInfo" /> tramite reflection. Se <c>binder</c> è Null, verrà usato il binder predefinito.</param>
        <param name="args">Argomenti da passare al costruttore. La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo. Per usare il costruttore predefinito, <c>args</c> deve essere una matrice vuota o Null.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>typeName</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <param name="securityAttributes">Informazioni usate per autorizzare la creazione di <c>typeName</c>.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nell'assembly specificato. I parametri specificano lo strumento di associazione, i flag di associazione, gli argomenti del costruttore, le informazioni specifiche delle impostazioni cultura usate per interpretare gli argomenti, gli attributi di attivazione e l'autorizzazione per la creazione del tipo.</summary>
        <returns>Oggetto che rappresenta un wrapper per la nuova istanza specificata da <paramref name="typeName" />. Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visualizzare <xref:System.Reflection.AssemblyName> per il formato di `assemblyName`.  
  
 Un tentativo di chiamare <xref:System.AppDomain.CreateInstance%2A> una destinazione dominio dell'applicazione che non è il dominio applicazione corrente comporterà un caricamento corretto dell'assembly nel dominio dell'applicazione di destinazione. Poiché un' <xref:System.Reflection.Assembly> non è <xref:System.MarshalByRefObject>, quando questo metodo tenta di restituire il <xref:System.Reflection.Assembly> per l'assembly caricato nel dominio applicazione corrente, common language runtime proverà a caricare l'assembly nel dominio applicazione corrente e il carico potrebbe non riuscire. L'assembly caricato nel dominio applicazione corrente potrebbe essere diverso dall'assembly che è stato caricato prima di tutto se le impostazioni del percorso per i due domini applicazione sono diverse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.  
  
oppure 
 <paramref name="securityAttributes" /> non è <see langword="null" />. Quando i criteri di protezione dall'accesso di codice legacy non sono abilitati, <paramref name="securityAttributes" /> deve essere <see langword="null." /></exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">Questa istanza è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">la possibilità di leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">la possibilità di richiamare le operazioni su tutti i membri di tipo. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nuova istanza di un tipo specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <summary>Crea una nuova istanza del tipo specificato. I parametri specificano l'assembly in cui è definito il tipo e il nome del tipo.</summary>
        <returns>Istanza dell'oggetto specificato da <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstance%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Questo metodo chiama il costruttore predefinito per `typeName`.  
  
 Visualizzare <xref:System.Reflection.AssemblyName> per il formato di `assemblyName`. Vedere le <xref:System.Type.FullName%2A?displayProperty=nameWithType> proprietà relative al formato degli `typeName`.  
  
> [!NOTE]
>  Se si effettua una chiamata ad associazione anticipata per un metodo `M` di un oggetto di tipo `T1` che è stato restituito da <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, e tale metodo effettua una chiamata ad associazione anticipata di un metodo di un oggetto di tipo `T2` in un assembly `C` oltre il assembly corrente o l'assembly contenente `T1`, assembly `C` viene caricato nel dominio applicazione corrente. Il caricamento viene eseguito anche se l'associazione anticipata chiamata a `T1.M()` è stato effettuato nel corpo di un <xref:System.Reflection.Emit.DynamicMethod>, o in un altro codice generato dinamicamente. Se il dominio corrente è il dominio predefinito, assembly `C` non può essere scaricato finché non termina il processo. Se il dominio corrente in un secondo momento tenta di caricare l'assembly `C`, il carico potrebbe non riuscire.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il modo più semplice per eseguire codice in un altro dominio applicazione. L'esempio definisce una classe denominata `Worker` che eredita da <xref:System.MarshalByRefObject>. Il `Worker` classe definisce un metodo che visualizza il nome del dominio dell'applicazione in cui è in esecuzione. L'esempio crea istanze di `Worker` nel dominio dell'applicazione predefinito in un nuovo dominio applicazione.  
  
> [!NOTE]
>  L'assembly contenente `Worker` devono essere caricati in entrambi i domini applicazione, ma è possibile caricare altri assembly che esiste solo nel nuovo dominio applicazione.  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">la possibilità di leggere il file contenente il manifesto dell'assembly, o se si sta creando un tipo da un modulo diverso dal file manifesto. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea una nuova istanza del tipo specificato. I parametri specificano l'assembly in cui è definito il tipo, il nome del tipo e una matrice di attributi di attivazione.</summary>
        <returns>Istanza dell'oggetto specificato da <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstance%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Questo metodo chiama il costruttore predefinito per `typeName`.  
  
 Visualizzare <xref:System.Reflection.AssemblyName> per il formato di `assemblyName`. Vedere le <xref:System.Type.FullName%2A?displayProperty=nameWithType> proprietà relative al formato degli `typeName`.  
  
> [!NOTE]
>  Se si effettua una chiamata ad associazione anticipata per un metodo `M` di un oggetto di tipo `T1` che è stato restituito da <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, e tale metodo effettua una chiamata ad associazione anticipata di un metodo di un oggetto di tipo `T2` in un assembly `C` oltre il assembly corrente o l'assembly contenente `T1`, assembly `C` viene caricato nel dominio applicazione corrente. Il caricamento viene eseguito anche se l'associazione anticipata chiamata a `T1.M()` è stato effettuato nel corpo di un <xref:System.Reflection.Emit.DynamicMethod>, o in un altro codice generato dinamicamente. Se il dominio corrente è il dominio predefinito, assembly `C` non può essere scaricato finché non termina il processo. Se il dominio corrente in un secondo momento tenta di caricare l'assembly `C`, il carico potrebbe non riuscire.  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">la possibilità di leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">la possibilità di richiamare le operazioni su tutti i membri di tipo. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che consente l'associazione, la coercizione dei tipi di argomento, la chiamata dei membri e il recupero di oggetti <see cref="T:System.Reflection.MemberInfo" /> tramite reflection. Se <c>binder</c> è Null, verrà usato il binder predefinito.</param>
        <param name="args">Argomenti da passare al costruttore. La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo. Per usare il costruttore predefinito, <c>args</c> deve essere una matrice vuota o Null.</param>
        <param name="culture">Oggetto specifico delle impostazioni cultura usato per regolare la coercizione dei tipi. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see langword="CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, corrisponde a una matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />. specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nell'assembly specificato, indicando se ignorare le maiuscole/minuscole del nome del tipo, gli attributi e lo strumento di associazione usati per selezionare il tipo da creare, gli argomenti del costruttore, le impostazioni cultura e gli attributi di attivazione.</summary>
        <returns>Istanza dell'oggetto specificato da <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstance%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Visualizzare <xref:System.Reflection.AssemblyName> per il formato di `assemblyName`. Vedere le <xref:System.Type.FullName%2A?displayProperty=nameWithType> proprietà relative al formato degli `typeName`.  
  
> [!NOTE]
>  Se si effettua una chiamata ad associazione anticipata per un metodo `M` di un oggetto di tipo `T1` che è stato restituito da <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, e tale metodo effettua una chiamata ad associazione anticipata di un metodo di un oggetto di tipo `T2` in un assembly `C` oltre il assembly corrente o l'assembly contenente `T1`, assembly `C` viene caricato nel dominio applicazione corrente. Il caricamento viene eseguito anche se l'associazione anticipata chiamata a `T1.M()` è stato effettuato nel corpo di un <xref:System.Reflection.Emit.DynamicMethod>, o in un altro codice generato dinamicamente. Se il dominio corrente è il dominio predefinito, assembly `C` non può essere scaricato finché non termina il processo. Se il dominio corrente in un secondo momento tenta di caricare l'assembly `C`, il carico potrebbe non riuscire.  
  
   
  
## Examples  
 L'esempio seguente illustra l'uso del `ignoreCase` parametro.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
 <paramref name="assemblyName" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">la possibilità di leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">la possibilità di richiamare le operazioni su tutti i membri di tipo. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che consente l'associazione, la coercizione dei tipi di argomento, la chiamata dei membri e il recupero di oggetti <see cref="T:System.Reflection.MemberInfo" /> tramite reflection. Se <c>binder</c> è Null, verrà usato il binder predefinito.</param>
        <param name="args">Argomenti da passare al costruttore. La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo. Per usare il costruttore predefinito, <c>args</c> deve essere una matrice vuota o Null.</param>
        <param name="culture">Oggetto specifico delle impostazioni cultura usato per regolare la coercizione dei tipi. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see langword="CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <param name="securityAttributes">Informazioni usate per autorizzare la creazione di <c>typeName</c>.</param>
        <summary>Crea una nuova istanza del tipo specificato. I parametri specificano il nome del tipo e le relative modalità di individuazione e creazione.</summary>
        <returns>Istanza dell'oggetto specificato da <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstance%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Visualizzare <xref:System.Reflection.AssemblyName> per il formato di `assemblyName`. Vedere le <xref:System.Type.FullName%2A?displayProperty=nameWithType> proprietà relative al formato degli `typeName`.  
  
> [!NOTE]
>  Se si effettua una chiamata ad associazione anticipata per un metodo `M` di un oggetto di tipo `T1` che è stato restituito da <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, e tale metodo effettua una chiamata ad associazione anticipata di un metodo di un oggetto di tipo `T2` in un assembly `C` oltre il assembly corrente o l'assembly contenente `T1`, assembly `C` viene caricato nel dominio applicazione corrente. Il caricamento viene eseguito anche se l'associazione anticipata chiamata a `T1.M()` è stato effettuato nel corpo di un <xref:System.Reflection.Emit.DynamicMethod>, o in un altro codice generato dinamicamente. Se il dominio corrente è il dominio predefinito, assembly `C` non può essere scaricato finché non termina il processo. Se il dominio corrente in un secondo momento tenta di caricare l'assembly `C`, il carico potrebbe non riuscire.  
  
   
  
## Examples  
 L'esempio seguente illustra l'uso del `ignoreCase` parametro.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">la possibilità di leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">la possibilità di richiamare le operazioni su tutti i membri di tipo. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nuova istanza di un tipo specificato definito nel file di assembly specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome di un file, comprensivo di percorso, contenente un assembly in cui viene definito il tipo richiesto. L'assembly viene caricato utilizzando il metodo <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nel file di assembly specificato.</summary>
        <returns>Wrapper per la nuova istanza oppure <see langword="null" /> se <paramref name="typeName" /> non viene trovato. Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il costruttore predefinito per `typeName` viene richiamato.  
  
 Per altre informazioni, vedere il metodo <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Quando il <xref:System.AppDomain.CreateInstanceFrom%2A> metodo viene usato per creare un'istanza in un dominio di applicazione di destinazione, diverso dal dominio dell'applicazione da cui viene effettuata la chiamata, l'assembly viene caricato nel dominio dell'applicazione di destinazione. Tuttavia, se l'istanza è annullato il wrapping nel dominio dell'applicazione chiamante, usando l'istanza annullato il wrapping in determinati modi può causare l'assembly da caricare nel dominio dell'applicazione chiamante. Ad esempio, dopo che l'istanza è annullato il wrapping, potrebbero essere richieste informazioni relative al tipo, per poter chiamare i metodi con associazione tardiva. Quando l'assembly viene caricato nel dominio dell'applicazione chiamante, le eccezioni possano verificarsi.  
  
-   Se un'altra versione dello stesso assembly in precedenza è stata caricata nel dominio dell'applicazione chiamante o se il percorso di caricamento del dominio dell'applicazione chiamante è diverso da quello del dominio dell'applicazione di destinazione, le eccezioni, ad esempio <xref:System.MissingMethodException> possono verificarsi.  
  
-   Se il dominio dell'applicazione chiamante effettua chiamate ad associazione anticipata per il tipo di istanza <xref:System.InvalidCastException> può essere generata quando viene effettuato un tentativo di eseguire il cast di istanza.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> overload del metodo per creare un'istanza di un oggetto in un dominio di applicazione di destinazione e chiamarne i metodi.  
  
 Nell'esempio viene definito il `MarshallableExample` classe, che può essere sottoposto a marshalling attraverso i limiti del dominio applicazione. L'esempio compila un percorso all'assembly attualmente in esecuzione, crea un dominio di applicazione di destinazione e Usa il <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> overload del metodo per caricare l'assembly di esempio nel dominio dell'applicazione di destinazione e creare un'istanza di `MarshallableExample`.  
  
> [!NOTE]
>  Il percorso è assoluto in questo esempio, ma un percorso relativo funzionerebbe anche perché il <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> metodo viene utilizzato per caricare l'assembly.  
  
 Dopo l'annullamento del wrapping l'handle dell'oggetto, nell'esempio vengono illustrati tre modi per usare un oggetto in un dominio di applicazione di destinazione:  
  
-   Richiama un metodo con associazione tardiva, usando la reflection. Ciò richiede informazioni sul tipo, che fa sì che l'assembly da caricare nel dominio dell'applicazione del chiamante. (In questo esempio, è già caricato.)  
  
-   Il cast dell'oggetto a un'interfaccia definita per il chiamante e chiamato. Se l'interfaccia viene definita nell'assembly chiamante o in un terzo assembly fa riferimento il chiamante e chiamato, l'assembly chiamato non è caricato nel dominio dell'applicazione del chiamante.  
  
-   Utilizzo dell'oggetto direttamente quando il relativo tipo è noto al chiamante. L'assembly deve essere caricato nel dominio dell'applicazione del chiamante.  
  
 È un altro modo per evitare di caricare l'assembly chiamato nel dominio dell'applicazione del chiamante del chiamante da cui derivare il <xref:System.MarshalByRefObject> classe e per definire un metodo che può essere eseguito nel dominio dell'applicazione di destinazione. Tale metodo può usare la reflection per esaminare un assembly di destinazione, perché l'assembly di destinazione è già caricato nel dominio dell'applicazione di destinazione. Vedere l'esempio per il <xref:System.AppDomain.DynamicDirectory%2A> proprietà.  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.  
  
oppure 
 <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyFile" /> non è stato trovato.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typeName" /> in <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico senza parametri.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.NullReferenceException">Questa istanza è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">la possibilità di leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome di un file, comprensivo di percorso, contenente un assembly in cui viene definito il tipo richiesto. L'assembly viene caricato utilizzando il metodo <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nel file di assembly specificato.</summary>
        <returns>Wrapper per la nuova istanza oppure <see langword="null" /> se <paramref name="typeName" /> non viene trovato. Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il costruttore predefinito per `typeName` viene richiamato.  
  
 Per altre informazioni su questo metodo, vedere il <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> (metodo).  
  
 Quando il <xref:System.AppDomain.CreateInstanceFrom%2A> metodo viene usato per creare un'istanza in un dominio di applicazione di destinazione, diverso dal dominio dell'applicazione da cui viene effettuata la chiamata, l'assembly viene caricato nel dominio dell'applicazione di destinazione. Tuttavia, se l'istanza è annullato il wrapping nel dominio dell'applicazione chiamante, usando l'istanza annullato il wrapping in determinati modi può causare l'assembly da caricare nel dominio dell'applicazione chiamante. Ad esempio, dopo che l'istanza è annullato il wrapping, potrebbero essere richieste informazioni relative al tipo, per poter chiamare i metodi con associazione tardiva. Quando l'assembly viene caricato nel dominio dell'applicazione chiamante, le eccezioni possano verificarsi.  
  
-   Se un'altra versione dello stesso assembly in precedenza è stata caricata nel dominio dell'applicazione chiamante o se il percorso di caricamento del dominio dell'applicazione chiamante è diverso da quello del dominio dell'applicazione di destinazione, le eccezioni, ad esempio <xref:System.MissingMethodException> possono verificarsi.  
  
-   Se il dominio dell'applicazione chiamante effettua chiamate ad associazione anticipata per il tipo di istanza <xref:System.InvalidCastException> può essere generata quando viene effettuato un tentativo di eseguire il cast di istanza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyFile" /> non è stato trovato.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typeName" /> in <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.NullReferenceException">Questa istanza è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">la possibilità di leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome di un file, comprensivo di percorso, contenente un assembly in cui viene definito il tipo richiesto. L'assembly viene caricato utilizzando il metodo <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che consente l'associazione, la coercizione di tipi di argomento, la chiamata di membri e il recupero di oggetti <see cref="T:System.Reflection.MemberInfo" /> tramite la reflection. Se <c>binder</c> è Null, verrà usato il binder predefinito.</param>
        <param name="args">Argomenti da passare al costruttore. La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo. Per usare il costruttore predefinito, <c>args</c> deve essere una matrice vuota o Null.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>typeName</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nel file di assembly specificato.</summary>
        <returns>Wrapper per la nuova istanza oppure <see langword="null" /> se <paramref name="typeName" /> non viene trovato. Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per altre informazioni, vedere il metodo <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Quando il <xref:System.AppDomain.CreateInstanceFrom%2A> metodo viene usato per creare un'istanza in un dominio di applicazione di destinazione, diverso dal dominio dell'applicazione da cui viene effettuata la chiamata, l'assembly viene caricato nel dominio dell'applicazione di destinazione. Tuttavia, se l'istanza è annullato il wrapping nel dominio dell'applicazione chiamante, usando l'istanza annullato il wrapping in determinati modi può causare l'assembly da caricare nel dominio dell'applicazione chiamante. Ad esempio, dopo che l'istanza è annullato il wrapping, potrebbero essere richieste informazioni relative al tipo, per poter chiamare i metodi con associazione tardiva. Quando l'assembly viene caricato nel dominio dell'applicazione chiamante, le eccezioni possano verificarsi.  
  
-   Se un'altra versione dello stesso assembly in precedenza è stata caricata nel dominio dell'applicazione chiamante o se il percorso di caricamento del dominio dell'applicazione chiamante è diverso da quello del dominio dell'applicazione di destinazione, le eccezioni, ad esempio <xref:System.MissingMethodException> possono verificarsi.  
  
-   Se il dominio dell'applicazione chiamante effettua chiamate ad associazione anticipata per il tipo di istanza <xref:System.InvalidCastException> può essere generata quando viene effettuato un tentativo di eseguire il cast di istanza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.  
  
oppure 
 <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyFile" /> non è stato trovato.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typeName" /> in <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
oppure 
 <paramref name="assemblyFile" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.NullReferenceException">Questa istanza è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">la possibilità di leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome di un file, comprensivo di percorso, contenente un assembly in cui viene definito il tipo richiesto. L'assembly viene caricato utilizzando il metodo <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che consente l'associazione, la coercizione di tipi di argomento, la chiamata di membri e il recupero di oggetti <see cref="T:System.Reflection.MemberInfo" /> tramite la reflection. Se <c>binder</c> è Null, verrà usato il binder predefinito.</param>
        <param name="args">Argomenti da passare al costruttore. La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo. Per usare il costruttore predefinito, <c>args</c> deve essere una matrice vuota o Null.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>typeName</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <param name="securityAttributes">Informazioni usate per autorizzare la creazione di <c>typeName</c>.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nel file di assembly specificato.</summary>
        <returns>Wrapper per la nuova istanza oppure <see langword="null" /> se <paramref name="typeName" /> non viene trovato. Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per altre informazioni su questo metodo, vedere il <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> (metodo).  
  
 Quando il <xref:System.AppDomain.CreateInstanceFrom%2A> metodo viene usato per creare un'istanza in un dominio di applicazione di destinazione, diverso dal dominio dell'applicazione da cui viene effettuata la chiamata, l'assembly viene caricato nel dominio dell'applicazione di destinazione. Tuttavia, se l'istanza è annullato il wrapping nel dominio dell'applicazione chiamante, usando l'istanza annullato il wrapping in determinati modi può causare l'assembly da caricare nel dominio dell'applicazione chiamante. Ad esempio, dopo che l'istanza è annullato il wrapping, potrebbero essere richieste informazioni relative al tipo, per poter chiamare i metodi con associazione tardiva. Quando l'assembly viene caricato nel dominio dell'applicazione chiamante, le eccezioni possano verificarsi.  
  
-   Se un'altra versione dello stesso assembly in precedenza è stata caricata nel dominio dell'applicazione chiamante o se il percorso di caricamento del dominio dell'applicazione chiamante è diverso da quello del dominio dell'applicazione di destinazione, le eccezioni, ad esempio <xref:System.MissingMethodException> possono verificarsi.  
  
-   Se il dominio dell'applicazione chiamante effettua chiamate ad associazione anticipata per il tipo di istanza <xref:System.InvalidCastException> può essere generata quando viene effettuato un tentativo di eseguire il cast di istanza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.  
  
oppure 
 <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.  
  
oppure 
 <paramref name="securityAttributes" /> non è <see langword="null" />. Quando i criteri di sicurezza dall'accesso di codice legacy non sono abilitati, <paramref name="securityAttributes" /> deve essere <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyFile" /> non è stato trovato.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typeName" /> in <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.NullReferenceException">Questa istanza è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">la possibilità di leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nuova istanza di un tipo specificato definito nel file di assembly specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome e percorso del file dell'assembly in cui viene definito il tipo richiesto.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nel file di assembly specificato.</summary>
        <returns>Oggetto richiesto o <see langword="null" /> se <paramref name="typeName" /> non è stato trovato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Questo metodo chiama il costruttore predefinito per `typeName`.  
  
 Per altre informazioni, vedere il metodo <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> è <see langword="null" />.  
  
oppure 
 <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typeName" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico senza parametri.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">la possibilità di leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome e percorso del file dell'assembly in cui viene definito il tipo richiesto.</param>
        <param name="typeName">Nome completo del tipo richiesto, incluso lo spazio dei nomi ma non l'assembly (vedere la proprietà <see cref="P:System.Type.FullName" />).</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nel file di assembly specificato.</summary>
        <returns>Oggetto richiesto o <see langword="null" /> se <paramref name="typeName" /> non è stato trovato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Questo metodo chiama il costruttore predefinito per `typeName`.  
  
 Per altre informazioni su questo metodo, vedere il <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> è <see langword="null" />.  
  
oppure 
 <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typeName" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico senza parametri.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">la possibilità di leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome e percorso del file dell'assembly in cui viene definito il tipo richiesto.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che consente l'associazione, la coercizione di tipi di argomento, la chiamata di membri e il recupero di oggetti <see cref="T:System.Reflection.MemberInfo" /> tramite la reflection. Se <c>binder</c> è Null, verrà usato il binder predefinito.</param>
        <param name="args">Argomenti da passare al costruttore. La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo. Per usare il costruttore predefinito, <c>args</c> deve essere una matrice vuota o Null.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>typeName</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nel file di assembly specificato, indicando se ignorare le maiuscole/minuscole del nome del tipo, gli attributi e lo strumento di associazione usati per selezionare il tipo da creare, gli argomenti del costruttore, le impostazioni cultura e gli attributi di attivazione.</summary>
        <returns>Oggetto richiesto o <see langword="null" /> se <paramref name="typeName" /> non è stato trovato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Per altre informazioni su questo metodo, vedere il <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> è <see langword="null" />.  
  
oppure 
 <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typeName" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
 <paramref name="assemblyName" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">la possibilità di leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFromAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome e percorso del file dell'assembly in cui viene definito il tipo richiesto.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che consente l'associazione, la coercizione di tipi di argomento, la chiamata di membri e il recupero di oggetti <see cref="T:System.Reflection.MemberInfo" /> tramite la reflection. Se <c>binder</c> è Null, verrà usato il binder predefinito.</param>
        <param name="args">Argomenti da passare al costruttore. La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo. Per usare il costruttore predefinito, <c>args</c> deve essere una matrice vuota o Null.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>typeName</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <param name="securityAttributes">Informazioni usate per autorizzare la creazione di <c>typeName</c>.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nel file di assembly specificato.</summary>
        <returns>Oggetto richiesto o <see langword="null" /> se <paramref name="typeName" /> non è stato trovato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Per altre informazioni su questo metodo, vedere il <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> è <see langword="null" />.  
  
oppure 
 <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile trovare <paramref name="typeName" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">la possibilità di leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDomain : AppDomain" Usage="System.AppDomain.CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il dominio applicazione corrente per l'oggetto <see cref="T:System.Threading.Thread" /> corrente.</summary>
        <value>Dominio applicazione corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio di codice riportato di seguito viene creato un nuovo dominio dell'applicazione. La proprietà <xref:System.AppDomain.CurrentDomain%2A> viene utilizzata per ottenere un oggetto <xref:System.AppDomain> che rappresenta il dominio dell'applicazione corrente. Il <xref:System.AppDomain.FriendlyName%2A> proprietà fornisce il nome del dominio applicazione corrente, che viene quindi visualizzato nella riga di comando.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definisce un assembly dinamico nel dominio applicazione corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità di accesso per l'assembly dinamico.</param>
        <summary>Definisce un assembly dinamico con nome e modalità di accesso specificati.</summary>
        <returns>Assembly dinamico con il nome e la modalità di accesso specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio dell'applicazione corrente. Per altre informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
> [!NOTE]
>  Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile usare un overload del <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo che specifica l'evidenza e le autorizzazioni, fornire l'evidenza che l'assembly dinamico e che includono <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> nella `refusedPermissions` parametro assicura che il codice MSIL viene verificato. Una limitazione di questa tecnica è che anche una classe <xref:System.Security.SecurityException> venga generata quando usato con il codice che richiede l'attendibilità.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo e <xref:System.AppDomain.AssemblyResolve> evento.  
  
 Per questo esempio di codice per l'esecuzione, è necessario specificare il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
oppure 
La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità di accesso per l'assembly dinamico.</param>
        <param name="assemblyAttributes">Elenco enumerabile di attributi da applicare all'assembly oppure <see langword="null" /> se non sono presenti attributi.</param>
        <summary>Definisce un assembly dinamico con il nome, la modalità di accesso e gli attributi personalizzati specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload del metodo per specificare gli attributi che non funzionano correttamente a meno che non vengono applicate quando viene creato un assembly dinamico. Ad esempio, attributi di sicurezza, ad esempio <xref:System.Security.SecurityTransparentAttribute> e <xref:System.Security.SecurityCriticalAttribute> non funzionano correttamente se vengono aggiunti dopo aver creato un assembly dinamico.  
  
 Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio dell'applicazione corrente. Per altre informazioni su questa restrizione, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
 Questo overload del metodo è stato introdotto nel [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come creare un assembly dinamico che contiene il <xref:System.Security.SecurityTransparentAttribute>. L'attributo deve essere specificato come elemento di una matrice di <xref:System.Reflection.Emit.CustomAttributeBuilder> oggetti.  
  
 Il primo passaggio nella creazione di <xref:System.Reflection.Emit.CustomAttributeBuilder> consiste nell'ottenere un costruttore dell'attributo. Il costruttore non ha parametri, in modo che il <xref:System.Type.GetConstructor%2A> metodo viene chiamato con una matrice vuota di <xref:System.Type> oggetti per rappresentare i tipi dei parametri. Il secondo passaggio consiste nel passare l'oggetto risultante <xref:System.Reflection.ConstructorInfo> oggetto al costruttore per il <xref:System.Reflection.Emit.CustomAttributeBuilder> (classe), insieme a una matrice vuota di tipo <xref:System.Object> per rappresentare gli argomenti.  
  
 L'oggetto risultante <xref:System.Reflection.Emit.CustomAttributeBuilder> viene quindi passato al <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo come l'unico elemento di matrice.  
  
 Il codice di esempio definisce un modulo e un tipo nell'assembly dinamici nuovi e quindi Visualizza gli attributi dell'assembly.  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
oppure 
La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto oppure contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità mediante cui si accederà all'assembly dinamico.</param>
        <param name="evidence">Evidenza fornita per l'assembly dinamico. L'evidenza viene usata senza modifiche come il set di evidenza finale impiegato per la risoluzione dei criteri.</param>
        <summary>Definisce un assembly dinamico tramite il nome, la modalità di accesso e l'evidenza specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo è considerato completamente attendibile i chiamanti possono fornire loro `evidence` quando si definisce una dinamica <xref:System.Reflection.Assembly>. Il runtime eseguirà il mapping di <xref:System.Security.Policy.Evidence> tramite i criteri di sicurezza per determinare le autorizzazioni concesse. Chiamanti parzialmente attendibili devono fornire un valore null `evidence`. Se `evidence` viene `null`, il runtime consente di copiare il set di autorizzazioni, vale a dire, cui corrente autorizzazioni concesse e negate, del chiamante <xref:System.Reflection.Assembly> il dinamico <xref:System.Reflection.Assembly> definito e contrassegna i criteri come risolto.  
  
 Se dinamica <xref:System.Reflection.Assembly> viene salvato su disco, caricamenti successivi verranno concesse autorizzazioni in base ai criteri associati al percorso in cui il <xref:System.Reflection.Assembly> è stato salvato.  
  
 Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio dell'applicazione corrente. Per altre informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
> [!NOTE]
>  Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile usare un overload del <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo che specifica l'evidenza e le autorizzazioni, fornire l'evidenza che l'assembly dinamico e che includono <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> nella `refusedPermissions` parametro assicura che il codice MSIL viene verificato. Una limitazione di questa tecnica è che anche una classe <xref:System.Security.SecurityException> venga generata quando usato con il codice che richiede l'attendibilità.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo e <xref:System.AppDomain.AssemblyResolve> evento.  
  
 L'esempio di codice prima di tutto, tenta di creare un'istanza di `MyDynamicType` chiamando il <xref:System.AppDomain.CreateInstance%2A> metodo con un nome di assembly non valido e rileva l'eccezione risulta.  
  
 L'esempio di codice aggiunge quindi un gestore eventi per il <xref:System.AppDomain.AssemblyResolve> evento e si tenta nuovamente di creare un'istanza di`MyDynamicType`. Durante la chiamata a <xref:System.AppDomain.CreateInstance%2A>, il <xref:System.AppDomain.AssemblyResolve> evento viene generato per l'assembly non valido. Il gestore eventi crea un assembly dinamico che contiene un tipo denominato `MyDynamicType`, restituisce il tipo di un costruttore senza parametri e restituisce il nuovo assembly dinamico. La chiamata a <xref:System.AppDomain.CreateInstance%2A> quindi viene completata correttamente e il costruttore per `MyDynamicType` Visualizza un messaggio nella console.  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
oppure 
La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità mediante cui si accederà all'assembly dinamico.</param>
        <param name="dir">Nome della directory nella quale verrà salvato l'assembly. Se <c>dir</c> è <see langword="null" />, la directory predefinita sarà la directory corrente.</param>
        <summary>Definisce un assembly dinamico usando il nome, la modalità di accesso e la directory di archiviazione specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio dell'applicazione corrente. Per altre informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
> [!NOTE]
>  Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile usare un overload del <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo che specifica l'evidenza e le autorizzazioni, fornire l'evidenza che l'assembly dinamico e che includono <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> nella `refusedPermissions` parametro assicura che il codice MSIL viene verificato. Una limitazione di questa tecnica è che anche una classe <xref:System.Security.SecurityException> venga generata quando usato con il codice che richiede l'attendibilità.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo e <xref:System.AppDomain.AssemblyResolve> evento.  
  
 Per questo esempio di codice per l'esecuzione, è necessario specificare il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
oppure 
La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; * System.Security.SecurityContextSource -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità di accesso per l'assembly dinamico.</param>
        <param name="assemblyAttributes">Elenco enumerabile di attributi da applicare all'assembly oppure <see langword="null" /> se non sono presenti attributi.</param>
        <param name="securityContextSource">Origine del contesto di sicurezza.</param>
        <summary>Definisce un assembly dinamico con il nome, la modalità di accesso e gli attributi personalizzati specificati e usando il database di origine specificato per il contesto di sicurezza.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload del metodo per specificare gli attributi che non funzionano correttamente a meno che non vengono applicate quando viene creato un assembly dinamico. Ad esempio, attributi di sicurezza, ad esempio <xref:System.Security.SecurityTransparentAttribute> e <xref:System.Security.SecurityCriticalAttribute> non funzionano correttamente se vengono aggiunti dopo aver creato un assembly dinamico.  
  
 Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio dell'applicazione corrente. Per altre informazioni su questa restrizione, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
oppure 
La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto oppure contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="securityContextSource" /> non è uno dei valori di enumerazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of DefineDynamicAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità mediante cui si accederà all'assembly dinamico.</param>
        <param name="dir">Nome della directory nella quale verrà salvato l'assembly. Se <c>dir</c> è <see langword="null" />, la directory predefinita sarà la directory corrente.</param>
        <param name="evidence">Evidenza fornita per l'assembly dinamico. L'evidenza viene usata senza modifiche come il set di evidenza finale impiegato per la risoluzione dei criteri.</param>
        <summary>Definisce un assembly dinamico mediante il nome, la modalità di accesso, la directory di archiviazione e l'evidenza specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo è considerato completamente attendibile i chiamanti possono fornire loro `evidence` quando si definisce una dinamica <xref:System.Reflection.Assembly>. Il runtime eseguirà il mapping di <xref:System.Security.Policy.Evidence> tramite i criteri di sicurezza per determinare le autorizzazioni concesse. Chiamanti parzialmente attendibili devono fornire un valore null `evidence`. Se `evidence` viene `null`, il runtime consente di copiare il set di autorizzazioni, vale a dire, cui corrente autorizzazioni concesse e negate, del chiamante <xref:System.Reflection.Assembly> il dinamico <xref:System.Reflection.Assembly> definito e contrassegna i criteri come risolto.  
  
 Se dinamica <xref:System.Reflection.Assembly> viene salvato su disco, caricamenti successivi verranno concesse autorizzazioni in base ai criteri associati al percorso in cui il <xref:System.Reflection.Assembly> è stato salvato.  
  
 Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio dell'applicazione corrente. Per altre informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
> [!NOTE]
>  Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile usare un overload del <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo che specifica l'evidenza e le autorizzazioni, fornire l'evidenza che l'assembly dinamico e che includono <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> nella `refusedPermissions` parametro assicura che il codice MSIL viene verificato. Una limitazione di questa tecnica è che anche una classe <xref:System.Security.SecurityException> venga generata quando usato con il codice che richiede l'attendibilità.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo e <xref:System.AppDomain.AssemblyResolve> evento.  
  
 Per questo esempio di codice per l'esecuzione, è necessario specificare il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
oppure 
La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità mediante cui si accederà all'assembly dinamico.</param>
        <param name="requiredPermissions">Richiesta di autorizzazioni obbligatoria.</param>
        <param name="optionalPermissions">Richiesta di autorizzazioni facoltativa.</param>
        <param name="refusedPermissions">Richiesta di autorizzazioni rifiutata.</param>
        <summary>Definisce un assembly dinamico usando il nome, la modalità di accesso e le richieste di autorizzazione specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le richieste di autorizzazione specificate per `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` non vengono usate, a meno che l'assembly dinamico è stato salvato e ricaricato in memoria. Per specificare le richieste di autorizzazione per un assembly temporaneo che non viene mai salvato su disco, usare un overload del <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo che specifica l'evidenza autorizzazioni anche come richiesto e si fornisce un <xref:System.Security.Policy.Evidence> oggetto.  
  
> [!NOTE]
>  Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile usare un overload del <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo che specifica l'evidenza e le autorizzazioni, fornire l'evidenza che l'assembly dinamico e che includono <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> nella `refusedPermissions` parametro assicura che il codice MSIL viene verificato. Una limitazione di questa tecnica è che anche una classe <xref:System.Security.SecurityException> venga generata quando usato con il codice che richiede l'attendibilità.  
  
 Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio dell'applicazione corrente. Per altre informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo e <xref:System.AppDomain.AssemblyResolve> evento.  
  
 Per questo esempio di codice per l'esecuzione, è necessario specificare il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
oppure 
La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità mediante cui si accederà all'assembly dinamico.</param>
        <param name="dir">Nome della directory nella quale verrà salvato l'assembly dinamico. Se <c>dir</c> è <see langword="null" />, viene usata la directory corrente.</param>
        <param name="isSynchronized">
          <see langword="true" /> per sincronizzare la creazione di moduli, tipi e membri nell'assembly dinamico; in caso contrario, <see langword="false" />.</param>
        <param name="assemblyAttributes">Elenco enumerabile di attributi da applicare all'assembly oppure <see langword="null" /> se non sono presenti attributi.</param>
        <summary>Definisce un assembly dinamico usando il nome, la modalità di accesso, la directory di archiviazione e l'opzione di sincronizzazione specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload del metodo per specificare gli attributi che non funzionano correttamente a meno che non vengono applicate quando viene creato un assembly dinamico. Ad esempio, attributi di sicurezza, ad esempio <xref:System.Security.SecurityTransparentAttribute> e <xref:System.Security.SecurityCriticalAttribute> non funzionano correttamente se vengono aggiunti dopo aver creato un assembly dinamico.  
  
 Se `isSynchronized` viene `true`, i metodi seguenti della risultante <xref:System.Reflection.Emit.AssemblyBuilder> verranno sincronizzati: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, e <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Se due di questi metodi vengono chiamati su thread diversi, uno si bloccherà fino al completamento di altro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
oppure 
La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto oppure contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità mediante cui si accederà all'assembly dinamico.</param>
        <param name="evidence">Evidenza fornita per l'assembly dinamico. L'evidenza viene usata senza modifiche come il set di evidenza finale impiegato per la risoluzione dei criteri.</param>
        <param name="requiredPermissions">Richiesta di autorizzazioni obbligatoria.</param>
        <param name="optionalPermissions">Richiesta di autorizzazioni facoltativa.</param>
        <param name="refusedPermissions">Richiesta di autorizzazioni rifiutata.</param>
        <summary>Definisce un assembly dinamico usando il nome, la modalità di accesso, l'evidenza e le richieste di autorizzazione specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le richieste di autorizzazione specificate per `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` vengono usati solo se `evidence` viene inoltre fornita, oppure se l'assembly dinamico viene salvato e ricaricato in memoria.  
  
> [!NOTE]
>  Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile includere <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> nella `refusedPermissions` parametro assicura che il codice MSIL viene verificato. Una limitazione di questa tecnica è che anche una classe <xref:System.Security.SecurityException> venga generata quando usato con il codice che richiede l'attendibilità.  
  
 Solo è considerato completamente attendibile i chiamanti possono fornire loro `evidence` quando si definisce una dinamica <xref:System.Reflection.Assembly>. Il runtime eseguirà il mapping di <xref:System.Security.Policy.Evidence> tramite i criteri di sicurezza per determinare le autorizzazioni concesse. Chiamanti parzialmente attendibili devono fornire un valore null `evidence`. Se `evidence` viene `null`, il runtime consente di copiare il set di autorizzazioni, vale a dire, cui corrente autorizzazioni concesse e negate, del chiamante <xref:System.Reflection.Assembly> il dinamico <xref:System.Reflection.Assembly> definito e contrassegna i criteri come risolto.  
  
 Se dinamica <xref:System.Reflection.Assembly> viene salvato su disco, caricamenti successivi verranno concesse autorizzazioni in base ai criteri associati al percorso in cui il <xref:System.Reflection.Assembly> è stato salvato.  
  
 Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio dell'applicazione corrente. Per altre informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo e <xref:System.AppDomain.AssemblyResolve> evento.  
  
 Per questo esempio di codice per l'esecuzione, è necessario specificare il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
oppure 
La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità mediante cui si accederà all'assembly dinamico.</param>
        <param name="dir">Nome della directory nella quale verrà salvato l'assembly. Se <c>dir</c> è <see langword="null" />, la directory predefinita sarà la directory corrente.</param>
        <param name="requiredPermissions">Richiesta di autorizzazioni obbligatoria.</param>
        <param name="optionalPermissions">Richiesta di autorizzazioni facoltativa.</param>
        <param name="refusedPermissions">Richiesta di autorizzazioni rifiutata.</param>
        <summary>Definisce un assembly dinamico usando il nome, la modalità di accesso, la directory di archiviazione e le richieste di autorizzazione specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le richieste di autorizzazione specificate per `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` non vengono usate, a meno che l'assembly dinamico è stato salvato e ricaricato in memoria. Per specificare le richieste di autorizzazione per un assembly temporaneo che non viene mai salvato su disco, usare un overload del <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo che specifica l'evidenza autorizzazioni anche come richiesto e si fornisce un <xref:System.Security.Policy.Evidence> oggetto.  
  
> [!NOTE]
>  Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile usare un overload del <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo che specifica l'evidenza e le autorizzazioni, fornire l'evidenza che l'assembly dinamico e che includono <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> nella `refusedPermissions` parametro assicura che il codice MSIL viene verificato. Una limitazione di questa tecnica è che anche una classe <xref:System.Security.SecurityException> venga generata quando usato con il codice che richiede l'attendibilità.  
  
 Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio dell'applicazione corrente. Per altre informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo e <xref:System.AppDomain.AssemblyResolve> evento.  
  
 Per questo esempio di codice per l'esecuzione, è necessario specificare il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
oppure 
La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  Please see http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità mediante cui si accederà all'assembly dinamico.</param>
        <param name="dir">Nome della directory nella quale verrà salvato l'assembly. Se <c>dir</c> è <see langword="null" />, la directory predefinita sarà la directory corrente.</param>
        <param name="evidence">Evidenza fornita per l'assembly dinamico. L'evidenza viene usata senza modifiche come il set di evidenza finale impiegato per la risoluzione dei criteri.</param>
        <param name="requiredPermissions">Richiesta di autorizzazioni obbligatoria.</param>
        <param name="optionalPermissions">Richiesta di autorizzazioni facoltativa.</param>
        <param name="refusedPermissions">Richiesta di autorizzazioni rifiutata.</param>
        <summary>Definisce un assembly dinamico usando il nome, la modalità di accesso, la directory di archiviazione, l'evidenza e le richieste di autorizzazione specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le richieste di autorizzazione specificate per `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` vengono usati solo se `evidence` viene inoltre fornita, oppure se l'assembly dinamico viene salvato e ricaricato in memoria.  
  
> [!NOTE]
>  Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile includere <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> nella `refusedPermissions` parametro assicura che il codice MSIL viene verificato. Una limitazione di questa tecnica è che anche una classe <xref:System.Security.SecurityException> venga generata quando usato con il codice che richiede l'attendibilità.  
  
 Solo è considerato completamente attendibile i chiamanti possono fornire loro `evidence` quando si definisce una dinamica <xref:System.Reflection.Assembly>. Il runtime eseguirà il mapping di <xref:System.Security.Policy.Evidence> tramite i criteri di sicurezza per determinare le autorizzazioni concesse. Chiamanti parzialmente attendibili devono fornire un valore null `evidence`. Se `evidence` viene `null`, il runtime consente di copiare il set di autorizzazioni, vale a dire, cui corrente autorizzazioni concesse e negate, del chiamante <xref:System.Reflection.Assembly> il dinamico <xref:System.Reflection.Assembly> definito e contrassegna i criteri come risolto.  
  
 Se dinamica <xref:System.Reflection.Assembly> viene salvato su disco, caricamenti successivi verranno concesse autorizzazioni in base ai criteri associati al percorso in cui il <xref:System.Reflection.Assembly> è stato salvato.  
  
 Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio dell'applicazione corrente. Per altre informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo e <xref:System.AppDomain.AssemblyResolve> evento.  
  
 Per questo esempio di codice per l'esecuzione, è necessario specificare il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
oppure 
La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità mediante cui si accederà all'assembly dinamico.</param>
        <param name="dir">Nome della directory nella quale verrà salvato l'assembly dinamico. Se <c>dir</c> è <see langword="null" />, la directory predefinita sarà la directory corrente.</param>
        <param name="evidence">Evidenza fornita per l'assembly dinamico. L'evidenza viene usata senza modifiche come il set di evidenza finale impiegato per la risoluzione dei criteri.</param>
        <param name="requiredPermissions">Richiesta di autorizzazioni obbligatoria.</param>
        <param name="optionalPermissions">Richiesta di autorizzazioni facoltativa.</param>
        <param name="refusedPermissions">Richiesta di autorizzazioni rifiutata.</param>
        <param name="isSynchronized">
          <see langword="true" /> per sincronizzare la creazione di moduli, tipi e membri nell'assembly dinamico; in caso contrario, <see langword="false" />.</param>
        <summary>Definisce un assembly dinamico usando il nome, la modalità di accesso, la directory di archiviazione, l'evidenza, le richieste di autorizzazione e l'opzione di sincronizzazione specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le richieste di autorizzazione specificate per `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` vengono usati solo se `evidence` viene inoltre fornita, oppure se l'assembly dinamico viene salvato e ricaricato in memoria.  
  
> [!NOTE]
>  Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile includere <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> nella `refusedPermissions` parametro assicura che il codice MSIL viene verificato. Una limitazione di questa tecnica è che anche una classe <xref:System.Security.SecurityException> venga generata quando usato con il codice che richiede l'attendibilità.  
  
 Solo i chiamanti completamente attendibili possono fornire la propria evidence quando si definisce una dinamica <xref:System.Reflection.Assembly>. Il runtime eseguirà il mapping di <xref:System.Security.Policy.Evidence> tramite i criteri di sicurezza per determinare le autorizzazioni concesse. Chiamanti parzialmente attendibili devono fornire `null` per il `evidence` parametro. Se `evidence` viene `null`, il runtime consente di copiare il set di autorizzazioni, vale a dire, cui corrente autorizzazioni concesse e negate, del chiamante <xref:System.Reflection.Assembly> il dinamico <xref:System.Reflection.Assembly> definito e contrassegna i criteri come risolto.  
  
 Se dinamica <xref:System.Reflection.Assembly> viene salvato su disco, caricamenti successivi verranno concesse autorizzazioni in base ai criteri associati al percorso in cui il <xref:System.Reflection.Assembly> è stato salvato.  
  
 Se `isSynchronized` viene `true`, i metodi seguenti della risultante <xref:System.Reflection.Emit.AssemblyBuilder> verranno sincronizzati: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, e <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Se due di questi metodi vengono chiamati su thread diversi, uno si bloccherà fino a quando il loro completamento.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo e <xref:System.AppDomain.AssemblyResolve> evento.  
  
 Per questo esempio di codice per l'esecuzione, è necessario specificare il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
oppure 
La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità mediante cui si accederà all'assembly dinamico.</param>
        <param name="dir">Nome della directory nella quale verrà salvato l'assembly dinamico. Se <c>dir</c> è <see langword="null" />, viene usata la directory corrente.</param>
        <param name="evidence">Evidenza fornita per l'assembly dinamico. L'evidenza viene usata senza modifiche come il set di evidenza finale impiegato per la risoluzione dei criteri.</param>
        <param name="requiredPermissions">Richiesta di autorizzazioni obbligatoria.</param>
        <param name="optionalPermissions">Richiesta di autorizzazioni facoltativa.</param>
        <param name="refusedPermissions">Richiesta di autorizzazioni rifiutata.</param>
        <param name="isSynchronized">
          <see langword="true" /> per sincronizzare la creazione di moduli, tipi e membri nell'assembly dinamico; in caso contrario, <see langword="false" />.</param>
        <param name="assemblyAttributes">Elenco enumerabile di attributi da applicare all'assembly oppure <see langword="null" /> se non sono presenti attributi.</param>
        <summary>Definisce un assembly dinamico con il nome, la modalità di accesso, la directory di archiviazione, l'evidenza, le richieste di autorizzazione, l'opzione di sincronizzazione e gli attributi personalizzati specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload del metodo per specificare gli attributi che non funzionano correttamente a meno che non vengono applicate quando viene creato un assembly dinamico. Ad esempio, attributi di sicurezza, ad esempio <xref:System.Security.SecurityTransparentAttribute> e <xref:System.Security.SecurityCriticalAttribute> non funzionano correttamente se vengono aggiunti dopo aver creato un assembly dinamico.  
  
 Le richieste di autorizzazione specificate per il `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` i parametri vengono usati solo se il `evidence` viene fornito anche parametro, o se l'assembly dinamico viene salvato e ricaricato in memoria.  
  
> [!NOTE]
>  Quando si sviluppa codice che genera gli assembly dinamici, si consiglia di includere il <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> flag nel `refusedPermissions` parametro. L'inclusione di questo flag assicura che il Microsoft intermediate language (MSIL) verrà verificate. Questa tecnica rileverà la generazione di codice non verificabile, che in caso contrario, è molto difficile da rilevare non intenzionale. Una limitazione di questa tecnica è che anche una classe <xref:System.Security.SecurityException> venga generata quando viene usato con il codice che richiede l'attendibilità.  
  
 Solo i chiamanti completamente attendibili possono fornire l'evidenza quando si definisce una dinamica <xref:System.Reflection.Assembly>. Il runtime esegue il mapping di <xref:System.Security.Policy.Evidence> tramite i criteri di sicurezza per determinare le autorizzazioni concesse. Chiamanti parzialmente attendibili devono fornire `null` per il `evidence` parametro. Se `evidence` è `null`, il runtime consente di copiare i set di autorizzazioni (ovvero, il correnti concesse e negate) dall'assembly del chiamante per l'assembly dinamico che viene definito e contrassegna i criteri come risolto.  
  
 Se l'assembly dinamico viene salvato su disco, successivi caricamenti verranno concesse autorizzazioni in base ai criteri che sono associati al percorso in cui è stato salvato l'assembly dinamico.  
  
 Se `isSynchronized` viene `true`, i metodi seguenti della risultante <xref:System.Reflection.Emit.AssemblyBuilder> verranno sincronizzati: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, e <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Se due di questi metodi vengono chiamati su thread diversi, uno si bloccherà fino al completamento di altro.  
  
 Questo overload del metodo è stato introdotto nel [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
oppure 
La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto oppure contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberSignature Language="F#" Value="abstract member DoCallBack : CrossAppDomainDelegate -&gt; unit&#xA;override this.DoCallBack : CrossAppDomainDelegate -&gt; unit" Usage="appDomain.DoCallBack callBackDelegate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate">Delegato con cui viene specificato un metodo da chiamare.</param>
        <summary>Esegue il codice in un altro dominio applicazione, identificato dal delegato specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `callBackDelegate` può specificare un marshalling per valore, <xref:System.MarshalByRefObject>, o <xref:System.ContextBoundObject>.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato come utilizzare un valore statico <xref:System.AppDomain.DoCallBack%2A> (metodo).  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 L'esempio seguente viene illustrato l'utilizzo di <xref:System.AppDomain.DoCallBack%2A> metodo tramite valore.  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 L'esempio seguente viene illustrato l'utilizzo di <xref:System.AppDomain.DoCallBack%2A> metodo per riferimento.  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBackDelegate" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainManager : AppDomainManager" Usage="System.AppDomain.DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il gestore di dominio fornito dall'host al momento dell'inizializzazione del dominio applicazione.</summary>
        <value>Oggetto che rappresenta il gestore di dominio fornito dall'host quando è stato inizializzato il dominio dell'applicazione o <see langword="null" /> se non è stato fornito alcun gestore di dominio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un host non gestito di common language runtime (CLR) può fornire un gestore di dominio. Il gestore di dominio possa partecipare all'inizializzazione del nuovo dominio applicazione e fornire altri gestori, ad esempio un <xref:System.Security.HostSecurityManager>, che partecipano alle operazioni del dominio dell'applicazione.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberSignature Language="F#" Value="member this.DomainUnload : EventHandler " Usage="member this.DomainUnload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un oggetto <see cref="T:System.AppDomain" /> sta per essere scaricato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.EventHandler> delegato per questo evento è possibile eseguire qualsiasi attività di chiusura prima che venga scaricato il dominio dell'applicazione.  
  
 Ogni dominio dell'applicazione che deve eseguire l'elaborazione quando viene scaricato deve registrare un gestore eventi per questo evento. Un gestore eventi condivisi non deve essere usato, in quanto il <xref:System.EventHandler> delegato non identifica il dominio che sta per essere scaricato.  
  
> [!NOTE]
>  Questo evento non viene mai generato nel dominio applicazione predefinito.  
  
 Non dare per scontati del thread che su cui viene generato l'evento. L'evento può essere generato in un thread diverso da quello che chiamava il <xref:System.AppDomain.Unload%2A> (metodo).  
  
 Per ulteriori informazioni sulla gestione degli eventi, consultare [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicDirectory : string" Usage="System.AppDomain.DynamicDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la directory usata dal resolver dell'assembly per verificare la presenza di assembly creati dinamicamente.</summary>
        <value>Directory usata dal resolver dell'assembly per verificare la presenza di assembly creati dinamicamente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostare la directory dinamica, assegnare un percorso di directory di base per il <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> proprietà del <xref:System.AppDomainSetup> oggetto che verrà utilizzato per creare il nuovo dominio applicazione. Il percorso della directory base assegnare alla proprietà viene modificato mediante l'aggiunta di una sottodirectory il cui nome semplice è il codice hash della stringa è assegnare al <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> proprietà, in modo che il formato della directory base è *percorso originale* \\ *il codice hash*. La directory dinamica è una sottodirectory della directory di base. Il nome semplice è il valore della <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> proprietà, in modo che il formato è *percorso originale*\\*codice hash*\\*nome applicazione*.  
  
   
  
## Examples  
 Nell'esempio seguente crea un dominio dell'applicazione con una directory per gli assembly dinamici, genera un assembly dinamico e lo archivia nella directory dinamica e quindi carica l'assembly nel nuovo dominio applicazione e lo usa.  
  
 Nell'esempio viene creato un <xref:System.AppDomainSetup> oggetto e imposta relativi <xref:System.AppDomainSetup.ApplicationName%2A> proprietà su "Example" e il relativo <xref:System.AppDomainSetup.DynamicBase%2A> proprietà su "C:\DynamicAssemblyDir". Nell'esempio viene quindi visualizzato il <xref:System.AppDomainSetup.DynamicBase%2A> proprietà, per mostrare che il codice hash del nome dell'applicazione è stato aggiunto come una sottodirectory del percorso a cui è stato originariamente assegnato.  
  
> [!NOTE]
>  La directory di base in questo esempio deve essere all'esterno del percorso probe per l'applicazione di esempio. Assicurarsi di compilare l'esempio in una posizione diversa. Eliminare la directory di base e tutte le relative sottodirectory ogni volta che si esegue l'esempio.  
  
 L'esempio crea un nuovo dominio applicazione, usando il <xref:System.AppDomainSetup> oggetto. Nell'esempio viene usato il <xref:System.AppDomain.DynamicDirectory%2A> proprietà per recuperare il nome della directory, così da poter creare la directory. (L'esempio è stato possibile semplicemente creare la directory in anticipo concatenando il percorso originale, il codice hash del nome dell'applicazione e il nome dell'applicazione).  
  
 Nell'esempio è presente una `GenerateDynamicAssembly` metodo che genera un assembly denominato `DynamicHelloWorld.dll` e lo archivia nella directory dinamico del nuovo dominio applicazione. L'assembly dinamico contiene un solo tipo, `HelloWorld`, che dispone di un metodo statico (`Shared` metodo in Visual Basic) denominata `HelloFromAD`. Chiamare questo metodo visualizza il nome del dominio dell'applicazione.  
  
 Il `Example` deriva dalla classe <xref:System.MarshalByRefObject>, in modo che l'esempio è possibile creare un'istanza della classe nel nuovo dominio dell'applicazione delle chiamata relativo `Test` (metodo). Il `Test` metodo carica l'assembly dinamico con il nome visualizzato e chiama il metodo statico `HelloFromAD` (metodo).  
  
 È possibile mostrare che viene eseguita la ricerca di directory dinamica dopo i percorsi di sondaggio normale scrivendo codice per un assembly denominato `DynamicHelloWorld.dll` e compilarlo nella stessa directory in questo esempio. L'assembly deve avere una classe denominata `HelloWorld` con un metodo statico denominato `HelloFromAD`. Questo metodo non deve avere la stessa funzionalità come quello nell'esempio; sufficiente visualizzare una stringa nella console. L'assembly deve avere anche un <xref:System.Reflection.AssemblyVersionAttribute> attributo che imposta la versione 1.0.0.0. Quando si esegue l'esempio, l'assembly che è stato compilato nella directory corrente si trova prima la directory dinamica viene eseguita la ricerca.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni sul percorso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.AppDomain.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Security.Policy.Evidence" /> associato al dominio applicazione.</summary>
        <value>Evidenza associata al dominio applicazione.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue l'assembly contenuto nel file specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string -&gt; int&#xA;override this.ExecuteAssembly : string -&gt; int" Usage="appDomain.ExecuteAssembly assemblyFile" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome del file contenente l'assembly da eseguire.</param>
        <summary>Esegue l'assembly contenuto nel file specificato.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Questo metodo crea un nuovo processo o il dominio dell'applicazione e non eseguito il metodo del punto di ingresso in un nuovo thread.  
  
 Questo metodo carica gli assembly mediante il <xref:System.Reflection.Assembly.LoadFile%2A> (metodo). È anche possibile eseguire gli assembly mediante il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo, che carica assembly utilizzando il <xref:System.Reflection.Assembly.Load%2A> (metodo).  
  
 Per creare il <xref:System.AppDomain> per caricare ed eseguire, utilizzare il <xref:System.AppDomain.CreateDomain%2A> (metodo).  
  
   
  
## Examples  
 L'esempio seguente viene illustrato come utilizzare uno degli overload di <xref:System.AppDomain.ExecuteAssembly%2A> in due domini diversi.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome del file contenente l'assembly da eseguire.</param>
        <param name="assemblySecurity">Evidenza per il caricamento dell'assembly.</param>
        <summary>Esegue l'assembly contenuto nel file specificato usando l'evidenza specificata.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Il <xref:System.AppDomain.ExecuteAssembly%2A> metodo non crea un nuovo processo o il dominio dell'applicazione e non eseguito il metodo del punto di ingresso in un nuovo thread.  
  
 Questo metodo carica gli assembly mediante il <xref:System.Reflection.Assembly.LoadFile%2A> (metodo). È anche possibile eseguire gli assembly mediante il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo, che carica assembly utilizzando il <xref:System.Reflection.Assembly.Load%2A> (metodo).  
  
   
  
## Examples  
 L'esempio seguente viene illustrato come utilizzare uno degli overload di <xref:System.AppDomain.ExecuteAssembly%2A> in due domini diversi.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome del file contenente l'assembly da eseguire.</param>
        <param name="args">Argomenti per il punto di ingresso dell'assembly.</param>
        <summary>Esegue l'assembly contenuto nel file specificato, usando gli argomenti specificati.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Questo metodo crea un nuovo processo o il dominio dell'applicazione e non eseguito il metodo del punto di ingresso in un nuovo thread.  
  
 Questo metodo carica gli assembly mediante il <xref:System.Reflection.Assembly.LoadFile%2A> (metodo). È anche possibile eseguire gli assembly mediante il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo, che carica assembly utilizzando il <xref:System.Reflection.Assembly.Load%2A> (metodo).  
  
   
  
## Examples  
 L'esempio seguente viene illustrato come utilizzare uno degli overload di <xref:System.AppDomain.ExecuteAssembly%2A> in due domini diversi.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
oppure 
 <paramref name="assemblyFile" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome del file contenente l'assembly da eseguire.</param>
        <param name="assemblySecurity">Evidenza fornita per l'assembly.</param>
        <param name="args">Argomenti per il punto di ingresso dell'assembly.</param>
        <summary>Esegue l'assembly contenuto nel file specificato usando l'evidenza e gli argomenti specificati.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Questo metodo crea un nuovo processo o il dominio dell'applicazione e non eseguito il metodo del punto di ingresso in un nuovo thread.  
  
 Questo metodo carica gli assembly mediante il <xref:System.Reflection.Assembly.LoadFile%2A> (metodo). È anche possibile eseguire gli assembly mediante il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo, che carica assembly utilizzando il <xref:System.Reflection.Assembly.Load%2A> (metodo).  
  
   
  
## Examples  
 L'esempio seguente viene illustrato come utilizzare uno degli overload di <xref:System.AppDomain.ExecuteAssembly%2A> in due domini diversi.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> non è <see langword="null" />. Quando i criteri di sicurezza dall'accesso di codice legacy non sono abilitati, <paramref name="assemblySecurity" /> deve essere <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome del file contenente l'assembly da eseguire.</param>
        <param name="args">Argomenti per il punto di ingresso dell'assembly.</param>
        <param name="hashValue">Rappresenta il valore del codice hash calcolato.</param>
        <param name="hashAlgorithm">Rappresenta l'algoritmo hash usato dal manifesto dell'assembly.</param>
        <summary>Esegue l'assembly contenuto nel file specificato, usando gli argomenti, il valore hash e l'algoritmo hash specificati.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Questo metodo crea un nuovo processo o il dominio dell'applicazione e non eseguito il metodo del punto di ingresso in un nuovo thread.  
  
 Questo metodo carica gli assembly mediante il <xref:System.Reflection.Assembly.LoadFile%2A> (metodo). È anche possibile eseguire gli assembly mediante il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo, che carica assembly utilizzando il <xref:System.Reflection.Assembly.Load%2A> (metodo).  
  
   
  
## Examples  
 L'esempio seguente viene illustrato come utilizzare uno degli overload di <xref:System.AppDomain.ExecuteAssembly%2A> in due domini diversi.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
oppure 
 <paramref name="assemblyFile" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome del file contenente l'assembly da eseguire.</param>
        <param name="assemblySecurity">Evidenza fornita per l'assembly.</param>
        <param name="args">Argomenti per il punto di ingresso dell'assembly.</param>
        <param name="hashValue">Rappresenta il valore del codice hash calcolato.</param>
        <param name="hashAlgorithm">Rappresenta l'algoritmo hash usato dal manifesto dell'assembly.</param>
        <summary>Esegue l'assembly contenuto nel file specificato, usando l'evidenza, gli argomenti, il valore hash e l'algoritmo hash specificati.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Questo metodo crea un nuovo processo o il dominio dell'applicazione e non eseguito il metodo del punto di ingresso in un nuovo thread.  
  
 Questo metodo carica gli assembly mediante il <xref:System.Reflection.Assembly.LoadFile%2A> (metodo). È anche possibile eseguire gli assembly mediante il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo, che carica assembly utilizzando il <xref:System.Reflection.Assembly.Load%2A> (metodo).  
  
   
  
## Examples  
 Thefollowing esempio viene illustrato come utilizzare uno degli overload di <xref:System.AppDomain.ExecuteAssembly%2A> in due domini diversi.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> non è <see langword="null" />. Quando i criteri di sicurezza dall'accesso di codice legacy non sono abilitati, <paramref name="assemblySecurity" /> deve essere <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue un assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string -&gt; int" Usage="appDomain.ExecuteAssemblyByName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Esegue un assembly in base al nome visualizzato.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo fornisce funzionalità simili a quelle di <xref:System.AppDomain.ExecuteAssembly%2A> (metodo), ma specifica l'assembly dal nome visualizzato o <xref:System.Reflection.AssemblyName> anziché dal percorso del file. Pertanto <xref:System.AppDomain.ExecuteAssemblyByName%2A> carica gli assembly con il <xref:System.Reflection.Assembly.Load%2A> metodo invece che con il <xref:System.Reflection.Assembly.LoadFile%2A> (metodo).  
  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Questo metodo crea un nuovo processo o il dominio dell'applicazione e non eseguito il metodo del punto di ingresso in un nuovo thread.  
  
 Per creare il <xref:System.AppDomain> per caricare ed eseguire, utilizzare il <xref:System.AppDomain.CreateDomain%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">L'assembly specificato da <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly specificato da <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">L'assembly specificato da <paramref name="assemblyName" /> è stato trovato, ma non è stato possibile caricarlo.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere in lettura da un file o directory, per l'accesso alle informazioni presenti nel percorso stesso e per il reindirizzamento di un nome visualizzato in un percorso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per l'accesso a un sito Web, quando un nome visualizzato viene reindirizzato a un URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Oggetto <see cref="T:System.Reflection.AssemblyName" /> che rappresenta il nome dell'assembly.</param>
        <param name="args">Argomenti della riga di comando da passare all'avvio del processo.</param>
        <summary>Esegue l'assembly in base a un oggetto <see cref="T:System.Reflection.AssemblyName" />, usando gli argomenti specificati.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo fornisce funzionalità simili a quelle di <xref:System.AppDomain.ExecuteAssembly%2A> (metodo), ma specifica l'assembly dal nome visualizzato o <xref:System.Reflection.AssemblyName> anziché dal percorso del file. Pertanto <xref:System.AppDomain.ExecuteAssemblyByName%2A> carica gli assembly con il <xref:System.Reflection.Assembly.Load%2A> metodo invece che con il <xref:System.Reflection.Assembly.LoadFile%2A> (metodo).  
  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Questo metodo crea un nuovo processo o il dominio dell'applicazione e non eseguito il metodo del punto di ingresso in un nuovo thread.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">L'assembly specificato da <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">L'assembly specificato da <paramref name="assemblyName" /> è stato trovato, ma non è stato possibile caricarlo.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly specificato da <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
 <paramref name="assemblyName" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere in lettura da un file o directory, per l'accesso alle informazioni presenti nel percorso stesso e per il reindirizzamento di un nome visualizzato in un percorso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per l'accesso a un sito Web, quando un nome visualizzato viene reindirizzato a un URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Evidenza per il caricamento dell'assembly.</param>
        <summary>Esegue un assembly in base al nome visualizzato, usando l'evidenza specificata.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo fornisce funzionalità simili a quelle di <xref:System.AppDomain.ExecuteAssembly%2A> (metodo), ma specifica l'assembly dal nome visualizzato o <xref:System.Reflection.AssemblyName> anziché dal percorso del file. Pertanto <xref:System.AppDomain.ExecuteAssemblyByName%2A> carica gli assembly con il <xref:System.Reflection.Assembly.Load%2A> metodo invece che con il <xref:System.Reflection.Assembly.LoadFile%2A> (metodo).  
  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo non crea un nuovo processo o il dominio dell'applicazione e non eseguito il metodo del punto di ingresso in un nuovo thread.  
  
> [!NOTE]
>  Quando si usa la <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo con un <xref:System.Security.Policy.Evidence> parametro evidenze vengono uniti. Evidenze fornito come argomento per il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo sostituiscono evidenze fornito dal caricatore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">L'assembly specificato da <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">L'assembly specificato da <paramref name="assemblyName" /> è stato trovato, ma non è stato possibile caricarlo.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly specificato da <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere in lettura da un file o directory, per l'accesso alle informazioni presenti nel percorso stesso e per il reindirizzamento di un nome visualizzato in un percorso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">per l'accesso a un sito Web, quando un nome visualizzato viene reindirizzato a un URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="args">Argomenti della riga di comando da passare all'avvio del processo.</param>
        <summary>Esegue l'assembly in base al nome visualizzato, usando gli argomenti specificati.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo fornisce funzionalità simili a quelle di <xref:System.AppDomain.ExecuteAssembly%2A> (metodo), ma specifica l'assembly dal nome visualizzato o <xref:System.Reflection.AssemblyName> anziché dal percorso del file. Pertanto <xref:System.AppDomain.ExecuteAssemblyByName%2A> carica gli assembly con il <xref:System.Reflection.Assembly.Load%2A> metodo invece che con il <xref:System.Reflection.Assembly.LoadFile%2A> (metodo).  
  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Questo metodo crea un nuovo processo o il dominio dell'applicazione e non eseguito il metodo del punto di ingresso in un nuovo thread.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">L'assembly specificato da <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">L'assembly specificato da <paramref name="assemblyName" /> è stato trovato, ma non è stato possibile caricarlo.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly specificato da <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
 <paramref name="assemblyName" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere in lettura da un file o directory, per l'accesso alle informazioni presenti nel percorso stesso e per il reindirizzamento di un nome visualizzato in un percorso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per l'accesso a un sito Web, quando un nome visualizzato viene reindirizzato a un URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Oggetto <see cref="T:System.Reflection.AssemblyName" /> che rappresenta il nome dell'assembly.</param>
        <param name="assemblySecurity">Evidenza per il caricamento dell'assembly.</param>
        <param name="args">Argomenti della riga di comando da passare all'avvio del processo.</param>
        <summary>Esegue l'assembly in base a un dato oggetto <see cref="T:System.Reflection.AssemblyName" />, usando l'evidenza e gli argomenti specificati.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo fornisce funzionalità simili a quelle di <xref:System.AppDomain.ExecuteAssembly%2A> (metodo), ma specifica l'assembly dal nome visualizzato o <xref:System.Reflection.AssemblyName> anziché dal percorso del file. Pertanto <xref:System.AppDomain.ExecuteAssemblyByName%2A> carica gli assembly con il <xref:System.Reflection.Assembly.Load%2A> metodo invece che con il <xref:System.Reflection.Assembly.LoadFile%2A> (metodo).  
  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Questo metodo crea un nuovo processo o il dominio dell'applicazione e non eseguito il metodo del punto di ingresso in un nuovo thread.  
  
> [!NOTE]
>  Quando si usa la <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo con un <xref:System.Security.Policy.Evidence> parametro evidenze vengono uniti. Evidenze fornito come argomento per il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo sostituiscono evidenze fornito dal caricatore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">L'assembly specificato da <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">L'assembly specificato da <paramref name="assemblyName" /> è stato trovato, ma non è stato possibile caricarlo.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly specificato da <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> non è <see langword="null" />. Quando i criteri di sicurezza dall'accesso di codice legacy non sono abilitati, <paramref name="assemblySecurity" /> deve essere <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere in lettura da un file o directory, per l'accesso alle informazioni presenti nel percorso stesso e per il reindirizzamento di un nome visualizzato in un percorso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">per l'accesso a un sito Web, quando un nome visualizzato viene reindirizzato a un URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Evidenza per il caricamento dell'assembly.</param>
        <param name="args">Argomenti della riga di comando da passare all'avvio del processo.</param>
        <summary>Esegue l'assembly in base al nome visualizzato, usando l'evidenza e gli argomenti specificati.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo fornisce funzionalità simili a quelle di <xref:System.AppDomain.ExecuteAssembly%2A> (metodo), ma specifica l'assembly dal nome visualizzato o <xref:System.Reflection.AssemblyName> anziché dal percorso del file. Pertanto <xref:System.AppDomain.ExecuteAssemblyByName%2A> carica gli assembly con il <xref:System.Reflection.Assembly.Load%2A> metodo invece che con il <xref:System.Reflection.Assembly.LoadFile%2A> (metodo).  
  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Questo metodo crea un nuovo processo o il dominio dell'applicazione e non eseguito il metodo del punto di ingresso in un nuovo thread.  
  
> [!NOTE]
>  Quando si usa la <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo con un <xref:System.Security.Policy.Evidence> parametro evidenze vengono uniti. Evidenze fornito come argomento per il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo sostituiscono evidenze fornito dal caricatore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">L'assembly specificato da <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">L'assembly specificato da <paramref name="assemblyName" /> è stato trovato, ma non è stato possibile caricarlo.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly specificato da <paramref name="assemblyName" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> non è <see langword="null" />. Quando i criteri di sicurezza dall'accesso di codice legacy non sono abilitati, <paramref name="assemblySecurity" /> deve essere <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere in lettura da un file o directory, per l'accesso alle informazioni presenti nel percorso stesso e per il reindirizzamento di un nome visualizzato in un percorso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">per l'accesso a un sito Web, quando un nome visualizzato viene reindirizzato a un URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberSignature Language="F#" Value="member this.FirstChanceException : EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " Usage="member this.FirstChanceException : System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un'eccezione viene generata in codice gestito prima che il runtime cerchi un gestore di eccezioni nello stack di chiamate del dominio applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento è solo una notifica. Questo evento non gestire l'eccezione, né altera in alcun modo di gestione delle eccezioni successive. Dopo che è stato generato l'evento e sono stati richiamati i gestori eventi, common language runtime (CLR) inizia a eseguire la ricerca di un gestore per l'eccezione. <xref:System.AppDomain.FirstChanceException> fornisce il dominio dell'applicazione con una prima opportunità per esaminare qualsiasi eccezione gestita.  
  
 L'evento può essere gestito per ogni dominio dell'applicazione. Se un thread passa attraverso più domini dell'applicazione durante l'esecuzione di una chiamata, l'evento viene generato in ogni dominio applicazione che ha registrato un gestore eventi, prima che Common Language Runtime inizi la ricerca di un gestore di eccezioni corrispondente in tale dominio dell'applicazione. Dopo l'evento è stato gestito, viene eseguita una ricerca per un gestore di eccezioni corrispondente in tale dominio dell'applicazione. Se non ne viene trovato, viene generato l'evento nel dominio dell'applicazione successivo.  
  
 È necessario gestire tutte le eccezioni che si verificano nell'evento gestore per il <xref:System.AppDomain.FirstChanceException> evento. In caso contrario, <xref:System.AppDomain.FirstChanceException> viene generato in modo ricorsivo. Ciò potrebbe causare un overflow dello stack e la chiusura dell'applicazione. Si consiglia di implementare i gestori eventi per questo evento come aree a esecuzione vincolata (CER), per evitare che interessano la macchina virtuale durante la notifica di eccezione è che le eccezioni correlate all'infrastruttura, ad esempio di memoria insufficiente o stack overflow in fase di elaborazione.  
  
 Questo evento non viene generato per le eccezioni che indicano il danneggiamento dello stato del processo, ad esempio le violazioni di accesso, a meno che il gestore dell'evento è critico per la sicurezza e ha il <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> attributo.  
  
 Common language runtime sospende le interruzioni di thread mentre viene gestito l'evento di notifica.  
  
   
  
## Examples  
 L'esempio seguente crea una serie di domini dell'applicazione denominata `AD0` attraverso `AD3`, con un `Worker` oggetto in ogni dominio applicazione. Ogni `Worker` oggetto ha un riferimento al `Worker` dell'oggetto nel dominio dell'applicazione Avanti, fatta eccezione per il `Worker` nel dominio dell'applicazione ultimo. Il <xref:System.AppDomain.FirstChanceException> evento viene gestito in tutti i domini applicazione, ad eccezione `AD1`.  
  
> [!NOTE]
>  Oltre a questo esempio, che illustra le notifiche di eccezioni first-chance in più domini applicazione, è possibile trovare casi di utilizzo semplici [procedura: ricevere notifiche di eccezioni First-Chance](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md).  
  
 Quando sono stati creati i domini applicazione, il dominio applicazione predefinito chiama il `TestException` metodo per il primo dominio dell'applicazione. Ciascuna `Worker` object chiama il `TestException` metodo per il dominio di applicazione successivo, finché l'ultimo `Worker` genera un'eccezione che viene o non gestita. Di conseguenza, il thread corrente attraversa tutti i domini dell'applicazione e `TestException` viene aggiunta allo stack in ogni dominio applicazione.  
  
 Quando l'ultima `Worker` oggetto gestisce l'eccezione, il <xref:System.AppDomain.FirstChanceException> evento viene generato solo nel dominio dell'applicazione ultimo. Gli altri domini applicazione mai l'opportunità di gestire l'eccezione, pertanto non viene generato l'evento.  
  
 Quando l'ultima `Worker` oggetto non gestisce l'eccezione, il <xref:System.AppDomain.FirstChanceException> in ogni dominio applicazione che dispone di un gestore di evento viene generato l'evento. Al termine di ogni gestore eventi, lo stack continua a di rimozione fino a quando non viene rilevata l'eccezione per il dominio applicazione predefinito.  
  
> [!NOTE]
>  Per visualizzare la modalità di visualizzazione dello stack aumenta man mano che viene generato l'evento più vicino e più prossimo al dominio applicazione predefinito, modificare `e.Exception.Message` al `e.Exception` nel `FirstChanceHandler` gestori eventi. Si noti che quando `TestException` viene chiamato attraverso i limiti del dominio applicazione, viene visualizzato due volte: una volta per il proxy e una volta per lo stub.  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FriendlyName : string" Usage="System.AppDomain.FriendlyName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome descrittivo del dominio applicazione.</summary>
        <value>Nome descrittivo del dominio applicazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il nome descrittivo del dominio applicazione predefinito è il nome del file dell'eseguibile del processo. Ad esempio, se il file eseguibile usato per avviare il processo viene `"c:\MyAppDirectory\MyAssembly.exe"`, il nome descrittivo del dominio applicazione predefinito è `"MyAssembly.exe"`.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.AppDomain.FriendlyName%2A> proprietà da ottenere il nome descrittivo del dominio applicazione corrente. Per il dominio applicazione predefinito, il nome descrittivo è il nome del file eseguibile dell'applicazione. L'esempio di codice visualizza anche informazioni aggiuntive sul dominio applicazione.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblies : unit -&gt; System.Reflection.Assembly[]&#xA;override this.GetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.GetAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene gli assembly caricati nel contesto di esecuzione del dominio applicazione.</summary>
        <returns>Matrice di assembly nel dominio applicazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.AppDomain.GetAssemblies%2A> metodo per ottenere un elenco di tutti gli assembly che sono stati caricati nel dominio dell'applicazione. Gli assembly verranno quindi visualizzati nella console.  
  
 Per eseguire questo esempio di codice, è necessario creare un assembly denominato `CustomLibrary.dll`, o modificare il nome dell'assembly che viene passato per il <xref:System.AppDomain.GetAssemblies%2A> (metodo).  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentThreadId : unit -&gt; int" Usage="System.AppDomain.GetCurrentThreadId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene l'identificatore del thread attuale.</summary>
        <returns>Intero con segno a 32 bit che rappresenta l'identificatore del thread attuale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> proprietà, ovvero stabile anche quando .NET Framework è ospitato da un ambiente che supporta i fiber (vale a dire, i thread lightweight).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">chiamare questo metodo. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetData : string -&gt; obj&#xA;override this.GetData : string -&gt; obj" Usage="appDomain.GetData name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome di una proprietà del dominio applicazione predefinita o nome della proprietà di un dominio applicazione definito.</param>
        <summary>Ottiene il valore archiviato nel dominio applicazione attuale per il nome specificato.</summary>
        <returns>Valore della proprietà <paramref name="name" /> oppure <see langword="null" /> se la proprietà non esiste.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per recuperare il valore di una voce in una cache interna di coppie nome-data che descrivono le proprietà di questa istanza di <xref:System.AppDomain>. Si noti che il confronto di `name` con il nome di coppie chiave-valore è tra maiuscole e minuscole.  
  
 La cache contiene automaticamente le voci di sistema predefiniti che vengono inserite quando viene creato il dominio dell'applicazione. È possibile esaminare i relativi valori con il <xref:System.AppDomain.GetData%2A> metodo, o equivalente <xref:System.AppDomainSetup> proprietà.  
  
 È possibile inserire o modificare il proprio coppie nome / dati definiti dall'utente con il <xref:System.AppDomain.SetData%2A> metodo ed esaminare i valori mediante il <xref:System.AppDomain.GetData%2A> (metodo).  
  
 Nella tabella seguente vengono descritte le `name` di ogni voce del sistema e predefiniti corrispondente <xref:System.AppDomainSetup> proprietà.  
  
|Valore della proprietà 'name'|Proprietà|  
|---------------------|--------------|  
|"APPBASE"|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|"APP_CONFIG_FILE"|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|"APP_LAUNCH_URL"|(nessuna proprietà)<br /><br /> "APP_LAUNCH_URL" rappresenta l'URL originariamente richiesto dall'utente, prima di qualsiasi reindirizzamento. È disponibile solo quando l'applicazione è stata avviata con un browser quale Internet Explorer. Non tutti i browser specificare questo valore.|  
|"APP_NAME"|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|"BINPATH_PROBE_ONLY"|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|"CACHE_BASE"|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|"CODE_DOWNLOAD_DISABLED"|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|"DEV_PATH"|(nessuna proprietà)|  
|"DISALLOW_APP"|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_BASE_PROBING"|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_REDIRECTS"|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|"DYNAMIC_BASE"|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|"FORCE_CACHE_INSTALL"|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|"LICENSE_FILE" o una stringa specifica dell'applicazione|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|"LOADER_OPTIMIZATION"|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|"LOCATION_URI"|(nessuna proprietà)|  
|"PRIVATE_BINPATH"|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|"REGEX_DEFAULT_MATCH_TIMEOUT"|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> "REGEX_DEFAULT_MATCH_TIMEOUT" non è una voce del sistema e il valore può essere impostato tramite la chiamata di <xref:System.AppDomain.SetData%2A> (metodo).|  
|"SHADOW_COPY_DIRS"|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 Nell'esempio seguente crea un nuovo dominio applicazione, imposta un valore fornito dal sistema per il dominio e aggiunge una nuova coppia di valore per il dominio. Nell'esempio viene quindi illustrato come utilizzare il <xref:System.AppDomain.GetData%2A> metodo per recuperare i dati da queste coppie di valori e visualizzarli nella console.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni presenti nel percorso stesso, se la proprietà si applica a un percorso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="appDomain.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene il tipo dell'istanza corrente.</summary>
        <returns>Tipo dell'istanza corrente.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.AppDomain.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un intero che identifica in modo univoco il dominio applicazione all'interno del processo.</summary>
        <value>Intero che identifica il dominio applicazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente crea un secondo dominio dell'applicazione e visualizza le informazioni del dominio predefinito e il nuovo dominio.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="override this.InitializeLifetimeService : unit -&gt; obj" Usage="appDomain.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fornisce all'oggetto <see cref="T:System.AppDomain" /> una durata infinita impedendo la creazione di lease.</summary>
        <returns>Sempre <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsCompatibilitySwitchSet : string -&gt; Nullable&lt;bool&gt;" Usage="appDomain.IsCompatibilitySwitchSet value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Opzione di compatibilità da testare.</param>
        <summary>Ottiene un valore booleano che ammette valori Null, indica se sono impostate opzioni di compatibilità e, in tal caso, se è impostata l'opzione di compatibilità specificata.</summary>
        <returns>Riferimento Null (<see langword="Nothing" /> in Visual Basic) se non è impostata alcuna opzione di compatibilità; in caso contrario, un valore booleano che indica se l'opzione di compatibilità specificata da <paramref name="value" /> è impostata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo verifica se l'opzione di compatibilità specificata è stata impostata per il dominio applicazione corrente. Opzioni di compatibilità ripristino in genere un comportamento (ad esempio le stringhe di modalità vengono ordinate) che è stato modificato tra versioni diverse di .NET Framework.  Vengono impostati chiamando la <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> metodo prima di creare un dominio dell'applicazione.  
  
 Nella tabella seguente vengono forniti esempi di opzioni di compatibilità che è possibile impostare per ripristinare il comportamento delle versioni precedenti di .NET Framework.  
  
|Opzione|Significato|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Codice di accesso di sicurezza per il [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] è abilitata in questo dominio applicazione. Visualizzare [ &lt;NetFx40_LegacySecurityPolicy&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|"NetFx40_Legacy20SortingBehavior"|Stringa di ordinamento delle impostazioni predefinite per il [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] sono abilitate nel dominio applicazione. Il suo successo richiede sort00001000.dll da installare. Visualizzare [ &lt;CompatSortNLSVersion&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|"NetFx40_Legacy40SortingBehavior"|Stringa di ordinamento delle impostazioni predefinite per il [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]e Unicode 5.0 sono abilitate nel dominio applicazione. Il suo successo richiede sort00060101.dll da installare.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> il comportamento di formattazione di [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] è abilitata in questo dominio applicazione.  Visualizzare [ &lt;TimeSpan_LegacyFormatMode&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) e la sezione "Ripristino Legacy TimeSpan formattazione" il <xref:System.TimeSpan> argomento.|  
|"UseRandomizedStringHashAlgorithm"|Il runtime calcola i codici hash per le stringhe in una base di dominio dell'applicazione invece di usare un singolo algoritmo di hash che produce un codice hash coerente tra più domini applicazione. Visualizzare [ &lt;UseRandomizedStringHashAlgorithm&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberSignature Language="F#" Value="member this.IsDefaultAppDomain : unit -&gt; bool" Usage="appDomain.IsDefaultAppDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un valore che indica se il dominio applicazione è quello predefinito per il processo.</summary>
        <returns>
          <see langword="true" /> se l'oggetto <see cref="T:System.AppDomain" /> corrente rappresenta il dominio applicazione predefinito per il processo. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni processo gestito dispone di un dominio applicazione predefinito. L'esecuzione inizia nel dominio predefinito.  
  
   
  
## Examples  
 Esempio di codice seguente crea un secondo dominio dell'applicazione e visualizza le informazioni del dominio predefinito e il nuovo dominio.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberSignature Language="F#" Value="member this.IsFinalizingForUnload : unit -&gt; bool" Usage="appDomain.IsFinalizingForUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica se è in corso lo scaricamento del dominio applicazione e se il completamento degli oggetti in esso contenuti è stato avviato in Common Language Runtime.</summary>
        <returns>
          <see langword="true" /> se è in corso lo scaricamento del dominio applicazione ed è stato avviato il richiamo dei finalizzatori in Common Language Runtime. In caso contrario, <see langword="false" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo di finalizzazione per un oggetto fornisce un'opportunità per eseguire eventuali operazioni di pulizia prima che l'oggetto venga sottoposto a garbage collection. Dopo la finalizzazione, l'oggetto è accessibile, ma in uno stato non valido e di conseguenza inutilizzabili. Infine, la garbage collection completa e recupera l'oggetto.  
  
 Viene chiamato il metodo di finalizzazione dell'oggetto in una delle situazioni seguenti: durante l'operazione di garbage collection, quando common language runtime è in fase di arresto o quando viene scaricato il dominio dell'applicazione che contiene l'oggetto. Il <xref:System.AppDomain.IsFinalizingForUnload%2A> restituzione del metodo `true` solo nell'ultimo caso; non restituisce `true` se dà come risultato la finalizzazione dalla routine operazione di garbage collection o dall'arresto CLR.  
  
> [!NOTE]
>  Per determinare se la finalizzazione è a causa dell'arresto CLR, usare il <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> proprietà. Restituisce `true` se la finalizzazione è a causa di un dominio dell'applicazione in corso lo scaricamento o all'arresto di CLR.  
  
 Durante l'esecuzione del metodo di finalizzazione durante lo scaricamento del dominio, è possibile accedere a un altro oggetto che fa riferimento un campo statico e dispone di un metodo di finalizzazione. Tuttavia, è possibile in modo affidabile farlo perché l'oggetto a cui si accede potrebbe essere già stato completato.  
  
> [!NOTE]
>  Un'eccezione a questa regola è la <xref:System.Console> (classe), che contiene i campi statici che fanno riferimento a oggetti di flusso, ma viene implementato in modo tale è sempre possibile scrivere nella console di sistema, anche durante l'arresto del sistema o lo scaricamento di dominio.  
  
 Usare questo metodo nel metodo di finalizzazione dell'oggetto per determinare se lo scaricamento di dominio dell'applicazione che contiene l'oggetto. In tal caso, è possibile accedere in modo affidabile qualsiasi oggetto che dispone di un metodo di finalizzazione e viene fatto riferimento da un campo statico.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.AppDomain.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se gli assembly caricati nel dominio applicazione corrente vengono eseguiti con attendibilità totale.</summary>
        <value>
          <see langword="true" /> se gli assembly caricati nel dominio dell'applicazione corrente vengono eseguiti con attendibilità totale; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce sempre `true` per il dominio applicazione predefinito di un'applicazione che viene eseguito sul desktop. Viene restituito `false` relativo al dominio applicazione creato mediante sandbox è stato creato utilizzando il <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> overload del metodo, a meno che non sono equivalenti a con attendibilità totale le autorizzazioni concesse al dominio dell'applicazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.IsFullyTrusted%2A> proprietà e il <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> proprietà con i domini applicazione completamente o parzialmente attendibile. Il dominio applicazione con attendibilità totale è il dominio applicazione predefinito per l'applicazione. Il dominio applicazione parzialmente attendibile viene creato utilizzando il <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> overload del metodo.  
  
 L'esempio Usa un' `Worker` classe che deriva da <xref:System.MarshalByRefObject>, pertanto può essere sottoposta a marshalling attraverso i limiti del dominio applicazione. Nell'esempio viene creato un `Worker` oggetto nel dominio applicazione predefinito. Chiama quindi il `TestIsFullyTrusted` metodo per visualizzare il valore della proprietà per il dominio applicazione e per i due assembly caricati nel dominio dell'applicazione: mscorlib, che fa parte di .NET Framework e l'assembly di esempio. Il dominio dell'applicazione è completamente attendibile, in modo che entrambi gli assembly sono completamente attendibili.  
  
 Nell'esempio viene creata un'altra `Worker` oggetti in un dominio applicazione creato mediante sandbox e anche in questo caso chiama il `TestIsFullyTrusted` (metodo). Mscorlib viene sempre considerato attendibile, anche in un dominio applicazione parzialmente attendibile, ma l'assembly di esempio è parzialmente attendibile.  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHomogenous : bool" Usage="System.AppDomain.IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il dominio applicazione corrente dispone di un set di autorizzazioni concesso a tutti gli assembly caricati nel dominio applicazione.</summary>
        <value>
          <see langword="true" /> se il dominio applicazione corrente dispone di un set omogeneo di autorizzazioni; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce `true` per i domini dell'applicazione sandbox che sono stati creati tramite il <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> overload del metodo. Domini dell'applicazione sandbox hanno un set omogeneo di autorizzazioni. vale a dire, lo stesso set di autorizzazioni viene concesso a tutti gli assembly parzialmente attendibili che vengono caricati nel dominio dell'applicazione. Un dominio applicazione creato mediante sandbox, facoltativamente, include un elenco di assembly con nome sicuro che non sono interessati da questo set di autorizzazioni e invece eseguite con attendibilità totale.  
  
 È considerato completamente attendibile codice può usare il <xref:System.AppDomain.PermissionSet%2A> proprietà per determinare il set di concessioni omogeneo di un dominio applicazione creato mediante sandbox.  
  
 Questa proprietà restituisce inoltre `true` per il dominio applicazione predefinito di un'applicazione desktop, perché tale dominio applicazione concede l'attendibilità a tutti gli assembly.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carica <see cref="T:System.Reflection.Assembly" /> nel dominio applicazione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Matrice di tipo <see langword="byte" /> costituita da un'immagine in formato COFF contenente un assembly generato.</param>
        <summary>Carica l'oggetto <see cref="T:System.Reflection.Assembly" /> con un'immagine in formato COFF (Common Object File Format) contenente un oggetto <see cref="T:System.Reflection.Assembly" /> generato.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il livello di attendibilità di un assembly che viene caricato usando questo metodo è lo stesso livello di attendibilità del dominio dell'applicazione.  
  
 Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente. Questo metodo è fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> (metodo). Per caricare gli assembly in altri domini applicazione, usare un metodo, ad esempio <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Per informazioni comuni a tutti gli overload di questo metodo, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato l'utilizzo del caricamento di un assembly non elaborato.  
  
 Per questo esempio di codice per l'esecuzione, è necessario specificare il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="rawAssembly" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Oggetto che descrive l'assembly da caricare.</param>
        <summary>Carica <see cref="T:System.Reflection.Assembly" />, dato il relativo <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente. Questo metodo è fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> (metodo). Per caricare gli assembly in altri domini applicazione, usare un metodo, ad esempio <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Se una versione dell'assembly richiesto è già stata caricata, questo metodo restituisce l'assembly caricato, anche se non è necessaria una versione diversa.  
  
 Indicando un nome di assembly parziali per `assemblyRef` non è consigliata. (Un nome parziale omette una o più delle impostazioni cultura, versione o token di chiave pubblica. Per gli overload che accettano una stringa anziché un <xref:System.Reflection.AssemblyName> oggetto, "MyAssembly, Version = 1.0.0.0" è un esempio di un nome parziale e "MyAssembly, versione Version=1.0.0.0, Culture = neutral, PublicKeyToken = 18ab3442da84b47" è riportato un esempio di un nome completo.) Usando nomi parziali ha un effetto negativo sulle prestazioni. Inoltre, un nome di assembly parziali possa caricare un assembly dalla global assembly cache solo se è presente una copia esatta dell'assembly nella directory di base dell'applicazione (<xref:System.AppDomain.BaseDirectory%2A> o <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).  
  
 Se corrente <xref:System.AppDomain> oggetto rappresenta il dominio dell'applicazione `A`e il <xref:System.AppDomain.Load%2A> viene chiamato dal dominio applicazione `B`, l'assembly viene caricato in entrambi i domini applicazione. Ad esempio, il codice seguente carichi `MyAssembly` nel nuovo dominio applicazione `ChildDomain` e anche nel dominio dell'applicazione in cui viene eseguito il codice:  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 L'assembly viene caricato in entrambi i domini, perché <xref:System.Reflection.Assembly> non deriva da <xref:System.MarshalByRefObject>e pertanto il valore restituito di <xref:System.AppDomain.Load%2A> (metodo) non è possibile effettuare il marshalling. Al contrario, common language runtime prova a caricare l'assembly nel dominio dell'applicazione chiamante. Gli assembly caricati in due domini applicazione potrebbero essere diversi se le impostazioni del percorso per i due domini applicazione sono diverse.  
  
> [!NOTE]
>  Se entrambi i <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> proprietà e i <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> proprietà sono impostate, il primo tentativo di caricare l'assembly viene utilizzato il nome visualizzato (inclusi versione, impostazioni cultura e così via, come restituito dal <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> proprietà). Se il file non viene trovato, il <xref:System.Reflection.AssemblyName.CodeBase%2A> proprietà viene utilizzata per cercare l'assembly. Se l'assembly viene trovato tramite <xref:System.Reflection.AssemblyName.CodeBase%2A>, il nome visualizzato viene confrontato con l'assembly. Se la corrispondenza ha esito negativo, un <xref:System.IO.FileLoadException> viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyRef" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; System.Reflection.Assembly&#xA;override this.Load : string -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyString" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Carica <see cref="T:System.Reflection.Assembly" />, dato il nome visualizzato.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente. Questo metodo è fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> (metodo). Per caricare gli assembly in altri domini applicazione, usare un metodo, ad esempio <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Per informazioni comuni a tutti gli overload di questo metodo, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> è <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyString" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Matrice di tipo <see langword="byte" /> costituita da un'immagine in formato COFF contenente un assembly generato.</param>
        <param name="rawSymbolStore">Matrice di tipo <see langword="byte" /> contenente i byte non elaborati che rappresentano i simboli per l'assembly.</param>
        <summary>Carica l'oggetto <see cref="T:System.Reflection.Assembly" /> con un'immagine in formato COFF (Common Object File Format) contenente un oggetto <see cref="T:System.Reflection.Assembly" /> generato. Vengono caricati anche i byte non elaborati che rappresentano i simboli per l'oggetto <see cref="T:System.Reflection.Assembly" />.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il livello di attendibilità di un assembly che viene caricato usando questo metodo è lo stesso livello di attendibilità del dominio dell'applicazione.  
  
 Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente. Questo metodo è fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> (metodo). Per caricare gli assembly in altri domini applicazione, usare un metodo, ad esempio <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Per informazioni comuni a tutti gli overload di questo metodo, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato l'utilizzo del caricamento di un assembly non elaborato.  
  
 Per questo esempio di codice per l'esecuzione, è necessario specificare il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="rawAssembly" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Oggetto che descrive l'assembly da caricare.</param>
        <param name="assemblySecurity">Evidenza per il caricamento dell'assembly.</param>
        <summary>Carica <see cref="T:System.Reflection.Assembly" />, dato il relativo <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente. Questo metodo è fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> (metodo). Per caricare gli assembly in altri domini applicazione, usare un metodo, ad esempio <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Per informazioni comuni a tutti gli overload di questo metodo, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> è <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyRef" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un percorso che non è nel formato "file://" o "\\\UNC\dir\\" o "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Evidenza per il caricamento dell'assembly.</param>
        <summary>Carica <see cref="T:System.Reflection.Assembly" />, dato il nome visualizzato.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente. Questo metodo è fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> (metodo). Per caricare gli assembly in altri domini applicazione, usare un metodo, ad esempio <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Per informazioni comuni a tutti gli overload di questo metodo, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> è <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyString" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un percorso che non è nel formato "file://" o "\\\UNC\dir\\" o "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Matrice di tipo <see langword="byte" /> costituita da un'immagine in formato COFF contenente un assembly generato.</param>
        <param name="rawSymbolStore">Matrice di tipo <see langword="byte" /> contenente i byte non elaborati che rappresentano i simboli per l'assembly.</param>
        <param name="securityEvidence">Evidenza per il caricamento dell'assembly.</param>
        <summary>Carica l'oggetto <see cref="T:System.Reflection.Assembly" /> con un'immagine in formato COFF (Common Object File Format) contenente un oggetto <see cref="T:System.Reflection.Assembly" /> generato. Vengono caricati anche i byte non elaborati che rappresentano i simboli per l'oggetto <see cref="T:System.Reflection.Assembly" />.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il livello di attendibilità di un assembly che viene caricato usando questo metodo è lo stesso livello di attendibilità del dominio dell'applicazione.  
  
 Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente. Questo metodo è fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> (metodo). Per caricare gli assembly in altri domini applicazione, usare un metodo, ad esempio <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Per informazioni comuni a tutti gli overload di questo metodo, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato l'utilizzo del caricamento di un assembly non elaborato.  
  
 Per questo esempio di codice per l'esecuzione, è necessario specificare il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> non è un assembly valido.  
  
oppure 
Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="rawAssembly" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> non è <see langword="null" />. Quando i criteri di sicurezza dall'accesso di codice legacy non sono abilitati, <paramref name="securityEvidence" /> deve essere <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire la prova. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un percorso che non è nel formato "file://" o "\\\UNC\dir\\" o "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringIsEnabled : bool with get, set" Usage="System.AppDomain.MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il monitoraggio della memoria e della CPU dei domini applicazione è abilitato per il processo corrente. Una volta abilitato per un processo, il monitoraggio non può più essere disabilitato.</summary>
        <value>
          <see langword="true" /> se il monitoraggio è abilitato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ciò `static` proprietà (`Shared` proprietà in Visual Basic) controlla della CPU e il monitoraggio della memoria di tutti i domini applicazione nel processo.  
  
 Se si prova a impostare questa proprietà su `false`, una <xref:System.ArgumentException> viene generata l'eccezione, anche se il valore corrente della proprietà è `false`.  
  
 Dopo aver abilitato il monitoraggio, è possibile usare la <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, e <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> delle proprietà per monitorare l'utilizzo della CPU e memoria dei singoli domini applicazione dell'istanza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il processo corrente ha tentato di assegnare il valore <see langword="false" /> a questa proprietà.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di byte esclusi dall'ultima raccolta e a cui fa riferimento il dominio applicazione corrente.</summary>
        <value>Numero di byte esclusi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le statistiche vengono aggiornate con ogni operazione di garbage collection. Tuttavia, essi vengono sicuramente accurata solo dopo una procedura completa di Garbage collection; di blocco vale a dire, si verifica una raccolta che include tutte le generazioni e che l'applicazione durante la raccolta viene arrestata. Ad esempio, il <xref:System.GC.Collect?displayProperty=nameWithType> overload del metodo esegue una procedura completa di Garbage collection di blocco. (Raccolta simultanea avviene in background e non blocca l'applicazione).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> è impostata su <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedProcessMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene i byte totali esclusi dall'ultima raccolta per tutti i domini applicazione nel processo.</summary>
        <value>Numero totale di byte esclusi per il processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo una raccolta completa di, questo numero rappresenta il numero di byte attualmente mantenuti attivi in gestiti gli heap. Dovrebbe essere simile al numero riportato dal <xref:System.GC.GetTotalMemory%2A> (metodo). Dopo una raccolta temporanea, questo numero rappresenta il numero di byte attualmente mantenuti attivo in generazioni temporanee.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> è impostata su <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalAllocatedMemorySize : int64" Usage="System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene le dimensioni totali, in byte, di tutte le allocazioni di memoria effettuate dal dominio applicazione da quando è stato creato, senza sottrarre la memoria che è stata raccolta.</summary>
        <value>Dimensioni totali, in byte, di tutte le allocazioni di memoria.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> è impostata su <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalProcessorTime : TimeSpan" Usage="System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tempo del processore totale usato da tutti i thread durante l'esecuzione nel dominio applicazione corrente, da quando il processo è stato avviato.</summary>
        <value>Tempo del processore totale per il dominio applicazione corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tempo totale che viene segnalato per un dominio dell'applicazione include il tempo impiegato da ogni thread nel processo di esecuzione nel dominio dell'applicazione.  
  
 Un thread che chiama codice non gestito è ancora associato a un dominio dell'applicazione e il tempo del processore impiegato per l'esecuzione che del codice non gestito viene segnalato per il dominio applicazione in cui è stata effettuata la chiamata.  
  
 Quando un thread è bloccato o sospesi, non usano tempo del processore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> è impostata su <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.AppDomain.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il set di autorizzazioni di un dominio applicazione creato mediante sandbox.</summary>
        <value>Set di autorizzazioni di un dominio applicazione creato mediante sandbox.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domini dell'applicazione sandbox che sono stati creati tramite il <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> overload del metodo dispone di un set omogeneo di autorizzazioni; vale a dire, lo stesso set di autorizzazioni viene concesso a tutti gli assembly parzialmente attendibili che vengono caricati nel dominio dell'applicazione. Un dominio applicazione creato mediante sandbox, facoltativamente, include un elenco di assembly con nome sicuro che non sono interessati da questo set di autorizzazioni e invece eseguite con attendibilità totale.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberSignature Language="F#" Value="member this.ProcessExit : EventHandler " Usage="member this.ProcessExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica alla chiusura del processo padre del dominio applicazione predefinito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.EventHandler> per questo evento è possibile eseguire le attività di chiusura, ad esempio la chiusura di file, il rilascio di archiviazione e così via, prima della scadenza del processo.  
  
 A partire da .NET Framework versione 2.0, questo evento viene generato in ogni dominio applicazione che registra un gestore eventi.  
  
> [!NOTE]
>  Il tempo di esecuzione totale di tutte le <xref:System.AppDomain.ProcessExit> gestori di eventi è limitato, esattamente come il tempo di esecuzione totale di tutti i finalizzatori non è limitato all'arresto del processo. Il valore predefinito è di due secondi. Un host non gestito può modificare questo tempo di esecuzione chiamando il [ICLRPolicyManager](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) metodo con il [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) valore di enumerazione.  
  
 Nelle versioni 1.0 e 1.1 di .NET Framework, questo evento viene generato solo nel dominio dell'applicazione predefinito e solo se è registrato un gestore di evento nel dominio applicazione predefinito.  
  
 Per registrare un gestore eventi per questo evento, è necessario disporre delle autorizzazioni necessarie, o un <xref:System.Security.SecurityException> viene generata un'eccezione.  
  
 Per ulteriori informazioni sulla gestione degli eventi, consultare [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyAssemblyResolve : ResolveEventHandler " Usage="member this.ReflectionOnlyAssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando la risoluzione di un assembly ha esito negativo nel contesto ReflectionOnly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nel contesto reflection-only, le dipendenze non vengono risolti automaticamente. Deve essere precaricate o restituiti dal gestore per questo evento. Questo evento viene generato quando un assembly ha una dipendenza che non è già caricata nel contesto reflection-only. La dipendenza manca è specificata da di <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> proprietà. Il <xref:System.ResolveEventHandler> per questo evento deve restituire un assembly che soddisfa la dipendenza. L'assembly restituito deve essere caricato nel contesto reflection-only.  
  
> [!IMPORTANT]
>  Questo evento viene generato solo per le dipendenze mancanti dell'assembly che si sta caricando nel contesto reflection-only (ad esempio, usando il <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> (metodo)). Non viene generato se non è possibile trovare l'assembly che si sta caricando.  
  
 Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> proprietà restituisce l'assembly che ha richiesto il caricamento dell'assembly che non può essere risolto. Conoscere l'identità dell'assembly richiesta potrebbe essere utile per identificare la versione corretta della dipendenza, se è disponibile più di una versione. Per ulteriori informazioni, vedere <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Per questo evento, il <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> proprietà restituisce il nome dell'assembly prima di applicare dei criteri.  
  
 Per ulteriori informazioni sulla gestione degli eventi, consultare [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyGetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.ReflectionOnlyGetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce gli assembly caricati nel contesto ReflectionOnly del dominio applicazione.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.Assembly" /> che rappresentano gli assembly caricati nel contesto ReflectionOnly del dominio applicazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce gli assembly che sono stati caricati nel contesto reflection-only. Per ottenere gli assembly che sono stati caricati per l'esecuzione, usare il <xref:System.AppDomain.GetAssemblies%2A> (metodo).  
  
   
  
## Examples  
 Esempio di codice seguente carica l'assembly System. dll nel contesto di esecuzione e quindi nel contesto reflection-only. Il <xref:System.AppDomain.GetAssemblies%2A> e <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> vengono utilizzati metodi per visualizzare gli assembly caricati in ogni contesto.  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Si è tentato di effettuare un'operazione su un dominio applicazione non caricato.</exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSearchPath : string" Usage="System.AppDomain.RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il percorso nella directory di base in cui deve essere verificata la presenza di assembly privati mediante il resolver dell'assembly.</summary>
        <value>Percorso nella directory di base in cui deve essere verificata la presenza di assembly privati mediante il resolver dell'assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli assembly privati vengono distribuiti nella stessa struttura di directory dell'applicazione. Se il percorso specificato per il <xref:System.AppDomain.RelativeSearchPath%2A> proprietà non è gestito <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, viene ignorato.  
  
 Questa proprietà restituisce il valore impostato usando <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni sul percorso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberSignature Language="F#" Value="member this.ResourceResolve : ResolveEventHandler " Usage="member this.ResourceResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando la risoluzione di una risorsa ha esito negativo in quanto la risorsa stessa non è una risorsa collegata valida o non è incorporata nell'assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ResolveEventHandler> per questo evento può tentare di individuare l'assembly che contiene la risorsa e lo restituisce.  
  
> [!IMPORTANT]
>  Questo evento non viene generato se la risoluzione non riesce perché può essere trovato alcun file per una risorsa collegata valida. Viene generato se non è possibile trovare un flusso di risorsa di manifesto, ma non viene generato se non è stata trovata una chiave singola risorsa.  
  
 Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> proprietà contiene l'assembly che la risorsa richiesta. Per ulteriori informazioni, vedere <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Per registrare un gestore eventi per questo evento, è necessario disporre delle autorizzazioni necessarie, o un <xref:System.Security.SecurityException> viene generata un'eccezione.  
  
 Per ulteriori informazioni sulla gestione degli eventi, consultare [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberSignature Language="F#" Value="member this.SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit" Usage="appDomain.SetAppDomainPolicy domainPolicy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="domainPolicy">Livello dei criteri di sicurezza.</param>
        <summary>Imposta il livello dei criteri di sicurezza per il dominio applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo prima viene caricato in un assembly il <xref:System.AppDomain> affinché i criteri di sicurezza avere effetto.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.AppDomain.SetAppDomainPolicy%2A> metodo per impostare il livello di criteri di sicurezza di un dominio applicazione.  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domainPolicy" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Il livello dei criteri di sicurezza è già stato impostato.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetCachePath : string -&gt; unit&#xA;override this.SetCachePath : string -&gt; unit" Usage="appDomain.SetCachePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso completo delle copie shadow.</param>
        <summary>Imposta il percorso di directory specificato come percorso in cui vengono replicati gli assembly mediante copia shadow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il percorso della cache viene ignorato se il <xref:System.AppDomainSetup.ApplicationName%2A> proprietà non è impostata. Vedere la proprietà <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>.  
  
 Per ulteriori informazioni sulla creazione di copie shadow vedere [copie replicate di assembly](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Assegna un valore a una proprietà del dominio applicazione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetData : string * obj -&gt; unit&#xA;override this.SetData : string * obj -&gt; unit" Usage="appDomain.SetData (name, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nome della proprietà del dominio applicazione definito dall'utente da creare o modificare.</param>
        <param name="data">Valore della proprietà.</param>
        <summary>Assegna il valore specificato alla proprietà specificata del dominio applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per inserire una voce o modificare il valore di una voce in una cache interna di coppie nome-data che descrivono le proprietà di questa istanza di <xref:System.AppDomain>.  
  
 La cache contiene automaticamente le voci di sistema predefiniti che vengono inserite quando viene creato il dominio dell'applicazione. È possibile inserire o modificare le voci di sistema con questo metodo. Una chiamata al metodo che tenta di modificare una voce del sistema non ha effetto. il metodo non genera un'eccezione. È possibile controllare i valori delle voci di sistema con il <xref:System.AppDomain.GetData%2A> metodo, o equivalente <xref:System.AppDomainSetup> descritte le proprietà <xref:System.AppDomain.GetData%2A>.  
  
 È possibile chiamare questo metodo per impostare il valore dell'intervallo di timeout predefinito per la valutazione di modelli di espressione regolare da supply "REGEX_DEFAULT_MATCH_TIMEOUT" come valore dei `name` argomento e un <xref:System.TimeSpan> valore che rappresenta il timeout uguale al valore dell'intervallo di `data` argomento. È anche possibile inserire o modificare il proprio coppie nome / dati definiti dall'utente con questo metodo e controllare i relativi valori con il <xref:System.AppDomain.GetData%2A> (metodo).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> metodo per creare una nuova coppia di valori. L'esempio Usa quindi il <xref:System.AppDomain.GetData%2A> metodo per recuperare il valore e lo visualizza nella console.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberSignature Language="F#" Value="member this.SetData : string * obj * System.Security.IPermission -&gt; unit" Usage="appDomain.SetData (name, data, permission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="permission" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="name">Nome della proprietà del dominio applicazione definito dall'utente da creare o modificare.</param>
        <param name="data">Valore della proprietà.</param>
        <param name="permission">Autorizzazione di richiesta del chiamante quando viene recuperata la proprietà.</param>
        <summary>Assegna il valore specificato alla proprietà del dominio applicazione indicata, con una determinata autorizzazione di richiesta del chiamante quando viene recuperata la proprietà.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per inserire o modificare voci personalizzate definite dall'utente in una cache interna di coppie nome/dati che descrivono le proprietà del dominio dell'applicazione. Quando si inserisce una voce, è possibile specificare una richiesta di autorizzazione deve applicare quando viene recuperata la voce. Inoltre, è possibile chiamare questo metodo per impostare il valore dell'intervallo di timeout predefinito per la valutazione di modelli di espressione regolare da supply "REGEX_DEFAULT_MATCH_TIMEOUT" come valore dei `name` argomento e un <xref:System.TimeSpan> valore che rappresenta il intervallo di timeout come valore del `data` argomento.  
  
 È possibile utilizzare questo metodo per assegnare una richiesta di sicurezza a una stringa di proprietà definito dal sistema.  
  
 La cache contiene automaticamente le voci di sistema predefiniti che vengono inserite quando viene creato il dominio dell'applicazione. È possibile inserire o modificare le voci di sistema con questo metodo. Una chiamata al metodo che tenta di modificare una voce del sistema non ha effetto. il metodo non genera un'eccezione. È possibile controllare i valori delle voci di sistema con il <xref:System.AppDomain.GetData%2A> metodo o l'equivalente <xref:System.AppDomainSetup> le proprietà descritte nella sezione Osservazioni per il <xref:System.AppDomain.GetData%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il parametro <paramref name="name" /> specifica una stringa di proprietà definita dal sistema e il parametro <paramref name="permission" /> non è <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetDynamicBase : string -&gt; unit" Usage="appDomain.SetDynamicBase path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso completo che costituisce la directory di base per le sottodirectory in cui sono archiviati gli assembly dinamici.</param>
        <summary>Imposta il percorso di directory specificato come directory di base per sottodirectory in cui vengono archiviati i file generati dinamicamente e tramite cui si accede a questi ultimi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo imposta la <xref:System.AppDomainSetup.DynamicBase%2A> proprietà dell'oggetto interno <xref:System.AppDomainSetup> associato a questa istanza.  
  
   
  
## Examples  
 Questo metodo è obsoleto e non deve essere utilizzato per nuove attività di sviluppo. Nell'esempio seguente viene illustrato come usare l'alternativa non obsoleta, la <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> proprietà. Per una spiegazione di questo esempio, vedere la <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> proprietà o il <xref:System.AppDomain.DynamicDirectory%2A> proprietà.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberSignature Language="F#" Value="member this.SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit" Usage="appDomain.SetPrincipalPolicy policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">Uno dei valori dell'enumerazione <see cref="T:System.Security.Principal.PrincipalPolicy" /> che specifica il tipo dell'oggetto Principal da associare ai thread.</param>
        <summary>Specifica come collegare oggetti Principal e Identity a un thread se si tenta di associare il thread a un Principal durante l'esecuzione nel dominio applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostazione di questo valore saranno effettiva solo se lo si imposta prima di usare il <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> proprietà. Ad esempio, se si imposta <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> a una determinata entità (ad esempio, un'entità generica) e quindi usare il <xref:System.AppDomain.SetPrincipalPolicy%2A> metodo per impostare il <xref:System.Security.Principal.PrincipalPolicy> a <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, l'oggetto principal corrente rimangono entità generica.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'effetto sul thread dell'utilizzo di <xref:System.AppDomain.SetPrincipalPolicy%2A> metodo per modificare i criteri dell'entità del dominio dell'applicazione. Viene inoltre illustrato l'effetto dell'uso di <xref:System.AppDomain.SetThreadPrincipal%2A> metodo per modificare l'entità che è disponibile per la connessione ai thread nel dominio dell'applicazione.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter modificare l'oggetto principal. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberSignature Language="F#" Value="member this.SetShadowCopyFiles : unit -&gt; unit" Usage="appDomain.SetShadowCopyFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Attiva la replica tramite copia shadow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla creazione di copie shadow, vedere [copie replicate di assembly](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Questo metodo è obsoleto e non deve essere utilizzato per nuove attività di sviluppo.  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetShadowCopyPath : string -&gt; unit&#xA;override this.SetShadowCopyPath : string -&gt; unit" Usage="appDomain.SetShadowCopyPath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Elenco di nomi di directory in cui i nomi sono separati da un punto e virgola.</param>
        <summary>Imposta il percorso di directory specificato come percorso degli assembly da replicare mediante copia shadow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, una copia shadow include tutti gli assembly rilevati tramite individuazione tramite probe. Il <xref:System.AppDomain.SetShadowCopyPath%2A> metodo limita la copia shadow degli assembly nella directory specificata da `path`.  
  
 Il <xref:System.AppDomain.SetShadowCopyPath%2A> (metodo) non specifica directory aggiuntive in cui cercare gli assembly. Assembly da una copia shadow deve essere già presente nel percorso di ricerca, ad esempio in <xref:System.AppDomain.BaseDirectory%2A>. Il <xref:System.AppDomain.SetShadowCopyPath%2A> metodo consente di specificare quali percorsi di ricerca sono idonei per l'esecuzione della copia shadow.  
  
 Questo metodo imposta la <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> proprietà dell'oggetto interno <xref:System.AppDomainSetup> associato a questa istanza.  
  
 Per ulteriori informazioni sulla creazione di copie shadow, vedere [copie replicate di assembly](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Questo metodo è obsoleto e non deve essere utilizzato per nuove attività di sviluppo.  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberSignature Language="F#" Value="member this.SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit" Usage="appDomain.SetThreadPrincipal principal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal">Oggetto Principal da collegare ai thread.</param>
        <summary>Imposta l'oggetto Principal predefinito da collegare ai thread se si tenta di associare questi ultimi a un oggetto Principal durante l'esecuzione nel dominio applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente illustra l'effetto dell'uso di <xref:System.AppDomain.SetThreadPrincipal%2A> metodo per modificare l'entità che è disponibile per la connessione ai thread che sono in esecuzione nel dominio dell'applicazione. Viene inoltre illustrato l'effetto sul thread dell'utilizzo di <xref:System.AppDomain.SetPrincipalPolicy%2A> metodo per modificare i criteri dell'entità del dominio dell'applicazione.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="principal" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">L'oggetto Principal del thread è già stato impostato.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter modificare l'oggetto principal. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SetupInformation : AppDomainSetup" Usage="System.AppDomain.SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene le informazioni sulla configurazione del dominio applicazione per l'istanza.</summary>
        <value>Informazioni sull'inizializzazione del dominio applicazione.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : bool" Usage="System.AppDomain.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se il dominio applicazione è configurato per eseguire la copia shadow di file.</summary>
        <value>
          <see langword="true" /> se il dominio applicazione è configurato per eseguire la copia shadow di file; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per altre informazioni, vedere <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> e [copie replicate di assembly](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Riservato per utilizzi futuri. Deve essere IID_NULL.</param>
        <param name="rgszNames">Matrice di nomi passata di cui eseguire il mapping.</param>
        <param name="cNames">Conteggio dei nomi di cui eseguire il mapping.</param>
        <param name="lcid">Contesto delle impostazioni locali in cui interpretare i nomi.</param>
        <param name="rgDispId">Matrice allocata dal chiamante che riceve gli ID corrispondenti ai nomi.</param>
        <summary>Esegue il mapping di un set di nomi a un set corrispondente di ID dispatch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per altre informazioni sulle `IDispatch::GetIDsOfNames`, consultare la MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informazioni sul tipo da restituire.</param>
        <param name="lcid">Identificatore delle impostazioni locali per le informazioni sul tipo.</param>
        <param name="ppTInfo">Riceve un puntatore all'oggetto relativo alle informazioni sul tipo richiesto.</param>
        <summary>Recupera le informazioni sul tipo relative a un oggetto che può quindi essere usato per ottenere informazioni sul tipo relative a un'interfaccia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per altre informazioni sulle `IDispatch::GetTypeInfo`, consultare la MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Punta a una posizione che riceve il numero di interfacce di informazioni sul tipo fornite dall'oggetto.</param>
        <summary>Recupera il numero delle interfacce di informazioni sul tipo fornite da un oggetto (0 o 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per altre informazioni sulle `IDispatch::GetTypeInfoCount`, consultare la MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifica il membro.</param>
        <param name="riid">Riservato per utilizzi futuri. Deve essere IID_NULL.</param>
        <param name="lcid">Contesto di impostazioni locali all'interno del quale devono essere interpretati gli argomenti.</param>
        <param name="wFlags">Flag che descrivono il contesto della chiamata.</param>
        <param name="pDispParams">Puntatore a una struttura contenente una matrice di argomenti, una matrice di DISPID per argomenti denominati e i conteggi del numero di elementi nelle matrici.</param>
        <param name="pVarResult">Puntatore alla posizione in cui deve essere archiviato il risultato.</param>
        <param name="pExcepInfo">Puntatore a una struttura contenente informazioni sull'eccezione.</param>
        <param name="puArgErr">Indice del primo argomento che contiene un errore.</param>
        <summary>Fornisce l'accesso a proprietà e metodi esposti da un oggetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per altre informazioni sulle `IDispatch::Invoke`, consultare la MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="appDomain.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene una rappresentazione di stringa che comprende il nome descrittivo del dominio applicazione e qualsiasi criterio di contesto.</summary>
        <returns>Stringa formata concatenando la rappresentazione formale di stringa "Name:", il nome descrittivo del dominio applicazione e le rappresentazioni di stringa dei criteri di contesto o la stringa "There are no context policies".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore restituito del <xref:System.AppDomain.ToString%2A> (metodo).  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Il dominio applicazione rappresentato dall'oggetto <see cref="T:System.AppDomain" /> corrente è stato scaricato.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberSignature Language="F#" Value="member this.TypeResolve : ResolveEventHandler " Usage="member this.TypeResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando la risoluzione di un tipo non riesce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AppDomain.TypeResolve> evento viene generato quando common language runtime non riesce a determinare l'assembly che è possibile creare il tipo richiesto. Ciò può verificarsi se il tipo è definito in un assembly dinamico, o il tipo non è definito in un assembly dinamico, ma il runtime non conosce l'assembly in cui è definito il tipo. La seconda situazione può verificarsi quando <xref:System.Type.GetType%2A?displayProperty=nameWithType> viene chiamato con un nome di tipo che non è qualificato con il nome dell'assembly.  
  
 Il <xref:System.ResolveEventHandler> per questo evento può tentare di individuare e creare il tipo.  
  
 Tuttavia, il <xref:System.AppDomain.TypeResolve> evento non viene eseguito se il runtime non saprà non è possibile trovare un tipo in determinati assembly. Ad esempio, questo evento non si verifica se il tipo non viene trovato in un assembly statico perché il runtime non saprà tipi non è possibile aggiungere in modo dinamico per gli assembly statici.  
  
 Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> proprietà contiene l'assembly che ha richiesto il tipo. Per ulteriori informazioni, vedere <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Per registrare un gestore eventi per questo evento, è necessario disporre delle autorizzazioni necessarie, o un <xref:System.Security.SecurityException> viene generata un'eccezione.  
  
 Per ulteriori informazioni sulla gestione degli eventi, consultare [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.TypeResolve> evento.  
  
 Per questo esempio di codice per l'esecuzione, è necessario specificare il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : UnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.UnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando non viene intercettata un'eccezione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento fornisce la notifica delle eccezioni non rilevate. Consente all'applicazione di registrare le informazioni sull'eccezione prima che il gestore di sistema predefinito segnala all'utente l'eccezione e termina l'applicazione. Se sono disponibili sufficienti informazioni sullo stato dell'applicazione, si possono intraprendere altre azioni, ad esempio per salvare i dati del programma per il ripristino di versioni successive. È consigliabile prestare attenzione, perché i dati del programma possono risultare danneggiati quando le eccezioni non gestite.  
  
> [!NOTE]
>  Nelle versioni 1.0 e 1.1 di .NET Framework, la terminazione dell'applicazione e le opzioni di debug vengono segnalate all'utente prima che venga generato questo evento, anziché dopo.  
  
 Questo evento può essere gestito in qualsiasi dominio dell'applicazione. Tuttavia, l'evento non viene necessariamente generato nel dominio dell'applicazione in cui si è verificata l'eccezione. Un'eccezione viene gestita solo se l'intero stack per il thread è stato rimosso senza trovare un gestore di eccezioni applicabili, in modo che il primo elemento che può essere generato l'evento è nel dominio dell'applicazione in cui il thread ha avuto origine.  
  
> [!NOTE]
>  Nelle versioni 1.0 e 1.1 di .NET Framework, questo evento si verifica solo per il dominio applicazione predefinito che viene creato dal sistema quando viene avviata un'applicazione. Se un'applicazione crea domini dell'applicazione, specificando un delegato per questo evento in tali domini delle applicazioni non ha alcun effetto.  
  
 Se il <xref:System.AppDomain.UnhandledException> evento viene gestito nel dominio applicazione predefinito, viene generato in per qualsiasi eccezione non gestita in qualsiasi thread, indipendentemente dal dominio applicazione avviato il thread. Se il thread avviato in un dominio dell'applicazione che dispone di un gestore eventi per <xref:System.AppDomain.UnhandledException>, viene generato l'evento nel dominio dell'applicazione. Dominio dell'applicazione non è il dominio applicazione predefinito, se è inoltre disponibile un gestore dell'evento nel dominio applicazione predefinito, l'evento viene generato in entrambi i domini applicazione.  
  
 Ad esempio, si supponga che un thread viene avviato dominio dell'applicazione "AD1", chiama un metodo nel dominio dell'applicazione "AD2" e da lì chiama un metodo nel dominio dell'applicazione "AD3", in cui viene generata un'eccezione. Il primo dominio dell'applicazione in cui il <xref:System.AppDomain.UnhandledException> evento può essere generato è "AD1". Se tale dominio dell'applicazione non è il dominio applicazione predefinito, l'evento può essere generato anche nel dominio applicazione predefinito.  
  
> [!NOTE]
>  Common language runtime sospende le interruzioni di thread durante i gestori eventi per il <xref:System.AppDomain.UnhandledException> eventi sono in esecuzione.  
  
 Se il gestore di evento include un <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attributo con il flag appropriato, il gestore dell'evento viene considerato come un'area a esecuzione vincolata.  
  
 Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], questo evento non viene generato per le eccezioni che danneggiano lo stato del processo, ad esempio stack overflow o violazioni di accesso, a meno che il gestore dell'evento è critico per la sicurezza e ha il <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> attributo.  
  
 Nelle versioni 1.0 e 1.1 di .NET Framework, un'eccezione non gestita che si verifica in un thread diverso da quello principale dell'applicazione viene intercettata dal runtime e pertanto non causa l'interruzione dell'applicazione. Di conseguenza, è possibile che il <xref:System.AppDomain.UnhandledException> generazione senza terminare l'applicazione dell'evento. A partire da .NET Framework versione 2.0, questa barriera per le eccezioni non gestite nei thread figlio è stato rimosso, poiché l'effetto cumulativo di tali errori invisibili all'utente inserito una riduzione delle prestazioni, i dati danneggiati e blocchi, ognuno dei quali non è semplice eseguire il debug. Per altre informazioni, incluso un elenco di casi in cui il runtime non viene terminato, vedere [eccezioni in thread gestiti](~/docs/standard/threading/exceptions-in-managed-threads.md).  
  
 Per registrare un gestore eventi per questo evento, è necessario disporre delle autorizzazioni necessarie, o un <xref:System.Security.SecurityException> viene generata un'eccezione.  
  
 Per ulteriori informazioni sulla gestione degli eventi, consultare [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
## <a name="other-events-for-unhandled-exceptions"></a>Altri eventi per le eccezioni non gestite  
 Per alcuni modelli di applicazione, il <xref:System.AppDomain.UnhandledException> evento può essere superato da altri eventi se si verifica un'eccezione non gestita nel thread principale dell'applicazione.  
  
 Nelle applicazioni che usano Windows Form, eccezioni non gestite nel causa thread principale dell'applicazione di <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> generazione dell'evento. Se questo evento è gestito, il comportamento predefinito prevede che l'eccezione non gestita termina l'applicazione, anche se l'applicazione viene lasciata in uno stato sconosciuto. In tal caso, il <xref:System.AppDomain.UnhandledException> non viene generato l'evento. Questo comportamento può essere modificato usando il file di configurazione dell'applicazione o tramite il <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> metodo per modificare la modalità a <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> prima di <xref:System.Windows.Forms.Application.ThreadException> gestore di evento è associato. Questo vale solo per il thread principale dell'applicazione. Il <xref:System.AppDomain.UnhandledException> evento viene generato per le eccezioni non gestite generate in altri thread.  
  
 A partire da Microsoft Visual Studio 2005, il framework di applicazione Visual Basic fornisce un altro evento per le eccezioni non gestite nel thread principale dell'applicazione. Vedere il <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> evento. Questo evento è un oggetto di argomenti di evento con lo stesso nome dell'oggetto di argomenti di evento utilizzato dal <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, ma con proprietà diverse. In particolare, questo oggetto di argomenti di evento include un <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> proprietà che consente all'applicazione di continuare l'esecuzione, ignorando l'eccezione non gestita (e lasciando l'applicazione in uno stato sconosciuto). In tal caso, il <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> non viene generato l'evento.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato il <xref:System.AppDomain.UnhandledException> evento. Definisce un gestore eventi, `MyHandler`, che viene richiamato ogni volta che viene generata un'eccezione non gestita nel dominio applicazione predefinito. Genera quindi le due eccezioni. Il primo è gestito da un **try/catch** blocco. La seconda non viene gestita e richiama il `MyHandle` routine prima che l'applicazione viene terminata.  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberSignature Language="F#" Value="static member Unload : AppDomain -&gt; unit" Usage="System.AppDomain.Unload domain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain">Dominio applicazione da scaricare.</param>
        <summary>Scarica il dominio applicazione corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework versione 2.0 è dedicata ai domini applicazione scaricando un thread. Ciò migliora l'affidabilità, specialmente quando è ospitato in .NET Framework. Quando un thread chiama <xref:System.AppDomain.Unload%2A>, il dominio di destinazione è contrassegnato per lo scaricamento. Il thread dedicato prova a scaricare il dominio e tutti i thread nel dominio vengono interrotte. Se un thread viene interrotto, ad esempio perché è in esecuzione il codice non gestito o perché è in esecuzione un `finally` blocco, quindi dopo un periodo di tempo una <xref:System.CannotUnloadAppDomainException> generata nel thread che ha chiamato originariamente <xref:System.AppDomain.Unload%2A>. Se il thread che potrebbe non essere interrotte alla fine termina, il dominio di destinazione non viene scaricato. Di conseguenza, in .NET Framework versione 2.0 `domain` non è garantito da scaricare, perché potrebbe non essere possibile terminare l'esecuzione di thread.  
  
> [!NOTE]
>  In alcuni casi, la chiamata <xref:System.AppDomain.Unload%2A> genera un'eccezione immediata <xref:System.CannotUnloadAppDomainException>, ad esempio se viene chiamato in un finalizzatore.  
  
 I thread nel `domain` vengono terminate con il <xref:System.Threading.Thread.Abort%2A> metodo, che genera un <xref:System.Threading.ThreadAbortException> nel thread. Anche se il thread deve terminare immediatamente, può continuare l'esecuzione di una quantità non prevedibile di tempo in un `finally` clausola.  
  
## <a name="version-compatibility"></a>Compatibilità tra versioni  
 In .NET Framework versioni 1.0 e 1.1 se il thread che chiama <xref:System.AppDomain.Unload%2A> è in esecuzione in `domain`, viene avviato un altro thread per eseguire l'operazione di scaricamento. Se `domain` non può essere scaricato, un <xref:System.CannotUnloadAppDomainException> viene generato in tale thread, non nel thread originale che ha chiamato <xref:System.AppDomain.Unload%2A>. Tuttavia, se il thread che chiama <xref:System.AppDomain.Unload%2A> è in esecuzione all'esterno di `domain`, che thread riceve l'eccezione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come scaricare un dominio dell'applicazione.  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> è <see langword="null" />.</exception>
        <exception cref="T:System.CannotUnloadAppDomainException">Impossibile scaricare <paramref name="domain" />.</exception>
        <exception cref="T:System.Exception">Si è verificato un errore durante il processo di scaricamento.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per aggiungere un gestore eventi per questo evento. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>