<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c3ab234edad8a65f7b4b6688da32990c9642f79d" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30731665" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un dominio applicazione, ossia un ambiente isolato nel quale vengono eseguite le applicazioni. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domini applicazione, che sono rappresentati da <xref:System.AppDomain> oggetti, forniscono i limiti di isolamento, scaricamento e sicurezza per l'esecuzione di codice gestito.  
  
-   Utilizzare i domini applicazione per isolare le operazioni che potrebbero arrestare un processo. Se lo stato del <xref:System.AppDomain> che esegue un'attività diventa instabile, il <xref:System.AppDomain> possono essere scaricati senza interferire con il processo. Questo è importante quando è necessario eseguire un processo per lunghi periodi senza riavviare il computer. È anche possibile utilizzare domini applicazione per isolare le operazioni che non devono condividere dati.  
  
-   Se un assembly viene caricato nel dominio applicazione predefinito, non può essere scaricato dalla memoria mentre il processo è in esecuzione. Tuttavia, se si apre un secondo dominio di applicazione da caricare ed eseguire l'assembly, l'assembly viene scaricato quando tale dominio applicazione viene scaricato. Utilizzare questa tecnica per ridurre al minimo il working set di processi a esecuzione prolungata che talvolta utilizzano DLL di grandi dimensioni.  
  
 Più domini applicazione è possono eseguire su un singolo processo. Tuttavia, non c'è un relazione uno a uno tra domini applicazione e thread. Più thread può appartenere a un singolo dominio applicazione e durante un determinato thread non è limitato a un singolo dominio applicazione, in qualsiasi momento, un thread viene eseguito in un singolo dominio applicazione.  
  
 Domini applicazione vengono creati utilizzando il <xref:System.AppDomain.CreateDomain%2A> metodo. <xref:System.AppDomain> le istanze vengono utilizzate per caricare ed eseguire assembly (<xref:System.Reflection.Assembly>). Quando un <xref:System.AppDomain> è non è più in uso, può essere scaricato.  
  
 Il <xref:System.AppDomain> implementa un set di eventi che consentono alle applicazioni di rispondere quando viene caricato un assembly, quando un dominio applicazione verrà scaricato o quando viene generata un'eccezione non gestita.  
  
 Per ulteriori informazioni sull'utilizzo dei domini applicazione, vedere [domini applicazione](~/docs/framework/app-domains/application-domains.md).  
  
 Questa classe implementa il <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, e <xref:System.Security.IEvidenceFactory> interfacce.  
  
 È consigliabile non creare mai un wrapper di utilizzabile in remoto per un <xref:System.AppDomain> oggetto. In questo modo è possibile pubblicare un riferimento a quello remoto <xref:System.AppDomain>, esporre metodi, ad esempio <xref:System.AppDomain.CreateInstance%2A> accesso remoto e dell'oggetto sicurezza dall'accesso di codice che <xref:System.AppDomain>. Client non autorizzati di connessione per la modalità remota <xref:System.AppDomain> è stato possibile accedere a qualsiasi risorsa di <xref:System.AppDomain> a sua volta ha accesso a. Non creare wrapper utilizzabile in remoto per qualsiasi tipo che estende <xref:System.MarshalByRefObject> e che implementa metodi che potrebbero essere utilizzati da client non autorizzati di ignorare il sistema di sicurezza.  
  
> [!CAUTION]
>  Il valore predefinito per il <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> proprietà `false`. Questa impostazione è sicura per i servizi. Per impedire a servizi di scaricare codice parzialmente attendibile, impostare questa proprietà su `true`.  
  
   
  
## Examples  
 In questo esempio viene illustrato come creare un nuovo <xref:System.AppDomain>, creare un'istanza di un tipo nel nuovo <xref:System.AppDomain>e comunicare con l'oggetto di quel tipo. Inoltre, in questo esempio viene illustrato come scaricare il <xref:System.AppDomain> causando l'oggetto di garbage collection.  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il contesto di attivazione del dominio applicazione corrente.</summary>
        <value>Oggetto che rappresenta il contesto di attivazione del dominio dell'applicazione corrente o <see langword="null" /> se al dominio non è associato alcun contesto di attivazione.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nome della directory da aggiungere al percorso privato.</param>
        <summary>Aggiunge il nome di directory specificato all'elenco di percorsi privati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'utilizzo di questa proprietà è sconsigliato, perché potrebbe modificare il percorso di sondaggio per gli assembly dopo che sono già stati caricati. In alternativa, usare la proprietà <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
 Il percorso privato o il percorso di ricerca relativo, è il percorso relativo alla directory di base in cui il resolver dell'assembly viene eseguita la ricerca degli assembly privati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'identità dell'applicazione nel dominio applicazione.</summary>
        <value>Oggetto che identifica l'applicazione nel dominio dell'applicazione.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene informazioni che descrivono le autorizzazioni concesse a un'applicazione e che consentono di stabilire se all'applicazione è associato un livello di attendibilità che ne consente l'esecuzione.</summary>
        <value>Oggetto che incapsula informazioni sulle autorizzazioni e sull'attendibilità relative all'applicazione nel dominio dell'applicazione.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly, nel formato fornito dalla proprietà <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Restituisce il nome visualizzato dell'assembly dopo l'applicazione dei criteri.</summary>
        <returns>Stringa contenente il nome visualizzato dell'assembly dopo l'applicazione dei criteri.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AppDomain.ApplyPolicy%2A> visualizzati il nome di metodo richiede un assembly e restituisce il nome visualizzato di post-criteri. Ciò è utile se è necessario caricare un assembly mediante i criteri, in quanto il contesto reflection-only non applica i criteri.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica al caricamento di un assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AssemblyLoadEventHandler> delegato per questo evento indica quale assembly è stato caricato.  
  
 Per registrare un gestore eventi per questo evento, è necessario disporre delle autorizzazioni necessarie, o un <xref:System.Security.SecurityException> viene generata un'eccezione.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.AssemblyLoad> evento.  
  
 Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando la risoluzione di un assembly ha esito negativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È responsabilità del <xref:System.ResolveEventHandler> per questo evento per l'assembly specificato dal <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> , proprietà o per restituire null se l'assembly non è riconosciuto. L'assembly deve essere caricato in un contesto di esecuzione. Se viene caricato nel contesto reflection-only, il carico che ha causato l'evento da generare.  
  
 Per istruzioni sull'utilizzo di questo evento, vedere [Risoluzione caricamenti Assembly](~/docs/framework/app-domains/resolve-assembly-loads.md).  
  
 A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> proprietà restituisce l'assembly che ha richiesto il caricamento dell'assembly che non può essere risolto. Ad esempio, il caricatore potrebbe essere in grado di caricare una dipendenza dell'assembly richiesta perché l'assembly richiedente e la relativa dipendenza non sono nel percorso di sondaggio. Conoscere l'identità dell'assembly richiedente potrebbe essere utile individuare la dipendenza o identificare la versione corretta, se è disponibile più di una versione della dipendenza. Per ulteriori informazioni, vedere <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
> [!IMPORTANT]
>  A partire dal [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], <xref:System.ResolveEventHandler> evento viene generato per tutti gli assembly, inclusi gli assembly di risorse. Nelle versioni precedenti, l'evento non è stato generato per gli assembly di risorse. Se il sistema operativo localizzato, il gestore può essere chiamato più volte: una volta per ogni impostazione cultura nella catena di fallback.  
  
 Per questo evento, il <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> proprietà restituisce il nome dell'assembly prima di applicare criteri.  
  
> [!IMPORTANT]
>  Se più di un gestore dell'evento viene registrato per questo evento, l'evento handlersarecalled in ordine fino a quando un gestore eventi restituisce un valore che non è `null`. Gestori di eventi successivi vengono ignorati.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.AssemblyResolve> evento.  
  
 Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la directory di base usata dal resolver dell'assembly per verificare la presenza di assembly.</summary>
        <value>Directory di base usata dal resolver dell'assembly per verificare la presenza di assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà corrisponde al <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> proprietà. Può anche essere recuperato tramite il <xref:System.AppDomain.GetData%2A> (metodo) con la stringa "APPBASE".  
  
   
  
## Examples  
 Esempio di codice seguente crea un nuovo dominio applicazione, specificare una directory di base da utilizzare per la ricerca degli assembly da caricare nel dominio. Nell'esempio viene utilizzata la <xref:System.AppDomain.BaseDirectory%2A> proprietà per ottenere il percorso della directory di base per la visualizzazione nella console.  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni presenti nel percorso stesso, inclusi il percorso è nel formato "file://" o \\\UNC\dir o "c:\\". Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta su stringa vuota ("") il percorso che specifica la posizione degli assembly privati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il percorso privato è un percorso relativo alla directory di base che common language runtime cerca gli assembly privati.  
  
 Per ulteriori informazioni, vedere <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.AppDomain.ClearPrivatePath%2A> metodo per rimuovere tutte le voci dall'elenco di percorsi privati per la ricerca quando gli assembly vengono caricati.  
  
 Questo metodo è obsoleto e non deve essere utilizzato per nuove attività di sviluppo.  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reimposta su stringa vuota ("") l'elenco di directory contenenti assembly replicati mediante copia shadow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il percorso della copia shadow è un elenco di directory in cui replicati gli assembly vengono archiviati.  
  
 Per ulteriori informazioni, vedere <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> e [copie Shadow di assembly](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nuova istanza di un tipo COM specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome di un file contenente un assembly che definisce il tipo richiesto.</param>
        <param name="typeName">Nome del tipo richiesto.</param>
        <summary>Crea una nuova istanza di un tipo COM specificato. I parametri specificano il nome di un file contenente un assembly che, a sua volta, contiene il tipo e il nome del tipo.</summary>
        <returns>Oggetto che rappresenta un wrapper per la nuova istanza specificata da <paramref name="typeName" />. Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per creare oggetti in modalità remota senza dover caricare il tipo in locale.  
  
 Il valore restituito deve per essere annullato il wrapping per accedere all'oggetto reale.  
  
 A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attributo con un valore di `true` è necessario applicare in modo esplicito o per impostazione predefinita per il tipo COM per questo metodo per creare un'istanza di quel tipo; in caso contrario, <xref:System.TypeLoadException> viene generata un'eccezione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile caricare il tipo.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico senza parametri.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> non trovata.</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> è una classe astratta.  
  
 oppure  
  
 Questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> è una stringa vuota ("").</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.NullReferenceException">L'oggetto COM cui viene fatto riferimento è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Per poter leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome di un file contenente un assembly che definisce il tipo richiesto.</param>
        <param name="typeName">Nome del tipo richiesto.</param>
        <param name="hashValue">Rappresenta il valore del codice hash calcolato.</param>
        <param name="hashAlgorithm">Rappresenta l'algoritmo hash usato dal manifesto dell'assembly.</param>
        <summary>Crea una nuova istanza di un tipo COM specificato. I parametri specificano il nome di un file contenente un assembly che, a sua volta, contiene il tipo e il nome del tipo.</summary>
        <returns>Oggetto che rappresenta un wrapper per la nuova istanza specificata da <paramref name="typeName" />. Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per creare oggetti in modalità remota senza dover caricare il tipo in locale.  
  
 Il valore restituito deve per essere annullato il wrapping per accedere all'oggetto reale.  
  
 A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attributo con un valore di `true` è necessario applicare in modo esplicito o per impostazione predefinita per il tipo COM per questo metodo per creare un'istanza di quel tipo; in caso contrario, <xref:System.TypeLoadException> viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Non è possibile caricare il tipo.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico senza parametri.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non trovata.</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> è una classe astratta.  
  
 oppure  
  
 Questo membro è stato richiamato con un meccanismo di associazione tardiva.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> è la stringa vuota ("").</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.NullReferenceException">L'oggetto COM cui viene fatto riferimento è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Per poter leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo dominio applicazione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Nome descrittivo del dominio.</param>
        <summary>Crea un nuovo dominio applicazione con il nome specificato.</summary>
        <returns>Dominio applicazione appena creato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `friendlyName` parametro ha lo scopo di identificare il dominio in modo significativo per gli utenti. Questa stringa deve essere adatta per la visualizzazione nelle interfacce utente.  
  
 Questo overload del metodo utilizza il <xref:System.AppDomainSetup> informazioni dal dominio applicazione predefinito.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato, in generale, come creare un dominio utilizzando uno del <xref:System.AppDomain.CreateDomain%2A> overload.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Nome descrittivo del dominio. Questo nome descrittivo può essere visualizzato nelle interfacce utente per identificare il dominio. Per ulteriori informazioni, vedere <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidenza che stabilisce l'identità del codice che viene eseguito nel dominio applicazione. Passare <see langword="null" /> per usare l'evidenza del dominio applicazione corrente.</param>
        <summary>Crea un nuovo dominio applicazione con il nome specificato usando l'evidenza fornita.</summary>
        <returns>Dominio applicazione appena creato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del metodo utilizza il <xref:System.AppDomainSetup> informazioni dal dominio applicazione predefinito.  
  
 Se `securityInfo` viene omesso, viene utilizzato l'evidenza del dominio applicazione corrente.  
  
> [!IMPORTANT]
>  Non utilizzare questo overload del metodo per creare i domini di applicazione creato mediante sandbox. A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], l'evidenza fornita per `securityInfo` non influiscono più set di concessioni del dominio dell'applicazione. Utilizzare il <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> overload del metodo per creare i domini di applicazione creato mediante sandbox.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato, in generale, come creare un dominio utilizzando uno del <xref:System.AppDomain.CreateDomain%2A> overload.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Nome descrittivo del dominio. Questo nome descrittivo può essere visualizzato nelle interfacce utente per identificare il dominio. Per ulteriori informazioni, vedere <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidenza che stabilisce l'identità del codice che viene eseguito nel dominio applicazione. Passare <see langword="null" /> per usare l'evidenza del dominio applicazione corrente.</param>
        <param name="info">Oggetto contenente informazioni relative all'inizializzazione del dominio applicazione.</param>
        <summary>Crea un nuovo dominio applicazione usando il nome, l'evidenza e le informazioni di installazione del dominio applicazione specificati.</summary>
        <returns>Dominio applicazione appena creato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `info` viene omesso, viene utilizzato questo overload del metodo di <xref:System.AppDomainSetup> informazioni dal dominio applicazione predefinito.  
  
 Se `securityInfo` viene omesso, viene utilizzato l'evidenza del dominio applicazione corrente.  
  
> [!IMPORTANT]
>  Non utilizzare questo overload del metodo per creare i domini di applicazione creato mediante sandbox. A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], l'evidenza fornita per `securityInfo` non influiscono più set di concessioni del dominio dell'applicazione. Utilizzare il <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> overload del metodo per creare i domini di applicazione creato mediante sandbox.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato, in generale, come creare un dominio utilizzando uno del <xref:System.AppDomain.CreateDomain%2A> overload.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName">Nome descrittivo del dominio. Questo nome descrittivo può essere visualizzato nelle interfacce utente per identificare il dominio. Per altre informazioni, vedere la descrizione dell'oggetto <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidenza che stabilisce l'identità del codice che viene eseguito nel dominio applicazione. Passare <see langword="null" /> per usare l'evidenza del dominio applicazione corrente.</param>
        <param name="info">Oggetto contenente informazioni relative all'inizializzazione del dominio applicazione.</param>
        <param name="grantSet">Set di autorizzazioni predefinito concesso a tutti gli assembly caricati nel nuovo dominio applicazione a cui non sono concesse autorizzazioni specifiche.</param>
        <param name="fullTrustAssemblies">Matrice di nomi sicuri che rappresentano gli assembly da considerare come completamente attendibili nel nuovo dominio applicazione.</param>
        <summary>Crea un nuovo dominio applicazione usando il nome, l'evidenza, le informazioni di impostazione del dominio applicazione, il set di autorizzazioni predefinito e la matrice di assembly completamente attendibili specificati.</summary>
        <returns>Dominio applicazione appena creato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario impostare il <xref:System.AppDomainSetup.ApplicationBase%2A> proprietà del <xref:System.AppDomainSetup> oggetto che viene fornito per `info`. In caso contrario, viene generata un'eccezione.  
  
 Se `securityInfo` viene omesso, viene utilizzato l'evidenza del dominio applicazione corrente.  
  
 Le informazioni fornite per `grantSet` e `fullTrustAssemblies` viene utilizzato per creare un <xref:System.Security.Policy.ApplicationTrust> oggetto per il nuovo dominio applicazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il dominio applicazione è <see langword="null" />.  
  
 oppure  
  
 La proprietà <see cref="P:System.AppDomainSetup.ApplicationBase" /> non è impostata sull'oggetto <see cref="T:System.AppDomainSetup" /> fornito per <paramref name="info" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter creare e modificare un dominio applicazione. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Nome descrittivo del dominio. Questo nome descrittivo può essere visualizzato nelle interfacce utente per identificare il dominio. Per ulteriori informazioni, vedere <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidenza che stabilisce l'identità del codice che viene eseguito nel dominio applicazione. Passare <see langword="null" /> per usare l'evidenza del dominio applicazione corrente.</param>
        <param name="appBasePath">Directory di base usata dal resolver dell'assembly per verificare la presenza di assembly. Per ulteriori informazioni, vedere <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Percorso relativo alla directory di base in cui deve essere verificata la presenza di assembly privati mediante il resolver degli assembly. Per ulteriori informazioni, vedere <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">Se <see langword="true" />, nel dominio applicazione verrà caricata la copia shadow di un assembly.</param>
        <summary>Crea un nuovo dominio applicazione con il nome indicato mediante un'evidenza, un percorso base dell'applicazione, un percorso di ricerca relativo e un parametro che specifica se nel dominio applicazione deve essere caricata la copia shadow di un assembly.</summary>
        <returns>Dominio applicazione appena creato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `securityInfo` viene omesso, viene utilizzato l'evidenza del dominio applicazione corrente.  
  
 Per ulteriori informazioni sulla creazione di copie shadow, vedere <xref:System.AppDomain.ShadowCopyFiles%2A> e [copie Shadow di assembly](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  Non utilizzare questo overload del metodo per creare i domini di applicazione creato mediante sandbox. A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], l'evidenza fornita per `securityInfo` non influiscono più set di concessioni del dominio dell'applicazione. Utilizzare il <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> overload del metodo per creare i domini di applicazione creato mediante sandbox.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato, in generale, come creare un dominio utilizzando uno del <xref:System.AppDomain.CreateDomain%2A> overload.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" />
        <Parameter Name="adInitArgs" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Nome descrittivo del dominio. Questo nome descrittivo può essere visualizzato nelle interfacce utente per identificare il dominio. Per ulteriori informazioni, vedere <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidenza che stabilisce l'identità del codice che viene eseguito nel dominio applicazione. Passare <see langword="null" /> per usare l'evidenza del dominio applicazione corrente.</param>
        <param name="appBasePath">Directory di base usata dal resolver dell'assembly per verificare la presenza di assembly. Per ulteriori informazioni, vedere <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Percorso relativo alla directory di base in cui deve essere verificata la presenza di assembly privati mediante il resolver degli assembly. Per ulteriori informazioni, vedere <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">
          <see langword="true" /> per caricare una copia shadow di un assembly nel dominio applicazione.</param>
        <param name="adInit">Delegato <see cref="T:System.AppDomainInitializer" /> che rappresenta un metodo di callback da richiamare quando viene inizializzato il nuovo oggetto <see cref="T:System.AppDomain" />.</param>
        <param name="adInitArgs">Matrice di argomenti stringa da passare al metodo di callback rappresentato dal parametro <c>adInit</c> quando viene inizializzato il nuovo oggetto <see cref="T:System.AppDomain" />.</param>
        <summary>Crea un nuovo dominio applicazione con il nome indicato mediante un'evidenza, un percorso base dell'applicazione, un percorso di ricerca relativo e un parametro che specifica se nel dominio applicazione deve essere caricata la copia shadow di un assembly. Specifica un metodo di callback che viene richiamato quando viene inizializzato il dominio applicazione e indica una matrice di argomenti stringa da passare al metodo di callback.</summary>
        <returns>Dominio applicazione appena creato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo rappresentato dal `adInit` viene eseguito nel contesto del dominio applicazione appena creato.  
  
 Se `securityInfo` viene omesso, viene utilizzato l'evidenza del dominio applicazione corrente.  
  
 Per ulteriori informazioni sulla creazione di copie shadow, vedere <xref:System.AppDomain.ShadowCopyFiles%2A> e [copie Shadow di assembly](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  Non utilizzare questo overload del metodo per creare i domini di applicazione creato mediante sandbox. A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], l'evidenza fornita per `securityInfo` non influiscono più set di concessioni del dominio dell'applicazione. Utilizzare il <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> overload del metodo per creare i domini di applicazione creato mediante sandbox.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nuova istanza di un tipo specificato definito in un assembly specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nell'assembly specificato.</summary>
        <returns>Oggetto che rappresenta un wrapper per la nuova istanza specificata da <paramref name="typeName" />. Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo chiama il costruttore predefinito per `typeName`.  
  
 Vedere <xref:System.Reflection.AssemblyName> per il formato di `assemblyName`.  
  
 Un tentativo di chiamare <xref:System.AppDomain.CreateInstance%2A> una destinazione dominio dell'applicazione che non è il dominio applicazione corrente comporterà un caricamento ha esito positivo dell'assembly nel dominio dell'applicazione di destinazione. Poiché un <xref:System.Reflection.Assembly> non <xref:System.MarshalByRefObject>, quando questo metodo tenta di restituire il <xref:System.Reflection.Assembly> per l'assembly caricato nel dominio applicazione corrente, common language runtime tenterà di caricare l'assembly nel dominio applicazione corrente e il potrebbe non riuscire. L'assembly caricato nel dominio applicazione corrente potrebbe essere diverso dall'assembly è stato caricato prima di tutto se le impostazioni del percorso per i due domini applicazione sono diverse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">
          Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">Questa istanza è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
 Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nell'assembly specificato. Un parametro specifica una matrice di attributi di attivazione.</summary>
        <returns>Oggetto che rappresenta un wrapper per la nuova istanza specificata da <paramref name="typeName" />. Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo chiama il costruttore predefinito per `typeName`.  
  
 Vedere <xref:System.Reflection.AssemblyName> per il formato di `assemblyName`.  
  
 Un tentativo di chiamare <xref:System.AppDomain.CreateInstance%2A> una destinazione dominio dell'applicazione che non è il dominio applicazione corrente comporterà un caricamento ha esito positivo dell'assembly nel dominio dell'applicazione di destinazione. Poiché un <xref:System.Reflection.Assembly> non <xref:System.MarshalByRefObject>, quando questo metodo tenta di restituire il <xref:System.Reflection.Assembly> per l'assembly caricato nel dominio applicazione corrente, common language runtime tenterà di caricare l'assembly nel dominio applicazione corrente e il potrebbe non riuscire. L'assembly caricato nel dominio applicazione corrente potrebbe essere diverso dall'assembly è stato caricato prima di tutto se le impostazioni del percorso per i due domini applicazione sono diverse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.TypeLoadException">
          Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">Questa istanza è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Per poter leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Per poter richiamare operazioni su tutti i membri di tipo. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che consente l'associazione, la coercizione dei tipi di argomento, la chiamata dei membri e il recupero di oggetti <see cref="T:System.Reflection.MemberInfo" /> tramite reflection. Se <c>binder</c> è Null, verrà usato il binder predefinito.</param>
        <param name="args">Argomenti da passare al costruttore. La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo. Per usare il costruttore predefinito, <c>args</c> deve essere una matrice vuota o Null.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>typeName</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
 Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nell'assembly specificato. I parametri specificano uno strumento di associazione, i flag di associazione, gli argomenti del costruttore, le informazioni specifiche delle impostazioni cultura usate per interpretare gli argomenti e gli attributi di attivazione facoltativi.</summary>
        <returns>Oggetto che rappresenta un wrapper per la nuova istanza specificata da <paramref name="typeName" />. Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Reflection.AssemblyName> per il formato di `assemblyName`.  
  
 Un tentativo di chiamare <xref:System.AppDomain.CreateInstance%2A> una destinazione dominio dell'applicazione che non è il dominio applicazione corrente comporterà un caricamento ha esito positivo dell'assembly nel dominio dell'applicazione di destinazione. Poiché un <xref:System.Reflection.Assembly> non <xref:System.MarshalByRefObject>, quando questo metodo tenta di restituire il <xref:System.Reflection.Assembly> per l'assembly caricato nel dominio applicazione corrente, common language runtime tenterà di caricare l'assembly nel dominio applicazione corrente e il potrebbe non riuscire. L'assembly caricato nel dominio applicazione corrente potrebbe essere diverso dall'assembly è stato caricato prima di tutto se le impostazioni del percorso per i due domini applicazione sono diverse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
 oppure  
  
 <paramref name="assemblyName" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.TypeLoadException">
          Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">Questa istanza è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Per poter leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Per poter richiamare operazioni su tutti i membri di tipo. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che consente l'associazione, la coercizione dei tipi di argomento, la chiamata dei membri e il recupero di oggetti <see cref="T:System.Reflection.MemberInfo" /> tramite reflection. Se <c>binder</c> è Null, verrà usato il binder predefinito.</param>
        <param name="args">Argomenti da passare al costruttore. La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo. Per usare il costruttore predefinito, <c>args</c> deve essere una matrice vuota o Null.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>typeName</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
 Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <param name="securityAttributes">Informazioni usate per autorizzare la creazione di <c>typeName</c>.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nell'assembly specificato. I parametri specificano lo strumento di associazione, i flag di associazione, gli argomenti del costruttore, le informazioni specifiche delle impostazioni cultura usate per interpretare gli argomenti, gli attributi di attivazione e l'autorizzazione per la creazione del tipo.</summary>
        <returns>Oggetto che rappresenta un wrapper per la nuova istanza specificata da <paramref name="typeName" />. Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vedere <xref:System.Reflection.AssemblyName> per il formato di `assemblyName`.  
  
 Un tentativo di chiamare <xref:System.AppDomain.CreateInstance%2A> una destinazione dominio dell'applicazione che non è il dominio applicazione corrente comporterà un caricamento ha esito positivo dell'assembly nel dominio dell'applicazione di destinazione. Poiché un <xref:System.Reflection.Assembly> non <xref:System.MarshalByRefObject>, quando questo metodo tenta di restituire il <xref:System.Reflection.Assembly> per l'assembly caricato nel dominio applicazione corrente, common language runtime tenterà di caricare l'assembly nel dominio applicazione corrente e il potrebbe non riuscire. L'assembly caricato nel dominio applicazione corrente potrebbe essere diverso dall'assembly è stato caricato prima di tutto se le impostazioni del percorso per i due domini applicazione sono diverse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.  
  
 oppure  
  
 <paramref name="securityAttributes" /> non è <see langword="null" />. Quando i criteri di protezione dall'accesso di codice legacy non sono abilitati, <paramref name="securityAttributes" /> deve essere <see langword="null." /></exception>
        <exception cref="T:System.TypeLoadException">
          Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">Questa istanza è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Per poter leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Per poter richiamare operazioni su tutti i membri di tipo. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nuova istanza di un tipo specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <summary>Crea una nuova istanza del tipo specificato. I parametri specificano l'assembly in cui è definito il tipo e il nome del tipo.</summary>
        <returns>Istanza dell'oggetto specificato da <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstance%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Questo metodo chiama il costruttore predefinito per `typeName`.  
  
 Vedere <xref:System.Reflection.AssemblyName> per il formato di `assemblyName`. Vedere il <xref:System.Type.FullName%2A?displayProperty=nameWithType> proprietà per il formato di `typeName`.  
  
> [!NOTE]
>  Se si effettua una chiamata con associazione anticipata a un metodo `M` di un oggetto di tipo `T1` che è stato restituito da <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, e tale metodo effettua una chiamata con associazione anticipata a un metodo di un oggetto di tipo `T2` in un assembly `C` tranne il assembly corrente o l'assembly contenente `T1`, assembly `C` viene caricato nel dominio applicazione corrente. Il caricamento si verifica anche se l'associazione anticipata chiamata a `T1.M()` è stata effettuata nel corpo di un <xref:System.Reflection.Emit.DynamicMethod>, o in altro codice generato dinamicamente. Se il dominio corrente è il dominio predefinito, assembly `C` non può essere scaricato finché non termina il processo. Se il dominio corrente in un secondo momento tenta di caricare l'assembly `C`, potrebbe non riuscire.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il modo più semplice per eseguire codice in un altro dominio applicazione. Nell'esempio viene definita una classe denominata `Worker` che eredita da <xref:System.MarshalByRefObject>. La `Worker` classe definisce un metodo che visualizza il nome del dominio dell'applicazione in cui è in esecuzione. L'esempio crea istanze di `Worker` nel dominio applicazione predefinito in un nuovo dominio applicazione.  
  
> [!NOTE]
>  L'assembly che contiene `Worker` deve essere caricato in entrambi i domini applicazione, ma può caricare altri assembly che esiste solo nel nuovo dominio applicazione.  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">
          Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Per poter leggere il file contenente il manifesto dell'assembly, o se si sta creando un tipo da un modulo diverso dal file manifesto. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
 Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea una nuova istanza del tipo specificato. I parametri specificano l'assembly in cui è definito il tipo, il nome del tipo e una matrice di attributi di attivazione.</summary>
        <returns>Istanza dell'oggetto specificato da <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstance%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Questo metodo chiama il costruttore predefinito per `typeName`.  
  
 Vedere <xref:System.Reflection.AssemblyName> per il formato di `assemblyName`. Vedere il <xref:System.Type.FullName%2A?displayProperty=nameWithType> proprietà per il formato di `typeName`.  
  
> [!NOTE]
>  Se si effettua una chiamata con associazione anticipata a un metodo `M` di un oggetto di tipo `T1` che è stato restituito da <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, e tale metodo effettua una chiamata con associazione anticipata a un metodo di un oggetto di tipo `T2` in un assembly `C` tranne il assembly corrente o l'assembly contenente `T1`, assembly `C` viene caricato nel dominio applicazione corrente. Il caricamento si verifica anche se l'associazione anticipata chiamata a `T1.M()` è stata effettuata nel corpo di un <xref:System.Reflection.Emit.DynamicMethod>, o in altro codice generato dinamicamente. Se il dominio corrente è il dominio predefinito, assembly `C` non può essere scaricato finché non termina il processo. Se il dominio corrente in un secondo momento tenta di caricare l'assembly `C`, potrebbe non riuscire.  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">
          Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Per poter leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Per poter richiamare operazioni su tutti i membri di tipo. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che consente l'associazione, la coercizione dei tipi di argomento, la chiamata dei membri e il recupero di oggetti <see cref="T:System.Reflection.MemberInfo" /> tramite reflection. Se <c>binder</c> è Null, verrà usato il binder predefinito.</param>
        <param name="args">Argomenti da passare al costruttore. La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo. Per usare il costruttore predefinito, <c>args</c> deve essere una matrice vuota o Null.</param>
        <param name="culture">Oggetto specifico delle impostazioni cultura usato per regolare la coercizione dei tipi. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see langword="CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, corrisponde a una matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />. specifica l'URL necessario per attivare un oggetto remoto.  
  
 Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nell'assembly specificato, indicando se ignorare le maiuscole/minuscole del nome del tipo, gli attributi e lo strumento di associazione usati per selezionare il tipo da creare, gli argomenti del costruttore, le impostazioni cultura e gli attributi di attivazione.</summary>
        <returns>Istanza dell'oggetto specificato da <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstance%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Vedere <xref:System.Reflection.AssemblyName> per il formato di `assemblyName`. Vedere il <xref:System.Type.FullName%2A?displayProperty=nameWithType> proprietà per il formato di `typeName`.  
  
> [!NOTE]
>  Se si effettua una chiamata con associazione anticipata a un metodo `M` di un oggetto di tipo `T1` che è stato restituito da <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, e tale metodo effettua una chiamata con associazione anticipata a un metodo di un oggetto di tipo `T2` in un assembly `C` tranne il assembly corrente o l'assembly contenente `T1`, assembly `C` viene caricato nel dominio applicazione corrente. Il caricamento si verifica anche se l'associazione anticipata chiamata a `T1.M()` è stata effettuata nel corpo di un <xref:System.Reflection.Emit.DynamicMethod>, o in altro codice generato dinamicamente. Se il dominio corrente è il dominio predefinito, assembly `C` non può essere scaricato finché non termina il processo. Se il dominio corrente in un secondo momento tenta di caricare l'assembly `C`, potrebbe non riuscire.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato l'utilizzo del `ignoreCase` parametro.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">
          Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
 oppure  
  
 <paramref name="assemblyName" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Per poter leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per poter chiamare codice non gestito durante la creazione di un'istanza di un delegato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Per poter richiamare operazioni su tutti i membri di tipo. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che consente l'associazione, la coercizione dei tipi di argomento, la chiamata dei membri e il recupero di oggetti <see cref="T:System.Reflection.MemberInfo" /> tramite reflection. Se <c>binder</c> è Null, verrà usato il binder predefinito.</param>
        <param name="args">Argomenti da passare al costruttore. La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo. Per usare il costruttore predefinito, <c>args</c> deve essere una matrice vuota o Null.</param>
        <param name="culture">Oggetto specifico delle impostazioni cultura usato per regolare la coercizione dei tipi. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see langword="CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
 Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <param name="securityAttributes">Informazioni usate per autorizzare la creazione di <c>typeName</c>.</param>
        <summary>Crea una nuova istanza del tipo specificato. I parametri specificano il nome del tipo e le relative modalità di individuazione e creazione.</summary>
        <returns>Istanza dell'oggetto specificato da <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstance%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Vedere <xref:System.Reflection.AssemblyName> per il formato di `assemblyName`. Vedere il <xref:System.Type.FullName%2A?displayProperty=nameWithType> proprietà per il formato di `typeName`.  
  
> [!NOTE]
>  Se si effettua una chiamata con associazione anticipata a un metodo `M` di un oggetto di tipo `T1` che è stato restituito da <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, e tale metodo effettua una chiamata con associazione anticipata a un metodo di un oggetto di tipo `T2` in un assembly `C` tranne il assembly corrente o l'assembly contenente `T1`, assembly `C` viene caricato nel dominio applicazione corrente. Il caricamento si verifica anche se l'associazione anticipata chiamata a `T1.M()` è stata effettuata nel corpo di un <xref:System.Reflection.Emit.DynamicMethod>, o in altro codice generato dinamicamente. Se il dominio corrente è il dominio predefinito, assembly `C` non può essere scaricato finché non termina il processo. Se il dominio corrente in un secondo momento tenta di caricare l'assembly `C`, potrebbe non riuscire.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato l'utilizzo del `ignoreCase` parametro.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> o <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">
          Non è possibile trovare <paramref name="typename" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha l'autorizzazione necessaria per chiamare il costruttore.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Per poter leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Per poter richiamare operazioni su tutti i membri di tipo. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nuova istanza di un tipo specificato definito nel file di assembly specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome di un file, comprensivo di percorso, contenente un assembly in cui viene definito il tipo richiesto. L'assembly viene caricato utilizzando il metodo <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nel file di assembly specificato.</summary>
        <returns>Wrapper per la nuova istanza oppure <see langword="null" /> se <paramref name="typeName" /> non viene trovato. Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il costruttore predefinito per `typeName` viene richiamato.  
  
 Per altre informazioni, vedere il metodo <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Quando il <xref:System.AppDomain.CreateInstanceFrom%2A> metodo viene utilizzato per creare un'istanza in un dominio di applicazione di destinazione diverso dal dominio di applicazione da cui viene effettuata la chiamata, l'assembly viene caricato nel dominio dell'applicazione di destinazione. Tuttavia, se l'istanza è annullato il wrapping nel dominio dell'applicazione chiamante, utilizzando l'istanza annullato il wrapping in determinati modi può causare l'assembly nel dominio applicazione chiamante deve essere caricata. Ad esempio, dopo che l'istanza è annullato il wrapping, potrebbero richiedere le informazioni sul tipo, per chiamare i metodi ad associazione tardiva. Quando l'assembly viene caricato nel dominio applicazione chiamante, possono verificarsi eccezioni.  
  
-   Se un'altra versione dello stesso assembly in precedenza è stata caricata nel dominio applicazione chiamante oppure se il percorso di caricamento del dominio applicazione chiamante è diverso da quello del dominio dell'applicazione di destinazione, le eccezioni, ad esempio <xref:System.MissingMethodException> possono verificarsi.  
  
-   Se il dominio applicazione chiamante effettua chiamate ad associazione anticipata per il tipo di istanza <xref:System.InvalidCastException> può essere generata quando viene effettuato un tentativo di cast dell'istanza.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> overload del metodo per creare un'istanza di un oggetto in un dominio di applicazione di destinazione e chiamarne i metodi.  
  
 Nell'esempio viene definita la `MarshallableExample` classe, che può essere sottoposto a marshalling attraverso i limiti del dominio applicazione. Nell'esempio viene compilato un percorso per l'assembly attualmente in esecuzione, crea un dominio di applicazione di destinazione e utilizza il <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> overload del metodo per caricare l'assembly di esempio nel dominio applicazione di destinazione e creare un'istanza di `MarshallableExample`.  
  
> [!NOTE]
>  Il percorso è assoluto in questo esempio, ma un percorso relativo funzionerà anche perché il <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> metodo viene utilizzato per caricare l'assembly.  
  
 Dopo l'annullamento del wrapping l'handle di oggetto, l'esempio illustra tre modi per utilizzare un oggetto in un dominio di applicazione di destinazione:  
  
-   Richiama un metodo con associazione tardiva, tramite reflection. Ciò richiede informazioni sul tipo, determinando l'assembly da caricare nel dominio applicazione del chiamante. (In questo esempio, è già caricato.)  
  
-   Il cast dell'oggetto a un'interfaccia definita per il chiamante e chiamato. Se l'interfaccia è definita nell'assembly chiamante o in un terzo assembly a cui fa riferimento il chiamante e chiamato, l'assembly chiamato non è caricato nel dominio applicazione del chiamante.  
  
-   Utilizzo dell'oggetto direttamente quando il relativo tipo è noto al chiamante. L'assembly deve essere caricato nel dominio applicazione del chiamante.  
  
 È possibile evitare di caricare l'assembly chiamato nel dominio applicazione del chiamante per il chiamante da cui derivare la <xref:System.MarshalByRefObject> classe e per definire un metodo che può essere eseguito nel dominio dell'applicazione di destinazione. Tale metodo può usare la reflection per esaminare un assembly di destinazione, perché l'assembly di destinazione è già caricato nel dominio applicazione di destinazione. Vedere l'esempio per la <xref:System.AppDomain.DynamicDirectory%2A> proprietà.  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Il parametro <paramref name="assemblyFile" /> non è stato trovato.</exception>
        <exception cref="T:System.TypeLoadException">
          Non è possibile trovare <paramref name="typeName" /> in <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico senza parametri.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.NullReferenceException">Questa istanza è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Per poter leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome di un file, comprensivo di percorso, contenente un assembly in cui viene definito il tipo richiesto. L'assembly viene caricato utilizzando il metodo <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
 Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nel file di assembly specificato.</summary>
        <returns>Wrapper per la nuova istanza oppure <see langword="null" /> se <paramref name="typeName" /> non viene trovato. Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il costruttore predefinito per `typeName` viene richiamato.  
  
 Per ulteriori informazioni su questo metodo, vedere il <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metodo.  
  
 Quando il <xref:System.AppDomain.CreateInstanceFrom%2A> metodo viene utilizzato per creare un'istanza in un dominio di applicazione di destinazione diverso dal dominio di applicazione da cui viene effettuata la chiamata, l'assembly viene caricato nel dominio dell'applicazione di destinazione. Tuttavia, se l'istanza è annullato il wrapping nel dominio dell'applicazione chiamante, utilizzando l'istanza annullato il wrapping in determinati modi può causare l'assembly nel dominio applicazione chiamante deve essere caricata. Ad esempio, dopo che l'istanza è annullato il wrapping, potrebbero richiedere le informazioni sul tipo, per chiamare i metodi ad associazione tardiva. Quando l'assembly viene caricato nel dominio applicazione chiamante, possono verificarsi eccezioni.  
  
-   Se un'altra versione dello stesso assembly in precedenza è stata caricata nel dominio applicazione chiamante oppure se il percorso di caricamento del dominio applicazione chiamante è diverso da quello del dominio dell'applicazione di destinazione, le eccezioni, ad esempio <xref:System.MissingMethodException> possono verificarsi.  
  
-   Se il dominio applicazione chiamante effettua chiamate ad associazione anticipata per il tipo di istanza <xref:System.InvalidCastException> può essere generata quando viene effettuato un tentativo di cast dell'istanza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Il parametro <paramref name="assemblyFile" /> non è stato trovato.</exception>
        <exception cref="T:System.TypeLoadException">
          Non è possibile trovare <paramref name="typeName" /> in <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.NullReferenceException">Questa istanza è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Per poter leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome di un file, comprensivo di percorso, contenente un assembly in cui viene definito il tipo richiesto. L'assembly viene caricato utilizzando il metodo <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che consente l'associazione, la coercizione di tipi di argomento, la chiamata di membri e il recupero di oggetti <see cref="T:System.Reflection.MemberInfo" /> tramite la reflection. Se <c>binder</c> è Null, verrà usato il binder predefinito.</param>
        <param name="args">Argomenti da passare al costruttore. La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo. Per usare il costruttore predefinito, <c>args</c> deve essere una matrice vuota o Null.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>typeName</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
 Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nel file di assembly specificato.</summary>
        <returns>Wrapper per la nuova istanza oppure <see langword="null" /> se <paramref name="typeName" /> non viene trovato. Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per altre informazioni, vedere il metodo <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Quando il <xref:System.AppDomain.CreateInstanceFrom%2A> metodo viene utilizzato per creare un'istanza in un dominio di applicazione di destinazione diverso dal dominio di applicazione da cui viene effettuata la chiamata, l'assembly viene caricato nel dominio dell'applicazione di destinazione. Tuttavia, se l'istanza è annullato il wrapping nel dominio dell'applicazione chiamante, utilizzando l'istanza annullato il wrapping in determinati modi può causare l'assembly nel dominio applicazione chiamante deve essere caricata. Ad esempio, dopo che l'istanza è annullato il wrapping, potrebbero richiedere le informazioni sul tipo, per chiamare i metodi ad associazione tardiva. Quando l'assembly viene caricato nel dominio applicazione chiamante, possono verificarsi eccezioni.  
  
-   Se un'altra versione dello stesso assembly in precedenza è stata caricata nel dominio applicazione chiamante oppure se il percorso di caricamento del dominio applicazione chiamante è diverso da quello del dominio dell'applicazione di destinazione, le eccezioni, ad esempio <xref:System.MissingMethodException> possono verificarsi.  
  
-   Se il dominio applicazione chiamante effettua chiamate ad associazione anticipata per il tipo di istanza <xref:System.InvalidCastException> può essere generata quando viene effettuato un tentativo di cast dell'istanza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Il parametro <paramref name="assemblyFile" /> non è stato trovato.</exception>
        <exception cref="T:System.TypeLoadException">
          Non è possibile trovare <paramref name="typeName" /> in <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
 oppure  
  
 <paramref name="assemblyFile" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.NullReferenceException">Questa istanza è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Per poter leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome di un file, comprensivo di percorso, contenente un assembly in cui viene definito il tipo richiesto. L'assembly viene caricato utilizzando il metodo <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che consente l'associazione, la coercizione di tipi di argomento, la chiamata di membri e il recupero di oggetti <see cref="T:System.Reflection.MemberInfo" /> tramite la reflection. Se <c>binder</c> è Null, verrà usato il binder predefinito.</param>
        <param name="args">Argomenti da passare al costruttore. La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo. Per usare il costruttore predefinito, <c>args</c> deve essere una matrice vuota o Null.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>typeName</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
 Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <param name="securityAttributes">Informazioni usate per autorizzare la creazione di <c>typeName</c>.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nel file di assembly specificato.</summary>
        <returns>Wrapper per la nuova istanza oppure <see langword="null" /> se <paramref name="typeName" /> non viene trovato. Per accedere all'oggetto reale è necessario rimuovere il wrapping del valore restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni su questo metodo, vedere il <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metodo.  
  
 Quando il <xref:System.AppDomain.CreateInstanceFrom%2A> metodo viene utilizzato per creare un'istanza in un dominio di applicazione di destinazione diverso dal dominio di applicazione da cui viene effettuata la chiamata, l'assembly viene caricato nel dominio dell'applicazione di destinazione. Tuttavia, se l'istanza è annullato il wrapping nel dominio dell'applicazione chiamante, utilizzando l'istanza annullato il wrapping in determinati modi può causare l'assembly nel dominio applicazione chiamante deve essere caricata. Ad esempio, dopo che l'istanza è annullato il wrapping, potrebbero richiedere le informazioni sul tipo, per chiamare i metodi ad associazione tardiva. Quando l'assembly viene caricato nel dominio applicazione chiamante, possono verificarsi eccezioni.  
  
-   Se un'altra versione dello stesso assembly in precedenza è stata caricata nel dominio applicazione chiamante oppure se il percorso di caricamento del dominio applicazione chiamante è diverso da quello del dominio dell'applicazione di destinazione, le eccezioni, ad esempio <xref:System.MissingMethodException> possono verificarsi.  
  
-   Se il dominio applicazione chiamante effettua chiamate ad associazione anticipata per il tipo di istanza <xref:System.InvalidCastException> può essere generata quando viene effettuato un tentativo di cast dell'istanza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.  
  
 oppure  
  
 <paramref name="securityAttributes" /> non è <see langword="null" />. Quando i criteri di sicurezza dall'accesso di codice legacy non sono abilitati, <paramref name="securityAttributes" /> deve essere <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Il parametro <paramref name="assemblyFile" /> non è stato trovato.</exception>
        <exception cref="T:System.TypeLoadException">
          Non è possibile trovare <paramref name="typeName" /> in <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.NullReferenceException">Questa istanza è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Per poter leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nuova istanza di un tipo specificato definito nel file di assembly specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome e percorso del file dell'assembly in cui viene definito il tipo richiesto.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nel file di assembly specificato.</summary>
        <returns>Oggetto richiesto o <see langword="null" /> se <paramref name="typeName" /> non è stato trovato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Questo metodo chiama il costruttore predefinito per `typeName`.  
  
 Per altre informazioni, vedere il metodo <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.TypeLoadException">
          Non è possibile trovare <paramref name="typeName" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico senza parametri.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Per poter leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome e percorso del file dell'assembly in cui viene definito il tipo richiesto.</param>
        <param name="typeName">Nome completo del tipo richiesto, incluso lo spazio dei nomi ma non l'assembly (vedere la proprietà <see cref="P:System.Type.FullName" />).</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
 Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nel file di assembly specificato.</summary>
        <returns>Oggetto richiesto o <see langword="null" /> se <paramref name="typeName" /> non è stato trovato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Questo metodo chiama il costruttore predefinito per `typeName`.  
  
 Per ulteriori informazioni su questo metodo, vedere il <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.TypeLoadException">
          Non è possibile trovare <paramref name="typeName" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico senza parametri.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Per poter leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome e percorso del file dell'assembly in cui viene definito il tipo richiesto.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che consente l'associazione, la coercizione di tipi di argomento, la chiamata di membri e il recupero di oggetti <see cref="T:System.Reflection.MemberInfo" /> tramite la reflection. Se <c>binder</c> è Null, verrà usato il binder predefinito.</param>
        <param name="args">Argomenti da passare al costruttore. La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo. Per usare il costruttore predefinito, <c>args</c> deve essere una matrice vuota o Null.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>typeName</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
 Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nel file di assembly specificato, indicando se ignorare le maiuscole/minuscole del nome del tipo, gli attributi e lo strumento di associazione usati per selezionare il tipo da creare, gli argomenti del costruttore, le impostazioni cultura e gli attributi di attivazione.</summary>
        <returns>Oggetto richiesto o <see langword="null" /> se <paramref name="typeName" /> non è stato trovato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Per ulteriori informazioni su questo metodo, vedere il <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.TypeLoadException">
          Non è possibile trovare <paramref name="typeName" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
 oppure  
  
 <paramref name="assemblyName" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Per poter leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome e percorso del file dell'assembly in cui viene definito il tipo richiesto.</param>
        <param name="typeName">Nome completo del tipo richiesto, compreso lo spazio dei nomi ed escluso l'assembly, restituito dalla proprietà <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valore booleano che indica se deve o meno essere eseguita una ricerca con distinzione tra maiuscole e minuscole.</param>
        <param name="bindingAttr">Combinazione di zero o più flag di bit che influiscono sulla ricerca del costruttore <c>typeName</c>. Se <c>bindingAttr</c> è uguale a zero, verrà eseguita una ricerca di costruttori pubblici con distinzione tra maiuscole e minuscole.</param>
        <param name="binder">Oggetto che consente l'associazione, la coercizione di tipi di argomento, la chiamata di membri e il recupero di oggetti <see cref="T:System.Reflection.MemberInfo" /> tramite la reflection. Se <c>binder</c> è Null, verrà usato il binder predefinito.</param>
        <param name="args">Argomenti da passare al costruttore. La matrice di argomenti deve corrispondere ai parametri del costruttore da richiamare in quanto a numero, ordine e tipo. Per usare il costruttore predefinito, <c>args</c> deve essere una matrice vuota o Null.</param>
        <param name="culture">Informazioni specifiche delle impostazioni cultura che regolano la coercizione di <c>args</c> ai tipi formali dichiarati per il costruttore <c>typeName</c>. Se <c>culture</c> è <see langword="null" />, per il thread corrente verrà usato l'oggetto <see cref="T:System.Globalization.CultureInfo" />.</param>
        <param name="activationAttributes">Matrice di uno o più attributi che possono prendere parte all'attivazione. In genere, matrice che contiene un singolo oggetto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> che specifica l'URL necessario per attivare un oggetto remoto.  
  
 Il parametro è correlato agli oggetti attivati dal client. L'attivazione del client è una tecnologia legacy mantenuta per garantire la compatibilità con le versioni precedenti, ma non è consigliata per nuove attività di sviluppo. Per le applicazioni distribuite si dovrebbe usare invece Windows Communication Foundation.</param>
        <param name="securityAttributes">Informazioni usate per autorizzare la creazione di <c>typeName</c>.</param>
        <summary>Crea una nuova istanza del tipo specificato definito nel file di assembly specificato.</summary>
        <returns>Oggetto richiesto o <see langword="null" /> se <paramref name="typeName" /> non è stato trovato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tratta di un metodo pratico che combina <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Per ulteriori informazioni su questo metodo, vedere il <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il chiamante non può fornire attributi di attivazione per un oggetto che non eredita da <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Il parametro <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.TypeLoadException">
          Non è possibile trovare <paramref name="typeName" /> in <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è stato trovato alcun costruttore pubblico corrispondente.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha autorizzazioni sufficienti per chiamare il costruttore.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'oggetto <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Per poter leggere il file che contiene il manifesto dell'assembly. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il dominio applicazione corrente per l'oggetto <see cref="T:System.Threading.Thread" /> corrente.</summary>
        <value>Dominio applicazione corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio di codice riportato di seguito viene creato un nuovo dominio dell'applicazione. La proprietà <xref:System.AppDomain.CurrentDomain%2A> viene utilizzata per ottenere un oggetto <xref:System.AppDomain> che rappresenta il dominio dell'applicazione corrente. Il <xref:System.AppDomain.FriendlyName%2A> proprietà fornisce il nome del dominio applicazione corrente, che viene quindi visualizzato nella riga di comando.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definisce un assembly dinamico nel dominio applicazione corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità di accesso per l'assembly dinamico.</param>
        <summary>Definisce un assembly dinamico con nome e modalità di accesso specificati.</summary>
        <returns>Assembly dinamico con il nome e la modalità di accesso specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente. Per ulteriori informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
> [!NOTE]
>  Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile utilizzare un overload di <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo che specifica l'evidenza e le autorizzazioni, fornire l'evidenza l'assembly dinamico e includere <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> nel `refusedPermissions` parametro assicura che il codice MSIL viene verificato. Una limitazione di questa tecnica è che fa in modo <xref:System.Security.SecurityException> quando usato con il codice che richiede l'attendibilità totale.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.DefineDynamicAssembly%2A> (metodo) e <xref:System.AppDomain.AssemblyResolve> evento.  
  
 Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità di accesso per l'assembly dinamico.</param>
        <param name="assemblyAttributes">Elenco enumerabile di attributi da applicare all'assembly oppure <see langword="null" /> se non sono presenti attributi.</param>
        <summary>Definisce un assembly dinamico con il nome, la modalità di accesso e gli attributi personalizzati specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload del metodo per specificare gli attributi che non funzionano correttamente a meno che non vengono applicate quando viene creato un assembly dinamico. Ad esempio, attributi di sicurezza, ad esempio <xref:System.Security.SecurityTransparentAttribute> e <xref:System.Security.SecurityCriticalAttribute> non funzionano correttamente se vengono aggiunti dopo aver creato un assembly dinamico.  
  
 Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente. Per ulteriori informazioni su questa restrizione, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
 Questo overload del metodo è stato introdotto nel [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
   
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato come creare un assembly dinamico con il <xref:System.Security.SecurityTransparentAttribute>. L'attributo deve essere specificato come elemento di una matrice di <xref:System.Reflection.Emit.CustomAttributeBuilder> oggetti.  
  
 Il primo passaggio nella creazione di <xref:System.Reflection.Emit.CustomAttributeBuilder> consiste nell'ottenere un costruttore per l'attributo. Il costruttore non ha parametri, pertanto la <xref:System.Type.GetConstructor%2A> metodo viene chiamato con una matrice vuota di <xref:System.Type> oggetti per rappresentare i tipi dei parametri. Il secondo passaggio consiste nel passare il valore risultante <xref:System.Reflection.ConstructorInfo> oggetto per il costruttore di <xref:System.Reflection.Emit.CustomAttributeBuilder> (classe), insieme a una matrice vuota di tipo <xref:System.Object> per rappresentare gli argomenti.  
  
 Il valore risultante <xref:System.Reflection.Emit.CustomAttributeBuilder> viene quindi passato al <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo come l'unico elemento di matrice.  
  
 Nell'esempio di codice definisce un modulo e un tipo nell'assembly dinamico nuovo e quindi Visualizza gli attributi dell'assembly.  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto oppure contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità mediante cui si accederà all'assembly dinamico.</param>
        <param name="evidence">Evidenza fornita per l'assembly dinamico. L'evidenza viene usata senza modifiche come il set di evidenza finale impiegato per la risoluzione dei criteri.</param>
        <summary>Definisce un assembly dinamico tramite il nome, la modalità di accesso e l'evidenza specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo completamente attendibili i chiamanti possono fornire loro `evidence` quando si definisce un dinamico <xref:System.Reflection.Assembly>. Il runtime eseguirà il mapping di <xref:System.Security.Policy.Evidence> tramite i criteri di sicurezza per determinare le autorizzazioni concesse. Chiamanti parzialmente attendibili devono fornire un valore null `evidence`. Se `evidence` è `null`, il runtime copierà i set di autorizzazioni, vale a dire corrente concedere e negare set, da parte del chiamante <xref:System.Reflection.Assembly> per dinamica <xref:System.Reflection.Assembly> viene definito e contrassegna i criteri come risolti.  
  
 Se dinamica <xref:System.Reflection.Assembly> viene salvato su disco, caricamenti successivi verranno concesse in base ai criteri associati al percorso in cui il <xref:System.Reflection.Assembly> è stato salvato.  
  
 Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente. Per ulteriori informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
> [!NOTE]
>  Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile utilizzare un overload di <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo che specifica l'evidenza e le autorizzazioni, fornire l'evidenza l'assembly dinamico e includere <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> nel `refusedPermissions` parametro assicura che il codice MSIL viene verificato. Una limitazione di questa tecnica è che fa in modo <xref:System.Security.SecurityException> quando usato con il codice che richiede l'attendibilità totale.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.DefineDynamicAssembly%2A> (metodo) e <xref:System.AppDomain.AssemblyResolve> evento.  
  
 In primo luogo, l'esempio di codice tenta di creare un'istanza di `MyDynamicType` chiamando il <xref:System.AppDomain.CreateInstance%2A> metodo con un nome di assembly non valido e rileva l'eccezione risulta.  
  
 L'esempio di codice aggiunge quindi un gestore eventi per il <xref:System.AppDomain.AssemblyResolve> evento e si tenta nuovamente di creare un'istanza di`MyDynamicType`. Durante la chiamata a <xref:System.AppDomain.CreateInstance%2A>, <xref:System.AppDomain.AssemblyResolve> evento viene generato per l'assembly non valido. Il gestore eventi crea un assembly dinamico che contiene un tipo denominato `MyDynamicType`, fornisce il tipo di un costruttore senza parametri e restituisce il nuovo assembly dinamico. La chiamata a <xref:System.AppDomain.CreateInstance%2A> quindi completata correttamente e il costruttore per `MyDynamicType` Visualizza un messaggio nella console.  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità mediante cui si accederà all'assembly dinamico.</param>
        <param name="dir">Nome della directory nella quale verrà salvato l'assembly. Se <c>dir</c> è <see langword="null" />, la directory predefinita sarà la directory corrente.</param>
        <summary>Definisce un assembly dinamico usando il nome, la modalità di accesso e la directory di archiviazione specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente. Per ulteriori informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
> [!NOTE]
>  Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile utilizzare un overload di <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo che specifica l'evidenza e le autorizzazioni, fornire l'evidenza l'assembly dinamico e includere <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> nel `refusedPermissions` parametro assicura che il codice MSIL viene verificato. Una limitazione di questa tecnica è che fa in modo <xref:System.Security.SecurityException> quando usato con il codice che richiede l'attendibilità totale.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.DefineDynamicAssembly%2A> (metodo) e <xref:System.AppDomain.AssemblyResolve> evento.  
  
 Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità di accesso per l'assembly dinamico.</param>
        <param name="assemblyAttributes">Elenco enumerabile di attributi da applicare all'assembly oppure <see langword="null" /> se non sono presenti attributi.</param>
        <param name="securityContextSource">Origine del contesto di sicurezza.</param>
        <summary>Definisce un assembly dinamico con il nome, la modalità di accesso e gli attributi personalizzati specificati e usando il database di origine specificato per il contesto di sicurezza.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload del metodo per specificare gli attributi che non funzionano correttamente a meno che non vengono applicate quando viene creato un assembly dinamico. Ad esempio, attributi di sicurezza, ad esempio <xref:System.Security.SecurityTransparentAttribute> e <xref:System.Security.SecurityCriticalAttribute> non funzionano correttamente se vengono aggiunti dopo aver creato un assembly dinamico.  
  
 Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente. Per ulteriori informazioni su questa restrizione, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto oppure contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="securityContextSource" /> non è uno dei valori di enumerazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità mediante cui si accederà all'assembly dinamico.</param>
        <param name="dir">Nome della directory nella quale verrà salvato l'assembly. Se <c>dir</c> è <see langword="null" />, la directory predefinita sarà la directory corrente.</param>
        <param name="evidence">Evidenza fornita per l'assembly dinamico. L'evidenza viene usata senza modifiche come il set di evidenza finale impiegato per la risoluzione dei criteri.</param>
        <summary>Definisce un assembly dinamico mediante il nome, la modalità di accesso, la directory di archiviazione e l'evidenza specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo completamente attendibili i chiamanti possono fornire loro `evidence` quando si definisce un dinamico <xref:System.Reflection.Assembly>. Il runtime eseguirà il mapping di <xref:System.Security.Policy.Evidence> tramite i criteri di sicurezza per determinare le autorizzazioni concesse. Chiamanti parzialmente attendibili devono fornire un valore null `evidence`. Se `evidence` è `null`, il runtime copierà i set di autorizzazioni, vale a dire corrente concedere e negare set, da parte del chiamante <xref:System.Reflection.Assembly> per dinamica <xref:System.Reflection.Assembly> viene definito e contrassegna i criteri come risolti.  
  
 Se dinamica <xref:System.Reflection.Assembly> viene salvato su disco, caricamenti successivi verranno concesse in base ai criteri associati al percorso in cui il <xref:System.Reflection.Assembly> è stato salvato.  
  
 Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente. Per ulteriori informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
> [!NOTE]
>  Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile utilizzare un overload di <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo che specifica l'evidenza e le autorizzazioni, fornire l'evidenza l'assembly dinamico e includere <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> nel `refusedPermissions` parametro assicura che il codice MSIL viene verificato. Una limitazione di questa tecnica è che fa in modo <xref:System.Security.SecurityException> quando usato con il codice che richiede l'attendibilità totale.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.DefineDynamicAssembly%2A> (metodo) e <xref:System.AppDomain.AssemblyResolve> evento.  
  
 Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità mediante cui si accederà all'assembly dinamico.</param>
        <param name="requiredPermissions">Richiesta di autorizzazioni obbligatoria.</param>
        <param name="optionalPermissions">Richiesta di autorizzazioni facoltativa.</param>
        <param name="refusedPermissions">Richiesta di autorizzazioni rifiutata.</param>
        <summary>Definisce un assembly dinamico usando il nome, la modalità di accesso e le richieste di autorizzazione specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le richieste di autorizzazione specificate per `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` non vengono utilizzate, a meno che l'assembly dinamico è stato salvato e ricaricato in memoria. Per specificare le richieste di autorizzazione per un assembly temporaneo che non viene mai salvato su disco, utilizzare l'overload del metodo di <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo che specifica l'evidenza anche come richiesto e autorizzazioni, fornire un <xref:System.Security.Policy.Evidence> oggetto.  
  
> [!NOTE]
>  Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile utilizzare un overload di <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo che specifica l'evidenza e le autorizzazioni, fornire l'evidenza l'assembly dinamico e includere <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> nel `refusedPermissions` parametro assicura che il codice MSIL viene verificato. Una limitazione di questa tecnica è che fa in modo <xref:System.Security.SecurityException> quando usato con il codice che richiede l'attendibilità totale.  
  
 Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente. Per ulteriori informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.DefineDynamicAssembly%2A> (metodo) e <xref:System.AppDomain.AssemblyResolve> evento.  
  
 Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità mediante cui si accederà all'assembly dinamico.</param>
        <param name="dir">Nome della directory nella quale verrà salvato l'assembly dinamico. Se <c>dir</c> è <see langword="null" />, viene usata la directory corrente.</param>
        <param name="isSynchronized">
          <see langword="true" /> per sincronizzare la creazione di moduli, tipi e membri nell'assembly dinamico; in caso contrario, <see langword="false" />.</param>
        <param name="assemblyAttributes">Elenco enumerabile di attributi da applicare all'assembly oppure <see langword="null" /> se non sono presenti attributi.</param>
        <summary>Definisce un assembly dinamico usando il nome, la modalità di accesso, la directory di archiviazione e l'opzione di sincronizzazione specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload del metodo per specificare gli attributi che non funzionano correttamente a meno che non vengono applicate quando viene creato un assembly dinamico. Ad esempio, attributi di sicurezza, ad esempio <xref:System.Security.SecurityTransparentAttribute> e <xref:System.Security.SecurityCriticalAttribute> non funzionano correttamente se vengono aggiunti dopo aver creato un assembly dinamico.  
  
 Se `isSynchronized` è `true`, i metodi seguenti dell'oggetto risultante <xref:System.Reflection.Emit.AssemblyBuilder> verranno sincronizzati: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, e <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Se due di questi metodi vengono chiamati in thread diversi, uno verrà bloccata fino al completamento di altri.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto oppure contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità mediante cui si accederà all'assembly dinamico.</param>
        <param name="evidence">Evidenza fornita per l'assembly dinamico. L'evidenza viene usata senza modifiche come il set di evidenza finale impiegato per la risoluzione dei criteri.</param>
        <param name="requiredPermissions">Richiesta di autorizzazioni obbligatoria.</param>
        <param name="optionalPermissions">Richiesta di autorizzazioni facoltativa.</param>
        <param name="refusedPermissions">Richiesta di autorizzazioni rifiutata.</param>
        <summary>Definisce un assembly dinamico usando il nome, la modalità di accesso, l'evidenza e le richieste di autorizzazione specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le richieste di autorizzazione specificate per `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` vengono utilizzate solo se `evidence` viene anche fornito, o se l'assembly dinamico viene salvato e ricaricato in memoria.  
  
> [!NOTE]
>  Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile includere <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> nel `refusedPermissions` parametro assicura che il codice MSIL viene verificato. Una limitazione di questa tecnica è che fa in modo <xref:System.Security.SecurityException> quando usato con il codice che richiede l'attendibilità totale.  
  
 Solo completamente attendibili i chiamanti possono fornire loro `evidence` quando si definisce un dinamico <xref:System.Reflection.Assembly>. Il runtime eseguirà il mapping di <xref:System.Security.Policy.Evidence> tramite i criteri di sicurezza per determinare le autorizzazioni concesse. Chiamanti parzialmente attendibili devono fornire un valore null `evidence`. Se `evidence` è `null`, il runtime copierà i set di autorizzazioni, vale a dire corrente concedere e negare set, da parte del chiamante <xref:System.Reflection.Assembly> per dinamica <xref:System.Reflection.Assembly> viene definito e contrassegna i criteri come risolti.  
  
 Se dinamica <xref:System.Reflection.Assembly> viene salvato su disco, caricamenti successivi verranno concesse in base ai criteri associati al percorso in cui il <xref:System.Reflection.Assembly> è stato salvato.  
  
 Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente. Per ulteriori informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.DefineDynamicAssembly%2A> (metodo) e <xref:System.AppDomain.AssemblyResolve> evento.  
  
 Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità mediante cui si accederà all'assembly dinamico.</param>
        <param name="dir">Nome della directory nella quale verrà salvato l'assembly. Se <c>dir</c> è <see langword="null" />, la directory predefinita sarà la directory corrente.</param>
        <param name="requiredPermissions">Richiesta di autorizzazioni obbligatoria.</param>
        <param name="optionalPermissions">Richiesta di autorizzazioni facoltativa.</param>
        <param name="refusedPermissions">Richiesta di autorizzazioni rifiutata.</param>
        <summary>Definisce un assembly dinamico usando il nome, la modalità di accesso, la directory di archiviazione e le richieste di autorizzazione specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le richieste di autorizzazione specificate per `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` non vengono utilizzate, a meno che l'assembly dinamico è stato salvato e ricaricato in memoria. Per specificare le richieste di autorizzazione per un assembly temporaneo che non viene mai salvato su disco, utilizzare l'overload del metodo di <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo che specifica l'evidenza anche come richiesto e autorizzazioni, fornire un <xref:System.Security.Policy.Evidence> oggetto.  
  
> [!NOTE]
>  Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile utilizzare un overload di <xref:System.AppDomain.DefineDynamicAssembly%2A> metodo che specifica l'evidenza e le autorizzazioni, fornire l'evidenza l'assembly dinamico e includere <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> nel `refusedPermissions` parametro assicura che il codice MSIL viene verificato. Una limitazione di questa tecnica è che fa in modo <xref:System.Security.SecurityException> quando usato con il codice che richiede l'attendibilità totale.  
  
 Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente. Per ulteriori informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.DefineDynamicAssembly%2A> (metodo) e <xref:System.AppDomain.AssemblyResolve> evento.  
  
 Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità mediante cui si accederà all'assembly dinamico.</param>
        <param name="dir">Nome della directory nella quale verrà salvato l'assembly. Se <c>dir</c> è <see langword="null" />, la directory predefinita sarà la directory corrente.</param>
        <param name="evidence">Evidenza fornita per l'assembly dinamico. L'evidenza viene usata senza modifiche come il set di evidenza finale impiegato per la risoluzione dei criteri.</param>
        <param name="requiredPermissions">Richiesta di autorizzazioni obbligatoria.</param>
        <param name="optionalPermissions">Richiesta di autorizzazioni facoltativa.</param>
        <param name="refusedPermissions">Richiesta di autorizzazioni rifiutata.</param>
        <summary>Definisce un assembly dinamico usando il nome, la modalità di accesso, la directory di archiviazione, l'evidenza e le richieste di autorizzazione specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le richieste di autorizzazione specificate per `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` vengono utilizzate solo se `evidence` viene anche fornito, o se l'assembly dinamico viene salvato e ricaricato in memoria.  
  
> [!NOTE]
>  Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile includere <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> nel `refusedPermissions` parametro assicura che il codice MSIL viene verificato. Una limitazione di questa tecnica è che fa in modo <xref:System.Security.SecurityException> quando usato con il codice che richiede l'attendibilità totale.  
  
 Solo completamente attendibili i chiamanti possono fornire loro `evidence` quando si definisce un dinamico <xref:System.Reflection.Assembly>. Il runtime eseguirà il mapping di <xref:System.Security.Policy.Evidence> tramite i criteri di sicurezza per determinare le autorizzazioni concesse. Chiamanti parzialmente attendibili devono fornire un valore null `evidence`. Se `evidence` è `null`, il runtime copierà i set di autorizzazioni, vale a dire corrente concedere e negare set, da parte del chiamante <xref:System.Reflection.Assembly> per dinamica <xref:System.Reflection.Assembly> viene definito e contrassegna i criteri come risolti.  
  
 Se dinamica <xref:System.Reflection.Assembly> viene salvato su disco, caricamenti successivi verranno concesse in base ai criteri associati al percorso in cui il <xref:System.Reflection.Assembly> è stato salvato.  
  
 Questo metodo deve essere utilizzato solo per definire un assembly dinamico nel dominio applicazione corrente. Per ulteriori informazioni, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.DefineDynamicAssembly%2A> (metodo) e <xref:System.AppDomain.AssemblyResolve> evento.  
  
 Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità mediante cui si accederà all'assembly dinamico.</param>
        <param name="dir">Nome della directory nella quale verrà salvato l'assembly dinamico. Se <c>dir</c> è <see langword="null" />, la directory predefinita sarà la directory corrente.</param>
        <param name="evidence">Evidenza fornita per l'assembly dinamico. L'evidenza viene usata senza modifiche come il set di evidenza finale impiegato per la risoluzione dei criteri.</param>
        <param name="requiredPermissions">Richiesta di autorizzazioni obbligatoria.</param>
        <param name="optionalPermissions">Richiesta di autorizzazioni facoltativa.</param>
        <param name="refusedPermissions">Richiesta di autorizzazioni rifiutata.</param>
        <param name="isSynchronized">
          <see langword="true" /> per sincronizzare la creazione di moduli, tipi e membri nell'assembly dinamico; in caso contrario, <see langword="false" />.</param>
        <summary>Definisce un assembly dinamico usando il nome, la modalità di accesso, la directory di archiviazione, l'evidenza, le richieste di autorizzazione e l'opzione di sincronizzazione specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le richieste di autorizzazione specificate per `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` vengono utilizzate solo se `evidence` viene anche fornito, o se l'assembly dinamico viene salvato e ricaricato in memoria.  
  
> [!NOTE]
>  Durante lo sviluppo di codice che genera gli assembly dinamici, è consigliabile includere <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Tra cui <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> nel `refusedPermissions` parametro assicura che il codice MSIL viene verificato. Una limitazione di questa tecnica è che fa in modo <xref:System.Security.SecurityException> quando usato con il codice che richiede l'attendibilità totale.  
  
 Solo i chiamanti completamente attendibili possono fornire loro evidenza quando si definisce un dinamico <xref:System.Reflection.Assembly>. Il runtime eseguirà il mapping di <xref:System.Security.Policy.Evidence> tramite i criteri di sicurezza per determinare le autorizzazioni concesse. Chiamanti parzialmente attendibili devono fornire `null` per il `evidence` parametro. Se `evidence` è `null`, il runtime copierà i set di autorizzazioni, vale a dire corrente concedere e negare set, da parte del chiamante <xref:System.Reflection.Assembly> per dinamica <xref:System.Reflection.Assembly> viene definito e contrassegna i criteri come risolti.  
  
 Se dinamica <xref:System.Reflection.Assembly> viene salvato su disco, caricamenti successivi verranno concesse in base ai criteri associati al percorso in cui il <xref:System.Reflection.Assembly> è stato salvato.  
  
 Se `isSynchronized` è `true`, i metodi seguenti dell'oggetto risultante <xref:System.Reflection.Emit.AssemblyBuilder> verranno sincronizzati: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, e <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Se due di questi metodi vengono chiamati in thread diversi, uno verrà bloccata fino a quando il loro completamento.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.DefineDynamicAssembly%2A> (metodo) e <xref:System.AppDomain.AssemblyResolve> evento.  
  
 Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto o contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Identità univoca dell'assembly dinamico.</param>
        <param name="access">Modalità mediante cui si accederà all'assembly dinamico.</param>
        <param name="dir">Nome della directory nella quale verrà salvato l'assembly dinamico. Se <c>dir</c> è <see langword="null" />, viene usata la directory corrente.</param>
        <param name="evidence">Evidenza fornita per l'assembly dinamico. L'evidenza viene usata senza modifiche come il set di evidenza finale impiegato per la risoluzione dei criteri.</param>
        <param name="requiredPermissions">Richiesta di autorizzazioni obbligatoria.</param>
        <param name="optionalPermissions">Richiesta di autorizzazioni facoltativa.</param>
        <param name="refusedPermissions">Richiesta di autorizzazioni rifiutata.</param>
        <param name="isSynchronized">
          <see langword="true" /> per sincronizzare la creazione di moduli, tipi e membri nell'assembly dinamico; in caso contrario, <see langword="false" />.</param>
        <param name="assemblyAttributes">Elenco enumerabile di attributi da applicare all'assembly oppure <see langword="null" /> se non sono presenti attributi.</param>
        <summary>Definisce un assembly dinamico con il nome, la modalità di accesso, la directory di archiviazione, l'evidenza, le richieste di autorizzazione, l'opzione di sincronizzazione e gli attributi personalizzati specificati.</summary>
        <returns>Assembly dinamico con nome e funzionalità specificati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload del metodo per specificare gli attributi che non funzionano correttamente a meno che non vengono applicate quando viene creato un assembly dinamico. Ad esempio, attributi di sicurezza, ad esempio <xref:System.Security.SecurityTransparentAttribute> e <xref:System.Security.SecurityCriticalAttribute> non funzionano correttamente se vengono aggiunti dopo aver creato un assembly dinamico.  
  
 Le richieste di autorizzazione specificate per il `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` parametri vengono utilizzati solo se il `evidence` anche viene fornito alcun parametro, o se l'assembly dinamico viene salvato e ricaricato in memoria.  
  
> [!NOTE]
>  Quando si sviluppa codice che genera gli assembly dinamici, si consiglia di includere il <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> flag nel `refusedPermissions` parametro. L'inclusione di questo flag garantisce che il Microsoft intermediate language (MSIL) verrà verificata. Questa tecnica rileverà la generazione di codice non verificabile, che in caso contrario è molto difficili da rilevare non intenzionale. Una limitazione di questa tecnica è che fa in modo <xref:System.Security.SecurityException> viene generata quando viene utilizzato con il codice che richiede l'attendibilità totale.  
  
 Solo i chiamanti completamente attendibili possono fornire l'evidenza quando si definisce un dinamico <xref:System.Reflection.Assembly>. Il runtime esegue il mapping di <xref:System.Security.Policy.Evidence> tramite i criteri di sicurezza per determinare le autorizzazioni concesse. Chiamanti parzialmente attendibili devono fornire `null` per il `evidence` parametro. Se `evidence` è `null`, il runtime copierà i set di autorizzazioni (ovvero, il correnti concesse e negate) dall'assembly del chiamante all'assembly dinamico che viene definito, contrassegnando i criteri come risolti.  
  
 Se l'assembly dinamico viene salvato su disco, successivi caricamenti verranno concesse autorizzazioni in base ai criteri associati al percorso in cui è stato salvato l'assembly dinamico.  
  
 Se `isSynchronized` è `true`, i metodi seguenti dell'oggetto risultante <xref:System.Reflection.Emit.AssemblyBuilder> verranno sincronizzati: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, e <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Se due di questi metodi vengono chiamati in thread diversi, uno verrà bloccata fino al completamento di altri.  
  
 Questo overload del metodo è stato introdotto nel [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà <see langword="Name" /> di <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 La proprietà <see langword="Name" /> di <paramref name="name" /> inizia con uno spazio vuoto oppure contiene una barra o una barra rovesciata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate">Delegato con cui viene specificato un metodo da chiamare.</param>
        <summary>Esegue il codice in un altro dominio applicazione, identificato dal delegato specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `callBackDelegate` specificare un marshalling dal valore, <xref:System.MarshalByRefObject>, o <xref:System.ContextBoundObject>.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato come utilizzare un valore statico <xref:System.AppDomain.DoCallBack%2A> metodo.  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 L'esempio seguente viene illustrato l'utilizzo di <xref:System.AppDomain.DoCallBack%2A> metodo per valore.  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 L'esempio seguente viene illustrato l'utilizzo di <xref:System.AppDomain.DoCallBack%2A> metodo per riferimento.  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBackDelegate" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il gestore di dominio fornito dall'host al momento dell'inizializzazione del dominio applicazione.</summary>
        <value>Oggetto che rappresenta il gestore di dominio fornito dall'host quando è stato inizializzato il dominio dell'applicazione o <see langword="null" /> se non è stato fornito alcun gestore di dominio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un host non gestito di common language runtime (CLR) è possibile fornire un gestore di dominio. Il gestore di dominio può partecipare all'inizializzazione del nuovo dominio applicazione e fornire altri gestori, come ad esempio un <xref:System.Security.HostSecurityManager>, che partecipano alle operazioni del dominio dell'applicazione.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un oggetto <see cref="T:System.AppDomain" /> sta per essere scaricato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.EventHandler> delegato per questo evento è possibile eseguire qualsiasi attività di chiusura prima che venga scaricato il dominio dell'applicazione.  
  
 Ogni dominio applicazione che deve essere eseguita l'elaborazione quando viene scaricato deve registrare un gestore eventi per questo evento. Un gestore eventi condiviso non deve essere utilizzato, in quanto il <xref:System.EventHandler> delegato identifica il dominio che sta per essere scaricato.  
  
> [!NOTE]
>  Questo evento non viene mai generato nel dominio applicazione predefinito.  
  
 Non basarsi su presupposti sul thread che in cui viene generato l'evento. L'evento può essere generato in un thread diverso da quello che ha chiamato la <xref:System.AppDomain.Unload%2A> metodo.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la directory usata dal resolver dell'assembly per verificare la presenza di assembly creati dinamicamente.</summary>
        <value>Directory usata dal resolver dell'assembly per verificare la presenza di assembly creati dinamicamente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostare la directory dinamica, assegnare un percorso di directory di base per il <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> proprietà del <xref:System.AppDomainSetup> oggetto che verrà utilizzato per creare un nuovo dominio applicazione. Il percorso della directory base assegnare alla proprietà viene modificato mediante l'aggiunta di una sottodirectory il cui nome semplice è il codice hash della stringa di cui si assegna al <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> proprietà, pertanto è il formato della directory base *percorso originale* \\ *il codice hash*. La directory dinamica è una sottodirectory della directory di base. Il nome semplice è il valore della <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> proprietà, pertanto il formato è *percorso originale*\\*il codice hash*\\*nome applicazione*.  
  
   
  
## Examples  
 Nell'esempio seguente crea un dominio applicazione con una directory per gli assembly dinamici, genera un assembly dinamico e archiviarlo nella directory dinamica, carica l'assembly nel nuovo dominio applicazione e viene utilizzato.  
  
 Nell'esempio viene creato un <xref:System.AppDomainSetup> oggetto e imposta il relativo <xref:System.AppDomainSetup.ApplicationName%2A> proprietà su "Esempio" e il relativo <xref:System.AppDomainSetup.DynamicBase%2A> proprietà su "C:\DynamicAssemblyDir". Nell'esempio viene quindi visualizzato il <xref:System.AppDomainSetup.DynamicBase%2A> proprietà, per mostrare che il codice hash del nome dell'applicazione è stato aggiunto come una sottodirectory del percorso a cui è stato originariamente assegnato.  
  
> [!NOTE]
>  La directory di base in questo esempio deve essere utilizzata all'esterno del percorso di sondaggio per l'applicazione di esempio. Assicurarsi di compilare l'esempio in un percorso diverso. Eliminare la directory di base e tutte le relative sottodirectory ogni volta che si esegue l'esempio.  
  
 Nell'esempio viene creato un nuovo dominio applicazione, utilizzando il <xref:System.AppDomainSetup> oggetto. Nell'esempio viene utilizzata la <xref:System.AppDomain.DynamicDirectory%2A> proprietà per recuperare il nome della directory, così da poter creare la directory. (L'esempio può creare facilmente la directory in anticipo concatenando il percorso originale, il codice hash di nome dell'applicazione e il nome dell'applicazione.)  
  
 L'esempio include una `GenerateDynamicAssembly` metodo che genera un assembly denominato `DynamicHelloWorld.dll` e lo archivia nella directory dinamica del nuovo dominio applicazione. L'assembly dinamico contiene un solo tipo, `HelloWorld`, che dispone di un metodo statico (`Shared` metodo in Visual Basic) denominata `HelloFromAD`. Chiamare questo metodo visualizza il nome del dominio dell'applicazione.  
  
 Il `Example` deriva dalla classe <xref:System.MarshalByRefObject>, pertanto l'esempio è possibile creare un'istanza della classe in cui il nuovo dominio applicazione e chiamare il relativo `Test` metodo. Il `Test` metodo carica l'assembly dinamico con il nome visualizzato e chiama il metodo statico `HelloFromAD` metodo.  
  
 È possibile mostrare che viene eseguita la ricerca di directory dinamica dopo i percorsi di sondaggio normale scrivendo il codice per un assembly denominato `DynamicHelloWorld.dll` e compilarlo nella stessa directory in questo esempio. L'assembly deve avere una classe denominata `HelloWorld` con un metodo statico denominato `HelloFromAD`. Questo metodo non è necessario avere la stessa funzionalità come quello nell'esempio; può visualizzare semplicemente una stringa sulla console. L'assembly deve avere anche un <xref:System.Reflection.AssemblyVersionAttribute> attributo che imposta la versione 1.0.0.0. Quando si esegue l'esempio, si trova l'assembly che è stato compilato nella directory corrente prima che la directory dinamica viene eseguita la ricerca.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni sul percorso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Security.Policy.Evidence" /> associato al dominio applicazione.</summary>
        <value>Evidenza associata al dominio applicazione.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue l'assembly contenuto nel file specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome del file contenente l'assembly da eseguire.</param>
        <summary>Esegue l'assembly contenuto nel file specificato.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.  
  
 Questo metodo carica l'assembly utilizzando il <xref:System.Reflection.Assembly.LoadFile%2A> metodo. È anche possibile eseguire assembly utilizzando il <xref:System.AppDomain.ExecuteAssemblyByName%2A> (metodo), che carica l'assembly utilizzando il <xref:System.Reflection.Assembly.Load%2A> metodo.  
  
 Per creare il <xref:System.AppDomain> per caricare ed eseguire, utilizzare il <xref:System.AppDomain.CreateDomain%2A> metodo.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato come utilizzare uno degli overload di <xref:System.AppDomain.ExecuteAssembly%2A> in due domini diversi.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome del file contenente l'assembly da eseguire.</param>
        <param name="assemblySecurity">Evidenza per il caricamento dell'assembly.</param>
        <summary>Esegue l'assembly contenuto nel file specificato usando l'evidenza specificata.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Il <xref:System.AppDomain.ExecuteAssembly%2A> metodo crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.  
  
 Questo metodo carica l'assembly utilizzando il <xref:System.Reflection.Assembly.LoadFile%2A> metodo. È anche possibile eseguire assembly utilizzando il <xref:System.AppDomain.ExecuteAssemblyByName%2A> (metodo), che carica l'assembly utilizzando il <xref:System.Reflection.Assembly.Load%2A> metodo.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato come utilizzare uno degli overload di <xref:System.AppDomain.ExecuteAssembly%2A> in due domini diversi.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome del file contenente l'assembly da eseguire.</param>
        <param name="args">Argomenti per il punto di ingresso dell'assembly.</param>
        <summary>Esegue l'assembly contenuto nel file specificato, usando gli argomenti specificati.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.  
  
 Questo metodo carica l'assembly utilizzando il <xref:System.Reflection.Assembly.LoadFile%2A> metodo. È anche possibile eseguire assembly utilizzando il <xref:System.AppDomain.ExecuteAssemblyByName%2A> (metodo), che carica l'assembly utilizzando il <xref:System.Reflection.Assembly.Load%2A> metodo.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato come utilizzare uno degli overload di <xref:System.AppDomain.ExecuteAssembly%2A> in due domini diversi.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
 oppure  
  
 <paramref name="assemblyFile" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome del file contenente l'assembly da eseguire.</param>
        <param name="assemblySecurity">Evidenza fornita per l'assembly.</param>
        <param name="args">Argomenti per il punto di ingresso dell'assembly.</param>
        <summary>Esegue l'assembly contenuto nel file specificato usando l'evidenza e gli argomenti specificati.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.  
  
 Questo metodo carica l'assembly utilizzando il <xref:System.Reflection.Assembly.LoadFile%2A> metodo. È anche possibile eseguire assembly utilizzando il <xref:System.AppDomain.ExecuteAssemblyByName%2A> (metodo), che carica l'assembly utilizzando il <xref:System.Reflection.Assembly.Load%2A> metodo.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato come utilizzare uno degli overload di <xref:System.AppDomain.ExecuteAssembly%2A> in due domini diversi.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> non è <see langword="null" />. Quando i criteri di sicurezza dall'accesso di codice legacy non sono abilitati, <paramref name="assemblySecurity" /> deve essere <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome del file contenente l'assembly da eseguire.</param>
        <param name="args">Argomenti per il punto di ingresso dell'assembly.</param>
        <param name="hashValue">Rappresenta il valore del codice hash calcolato.</param>
        <param name="hashAlgorithm">Rappresenta l'algoritmo hash usato dal manifesto dell'assembly.</param>
        <summary>Esegue l'assembly contenuto nel file specificato, usando gli argomenti, il valore hash e l'algoritmo hash specificati.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.  
  
 Questo metodo carica l'assembly utilizzando il <xref:System.Reflection.Assembly.LoadFile%2A> metodo. È anche possibile eseguire assembly utilizzando il <xref:System.AppDomain.ExecuteAssemblyByName%2A> (metodo), che carica l'assembly utilizzando il <xref:System.Reflection.Assembly.Load%2A> metodo.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato come utilizzare uno degli overload di <xref:System.AppDomain.ExecuteAssembly%2A> in due domini diversi.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
 oppure  
  
 <paramref name="assemblyFile" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nome del file contenente l'assembly da eseguire.</param>
        <param name="assemblySecurity">Evidenza fornita per l'assembly.</param>
        <param name="args">Argomenti per il punto di ingresso dell'assembly.</param>
        <param name="hashValue">Rappresenta il valore del codice hash calcolato.</param>
        <param name="hashAlgorithm">Rappresenta l'algoritmo hash usato dal manifesto dell'assembly.</param>
        <summary>Esegue l'assembly contenuto nel file specificato, usando l'evidenza, gli argomenti, il valore hash e l'algoritmo hash specificati.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.  
  
 Questo metodo carica l'assembly utilizzando il <xref:System.Reflection.Assembly.LoadFile%2A> metodo. È anche possibile eseguire assembly utilizzando il <xref:System.AppDomain.ExecuteAssemblyByName%2A> (metodo), che carica l'assembly utilizzando il <xref:System.Reflection.Assembly.Load%2A> metodo.  
  
   
  
## Examples  
 Thefollowing esempio viene illustrato come utilizzare uno degli overload di <xref:System.AppDomain.ExecuteAssembly%2A> in due domini diversi.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyFile" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> non è <see langword="null" />. Quando i criteri di sicurezza dall'accesso di codice legacy non sono abilitati, <paramref name="assemblySecurity" /> deve essere <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue un assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Esegue un assembly in base al nome visualizzato.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo fornisce funzionalità simili a quelle di <xref:System.AppDomain.ExecuteAssembly%2A> (metodo), ma specifica l'assembly con nome visualizzato o <xref:System.Reflection.AssemblyName> anziché dal percorso del file. Di conseguenza, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carica gli assembly con il <xref:System.Reflection.Assembly.Load%2A> metodo anziché con il <xref:System.Reflection.Assembly.LoadFile%2A> metodo.  
  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.  
  
 Per creare il <xref:System.AppDomain> per caricare ed eseguire, utilizzare il <xref:System.AppDomain.CreateDomain%2A> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">L'assembly specificato da <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly specificato da <paramref name="assemblyName" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">L'assembly specificato da <paramref name="assemblyName" /> è stato trovato, ma non è stato possibile caricarlo.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory, per accedere alle informazioni presenti nel percorso stesso e per il reindirizzamento a un percorso di un nome visualizzato. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per l'accesso a un sito Web, quando un nome visualizzato viene reindirizzato a un URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Oggetto <see cref="T:System.Reflection.AssemblyName" /> che rappresenta il nome dell'assembly.</param>
        <param name="args">Argomenti della riga di comando da passare all'avvio del processo.</param>
        <summary>Esegue l'assembly in base a un oggetto <see cref="T:System.Reflection.AssemblyName" />, usando gli argomenti specificati.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo fornisce funzionalità simili a quelle di <xref:System.AppDomain.ExecuteAssembly%2A> (metodo), ma specifica l'assembly con nome visualizzato o <xref:System.Reflection.AssemblyName> anziché dal percorso del file. Di conseguenza, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carica gli assembly con il <xref:System.Reflection.Assembly.Load%2A> metodo anziché con il <xref:System.Reflection.Assembly.LoadFile%2A> metodo.  
  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">L'assembly specificato da <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">L'assembly specificato da <paramref name="assemblyName" /> è stato trovato, ma non è stato possibile caricarlo.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly specificato da <paramref name="assemblyName" /> non è un assembly valido.  
  
 oppure  
  
 <paramref name="assemblyName" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory, per accedere alle informazioni presenti nel percorso stesso e per il reindirizzamento a un percorso di un nome visualizzato. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per l'accesso a un sito Web, quando un nome visualizzato viene reindirizzato a un URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Evidenza per il caricamento dell'assembly.</param>
        <summary>Esegue un assembly in base al nome visualizzato, usando l'evidenza specificata.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo fornisce funzionalità simili a quelle di <xref:System.AppDomain.ExecuteAssembly%2A> (metodo), ma specifica l'assembly con nome visualizzato o <xref:System.Reflection.AssemblyName> anziché dal percorso del file. Di conseguenza, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carica gli assembly con il <xref:System.Reflection.Assembly.Load%2A> metodo anziché con il <xref:System.Reflection.Assembly.LoadFile%2A> metodo.  
  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.  
  
> [!NOTE]
>  Quando si utilizza il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo con un <xref:System.Security.Policy.Evidence> parametro evidenze vengono uniti. Evidenze fornito come argomento per il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo sostituiscono quelle di evidenza fornita dal caricatore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">L'assembly specificato da <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">L'assembly specificato da <paramref name="assemblyName" /> è stato trovato, ma non è stato possibile caricarlo.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly specificato da <paramref name="assemblyName" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory, per accedere alle informazioni presenti nel percorso stesso e per il reindirizzamento a un percorso di un nome visualizzato. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">per l'accesso a un sito Web, quando un nome visualizzato viene reindirizzato a un URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="args">Argomenti della riga di comando da passare all'avvio del processo.</param>
        <summary>Esegue l'assembly in base al nome visualizzato, usando gli argomenti specificati.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo fornisce funzionalità simili a quelle di <xref:System.AppDomain.ExecuteAssembly%2A> (metodo), ma specifica l'assembly con nome visualizzato o <xref:System.Reflection.AssemblyName> anziché dal percorso del file. Di conseguenza, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carica gli assembly con il <xref:System.Reflection.Assembly.Load%2A> metodo anziché con il <xref:System.Reflection.Assembly.LoadFile%2A> metodo.  
  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">L'assembly specificato da <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">L'assembly specificato da <paramref name="assemblyName" /> è stato trovato, ma non è stato possibile caricarlo.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly specificato da <paramref name="assemblyName" /> non è un assembly valido.  
  
 oppure  
  
 <paramref name="assemblyName" /> è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory, per accedere alle informazioni presenti nel percorso stesso e per il reindirizzamento a un percorso di un nome visualizzato. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per l'accesso a un sito Web, quando un nome visualizzato viene reindirizzato a un URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Oggetto <see cref="T:System.Reflection.AssemblyName" /> che rappresenta il nome dell'assembly.</param>
        <param name="assemblySecurity">Evidenza per il caricamento dell'assembly.</param>
        <param name="args">Argomenti della riga di comando da passare all'avvio del processo.</param>
        <summary>Esegue l'assembly in base a un dato oggetto <see cref="T:System.Reflection.AssemblyName" />, usando l'evidenza e gli argomenti specificati.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo fornisce funzionalità simili a quelle di <xref:System.AppDomain.ExecuteAssembly%2A> (metodo), ma specifica l'assembly con nome visualizzato o <xref:System.Reflection.AssemblyName> anziché dal percorso del file. Di conseguenza, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carica gli assembly con il <xref:System.Reflection.Assembly.Load%2A> metodo anziché con il <xref:System.Reflection.Assembly.LoadFile%2A> metodo.  
  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.  
  
> [!NOTE]
>  Quando si utilizza il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo con un <xref:System.Security.Policy.Evidence> parametro evidenze vengono uniti. Evidenze fornito come argomento per il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo sostituiscono quelle di evidenza fornita dal caricatore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">L'assembly specificato da <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">L'assembly specificato da <paramref name="assemblyName" /> è stato trovato, ma non è stato possibile caricarlo.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly specificato da <paramref name="assemblyName" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> non è <see langword="null" />. Quando i criteri di sicurezza dall'accesso di codice legacy non sono abilitati, <paramref name="assemblySecurity" /> deve essere <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory, per accedere alle informazioni presenti nel percorso stesso e per il reindirizzamento a un percorso di un nome visualizzato. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">per l'accesso a un sito Web, quando un nome visualizzato viene reindirizzato a un URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Evidenza per il caricamento dell'assembly.</param>
        <param name="args">Argomenti della riga di comando da passare all'avvio del processo.</param>
        <summary>Esegue l'assembly in base al nome visualizzato, usando l'evidenza e gli argomenti specificati.</summary>
        <returns>Valore restituito dal punto di ingresso dell'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo fornisce funzionalità simili a quelle di <xref:System.AppDomain.ExecuteAssembly%2A> (metodo), ma specifica l'assembly con nome visualizzato o <xref:System.Reflection.AssemblyName> anziché dal percorso del file. Di conseguenza, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carica gli assembly con il <xref:System.Reflection.Assembly.Load%2A> metodo anziché con il <xref:System.Reflection.Assembly.LoadFile%2A> metodo.  
  
 L'assembly inizia l'esecuzione nel punto di ingresso specificato nell'intestazione di .NET Framework.  
  
 Questo metodo non crea un nuovo processo o un dominio applicazione e non esegue il metodo del punto di ingresso in un nuovo thread.  
  
> [!NOTE]
>  Quando si utilizza il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo con un <xref:System.Security.Policy.Evidence> parametro evidenze vengono uniti. Evidenze fornito come argomento per il <xref:System.AppDomain.ExecuteAssemblyByName%2A> metodo sostituiscono quelle di evidenza fornita dal caricatore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">L'assembly specificato da <paramref name="assemblyName" /> non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">L'assembly specificato da <paramref name="assemblyName" /> è stato trovato, ma non è stato possibile caricarlo.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly specificato da <paramref name="assemblyName" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyName" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> non è <see langword="null" />. Quando i criteri di sicurezza dall'accesso di codice legacy non sono abilitati, <paramref name="assemblySecurity" /> deve essere <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">L'assembly specificato non ha alcun punto di ingresso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory, per accedere alle informazioni presenti nel percorso stesso e per il reindirizzamento a un percorso di un nome visualizzato. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">per l'accesso a un sito Web, quando un nome visualizzato viene reindirizzato a un URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Per eseguire un'applicazione console. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un'eccezione viene generata in codice gestito prima che il runtime cerchi un gestore di eccezioni nello stack di chiamate del dominio applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento è solo una notifica. Gestione di questo evento non gestire l'eccezione, né altera successive eccezioni in alcun modo. Dopo che è stato generato l'evento e i gestori eventi siano stati richiamati, common language runtime (CLR) inizia la ricerca di un gestore per l'eccezione. <xref:System.AppDomain.FirstChanceException> fornisce il dominio applicazione con una prima opportunità per esaminare qualsiasi eccezione gestita.  
  
 L'evento può essere gestito per ogni dominio applicazione. Se un thread passa attraverso più domini applicazione durante l'esecuzione di una chiamata, l'evento viene generato in ogni dominio applicazione che ha registrato un gestore di evento, prima di CLR inizia la ricerca per un gestore eccezioni corrispondente nel dominio dell'applicazione. Dopo l'evento è stata gestita, viene eseguita una ricerca per un gestore eccezioni corrispondente nel dominio dell'applicazione. Se non viene trovato, viene generato l'evento nel dominio dell'applicazione successivo.  
  
 È necessario gestire tutte le eccezioni che si verificano nel gestore per il <xref:System.AppDomain.FirstChanceException> evento. In caso contrario, <xref:System.AppDomain.FirstChanceException> viene generato in modo ricorsivo. Ciò potrebbe causare un overflow dello stack e la chiusura dell'applicazione. È consigliabile implementare i gestori eventi per questo evento come aree a esecuzione vincolata (CER), per evitare che le eccezioni correlate all'infrastruttura, ad esempio di memoria insufficiente o overflow dello stack di influire sulla macchina virtuale durante l'elaborazione della notifica dell'eccezione.  
  
 Questo evento non viene generato per le eccezioni che indicano il danneggiamento dello stato del processo, ad esempio le violazioni di accesso, a meno che il gestore dell'evento è critico per la sicurezza e ha il <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> attributo.  
  
 Common language runtime sospende le interruzioni di thread, mentre viene gestito l'evento di notifica.  
  
   
  
## Examples  
 Nell'esempio seguente crea una serie di domini di applicazione denominato `AD0` tramite `AD3`, con un `Worker` oggetto in ogni dominio applicazione. Ogni `Worker` oggetto ha un riferimento al `Worker` dell'oggetto nel dominio dell'applicazione Avanti, fatta eccezione per il `Worker` nell'ultimo dominio applicazione. Il <xref:System.AppDomain.FirstChanceException> evento viene gestito in tutti i domini applicazione, ad eccezione `AD1`.  
  
> [!NOTE]
>  Oltre a questo esempio, che dimostra le notifiche di eccezioni first-chance in più domini applicazione, è possibile trovare casi di utilizzo semplice [procedura: ricevere notifiche di eccezioni First-Chance](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md).  
  
 Quando sono stati creati i domini applicazione, il dominio applicazione predefinito chiama il `TestException` metodo per il primo dominio di applicazione. Ogni `Worker` chiama il `TestException` metodo per il dominio di applicazione successivo, fino a quando l'ultimo `Worker` genera un'eccezione che è o non gestita. Di conseguenza, il thread corrente attraversa tutti i domini applicazione, e `TestException` viene aggiunto allo stack in ogni dominio applicazione.  
  
 Quando l'ultimo `Worker` oggetto gestisce l'eccezione, il <xref:System.AppDomain.FirstChanceException> evento viene generato solo nell'ultimo dominio applicazione. Gli altri domini applicazione mai la possibilità di gestire l'eccezione, pertanto non viene generato l'evento.  
  
 Quando l'ultimo `Worker` oggetto non gestisce l'eccezione, il <xref:System.AppDomain.FirstChanceException> in ogni dominio applicazione che dispone di un gestore di evento viene generato l'evento. Al termine di ogni gestore dell'evento, lo stack continua la rimozione fino a quando l'eccezione viene intercettata dal dominio applicazione predefinito.  
  
> [!NOTE]
>  Per visualizzare la modalità di visualizzazione dello stack aumenta man mano che viene generato l'evento più vicino e verso il dominio applicazione predefinito, modificare `e.Exception.Message` a `e.Exception` nel `FirstChanceHandler` gestori eventi. Si noti che quando `TestException` viene chiamato attraverso i limiti del dominio applicazione, viene visualizzato due volte: una volta per il proxy e una volta per lo stub.  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome descrittivo del dominio applicazione.</summary>
        <value>Nome descrittivo del dominio applicazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il nome descrittivo del dominio applicazione predefinito è il nome del file dell'eseguibile del processo. Ad esempio, se l'eseguibile usato per avviare il processo è `"c:\MyAppDirectory\MyAssembly.exe"`, il nome descrittivo del dominio applicazione predefinito è `"MyAssembly.exe"`.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.AppDomain.FriendlyName%2A> proprietà da ottenere il nome descrittivo del dominio applicazione corrente. Per il dominio applicazione predefinito, il nome descrittivo è il nome del file eseguibile dell'applicazione. L'esempio di codice visualizza anche informazioni aggiuntive sul dominio applicazione.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene gli assembly caricati nel contesto di esecuzione del dominio applicazione.</summary>
        <returns>Matrice di assembly nel dominio applicazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.AppDomain.GetAssemblies%2A> metodo per ottenere un elenco di tutti gli assembly che sono stati caricati nel dominio applicazione. Gli assembly vengono quindi visualizzati nella console.  
  
 Per eseguire questo esempio di codice, è necessario creare un assembly denominato `CustomLibrary.dll`, o modificare il nome dell'assembly che viene passato per il <xref:System.AppDomain.GetAssemblies%2A> metodo.  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene l'identificatore del thread attuale.</summary>
        <returns>Intero con segno a 32 bit che rappresenta l'identificatore del thread attuale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> proprietà, che rimane stabile anche quando .NET Framework è ospitato da un ambiente che supporta i fiber (vale a dire il thread lightweight).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">chiamare questo metodo. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome di una proprietà del dominio applicazione predefinita o nome della proprietà di un dominio applicazione definito.</param>
        <summary>Ottiene il valore archiviato nel dominio applicazione attuale per il nome specificato.</summary>
        <returns>Valore della proprietà <paramref name="name" /> oppure <see langword="null" /> se la proprietà non esiste.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per recuperare il valore di una voce in una cache interna di coppie nome / dati che descrivono le proprietà di questa istanza di <xref:System.AppDomain>. Si noti che il confronto di `name` con il nome di coppie chiave-valore è tra maiuscole e minuscole.  
  
 La cache contiene automaticamente le voci di sistema predefiniti che vengono inserite quando viene creato il dominio dell'applicazione. È possibile controllare i valori mediante la <xref:System.AppDomain.GetData%2A> metodo o l'equivalente <xref:System.AppDomainSetup> proprietà.  
  
 È possibile inserire o modificare la propria coppie nome / dati definiti dall'utente con il <xref:System.AppDomain.SetData%2A> metodo ed esaminare i valori mediante la <xref:System.AppDomain.GetData%2A> metodo.  
  
 Nella tabella seguente vengono descritti il `name` di ogni voce nel sistema e predefiniti corrispondente <xref:System.AppDomainSetup> proprietà.  
  
|Valore della proprietà 'name'|Proprietà|  
|---------------------|--------------|  
|"APPBASE"|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|"APP_CONFIG_FILE"|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|"APP_LAUNCH_URL"|(nessuna proprietà)<br /><br /> "APP_LAUNCH_URL" rappresenta l'URL richiesto originariamente dall'utente, prima di qualsiasi reindirizzamento. È disponibile solo quando l'applicazione è stata avviata con un browser quale Internet Explorer. Non tutti i browser forniscono questo valore.|  
|"APP_NAME"|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|"BINPATH_PROBE_ONLY"|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|"CACHE_BASE"|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|"CODE_DOWNLOAD_DISABLED"|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|"DEV_PATH"|(nessuna proprietà)|  
|"DISALLOW_APP"|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_BASE_PROBING"|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_REDIRECTS"|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|"DYNAMIC_BASE"|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|"FORCE_CACHE_INSTALL"|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|"LICENSE_FILE" o una stringa specifica dell'applicazione|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|"LOADER_OPTIMIZATION"|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|"LOCATION_URI"|(nessuna proprietà)|  
|"PRIVATE_BINPATH"|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|"REGEX_DEFAULT_MATCH_TIMEOUT"|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> "REGEX_DEFAULT_MATCH_TIMEOUT" non è una voce di sistema e il relativo valore può essere impostato tramite la chiamata di <xref:System.AppDomain.SetData%2A> metodo.|  
|"SHADOW_COPY_DIRS"|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 Nell'esempio seguente crea un nuovo dominio applicazione, imposta un valore fornito dal sistema per il dominio e aggiunge una nuova coppia di valore per il dominio. Nell'esempio viene quindi illustrato come utilizzare il <xref:System.AppDomain.GetData%2A> metodo per recuperare i dati da queste coppie di valori e visualizzarli nella console.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni presenti nel percorso stesso, se la proprietà si applica a un percorso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene il tipo dell'istanza corrente.</summary>
        <returns>Tipo dell'istanza corrente.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un intero che identifica in modo univoco il dominio applicazione all'interno del processo.</summary>
        <value>Intero che identifica il dominio applicazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente crea un secondo dominio di applicazione e visualizza le informazioni del dominio predefinito e il nuovo dominio.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fornisce all'oggetto <see cref="T:System.AppDomain" /> una durata infinita impedendo la creazione di lease.</summary>
        <returns>Sempre <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Opzione di compatibilità da testare.</param>
        <summary>Ottiene un valore booleano che ammette valori Null, indica se sono impostate opzioni di compatibilità e, in tal caso, se è impostata l'opzione di compatibilità specificata.</summary>
        <returns>Riferimento Null (<see langword="Nothing" /> in Visual Basic) se non è impostata alcuna opzione di compatibilità; in caso contrario, un valore booleano che indica se l'opzione di compatibilità specificata da <paramref name="value" /> è impostata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo verifica se l'opzione di compatibilità specificata è stata impostata per il dominio applicazione corrente. Le opzioni di compatibilità in genere ripristino un comportamento (ad esempio le stringhe di modalità vengono ordinate) che è stato modificato tra le versioni di .NET Framework.  Vengono impostate da una chiamata di <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> metodo prima di creare un dominio applicazione.  
  
 Nella tabella seguente vengono forniti esempi di opzioni di compatibilità che è possibile impostare per ripristinare il comportamento delle versioni precedenti di .NET Framework.  
  
|Opzione|Significato|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Codice di accesso di sicurezza per il [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] è abilitato in questo dominio applicazione. Vedere [ &lt;NetFx40_LegacySecurityPolicy&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|"NetFx40_Legacy20SortingBehavior"|Stringa di ordinamento dei valori predefiniti per il [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] sono abilitate nel dominio applicazione. Il suo successo richiede sort00001000.dll da installare. Vedere [ &lt;CompatSortNLSVersion&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|"NetFx40_Legacy40SortingBehavior"|Stringa di ordinamento dei valori predefiniti per il [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]e Unicode 5.0 sono abilitate nel dominio applicazione. Il suo successo richiede sort00060101.dll da installare.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> il comportamento di formattazione di [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] è abilitato in questo dominio applicazione.  Vedere [ &lt;TimeSpan_LegacyFormatMode&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) e la sezione "Ripristino Legacy TimeSpan formattazione" del <xref:System.TimeSpan> argomento.|  
|"UseRandomizedStringHashAlgorithm"|Il runtime calcola i codici hash per le stringhe in una base di dominio dell'applicazione anziché un solo algoritmo hash che genera un codice hash coerente tra domini dell'applicazione. Vedere [ &lt;UseRandomizedStringHashAlgorithm&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un valore che indica se il dominio applicazione è quello predefinito per il processo.</summary>
        <returns>
          <see langword="true" /> se l'oggetto <see cref="T:System.AppDomain" /> corrente rappresenta il dominio applicazione predefinito per il processo. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni processo gestito dispone di un dominio applicazione predefinito. L'esecuzione inizia nel dominio predefinito.  
  
   
  
## Examples  
 Esempio di codice seguente crea un secondo dominio di applicazione e visualizza le informazioni del dominio predefinito e il nuovo dominio.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica se è in corso lo scaricamento del dominio applicazione e se il completamento degli oggetti in esso contenuti è stato avviato in Common Language Runtime.</summary>
        <returns>
          <see langword="true" /> se è in corso lo scaricamento del dominio applicazione ed è stato avviato il richiamo dei finalizzatori in Common Language Runtime. In caso contrario, <see langword="false" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo di finalizzazione per un oggetto si offre l'opportunità di eseguire eventuali operazioni di pulizia prima che l'oggetto è sottoposto a garbage collection. Dopo la finalizzazione, l'oggetto è accessibile ma in uno stato non valido ed è pertanto inutilizzabile. Infine, la garbage collection completa e viene recuperato l'oggetto.  
  
 Viene chiamato il metodo di finalizzazione dell'oggetto in una delle situazioni seguenti: durante l'operazione di garbage collection, quando common language runtime è in corso l'arresto o quando viene scaricato il dominio applicazione che contiene l'oggetto. Il <xref:System.AppDomain.IsFinalizingForUnload%2A> restituisce `true` solo nell'ultimo caso; non restituisce `true` se dà come risultato la finalizzazione da routine di garbage collection o dall'arresto CLR.  
  
> [!NOTE]
>  Per determinare se la finalizzazione a causa dell'arresto CLR, utilizzare il <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> proprietà. Restituisce `true` se la finalizzazione è dovuto a un dominio applicazione in corso lo scaricamento o all'arresto di CLR.  
  
 Durante l'esecuzione del metodo di finalizzazione durante lo scaricamento del dominio, è necessario per accedere a un altro oggetto che fa riferimento un campo statico e dispone di un metodo di finalizzazione. Tuttavia, non è possibile in modo affidabile avviene perché l'oggetto a cui si accede potrebbe essere già stato completato.  
  
> [!NOTE]
>  Un'eccezione a questa regola è la <xref:System.Console> (classe), che contiene i campi statici che fanno riferimento a oggetti di flusso, ma viene implementato in modo tale è sempre possibile scrivere nella console di sistema, anche durante l'arresto del sistema o lo scaricamento di dominio.  
  
 Utilizzare questo metodo nel metodo di finalizzazione dell'oggetto per determinare se il dominio applicazione che contiene l'oggetto di scaricamento. Se è questo il caso, è possibile accedere in modo affidabile qualsiasi oggetto che dispone di un metodo di finalizzazione e fa riferimento a un campo statico.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se gli assembly caricati nel dominio applicazione corrente vengono eseguiti con attendibilità totale.</summary>
        <value>
          <see langword="true" /> se gli assembly caricati nel dominio dell'applicazione corrente vengono eseguiti con attendibilità totale; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce sempre `true` per il dominio applicazione predefinito di un'applicazione che viene eseguito sul desktop. Restituisce `false` per un dominio applicazione creato mediante sandbox è stato creato utilizzando il <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> overload del metodo, a meno che le autorizzazioni concesse al dominio dell'applicazione sono equivalenti all'attendibilità.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.IsFullyTrusted%2A> proprietà e <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> proprietà con i domini applicazione completamente o parzialmente attendibile. Il dominio applicazione con attendibilità totale è il dominio applicazione predefinito per l'applicazione. Il dominio applicazione parzialmente attendibile viene creato utilizzando il <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> overload del metodo.  
  
 Nell'esempio viene utilizzato un `Worker` classe che deriva da <xref:System.MarshalByRefObject>, che può essere sottoposto a marshalling attraverso i limiti del dominio applicazione. Nell'esempio viene creato un `Worker` oggetto nel dominio applicazione predefinito. Chiama quindi il `TestIsFullyTrusted` metodo per visualizzare il valore della proprietà per il dominio applicazione e per due assembly caricati nel dominio dell'applicazione: mscorlib, che fa parte di .NET Framework e l'assembly di esempio. Il dominio applicazione è completamente attendibile, in modo entrambi gli assembly sono completamente attendibili.  
  
 Nell'esempio viene creato un altro `Worker` oggetto in un dominio applicazione creato mediante sandbox e chiamate di nuovo il `TestIsFullyTrusted` metodo. Mscorlib è sempre attendibile, anche in un dominio applicazione parzialmente attendibile, ma l'assembly di esempio è parzialmente attendibile.  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il dominio applicazione corrente dispone di un set di autorizzazioni concesso a tutti gli assembly caricati nel dominio applicazione.</summary>
        <value>
          <see langword="true" /> se il dominio applicazione corrente dispone di un set omogeneo di autorizzazioni; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce `true` per i domini di applicazione creato mediante sandbox che sono stati creati tramite il <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> overload del metodo. Domini di applicazione creato mediante sandbox dispongono di un set omogeneo di autorizzazioni. vale a dire lo stesso set di autorizzazioni viene concessa a tutti gli assembly parzialmente attendibili che vengono caricati nel dominio dell'applicazione. Facoltativamente, un dominio applicazione sandboxed include un elenco di assembly con nome sicuro che non sono interessati da questo set di autorizzazioni e vengono invece eseguiti con attendibilità totale.  
  
 È considerato completamente attendibile il codice può utilizzare il <xref:System.AppDomain.PermissionSet%2A> proprietà per determinare il set di concessioni omogeneo di un dominio applicazione creato mediante sandbox.  
  
 Questa proprietà restituisce inoltre `true` per il dominio applicazione predefinito di un'applicazione desktop, perché tale dominio applicazione concede l'attendibilità totale per tutti gli assembly.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carica <see cref="T:System.Reflection.Assembly" /> nel dominio applicazione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Matrice di tipo <see langword="byte" /> costituita da un'immagine in formato COFF contenente un assembly generato.</param>
        <summary>Carica l'oggetto <see cref="T:System.Reflection.Assembly" /> con un'immagine in formato COFF (Common Object File Format) contenente un oggetto <see cref="T:System.Reflection.Assembly" /> generato.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il livello di attendibilità di un assembly caricato dall'utilizzo di questo metodo è lo stesso livello di attendibilità del dominio dell'applicazione.  
  
 Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente. Questo metodo viene fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metodo. Per caricare gli assembly in altri domini applicazione, utilizzare un metodo, ad esempio <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Per informazioni comuni a tutti gli overload di questo metodo, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato l'utilizzo del caricamento di un assembly non elaborato.  
  
 Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="rawAssembly" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Oggetto che descrive l'assembly da caricare.</param>
        <summary>Carica <see cref="T:System.Reflection.Assembly" />, dato il relativo <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente. Questo metodo viene fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metodo. Per caricare gli assembly in altri domini applicazione, utilizzare un metodo, ad esempio <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Se è già caricata una versione dell'assembly richiesto, questo metodo restituisce l'assembly caricato, anche se non è necessaria una versione diversa.  
  
 Specificare un nome di assembly parziali per `assemblyRef` non è consigliata. (Un nome parziale omette una o più delle impostazioni cultura, versione o token di chiave pubblica. Di overload che accettano una stringa anziché un <xref:System.Reflection.AssemblyName> oggetto, "MyAssembly, Version = 1.0.0.0" è un esempio di un nome parziale e "MyAssembly, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = 18ab3442da84b47" è riportato un esempio di un nome completo.) Utilizzo di nomi parziali ha un effetto negativo sulle prestazioni. Inoltre, un nome di assembly parziali possa caricare un assembly dalla global assembly cache solo se è disponibile una copia esatta dell'assembly nella directory base dell'applicazione (<xref:System.AppDomain.BaseDirectory%2A> o <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).  
  
 Se l'oggetto corrente <xref:System.AppDomain> oggetto rappresenta il dominio applicazione `A`e <xref:System.AppDomain.Load%2A> metodo viene chiamato dal dominio applicazione `B`, l'assembly viene caricato in entrambi i domini applicazione. Ad esempio, il codice seguente carica `MyAssembly` nel nuovo dominio applicazione `ChildDomain` e anche nel dominio applicazione in cui viene eseguito il codice:  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 L'assembly viene caricato in entrambi i domini perché <xref:System.Reflection.Assembly> non deriva da <xref:System.MarshalByRefObject>e pertanto il valore restituito di <xref:System.AppDomain.Load%2A> metodo Impossibile effettuare il marshalling. In alternativa, common language runtime tenta di caricare l'assembly nel dominio applicazione chiamante. Gli assembly caricati in due domini applicazione potrebbero essere diversi se le impostazioni del percorso per i due domini applicazione sono diverse.  
  
> [!NOTE]
>  Se entrambi i <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> proprietà e <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> proprietà sono impostate, il primo tentativo di caricare l'assembly viene utilizzato il nome visualizzato (compreso versione, impostazioni cultura e così via, restituito dal <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> proprietà). Se il file non viene trovato, il <xref:System.Reflection.AssemblyName.CodeBase%2A> proprietà viene utilizzata per cercare l'assembly. Se l'assembly viene trovato tramite <xref:System.Reflection.AssemblyName.CodeBase%2A>, il nome visualizzato viene confrontato con l'assembly. Se la corrispondenza ha esito negativo, un <xref:System.IO.FileLoadException> viene generata un'eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyRef" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Carica <see cref="T:System.Reflection.Assembly" />, dato il nome visualizzato.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente. Questo metodo viene fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metodo. Per caricare gli assembly in altri domini applicazione, utilizzare un metodo, ad esempio <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Per informazioni comuni a tutti gli overload di questo metodo, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> è <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyString" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Per poter accedere al percorso dell'assembly se l'assembly non è locale.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Matrice di tipo <see langword="byte" /> costituita da un'immagine in formato COFF contenente un assembly generato.</param>
        <param name="rawSymbolStore">Matrice di tipo <see langword="byte" /> contenente i byte non elaborati che rappresentano i simboli per l'assembly.</param>
        <summary>Carica l'oggetto <see cref="T:System.Reflection.Assembly" /> con un'immagine in formato COFF (Common Object File Format) contenente un oggetto <see cref="T:System.Reflection.Assembly" /> generato. Vengono caricati anche i byte non elaborati che rappresentano i simboli per l'oggetto <see cref="T:System.Reflection.Assembly" />.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il livello di attendibilità di un assembly caricato dall'utilizzo di questo metodo è lo stesso livello di attendibilità del dominio dell'applicazione.  
  
 Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente. Questo metodo viene fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metodo. Per caricare gli assembly in altri domini applicazione, utilizzare un metodo, ad esempio <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Per informazioni comuni a tutti gli overload di questo metodo, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato l'utilizzo del caricamento di un assembly non elaborato.  
  
 Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="rawAssembly" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Net.WebPermission">per la lettura di un URI che iniziano con "file://".</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Oggetto che descrive l'assembly da caricare.</param>
        <param name="assemblySecurity">Evidenza per il caricamento dell'assembly.</param>
        <summary>Carica <see cref="T:System.Reflection.Assembly" />, dato il relativo <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente. Questo metodo viene fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metodo. Per caricare gli assembly in altri domini applicazione, utilizzare un metodo, ad esempio <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Per informazioni comuni a tutti gli overload di questo metodo, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> è <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyRef" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un percorso che non è nel formato "file://" o "\\\UNC\dir\\" o "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Nome visualizzato dell'assembly. Vedere <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Evidenza per il caricamento dell'assembly.</param>
        <summary>Carica <see cref="T:System.Reflection.Assembly" />, dato il nome visualizzato.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente. Questo metodo viene fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metodo. Per caricare gli assembly in altri domini applicazione, utilizzare un metodo, ad esempio <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Per informazioni comuni a tutti gli overload di questo metodo, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> è <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> non trovata.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="assemblyString" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per caricare un assembly con l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un percorso che non è nel formato "file://" o "\\\UNC\dir\\" o "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Matrice di tipo <see langword="byte" /> costituita da un'immagine in formato COFF contenente un assembly generato.</param>
        <param name="rawSymbolStore">Matrice di tipo <see langword="byte" /> contenente i byte non elaborati che rappresentano i simboli per l'assembly.</param>
        <param name="securityEvidence">Evidenza per il caricamento dell'assembly.</param>
        <summary>Carica l'oggetto <see cref="T:System.Reflection.Assembly" /> con un'immagine in formato COFF (Common Object File Format) contenente un oggetto <see cref="T:System.Reflection.Assembly" /> generato. Vengono caricati anche i byte non elaborati che rappresentano i simboli per l'oggetto <see cref="T:System.Reflection.Assembly" />.</summary>
        <returns>Assembly caricato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il livello di attendibilità di un assembly caricato dall'utilizzo di questo metodo è lo stesso livello di attendibilità del dominio dell'applicazione.  
  
 Questo metodo deve essere utilizzato solo per caricare un assembly nel dominio applicazione corrente. Questo metodo viene fornito per praticità per i chiamanti di interoperabilità che non è possibile chiamare il metodo statico <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> metodo. Per caricare gli assembly in altri domini applicazione, utilizzare un metodo, ad esempio <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Per informazioni comuni a tutti gli overload di questo metodo, vedere il <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> overload del metodo.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato l'utilizzo del caricamento di un assembly non elaborato.  
  
 Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> è <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> non è un assembly valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e il parametro <paramref name="rawAssembly" /> è stato compilato con una versione successiva.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly o un modulo è stato caricato due volte con due evidenze diverse.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> non è <see langword="null" />. Quando i criteri di sicurezza dall'accesso di codice legacy non sono abilitati, <paramref name="securityEvidence" /> deve essere <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per fornire l'evidenza. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">per l'accesso in lettura da un file o directory e per l'accesso alle informazioni presenti nel percorso stesso. Enumerazioni associate: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">per la lettura di un percorso che non è nel formato "file://" o "\\\UNC\dir\\" o "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il monitoraggio della memoria e della CPU dei domini applicazione è abilitato per il processo corrente. Una volta abilitato per un processo, il monitoraggio non può più essere disabilitato.</summary>
        <value>
          <see langword="true" /> se il monitoraggio è abilitato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo `static` proprietà (`Shared` proprietà in Visual Basic) controlla la CPU e il monitoraggio della memoria di tutti i domini applicazione nel processo.  
  
 Se si tenta di impostare questa proprietà su `false`, <xref:System.ArgumentException> viene generata l'eccezione, anche se il valore corrente della proprietà è `false`.  
  
 Il monitoraggio è abilitato, è possibile utilizzare il <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, e <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> delle proprietà per monitorare l'utilizzo della CPU e memoria dei singoli domini applicazione dell'istanza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il processo corrente ha tentato di assegnare il valore <see langword="false" /> a questa proprietà.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di byte esclusi dall'ultima raccolta e a cui fa riferimento il dominio applicazione corrente.</summary>
        <value>Numero di byte esclusi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le statistiche vengono aggiornate con ogni operazione di garbage collection. Tuttavia, essi sono sicuramente accurata solo dopo una procedura completa di Garbage collection; bloccante ovvero, si verifica una raccolta che include tutte le generazioni e che interrompe l'applicazione durante la raccolta. Ad esempio, il <xref:System.GC.Collect?displayProperty=nameWithType> overload del metodo esegue una procedura completa di Garbage collection bloccante. (Raccolta simultanea avviene in background e non blocca l'applicazione).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> è impostata su <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene i byte totali esclusi dall'ultima raccolta per tutti i domini applicazione nel processo.</summary>
        <value>Numero totale di byte esclusi per il processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo una raccolta completa di, questo numero rappresenta il numero di byte attualmente mantenuti attivi in gestiti heap. Dovrebbe essere simile al numero segnalato dal <xref:System.GC.GetTotalMemory%2A> metodo. Dopo una raccolta temporanea, questo numero rappresenta il numero di byte attualmente mantenuti attivo in generazioni temporanee.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> è impostata su <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene le dimensioni totali, in byte, di tutte le allocazioni di memoria effettuate dal dominio applicazione da quando è stato creato, senza sottrarre la memoria che è stata raccolta.</summary>
        <value>Dimensioni totali, in byte, di tutte le allocazioni di memoria.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> è impostata su <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tempo del processore totale usato da tutti i thread durante l'esecuzione nel dominio applicazione corrente, da quando il processo è stato avviato.</summary>
        <value>Tempo del processore totale per il dominio applicazione corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tempo totale, viene restituito per un dominio applicazione include il tempo impiegato da ogni thread nel processo di esecuzione nel dominio dell'applicazione.  
  
 Un thread che chiama codice non gestito è ancora associato a un dominio applicazione e il tempo del processore impiegato per l'esecuzione di che codice non gestito viene segnalato per il dominio applicazione in cui è stata effettuata la chiamata.  
  
 Quando un thread è bloccato o inattivo, non utilizzare il tempo del processore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La proprietà <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> è impostata su <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il set di autorizzazioni di un dominio applicazione creato mediante sandbox.</summary>
        <value>Set di autorizzazioni di un dominio applicazione creato mediante sandbox.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domini applicazione creata mediante sandbox che sono stati creati tramite il <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> overload del metodo dispone di un set omogeneo di autorizzazioni, vale a dire lo stesso set di autorizzazioni viene concesso a tutti gli assembly parzialmente attendibili che vengono caricati nel dominio dell'applicazione. Facoltativamente, un dominio applicazione sandboxed include un elenco di assembly con nome sicuro che non sono interessati da questo set di autorizzazioni e vengono invece eseguiti con attendibilità totale.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica alla chiusura del processo padre del dominio applicazione predefinito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.EventHandler> per questo evento è possibile eseguire le attività di chiusura, ad esempio la chiusura di file, il rilascio di archiviazione e così via, prima della fine del processo.  
  
 A partire da .NET Framework versione 2.0, questo evento viene generato in ogni dominio applicazione che registra un gestore dell'evento.  
  
> [!NOTE]
>  Il tempo di esecuzione totale di tutti <xref:System.AppDomain.ProcessExit> gestori eventi è limitato, esattamente come il tempo di esecuzione totale di tutti i finalizzatori è limitato all'arresto del processo. Il valore predefinito è di due secondi. Un host non gestito può modificare il tempo di esecuzione chiamando il [ICLRPolicyManager:: SetTimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) metodo con il [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) valore di enumerazione.  
  
 Nelle versioni di .NET Framework 1.0 e 1.1, questo evento viene generato solo nel dominio applicazione predefinito e solo se un gestore eventi è registrato nel dominio applicazione predefinito.  
  
 Per registrare un gestore eventi per questo evento, è necessario disporre delle autorizzazioni necessarie, o un <xref:System.Security.SecurityException> viene generata un'eccezione.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando la risoluzione di un assembly ha esito negativo nel contesto ReflectionOnly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nel contesto reflection-only, le dipendenze non vengono risolti automaticamente. Devono essere precaricati o restituiti dal gestore per questo evento. Questo evento viene generato quando un assembly ha una dipendenza che non è già caricata nel contesto reflection-only. La dipendenza mancante è specificata per il <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> proprietà. Il <xref:System.ResolveEventHandler> per questo evento deve restituire un assembly che soddisfa la dipendenza. L'assembly restituito deve essere caricato nel contesto reflection-only.  
  
> [!IMPORTANT]
>  Questo evento viene generato solo per le dipendenze mancanti dell'assembly che si sta caricando nel contesto reflection-only (ad esempio, tramite il <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> (metodo)). Non viene generato se l'assembly che si sta caricando non viene trovato.  
  
 A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> proprietà restituisce l'assembly che ha richiesto il caricamento dell'assembly che non può essere risolto. Conoscere l'identità dell'assembly richiesta potrebbe essere utile per identificare la versione corretta della dipendenza, se è disponibile più di una versione. Per ulteriori informazioni, vedere <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Per questo evento, il <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> proprietà restituisce il nome dell'assembly prima di applicare criteri.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce gli assembly caricati nel contesto ReflectionOnly del dominio applicazione.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.Assembly" /> che rappresentano gli assembly caricati nel contesto ReflectionOnly del dominio applicazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce gli assembly caricati nel contesto reflection-only. Per ottenere gli assembly che sono stati caricati per l'esecuzione, utilizzare il <xref:System.AppDomain.GetAssemblies%2A> metodo.  
  
   
  
## Examples  
 Esempio di codice seguente carica l'assembly System. dll nel contesto di esecuzione, quindi nel contesto reflection-only. Il <xref:System.AppDomain.GetAssemblies%2A> e <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> vengono utilizzati metodi per visualizzare gli assembly caricati in ogni contesto.  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Si è tentato di effettuare un'operazione su un dominio applicazione non caricato.</exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il percorso nella directory di base in cui deve essere verificata la presenza di assembly privati mediante il resolver dell'assembly.</summary>
        <value>Percorso nella directory di base in cui deve essere verificata la presenza di assembly privati mediante il resolver dell'assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Assembly privati vengono distribuiti nella stessa struttura di directory dell'applicazione. Se il percorso specificato per il <xref:System.AppDomain.RelativeSearchPath%2A> proprietà non è gestito da <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, viene ignorato.  
  
 Questa proprietà restituisce il valore impostato utilizzando <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni sul percorso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando la risoluzione di una risorsa ha esito negativo in quanto la risorsa stessa non è una risorsa collegata valida o non è incorporata nell'assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.ResolveEventHandler> per questo evento può tentare di individuare l'assembly contenente la risorsa e restituirlo.  
  
> [!IMPORTANT]
>  Questo evento non viene generato se la risoluzione non riesce perché può essere trovato alcun file per una risorsa collegata valida. Viene generato se un flusso di risorsa di manifesto non è stato trovato, ma non viene generato se non viene trovata una chiave singola risorsa.  
  
 A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> proprietà contiene l'assembly che ha richiesto la risorsa. Per ulteriori informazioni, vedere <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Per registrare un gestore eventi per questo evento, è necessario disporre delle autorizzazioni necessarie, o un <xref:System.Security.SecurityException> viene generata un'eccezione.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="domainPolicy">Livello dei criteri di sicurezza.</param>
        <summary>Imposta il livello dei criteri di sicurezza per il dominio applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo prima del caricamento in un assembly di <xref:System.AppDomain> affinché i criteri di sicurezza ha effetto.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.AppDomain.SetAppDomainPolicy%2A> per impostare il livello di criteri di sicurezza di un dominio applicazione.  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domainPolicy" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Il livello dei criteri di sicurezza è già stato impostato.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso completo delle copie shadow.</param>
        <summary>Imposta il percorso di directory specificato come percorso in cui vengono replicati gli assembly mediante copia shadow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il percorso della cache viene ignorato se il <xref:System.AppDomainSetup.ApplicationName%2A> non è impostata. Vedere la proprietà <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>.  
  
 Per ulteriori informazioni sulla creazione di copie shadow vedere [copie Shadow di assembly](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Assegna un valore a una proprietà del dominio applicazione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nome della proprietà del dominio applicazione definito dall'utente da creare o modificare.</param>
        <param name="data">Valore della proprietà.</param>
        <summary>Assegna il valore specificato alla proprietà specificata del dominio applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per inserire una voce o modificare il valore di una voce in una cache interna di coppie nome / dati che descrivono le proprietà di questa istanza di <xref:System.AppDomain>.  
  
 La cache contiene automaticamente le voci di sistema predefiniti che vengono inserite quando viene creato il dominio dell'applicazione. È possibile inserire o modificare voci di sistema con questo metodo. Una chiamata al metodo che tenta di modificare una voce nel sistema non ha effetto. il metodo non genera un'eccezione. È possibile controllare i valori delle voci di sistema con il <xref:System.AppDomain.GetData%2A> metodo o l'equivalente <xref:System.AppDomainSetup> descritte le proprietà <xref:System.AppDomain.GetData%2A>.  
  
 È possibile chiamare questo metodo per impostare il valore dell'intervallo di timeout predefinito per la valutazione di modelli di espressione regolare per fornire "REGEX_DEFAULT_MATCH_TIMEOUT" come valore della `name` argomento e un <xref:System.TimeSpan> valore che rappresenta il timeout il valore di intervallo di `data` argomento. È anche possibile inserire o modificare la propria coppie nome / dati definiti dall'utente con questo metodo e verificarne i valori con il <xref:System.AppDomain.GetData%2A> metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> metodo per creare una nuova coppia di valori. Nell'esempio viene utilizzata la <xref:System.AppDomain.GetData%2A> metodo per recuperare il valore e lo visualizza nella console.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="permission" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="name">Nome della proprietà del dominio applicazione definito dall'utente da creare o modificare.</param>
        <param name="data">Valore della proprietà.</param>
        <param name="permission">Autorizzazione di richiesta del chiamante quando viene recuperata la proprietà.</param>
        <summary>Assegna il valore specificato alla proprietà del dominio applicazione indicata, con una determinata autorizzazione di richiesta del chiamante quando viene recuperata la proprietà.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per inserire o modificare voci personalizzate definite dall'utente in una cache interna di coppie nome/dati che descrivono le proprietà del dominio dell'applicazione. Quando si inserisce una voce, è possibile specificare una richiesta di autorizzazione da applicare quando viene recuperata la voce. Inoltre, è possibile chiamare questo metodo per impostare il valore dell'intervallo di timeout predefinito per la valutazione di modelli di espressione regolare per fornire "REGEX_DEFAULT_MATCH_TIMEOUT" come valore del `name` argomento e un <xref:System.TimeSpan> valore che rappresenta il uguale al valore dell'intervallo di timeout di `data` argomento.  
  
 È possibile usare questo metodo per assegnare una richiesta di sicurezza in una stringa di proprietà definita dal sistema.  
  
 La cache contiene automaticamente le voci di sistema predefiniti che vengono inserite quando viene creato il dominio dell'applicazione. È possibile inserire o modificare voci di sistema con questo metodo. Una chiamata al metodo che tenta di modificare una voce nel sistema non ha effetto. il metodo non genera un'eccezione. È possibile controllare i valori delle voci di sistema con il <xref:System.AppDomain.GetData%2A> metodo o l'equivalente <xref:System.AppDomainSetup> proprietà descritte nella sezione Osservazioni per il <xref:System.AppDomain.GetData%2A> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          Il parametro <paramref name="name" /> specifica una stringa di proprietà definita dal sistema e il parametro <paramref name="permission" /> non è <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Percorso completo che costituisce la directory di base per le sottodirectory in cui sono archiviati gli assembly dinamici.</param>
        <summary>Imposta il percorso di directory specificato come directory di base per sottodirectory in cui vengono archiviati i file generati dinamicamente e tramite cui si accede a questi ultimi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo imposta la <xref:System.AppDomainSetup.DynamicBase%2A> proprietà dell'oggetto interno <xref:System.AppDomainSetup> associata a questa istanza.  
  
   
  
## Examples  
 Questo metodo è obsoleto e non deve essere utilizzato per nuove attività di sviluppo. Nell'esempio seguente viene illustrato come utilizzare l'alternativa non obsoleta, la <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> proprietà. Per una spiegazione di questo esempio, vedere il <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> proprietà o <xref:System.AppDomain.DynamicDirectory%2A> proprietà.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">Uno dei valori dell'enumerazione <see cref="T:System.Security.Principal.PrincipalPolicy" /> che specifica il tipo dell'oggetto Principal da associare ai thread.</param>
        <summary>Specifica come collegare oggetti Principal e Identity a un thread se si tenta di associare il thread a un Principal durante l'esecuzione nel dominio applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostando questo valore saranno effettiva solo se si imposta la proprietà prima di utilizzare il <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> proprietà. Ad esempio, se si imposta <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> a una determinata entità (ad esempio, un'entità generica) e quindi utilizzare il <xref:System.AppDomain.SetPrincipalPolicy%2A> per impostare il <xref:System.Security.Principal.PrincipalPolicy> a <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, l'entità corrente rimarrà entità generica.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'effetto sui thread dell'utilizzo di <xref:System.AppDomain.SetPrincipalPolicy%2A> metodo per modificare i criteri del dominio dell'applicazione principali. Viene inoltre illustrato l'effetto dell'uso di <xref:System.AppDomain.SetThreadPrincipal%2A> metodo per modificare l'entità che è disponibile per la connessione ai thread nel dominio dell'applicazione.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per modificare l'oggetto principal. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Attiva la replica tramite copia shadow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni sulla creazione di copie shadow, vedere [copie Shadow di assembly](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Questo metodo è obsoleto e non deve essere utilizzato per nuove attività di sviluppo.  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Elenco di nomi di directory in cui i nomi sono separati da un punto e virgola.</param>
        <summary>Imposta il percorso di directory specificato come percorso degli assembly da replicare mediante copia shadow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, una copia shadow include tutti gli assembly trovati durante il rilevamento. Il <xref:System.AppDomain.SetShadowCopyPath%2A> metodo limita la copia shadow agli assembly nella directory specificata da `path`.  
  
 Il <xref:System.AppDomain.SetShadowCopyPath%2A> (metodo) non specifica directory aggiuntive in cui cercare gli assembly. Assembly da una copia shadow deve già trovarsi nel percorso di ricerca, ad esempio in <xref:System.AppDomain.BaseDirectory%2A>. Il <xref:System.AppDomain.SetShadowCopyPath%2A> metodo specifica quali percorsi di ricerca sono idonei per l'esecuzione della copia shadow.  
  
 Questo metodo imposta la <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> proprietà dell'oggetto interno <xref:System.AppDomainSetup> associata a questa istanza.  
  
 Per ulteriori informazioni sulla creazione di copie shadow, vedere [copie Shadow di assembly](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Questo metodo è obsoleto e non deve essere utilizzato per nuove attività di sviluppo.  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal">Oggetto Principal da collegare ai thread.</param>
        <summary>Imposta l'oggetto Principal predefinito da collegare ai thread se si tenta di associare questi ultimi a un oggetto Principal durante l'esecuzione nel dominio applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato l'effetto dell'uso di <xref:System.AppDomain.SetThreadPrincipal%2A> metodo per modificare l'entità che è disponibile per la connessione ai thread sono in esecuzione nel dominio dell'applicazione. Viene inoltre illustrato l'effetto sui thread dell'utilizzo di <xref:System.AppDomain.SetPrincipalPolicy%2A> metodo per modificare i criteri del dominio dell'applicazione principali.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="principal" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">L'oggetto Principal del thread è già stato impostato.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per modificare l'oggetto principal. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene le informazioni sulla configurazione del dominio applicazione per l'istanza.</summary>
        <value>Informazioni sull'inizializzazione del dominio applicazione.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se il dominio applicazione è configurato per eseguire la copia shadow di file.</summary>
        <value>
          <see langword="true" /> se il dominio applicazione è configurato per eseguire la copia shadow di file; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni, vedere <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> e [copie Shadow di assembly](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L'operazione viene tentata in un dominio dell'applicazione non caricato.</exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Riservato per utilizzi futuri. Deve essere IID_NULL.</param>
        <param name="rgszNames">Matrice di nomi passata di cui eseguire il mapping.</param>
        <param name="cNames">Conteggio dei nomi di cui eseguire il mapping.</param>
        <param name="lcid">Contesto delle impostazioni locali in cui interpretare i nomi.</param>
        <param name="rgDispId">Matrice allocata dal chiamante che riceve gli ID corrispondenti ai nomi.</param>
        <summary>Esegue il mapping di un set di nomi a un set corrispondente di ID dispatch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::GetIDsOfNames`, vedere MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informazioni sul tipo da restituire.</param>
        <param name="lcid">Identificatore delle impostazioni locali per le informazioni sul tipo.</param>
        <param name="ppTInfo">Riceve un puntatore all'oggetto relativo alle informazioni sul tipo richiesto.</param>
        <summary>Recupera le informazioni sul tipo relative a un oggetto che può quindi essere usato per ottenere informazioni sul tipo relative a un'interfaccia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::GetTypeInfo`, vedere MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Punta a una posizione che riceve il numero di interfacce di informazioni sul tipo fornite dall'oggetto.</param>
        <summary>Recupera il numero delle interfacce di informazioni sul tipo fornite da un oggetto (0 o 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::GetTypeInfoCount`, vedere MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifica il membro.</param>
        <param name="riid">Riservato per utilizzi futuri. Deve essere IID_NULL.</param>
        <param name="lcid">Contesto di impostazioni locali all'interno del quale devono essere interpretati gli argomenti.</param>
        <param name="wFlags">Flag che descrivono il contesto della chiamata.</param>
        <param name="pDispParams">Puntatore a una struttura contenente una matrice di argomenti, una matrice di DISPID per argomenti denominati e i conteggi del numero di elementi nelle matrici.</param>
        <param name="pVarResult">Puntatore alla posizione in cui deve essere archiviato il risultato.</param>
        <param name="pExcepInfo">Puntatore a una struttura contenente informazioni sull'eccezione.</param>
        <param name="puArgErr">Indice del primo argomento che contiene un errore.</param>
        <summary>Fornisce l'accesso a proprietà e metodi esposti da un oggetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::Invoke`, vedere MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene una rappresentazione di stringa che comprende il nome descrittivo del dominio applicazione e qualsiasi criterio di contesto.</summary>
        <returns>Stringa formata concatenando la rappresentazione formale di stringa "Name:", il nome descrittivo del dominio applicazione e le rappresentazioni di stringa dei criteri di contesto o la stringa "There are no context policies".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore restituito di <xref:System.AppDomain.ToString%2A> metodo.  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Il dominio applicazione rappresentato dall'oggetto <see cref="T:System.AppDomain" /> corrente è stato scaricato.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando la risoluzione di un tipo non riesce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AppDomain.TypeResolve> evento si verifica quando in common language runtime è in grado di determinare l'assembly che è possibile creare il tipo richiesto. Ciò può verificarsi se il tipo è definito in un assembly dinamico, o il tipo non è definito in un assembly dinamico ma il runtime non conosce il tipo è definito nell'assembly. La seconda situazione può verificarsi quando <xref:System.Type.GetType%2A?displayProperty=nameWithType> viene chiamato con un nome di tipo che non è qualificato con il nome dell'assembly.  
  
 Il <xref:System.ResolveEventHandler> per questo evento può tentare di individuare e creare il tipo.  
  
 Tuttavia, il <xref:System.AppDomain.TypeResolve> evento non viene eseguito se il runtime è in grado non è possibile trovare un tipo in determinati assembly. Ad esempio, questo evento non si verifica se il tipo non viene trovato in un assembly statico perché il runtime è in grado di tipi non possono essere aggiunte dinamicamente per gli assembly statici.  
  
 A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> proprietà contiene l'assembly che ha richiesto il tipo. Per ulteriori informazioni, vedere <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Per registrare un gestore eventi per questo evento, è necessario disporre delle autorizzazioni necessarie, o un <xref:System.Security.SecurityException> viene generata un'eccezione.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.TypeResolve> evento.  
  
 Per eseguire questo esempio di codice, è necessario fornire il nome completo dell'assembly. Per informazioni su come ottenere il nome completo dell'assembly, vedere [i nomi degli Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando non viene intercettata un'eccezione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo evento di notifica delle eccezioni non rilevate. Consente all'applicazione di registrare informazioni sull'eccezione prima che il gestore di sistema predefinito segnala l'eccezione all'utente e termina l'applicazione. Se sono disponibili sufficienti informazioni sullo stato dell'applicazione, si possono intraprendere altre azioni, quali il salvataggio di dati del programma per il ripristino di versioni successive. È consigliabile prestare attenzione, perché i dati del programma possono risultare danneggiati quando le eccezioni non gestite.  
  
> [!NOTE]
>  Nelle versioni di .NET Framework 1.0 e 1.1, la terminazione dell'applicazione e le opzioni di debug vengono segnalati all'utente prima di questo evento viene generato, anziché dopo.  
  
 Questo evento può essere gestito in qualsiasi dominio applicazione. Tuttavia, l'evento non viene necessariamente generato nel dominio dell'applicazione in cui si è verificata l'eccezione. Un'eccezione viene gestita solo se l'intero stack per il thread è stato rimosso senza trovare un gestore di eccezioni applicabile, pertanto il primo elemento che può essere generato l'evento è nel dominio dell'applicazione in cui il thread ha avuto origine.  
  
> [!NOTE]
>  Nelle versioni di .NET Framework 1.0 e 1.1, questo evento si verifica solo per il dominio applicazione predefinito creato dal sistema quando viene avviata un'applicazione. Se un'applicazione crea domini applicazione aggiuntivi, specificando un delegato per questo evento in tali domini applicazioni non ha alcun effetto.  
  
 Se il <xref:System.AppDomain.UnhandledException> evento viene gestito nel dominio applicazione predefinito, viene generato in per qualsiasi eccezione non gestita in qualsiasi thread, indipendentemente dal dominio applicazione avviato il thread. Se il thread avviato in un dominio applicazione che dispone di un gestore eventi per <xref:System.AppDomain.UnhandledException>, l'evento viene generato nel dominio dell'applicazione. Dominio dell'applicazione non è il dominio applicazione predefinito, se non vi è un gestore dell'evento nel dominio applicazione predefinito, viene generato l'evento in entrambi i domini applicazione.  
  
 Ad esempio, si supponga che un thread viene avviato in dominio applicazione "AD1", chiama un metodo nel dominio applicazione "AD2" e da lì chiama un metodo nel dominio applicazione "AD3", in cui viene generata un'eccezione. Il primo dominio di applicazione in cui il <xref:System.AppDomain.UnhandledException> può essere generato l'evento è "AD1". Se il dominio dell'applicazione non è il dominio applicazione predefinito, l'evento può essere generato anche nel dominio applicazione predefinito.  
  
> [!NOTE]
>  Common language runtime sospende le interruzioni dei thread durante i gestori eventi per il <xref:System.AppDomain.UnhandledException> evento sono in esecuzione.  
  
 Se il gestore di evento include un <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attributo con il flag appropriati, il gestore dell'evento viene considerato come un'area a esecuzione vincolata.  
  
 A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], questo evento non viene generato per le eccezioni che danneggiano lo stato del processo, ad esempio overflow dello stack o violazioni di accesso, a meno che il gestore dell'evento è critico per la sicurezza e ha il <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> attributo.  
  
 Nelle versioni di .NET Framework 1.0 e 1.1, un'eccezione non gestita che si verifica in un thread diverso dal thread principale dell'applicazione viene intercettata dal runtime e pertanto non causa l'interruzione dell'applicazione. Di conseguenza, è possibile che il <xref:System.AppDomain.UnhandledException> dell'evento senza che l'applicazione termini. A partire da .NET Framework versione 2.0, questo trasparenti comprendeva per le eccezioni non gestite nei thread figlio è stato rimosso, poiché l'effetto cumulativo di tali errori invisibile all'utente un calo delle prestazioni, dati danneggiati e blocchi, ognuno dei quali sono stati difficile eseguire il debug. Per ulteriori informazioni, incluso un elenco di casi in cui il runtime non viene terminato, vedere [eccezioni in thread gestiti](~/docs/standard/threading/exceptions-in-managed-threads.md).  
  
 Per registrare un gestore eventi per questo evento, è necessario disporre delle autorizzazioni necessarie, o un <xref:System.Security.SecurityException> viene generata un'eccezione.  
  
 Per ulteriori informazioni sulla gestione degli eventi, vedere [gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
## <a name="other-events-for-unhandled-exceptions"></a>Altri eventi per le eccezioni non gestite  
 Per determinati modelli di applicazione, il <xref:System.AppDomain.UnhandledException> evento può essere superato da altri eventi se si verifica l'eccezione non gestita nel thread principale dell'applicazione.  
  
 Nelle applicazioni che usano Windows Form, eccezioni non gestite nella causa del thread principale dell'applicazione di <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> dell'evento. Se questo evento viene gestito, il comportamento predefinito prevede che l'eccezione non gestita non termina l'applicazione, anche se l'applicazione viene lasciato in uno stato sconosciuto. In tal caso, il <xref:System.AppDomain.UnhandledException> non viene generato l'evento. Questo comportamento può essere modificato utilizzando il file di configurazione dell'applicazione o tramite il <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> metodo per modificare la modalità di <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> prima di <xref:System.Windows.Forms.Application.ThreadException> gestore di evento è associato. Questo vale solo per il thread principale dell'applicazione. Il <xref:System.AppDomain.UnhandledException> evento viene generato per le eccezioni non gestite generate in altri thread.  
  
 A partire da Microsoft Visual Studio 2005, il framework dell'applicazione Visual Basic fornisce un altro evento per le eccezioni non gestite nel thread principale dell'applicazione. Vedere il <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> evento. Questo evento è un oggetto di argomenti di eventi con lo stesso nome dell'oggetto di argomenti di evento utilizzato da <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, ma con proprietà diverse. In particolare, questo oggetto di argomenti di evento include un <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> proprietà che consente all'applicazione di continuare l'esecuzione, ignorando l'eccezione non gestita (e lasciando l'applicazione in uno stato sconosciuto). In tal caso, il <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> non viene generato l'evento.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato il <xref:System.AppDomain.UnhandledException> evento. Definisce un gestore eventi, `MyHandler`, che viene richiamato ogni volta che viene generata un'eccezione non gestita nel dominio applicazione predefinito. Genera quindi due eccezioni. Il primo viene gestito da un **try/catch** blocco. Il secondo viene gestito e richiama il `MyHandle` routine prima della chiusura dell'applicazione.  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain">Dominio applicazione da scaricare.</param>
        <summary>Scarica il dominio applicazione corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework versione 2.0 è un thread dedicato di scaricamento di domini applicazione. Ciò migliora l'affidabilità, soprattutto quando è ospitato in .NET Framework. Quando un thread chiama <xref:System.AppDomain.Unload%2A>, il dominio di destinazione è contrassegnato per lo scaricamento. Il thread dedicato tenta di scaricare il dominio e tutti i thread nel dominio sono state interrotte. Se un thread viene interrotto, ad esempio perché è in esecuzione il codice non gestito o perché è in esecuzione un `finally` blocco, quindi dopo un periodo di tempo un <xref:System.CannotUnloadAppDomainException> viene generata nel thread che ha originariamente chiamato <xref:System.AppDomain.Unload%2A>. Se il thread che non venga interrotto infine termina, il dominio di destinazione non viene scaricato. Pertanto, in .NET Framework versione 2.0 `domain` non è garantita per essere scaricato, perché potrebbe non essere possibile terminare l'esecuzione di thread.  
  
> [!NOTE]
>  In alcuni casi, la chiamata <xref:System.AppDomain.Unload%2A> genera un'eccezione immediata <xref:System.CannotUnloadAppDomainException>, ad esempio se viene chiamato in un finalizzatore.  
  
 I thread nel `domain` vengono terminati mediante il <xref:System.Threading.Thread.Abort%2A> metodo, che genera un <xref:System.Threading.ThreadAbortException> nel thread. Anche se il thread viene terminato immediatamente, può continuare l'esecuzione per un periodo di tempo in imprevedibile un `finally` clausola.  
  
## <a name="version-compatibility"></a>Compatibilità tra versioni  
 In .NET Framework versioni 1.0 e 1.1, se il thread che chiama <xref:System.AppDomain.Unload%2A> è in esecuzione in `domain`, viene avviato un altro thread per eseguire l'operazione di scaricamento. Se `domain` non può essere scaricato, un <xref:System.CannotUnloadAppDomainException> viene generata in tale thread, non nel thread originale che ha chiamato <xref:System.AppDomain.Unload%2A>. Tuttavia, se il thread che chiama <xref:System.AppDomain.Unload%2A> è in esecuzione all'esterno di `domain`, che i thread riceve l'eccezione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come scaricare un dominio applicazione.  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> è <see langword="null" />.</exception>
        <exception cref="T:System.CannotUnloadAppDomainException">
          Impossibile scaricare <paramref name="domain" />.</exception>
        <exception cref="T:System.Exception">Si è verificato un errore durante il processo di scaricamento.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per aggiungere un gestore eventi per questo evento. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>