<Type Name="Delegate" FullName="System.Delegate">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e93909d2c823c996b099c481764f4950992421a9" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48646366" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un delegato, ossia la struttura di dati che fa riferimento a un metodo static o a un'istanza di classe e un metodo di istanza di quella classe.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Delegate> classe è la classe base per i tipi delegati. Tuttavia, solo il sistema e i compilatori possono derivare in modo esplicito il <xref:System.Delegate> classe o dal <xref:System.MulticastDelegate> classe. Non è inoltre possibile derivare un nuovo tipo da un tipo delegato. Il <xref:System.Delegate> classe non viene considerata un tipo delegato, ovvero una classe utilizzata per derivare i tipi delegati.  
  
 Implementano la maggior parte dei linguaggi una `delegate` parola chiave e i compilatori di tali linguaggi sono in grado di derivare dal <xref:System.MulticastDelegate> classe; pertanto, gli utenti devono usare il `delegate` parola chiave del linguaggio.  
  
> [!NOTE]
>  Common language runtime fornisce un `Invoke` metodo per ogni tipo di delegato, con la stessa firma del delegato. Non è necessario chiamare questo metodo in modo esplicito dal codice c#, Visual Basic o Visual C++, perché i compilatori chiamano automaticamente. Il `Invoke` metodo è utile negli [reflection](~/docs/framework/reflection-and-codedom/reflection.md) quando si desidera trovare la firma del tipo delegato.  
  
 Common language runtime fornisce ogni tipo di delegato con `BeginInvoke` e `EndInvoke` nei metodi per abilitare la chiamata asincrona del delegato. Per altre informazioni su questi metodi, vedere [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 La dichiarazione di un tipo delegato stabilisce un contratto che specifica la firma di uno o più metodi. Un delegato è un'istanza di un tipo delegato che contiene riferimenti a:  
  
-   Un metodo di istanza di un tipo e un oggetto di destinazione può essere assegnato a tale tipo.  
  
-   Un metodo di istanza di un tipo, con nascosto `this` parametro esposto nell'elenco di parametri formali. Il delegato è associato a un'istanza aperta di delegato.  
  
-   Un metodo statico.  
  
-   Un metodo statico e un oggetto di destinazione può essere assegnato al primo parametro del metodo. Il delegato per essere chiuso al primo argomento.  
  
 Per ulteriori informazioni sull'associazione di delegati, vedere il <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> overload del metodo.  
  
> [!NOTE]
>  Nelle versioni 1.0 e 1.1 di .NET Framework, un delegato può rappresentare un metodo solo se la firma del metodo corrisponde esattamente alla firma specificata dal tipo di delegato. Di conseguenza, è supportato solo il primo e il terzo punto dell'elenco precedente, e al primo punto richiede una corrispondenza di tipo esatto.  
  
 Quando un delegato rappresenta un metodo di istanza chiuso al primo argomento (il caso più comune), viene archiviato un riferimento al punto di ingresso del metodo e un riferimento a un oggetto, denominato destinazione, che è un tipo assegnabile al tipo di cui è definito il metodo. Quando un delegato rappresenta un metodo di istanza aperta, archivia un riferimento al punto di ingresso del metodo. La firma del delegato deve includere nascosto `this` parametro nel relativo elenco di parametri formali; in questo caso, il delegato non è un riferimento a un oggetto di destinazione, e un oggetto di destinazione deve essere specificato quando viene richiamato il delegato.  
  
 Quando un delegato rappresenta un metodo statico, il delegato archivia un riferimento al punto di ingresso del metodo. Quando un delegato rappresenta un metodo statico chiuso al primo argomento, il delegato archivia un riferimento al punto di ingresso del metodo e un riferimento a un oggetto di destinazione può essere assegnato al tipo del primo argomento del metodo. Quando il delegato viene richiamato, il primo argomento del metodo statico riceve l'oggetto di destinazione.  
  
 L'elenco chiamate di un delegato è un set ordinato di delegati in cui ogni elemento dell'elenco richiama esattamente uno dei metodi rappresentati dal delegato. Un elenco di chiamate può contenere metodi duplicati. Durante una chiamata, i metodi vengono richiamati nell'ordine in cui vengono visualizzati nell'elenco chiamate. Un delegato tenta di richiamare ogni metodo nell'elenco chiamate; una volta per ogni volta che vengono visualizzati nell'elenco chiamate, vengono richiamati i duplicati. I delegati sono immutabili. una volta creato, non modifica l'elenco chiamate di un delegato.  
  
 I delegati vengono definiti come multicast o combinabile, perché un delegato può richiamare uno o più metodi e può essere usato in combinazione di operazioni.  
  
 La combinazione di operazioni, ad esempio <xref:System.Delegate.Combine%2A> e <xref:System.Delegate.Remove%2A>, delegati esistenti non verranno modificati. Al contrario, questa operazione restituisce un nuovo delegato che contiene i risultati dell'operazione, un delegato invariato o `null`. Restituisce un'operazione di combinazione `null` quando il risultato dell'operazione è un delegato che non fa riferimento ad almeno un metodo. Un'operazione di combinazione restituisce un delegato invariato durante l'operazione richiesta non ha alcun effetto.  
  
> [!NOTE]
>  Linguaggi gestiti utilizzano le <xref:System.Delegate.Combine%2A> e <xref:System.Delegate.Remove%2A> metodi per implementare le operazioni di delegato. Gli esempi includono la `AddHandler` e `RemoveHandler` istruzioni in Visual Basic e gli operatori + = e -= in tipi delegati in c#.  
  
 A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], tipi delegati generici possono avere parametri di tipo variante. Parametri di tipo controvariante possono essere utilizzati come tipi di parametro del delegato e un parametro di tipo covariante può essere utilizzato come tipo restituito. Questa funzionalità consente di delegato generico tipi costruiti dalla stessa definizione di tipo generico per essere compatibili con l'assegnazione se i relativi argomenti di tipo sono tipi di riferimento con una relazione di ereditarietà, come spiegato in [covarianza e La controvarianza](~/docs/standard/generics/covariance-and-contravariance.md).  
  
> [!NOTE]
>  I delegati generici che sono compatibili con l'assegnazione a causa della varianza non sono necessariamente combinabili. Per essere combinabili, i tipi devono corrispondere esattamente. Ad esempio, si supponga che una classe denominata `Derived` deriva da una classe denominata `Base`. Un delegato del tipo `Action<Base>` (`Action(Of Base)` in Visual Basic) può essere assegnato a una variabile di tipo `Action<Derived>`, ma non è possibile combinare le due delegati perché i tipi non corrispondono esattamente.  
  
 Se un metodo richiamato genera un'eccezione, il metodo viene arrestata l'esecuzione, l'eccezione viene passata al chiamante del delegato e non vengono richiamati i metodi rimanenti nell'elenco chiamate. Rilevare l'eccezione nel chiamante non modificare questo comportamento.  
  
 Quando la firma dei metodi richiamati da un delegato include un valore restituito, il delegato restituisce il valore restituito dell'ultimo elemento nell'elenco chiamate. Quando la firma include un parametro che viene passato per riferimento, il valore finale del parametro è il risultato di ogni metodo nell'elenco chiamate in esecuzione in modo sequenziale e aggiornare il valore del parametro.  
  
 L'equivalente più vicino di un delegato in C o C++ è un puntatore a funzione. Un delegato può rappresentare un metodo statico o un metodo di istanza. Quando il delegato rappresenta un metodo di istanza, il delegato archivia non solo un riferimento al punto di ingresso del metodo, ma anche un riferimento all'istanza della classe. A differenza dei puntatori a funzione, i delegati sono orientate a oggetti e indipendente dai tipi.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come definire un delegato denominato `myMethodDelegate`. Vengono create istanze di questo delegato per un metodo di istanza e un metodo statico di annidata `mySampleClass` classe. Il delegato per il metodo di istanza richiede un'istanza di `mySampleClass`. Il `mySampleClass` istanza viene salvata in una variabile denominata `mySC`.  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
    <related type="Article" href="http://msdn.microsoft.com/library/41972034-92ed-450a-9664-ab93fcc6f1fb">Chiamata asincrona dei metodi sincroni</related>
    <related type="Article" href="~/docs/csharp/programming-guide/delegates/index.md">Delegati (Guida per programmatori C#)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/delegates/index.md">Delegati (Visual Basic)</related>
    <related type="Article" href="http://msdn.microsoft.com/library/1cdf3420-89c1-47c0-b796-aa984020e0f8">Procedura: definire e utilizzare delegati (C++/CLI)</related>
    <related type="Article" href="http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f">Gestione e generazione di eventi</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza un nuovo delegato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">Istanza di classe sulla quale viene richiamato il parametro <c>method</c>.</param>
        <param name="method">Nome del metodo di istanza rappresentato dal delegato.</param>
        <summary>Inizializza un delegato che richiama il metodo di istanza specificato nell'istanza di classe specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore non può essere utilizzato nel codice dell'applicazione. Per creare un delegato che specifica il nome di un metodo di istanza, usare un overload del <xref:System.Delegate.CreateDelegate%2A> metodo che specifica un nome di metodo e un oggetto di destinazione. Ad esempio, il <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> overload del metodo crea un delegato per un metodo di istanza con un nome specificato.  
  
 Questo costruttore crea i delegati, ad esempio solo i metodi. Un metodo di istanza è un metodo che è associato a un'istanza di una classe. un metodo statico è un metodo che è associato alla classe stessa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> è <see langword="null" />.  
  
oppure 
 <paramref name="method" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Si è verificato un errore durante l'associazione al metodo di destinazione.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">Classe <see cref="T:System.Type" /> che rappresenta la classe che definisce il parametro <c>method</c>.</param>
        <param name="method">Nome del metodo statico rappresentato dal delegato.</param>
        <summary>Inizializza un delegato tramite cui viene richiamato il metodo statico specificato dalla classe specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore non può essere utilizzato nel codice dell'applicazione. Per creare un delegato che specifica il nome di un metodo statico, usare un overload del <xref:System.Delegate.CreateDelegate%2A> metodo che specifica un nome di metodo, ma non specifica un oggetto di destinazione. Ad esempio, il <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> overload del metodo crea un delegato per un metodo statico con un nome specificato.  
  
 Questo costruttore crea i delegati per solo i metodi statici. Un metodo di istanza è un metodo che è associato a un'istanza di una classe. un metodo statico è un metodo che è associato alla classe stessa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> è <see langword="null" />.  
  
oppure 
 <paramref name="method" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> non è un oggetto <see langword="RuntimeType" />. Vedere [Tipi di runtime nella reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
oppure 
 <paramref name="target" /> rappresenta un tipo generico aperto.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una copia superficiale del delegato.</summary>
        <returns>Copia superficiale del delegato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clonazione presenta lo stesso <xref:System.Type>, elenco di destinazione, metodo e nella chiamata del delegato dell'originale.  
  
 Una copia superficiale crea una nuova istanza dello stesso tipo dell'oggetto originale e copia quindi i campi non statici dell'oggetto originale. Se il campo è un tipo di valore, viene eseguita una copia bit per bit del campo. Se il campo è un tipo riferimento, il riferimento è copiato ma l'oggetto di cui viene fatto riferimento non; Pertanto, il riferimento nell'oggetto originale e il riferimento nel clone puntare allo stesso oggetto. Al contrario, una copia completa di un oggetto consente di duplicare tutti gli elementi direttamente o indirettamente fa riferimento i campi nell'oggetto.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esegue la concatenazione dell'elenco chiamate dei delegati multicast, o combinabili, specificati.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">Matrice di delegati da combinare.</param>
        <summary>Esegue la concatenazione degli elenchi chiamate di una matrice di delegati.</summary>
        <returns>Nuovo delegato con un elenco chiamate in cui vengono concatenati gli elenchi chiamate dei delegati nella matrice <paramref name="delegates" />. Restituisce <see langword="null" /> se <paramref name="delegates" /> è <see langword="null" />, se <paramref name="delegates" /> contiene zero elementi o se ogni voce in <paramref name="delegates" /> è <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il `delegates` matrice contiene voci che sono `null`, tali voci vengono ignorate.  
  
 L'elenco chiamate può contenere le voci duplicate; vale a dire, le voci che fanno riferimento al metodo di stesso sullo stesso oggetto.  
  
> [!NOTE]
>  I delegati generici che sono compatibili con l'assegnazione a causa della varianza non sono necessariamente combinabili. Per essere combinabili, i tipi devono corrispondere esattamente. Ad esempio, si supponga che una classe denominata `Derived` deriva da una classe denominata `Base`. Un delegato del tipo `Action<Base>` (`Action(Of Base)` in Visual Basic) può essere assegnato a una variabile di tipo `Action<Derived>`, come illustrato in [covarianza e controvarianza](~/docs/standard/generics/covariance-and-contravariance.md), ma i due delegati non possono essere combinati in quanto i tipi non corrispondono esattamente.  
  
 <xref:System.Delegate.Combine%2A> è utile per la creazione di gestori di eventi che si verifica più metodi ogni volta un evento di chiamata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Non tutte le voci non null in <paramref name="delegates" /> sono istanze dello stesso tipo di delegato.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">Delegato il cui elenco chiamate viene considerato per primo.</param>
        <param name="b">Delegato il cui elenco chiamate viene considerato per ultimo.</param>
        <summary>Esegue la concatenazione degli elenchi chiamate di due delegati.</summary>
        <returns>Nuovo delegato con un elenco chiamate in cui vengono concatenati gli elenchi chiamate di <paramref name="a" /> e <paramref name="b" /> (in quell'ordine). Restituisce <paramref name="a" /> se <paramref name="b" /> è <see langword="null" />, restituisce <paramref name="b" /> se <paramref name="a" /> è un riferimento Null e restituisce un riferimento Null se <paramref name="a" /> e <paramref name="b" /> sono entrambi riferimenti Null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'elenco chiamate può contenere le voci duplicate; vale a dire, le voci che fanno riferimento al metodo di stesso sullo stesso oggetto.  
  
> [!NOTE]
>  I delegati generici che sono compatibili con l'assegnazione a causa della varianza non sono necessariamente combinabili. Per essere combinabili, i tipi devono corrispondere esattamente. Ad esempio, si supponga che una classe denominata `Derived` deriva da una classe denominata `Base`. Un delegato del tipo `Action<Base>` (`Action(Of Base)` in Visual Basic) può essere assegnato a una variabile di tipo `Action<Derived>`, come illustrato in [covarianza e controvarianza](~/docs/standard/generics/covariance-and-contravariance.md), ma i due delegati non possono essere combinati in quanto i tipi non corrispondono esattamente.  
  
 <xref:System.Delegate.Combine%2A> è utile per la creazione di gestori di eventi che si verifica più metodi ogni volta un evento di chiamata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Né <paramref name="a" /> e <paramref name="b" /> sono <see langword="null" /> e né <paramref name="a" /> né <paramref name="b" /> sono istanze dello stesso tipo delegato.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">Delegato multicast, o combinabile, il cui elenco chiamate va aggiunto alla fine dell'elenco chiamate del delegato multicast o combinabile corrente.</param>
        <summary>Esegue la concatenazione degli elenchi chiamate dei delegati multicast o combinabili specificati e del delegato multicast o combinabile corrente.</summary>
        <returns>Nuovo delegato multicast o combinabile nel cui elenco chiamate vengono concatenati l'elenco chiamate del delegato multicast o combinabile corrente e l'elenco chiamate di <paramref name="d" />; in alternativa, se <paramref name="d" /> è <see langword="null" />, verrà restituito il delegato multicast o combinabile corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo si applica solo se il delegato corrente è multicast, o combinabile.  
  
 L'implementazione corrente genera semplicemente un <xref:System.MulticastNotSupportedException>.  
  
 L'elenco chiamate può contenere le voci duplicate; vale a dire, le voci che fanno riferimento al metodo di stesso sullo stesso oggetto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">Sempre generato.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un delegato del tipo specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> del delegato da creare.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> che descrive il metodo statico o il metodo di istanza che deve essere rappresentato dal delegato. Nelle versioni 1.0 e 1.1 di .NET Framework sono supportati solo i metodi statici.</param>
        <summary>Crea un delegato del tipo specificato che rappresenta il metodo statico specificato.</summary>
        <returns>Delegato del tipo specificato che rappresenta il metodo statico specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework versioni 1.0 e 1.1, questo overload del metodo consente di creare i delegati per solo i metodi statici. In .NET Framework versione 2.0, questo overload del metodo anche può creare Apri istanza metodo i delegati; metodi di istanza, ovvero i delegati che forniscono in modo esplicito il primo argomento di nascosto. Per informazioni dettagliate, vedere il metodo più generico <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> overload del metodo, che consente di creare tutte le combinazioni dei delegati chiusi o aperti per l'istanza o metodi statici e, facoltativamente, specificare un primo argomento.  
  
> [!NOTE]
>  Questo overload del metodo deve essere utilizzato quando il delegato non viene chiusa al primo argomento, perché in tal caso è leggermente più veloce.  
  
 Questo overload del metodo è equivalente alla chiamata di <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> overload del metodo e specificando `true` per `throwOnBindFailure`.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a metodi non pubblici se il chiamante sia stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di concessioni dei metodi non pubblici è limitato al chiamante concedere set, oppure un subset della stessa. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
## <a name="compatible-parameter-types-and-return-type"></a>I tipi di parametro compatibili e il tipo restituito  
 In .NET Framework versione 2.0, i tipi di parametro e tipo restituito del delegato creato usando questo overload del metodo deve essere compatibile con i tipi di parametro e tipo restituito del metodo rappresentato dal delegato. i tipi non è in modo che corrispondano esattamente. Rappresenta un minore rigidità del comportamento di associazione in .NET Framework versioni 1.0 e 1.1, in cui i tipi devono corrispondere esattamente.  
  
 Un parametro di un delegato è compatibile con il parametro di un metodo corrispondente se il tipo del parametro del delegato è più restrittivo rispetto al tipo del parametro del metodo. In questo modo si garantisce che un argomento passato al delegato possa essere passato in modo sicuro al metodo.  
  
 Analogamente, il tipo restituito di un delegato è compatibile con il tipo restituito di un metodo se il tipo restituito del metodo è più restrittivo rispetto al tipo restituito del delegato. In questo modo si garantisce la possibilità di eseguire in modo sicuro il cast del valore restituito del metodo nel tipo restituito del delegato.  
  
 Ad esempio, un delegato con un parametro di tipo <xref:System.Collections.Hashtable> e un tipo restituito <xref:System.Object> può rappresentare un metodo con un parametro di tipo <xref:System.Object> e un valore restituito di tipo <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 In questa sezione sono riportati due esempi di codice. Nel primo esempio illustra i due tipi di delegati che possono essere creati con questo overload del metodo: aprire tramite un metodo di istanza e su un metodo statico.  
  
 Il secondo esempio di codice vengono illustrati i tipi di parametro compatibili e i tipi restituiti.  
  
 **Esempio 1**  
  
 Esempio di codice seguente illustra le due modalità un delegato può essere creato usando questo overload del metodo di <xref:System.Delegate.CreateDelegate%2A> (metodo).  
  
> [!NOTE]
>  Esistono due overload del <xref:System.Delegate.CreateDelegate%2A> metodo che specificano un <xref:System.Reflection.MethodInfo> ma non è un primo argomento; le relative funzionalità è uguale ad eccezione del fatto che uno consente di specificare se si desidera generare un errore di associazione e l'altra genera sempre un'eccezione. Questo esempio di codice Usa entrambi gli overload.  
  
 Nell'esempio viene dichiarata una classe `C` con un metodo statico `M2` e un metodo di istanza `M1`, e due tipi di delegato: `D1` accetta un'istanza di `C` e una stringa, e `D2` accetta una stringa.  
  
 Una seconda classe denominata `Example` contiene il codice che crea i delegati.  
  
-   Un delegato del tipo `D1`, che rappresenta un metodo di istanza aperta, viene creato per il metodo di istanza `M1`. Un'istanza deve essere passata quando viene richiamato il delegato.  
  
-   Un delegato del tipo `D2`, che rappresenta un metodo statico aperto, viene creato per il metodo statico `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Esempio 2**  
  
 Esempio di codice seguente illustra la compatibilità dei tipi di parametro e i tipi restituiti.  
  
 L'esempio di codice definisce una classe base denominata `Base` e una classe denominata `Derived` che deriva da `Base`. La classe derivata ha un `static` (`Shared` in Visual Basic) metodo denominato `MyMethod` con un parametro di tipo `Base` e un tipo restituito di `Derived`. L'esempio di codice definisce anche un delegato denominato `Example` che ha un parametro di tipo `Derived` e un tipo restituito di `Base`.  
  
 L'esempio di codice viene illustrato che il delegato denominato `Example` può essere utilizzato per rappresentare il metodo `MyMethod`. Il metodo può essere associato al delegato perché:  
  
-   Il tipo di parametro del delegato (`Derived`) è più restrittivo rispetto al tipo di parametro del `MyMethod` (`Base`), in modo che sia sempre possibile passare l'argomento del delegato da `MyMethod`.  
  
-   Il tipo restituito del `MyMethod` (`Derived`) è più restrittivo rispetto al tipo di parametro del delegato (`Base`), in modo che sia sempre possibile eseguire il cast di tipo restituito del metodo per il tipo restituito del delegato.  
  
 L'esempio di codice non genera alcun output.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.  
  
oppure 
 <paramref name="method" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> non eredita <see cref="T:System.MulticastDelegate" />.  
  
oppure 
 <paramref name="type" /> non è un oggetto <see langword="RuntimeType" />. Vedere [Tipi di runtime nella reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
oppure 
 <paramref name="method" /> non è un metodo statico e la versione di .NET Framework è 1.0 o 1.1.  
  
oppure 
 <paramref name="method" /> non può essere associato.  
  
oppure 
 <paramref name="method" /> non è un oggetto <see langword="RuntimeMethodInfo" />. Vedere [Tipi di runtime nella reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Non è possibile trovare il metodo <see langword="Invoke" /> di <paramref name="type" />.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha le autorizzazioni necessarie per accedere a <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> del delegato da creare.</param>
        <param name="firstArgument">Oggetto a cui il delegato è associato oppure <see langword="null" /> per trattare <c>method</c> come <see langword="static" /> (<see langword="Shared" /> in Visual Basic).</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> che descrive il metodo statico o il metodo di istanza che deve essere rappresentato dal delegato.</param>
        <summary>Crea un delegato del tipo specificato che rappresenta il metodo statico o il metodo di istanza indicato, con il primo argomento specificato.</summary>
        <returns>Delegato del tipo specificato che rappresenta il metodo statico o di istanza specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo overload del metodo è equivalente alla chiamata di <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> overload del metodo e specificando `true` per `throwOnBindFailure`. Questi due overload forniscono il modo più flessibile per creare i delegati. È possibile usarli per creare i delegati per statici o metodi di istanza e, facoltativamente, specificare il primo argomento.  
  
> [!NOTE]
>  Se non si fornisce un primo argomento, usare il <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> overload del metodo per ottenere prestazioni migliori.  
  
 Il tipo delegato e il metodo deve avere tipi restituiti compatibili. Vale a dire, il tipo restituito del `method` deve essere assegnabile al tipo restituito di `type`.  
  
 Se `firstArgument` viene fornito, viene passata a `method` ogni volta che viene richiamato il delegato; `firstArgument` viene definito da associare al delegato e il delegato per essere chiuso al primo argomento. Se `method` viene `static` (`Shared` in Visual Basic), l'elenco argomenti fornito quando si richiama il delegato include tutti i parametri tranne il primo; se `method` è un metodo di istanza, quindi `firstArgument` viene passato all'istanza nascosta parametro (rappresentato da `this` in c# o da `Me` in Visual Basic).  
  
 Se `firstArgument` viene fornito, il primo parametro di `method` deve essere un tipo riferimento, e `firstArgument` deve essere compatibile con tale tipo.  
  
> [!IMPORTANT]
>  Se `method` viene `static` (`Shared` in Visual Basic) e il primo parametro è di tipo <xref:System.Object> oppure <xref:System.ValueType>, quindi `firstArgument` può essere un tipo di valore. In questo caso `firstArgument` automaticamente viene sottoposto a boxing. Conversione boxing automatico non avviene per altri argomenti, come in una funzione c# o Visual Basic che chiamasse.  
  
 Se `firstArgument` è un riferimento null e `method` è un metodo di istanza, il risultato dipende dalle firme del tipo delegato `type` e di `method`:  
  
-   Se la firma dei `type` includa in modo esplicito il primo parametro nascosto di `method`, il delegato rappresenta un metodo di istanza aperta. Quando il delegato viene richiamato, il primo argomento nell'elenco di argomenti viene passato al parametro instance nascosta di `method`.  
  
-   Se le firme dei `method` e `type` corrispondenza (vale a dire, tutti i tipi di parametro compatibili), il delegato è associato in modo rigido un riferimento null. Richiamare il delegato è simile a chiamata al metodo di istanza in un'istanza null, che non è un'operazione particolarmente utile da eseguire.  
  
 Se `firstArgument` è un riferimento null e `method` è statica, il risultato dipende dalle firme del tipo delegato `type` e di `method`:  
  
-   Se la firma dei `method` e `type` corrispondenza (vale a dire, tutti i tipi di parametro compatibili), il delegato rappresenta un metodo statico open. Questo è il caso più comune per i metodi statici. In questo caso, è possibile ottenere prestazioni leggermente migliori usando il <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> overload del metodo.  
  
-   Se la firma dei `type` inizia con il secondo parametro di `method` e il resto dei tipi di parametro compatibili, quindi il delegato per essere chiuso un riferimento null. Quando il delegato viene richiamato, viene passato un riferimento null per il primo parametro di `method`.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a metodi non pubblici se il chiamante sia stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di concessioni dei metodi non pubblici è limitato al chiamante concedere set, oppure un subset della stessa. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
## <a name="compatible-parameter-types-and-return-type"></a>I tipi di parametro compatibili e il tipo restituito  
 I tipi di parametro e tipo restituito del delegato deve essere compatibile con i tipi di parametro e tipo restituito del metodo rappresentato dal delegato. i tipi non è in modo che corrispondano esattamente.  
  
> [!NOTE]
>  In .NET Framework versioni 1.0 e 1.1, i tipi devono corrispondere esattamente.  
  
 Un parametro di un delegato è compatibile con il parametro di un metodo corrispondente se il tipo del parametro del delegato è più restrittivo rispetto al tipo del parametro del metodo. In questo modo si garantisce che un argomento passato al delegato possa essere passato in modo sicuro al metodo.  
  
 Analogamente, il tipo restituito di un delegato è compatibile con il tipo restituito di un metodo se il tipo restituito del metodo è più restrittivo rispetto al tipo restituito del delegato. In questo modo si garantisce la possibilità di eseguire in modo sicuro il cast del valore restituito del metodo nel tipo restituito del delegato.  
  
 Ad esempio, un delegato con un parametro di tipo <xref:System.Collections.Hashtable> e un tipo restituito <xref:System.Object> può rappresentare un metodo con un parametro di tipo <xref:System.Object> e un valore restituito di tipo <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Determinazione dei metodi che può rappresentare un delegato  
 Un altro modo utile pensare alla flessibilità offerta da questo overload del metodo <xref:System.Delegate.CreateDelegate%2A> è che qualsiasi delegato specificato possa rappresentare quattro diverse combinazioni di firma del metodo e il tipo di metodo (statico o istanza). Si consideri un tipo delegato `D` con un solo argomento di tipo `C`. Di seguito vengono descritti i metodi `D` può rappresentare, ignorando il tipo restituito poiché deve corrispondere in tutti i casi:  
  
-   `D` può rappresentare qualsiasi metodo di istanza che dispone di esattamente un argomento di tipo `C`, indipendentemente dal tipo a cui appartiene il metodo di istanza. Quando <xref:System.Delegate.CreateDelegate%2A> viene chiamato `firstArgument` è un'istanza del tipo `method` appartiene, e il delegato risultante viene definito per essere chiuso in quell'istanza. (In modo rigido `D` può inoltre essere associato un riferimento null se `firstArgument` è un riferimento null.)  
  
-   `D` può rappresentare un metodo di istanza di `C` che non dispone di argomenti. Quando <xref:System.Delegate.CreateDelegate%2A> viene chiamato, `firstArgument` è un riferimento null. Il delegato risultante rappresenta un metodo di istanza aperta e un'istanza di `C` è necessario specificare ogni volta che viene richiamato.  
  
-   `D` può rappresentare un metodo statico che accetta un argomento di tipo `C`, e che può appartenere a qualsiasi tipo. Quando <xref:System.Delegate.CreateDelegate%2A> viene chiamato, `firstArgument` è un riferimento null. Il delegato risultante rappresenta un metodo statico aperto e un'istanza di `C` è necessario specificare ogni volta che viene richiamato.  
  
-   `D` può rappresentare un metodo statico che appartiene al tipo `F` e dispone di due argomenti, di tipo `F` e il tipo `C`. Quando <xref:System.Delegate.CreateDelegate%2A> viene chiamato `firstArgument` è un'istanza di `F`. Il delegato risultante rappresenta un metodo statico che viene chiuso in quell'istanza di `F`. Si noti che nel caso in cui `F` e `C` sono dello stesso tipo, il metodo statico dispone di due argomenti di quel tipo. (In questo caso `D` viene chiuso un riferimento null se `firstArgument` è un riferimento null.)  
  
   
  
## Examples  
 In questa sezione contiene tre esempi di codice. Nel primo esempio illustra i quattro tipi di delegati che possono essere creati: rigido a un metodo di istanza, aprire tramite un metodo di istanza, aprire tramite un metodo statico e chiusa tramite un metodo statico.  
  
 Il secondo esempio di codice vengono illustrati i tipi di parametro compatibili e i tipi restituiti.  
  
 Mostra tutti i metodi che il tipo delegato possono rappresentare il terzo esempio di codice definisce un tipo di delegato unico.  
  
 **Esempio 1**  
  
 Esempio di codice seguente illustra i quattro modi un delegato può essere creato usando l'overload del <xref:System.Delegate.CreateDelegate%2A> (metodo).  
  
> [!NOTE]
>  Esistono due overload del <xref:System.Delegate.CreateDelegate%2A> metodo che specificano `firstArgument` e un <xref:System.Reflection.MethodInfo>; le relative funzionalità è uguale ad eccezione del fatto che uno consente di specificare se si desidera generare un errore di associazione e l'altra genera sempre un'eccezione. Questo esempio di codice Usa entrambi gli overload.  
  
 Nell'esempio viene dichiarata una classe `C` con un metodo statico `M2` e un metodo di istanza `M1`, e tre i tipi di delegato: `D1` accetta un'istanza di `C` e una stringa, `D2` accetta una stringa e `D3`non dispone di argomenti.  
  
 Una seconda classe denominata `Example` contiene il codice che crea i delegati.  
  
-   Un delegato del tipo `D2`, chiuso su un'istanza di `C`, viene creato per il metodo di istanza `M1`. Viene richiamato con stringhe diverse, a indicare che l'istanza associata di `C` viene sempre usato.  
  
-   Un delegato del tipo `D1`, che rappresenta un metodo di istanza aperta, viene creato per il metodo di istanza `M1`. Un'istanza deve essere passata quando viene richiamato il delegato.  
  
-   Un delegato del tipo `D2`, che rappresenta un metodo statico aperto, viene creato per il metodo statico `M2`.  
  
-   Infine, un delegato del tipo `D3`, chiuso in una stringa, viene creato per il metodo statico `M2`. Il metodo viene richiamato per mostrare che usa la stringa associata.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Esempio 2**  
  
 Esempio di codice seguente illustra la compatibilità dei tipi di parametro e i tipi restituiti.  
  
> [!NOTE]
>  Questo esempio di codice Usa il <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> overload del metodo. L'utilizzo di altri overload che accettano <xref:System.Reflection.MethodInfo> è simile.  
  
 L'esempio di codice definisce una classe base denominata `Base` e una classe denominata `Derived` che deriva da `Base`. La classe derivata ha un `static` (`Shared` in Visual Basic) metodo denominato `MyMethod` con un parametro di tipo `Base` e un tipo restituito di `Derived`. L'esempio di codice definisce anche un delegato denominato `Example` che ha un parametro di tipo `Derived` e un tipo restituito di `Base`.  
  
 L'esempio di codice viene illustrato che il delegato denominato `Example` può essere utilizzato per rappresentare il metodo `MyMethod`. Il metodo può essere associato al delegato perché:  
  
-   Il tipo di parametro del delegato (`Derived`) è più restrittivo rispetto al tipo di parametro del `MyMethod` (`Base`), in modo che sia sempre possibile passare l'argomento del delegato da `MyMethod`.  
  
-   Il tipo restituito del `MyMethod` (`Derived`) è più restrittivo rispetto al tipo di parametro del delegato (`Base`), in modo che sia sempre possibile eseguire il cast di tipo restituito del metodo per il tipo restituito del delegato.  
  
 L'esempio di codice non genera alcun output.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Esempio 3**  
  
 Esempio di codice seguente illustra tutti i metodi rappresenta un singolo tipo delegato, usando il <xref:System.Delegate.CreateDelegate%2A> metodo per creare i delegati.  
  
> [!NOTE]
>  Esistono due overload del <xref:System.Delegate.CreateDelegate%2A> metodo che specificano `firstArgument` e un <xref:System.Reflection.MethodInfo>; le relative funzionalità è uguale ad eccezione del fatto che uno consente di specificare se si desidera generare un errore di associazione e l'altra genera sempre un'eccezione. Questo esempio di codice Usa entrambi gli overload.  
  
 L'esempio di codice definisce due classi `C` e `F`e un tipo delegato `D` con un solo argomento di tipo `C`. Le classi corrispondenti statici e metodi di istanza `M1`, `M3`, e `M4`e la classe `C` include inoltre un metodo di istanza `M2` che non dispone di argomenti.  
  
 Una terza classe denominata `Example` contiene il codice che crea i delegati.  
  
-   I delegati vengono creati il metodo, ad esempio `M1` di tipo `C` e il tipo `F`; ognuna viene chiuso su un'istanza del rispettivo tipo. Metodo `M1` typu `C` consente di visualizzare il `ID` le proprietà dell'istanza associata e dell'argomento.  
  
-   Viene creato un delegato per il metodo `M2` di tipo `C`. Si tratta di un delegato di istanza aperta, in cui l'argomento del delegato rappresenta il primo argomento nascosto sul metodo di istanza. Il metodo non dispone di altri argomenti. Viene chiamato come se fosse un metodo statico.  
  
-   I delegati vengono creati per il metodo statico `M3` typu `C` e il tipo `F`; questi sono aperti i delegati statici.  
  
-   Infine, i delegati vengono creati per il metodo statico `M4` typu `C` e il tipo `F`; ogni metodo presenta il tipo dichiarante come primo argomento e viene fornita un'istanza del tipo, in modo che i delegati vengono chiusi relativi primi argomenti . Metodo `M4` typu `C` consente di visualizzare il `ID` le proprietà dell'istanza associata e dell'argomento.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.  
  
oppure 
 <paramref name="method" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> non eredita <see cref="T:System.MulticastDelegate" />.  
  
oppure 
 <paramref name="type" /> non è un oggetto <see langword="RuntimeType" />. Vedere [Tipi di runtime nella reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
oppure 
 <paramref name="method" /> non può essere associato.  
  
oppure 
 <paramref name="method" /> non è un oggetto <see langword="RuntimeMethodInfo" />. Vedere [Tipi di runtime nella reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Non è possibile trovare il metodo <see langword="Invoke" /> di <paramref name="type" />.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha le autorizzazioni necessarie per accedere a <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> del delegato da creare.</param>
        <param name="target">Istanza di classe per la quale viene richiamato il parametro <c>method</c>.</param>
        <param name="method">Nome del metodo di istanza che deve essere rappresentato dal delegato.</param>
        <summary>Crea un delegato del tipo specificato che rappresenta il metodo di istanza specificato per il richiamo dell'istanza di classe specificata.</summary>
        <returns>Delegato del tipo specificato che rappresenta il metodo di istanza specificato per il richiamo dell'istanza di classe specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea i delegati, ad esempio solo i metodi. Un metodo di istanza è un metodo che è associato a un'istanza di una classe. un metodo statico è un metodo che è associato alla classe stessa.  
  
 Questo overload del metodo è equivalente alla chiamata di <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> overload del metodo, specificando `false` per `ignoreCase` e `true` per `throwOnBindFailure`.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a metodi non pubblici se il chiamante sia stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di concessioni dei metodi non pubblici è limitato al chiamante concedere set, oppure un subset della stessa. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.  
  
oppure 
 <paramref name="target" /> è <see langword="null" />.  
  
oppure 
 <paramref name="method" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> non eredita <see cref="T:System.MulticastDelegate" />.  
  
oppure 
 <paramref name="type" /> non è un oggetto <see langword="RuntimeType" />. Vedere [Tipi di runtime nella reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
oppure 
 <paramref name="method" /> non è un metodo di istanza.  
  
oppure 
 Non possibile associare <paramref name="method" />, ad esempio perché non è stato trovato.</exception>
        <exception cref="T:System.MissingMethodException">Non è possibile trovare il metodo <see langword="Invoke" /> di <paramref name="type" />.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha le autorizzazioni necessarie per accedere a <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> del delegato da creare.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> che descrive il metodo statico o il metodo di istanza che deve essere rappresentato dal delegato.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> per generare un'eccezione se non è possibile associare il parametro<c>method</c>; in caso contrario, <see langword="false" />.</param>
        <summary>Crea un delegato del tipo indicato per rappresentare il metodo statico specificato, in cui viene indicato anche il funzionamento in caso di errore di associazione.</summary>
        <returns>Delegato del tipo specificato che rappresenta il metodo statico specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del metodo è possibile creare delegati del metodo statico open e aprire i delegati del metodo di istanza, vale a dire, i delegati che espongono il primo argomento nascosto dei metodi di istanza. Per informazioni dettagliate, vedere il metodo più generico <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> overload del metodo che consente di creare, ad esempio tutte le combinazioni dei delegati aperte o chiuse o i metodi statici.  
  
> [!NOTE]
>  Questo overload del metodo deve essere utilizzato quando il delegato non viene chiusa al primo argomento, perché in tal caso è leggermente più veloce.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a metodi non pubblici se il chiamante sia stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di concessioni dei metodi non pubblici è limitato al chiamante concedere set, oppure un subset della stessa. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
## <a name="compatible-parameter-types-and-return-type"></a>I tipi di parametro compatibili e il tipo restituito  
 I tipi di parametro e tipo restituito del delegato deve essere compatibile con i tipi di parametro e tipo restituito del metodo rappresentato dal delegato. i tipi non è in modo che corrispondano esattamente.  
  
> [!NOTE]
>  In .NET Framework versioni 1.0 e 1.1, i tipi devono corrispondere esattamente.  
  
 Un parametro di un delegato è compatibile con il parametro di un metodo corrispondente se il tipo del parametro del delegato è più restrittivo rispetto al tipo del parametro del metodo. In questo modo si garantisce che un argomento passato al delegato possa essere passato in modo sicuro al metodo.  
  
 Analogamente, il tipo restituito di un delegato è compatibile con il tipo restituito di un metodo se il tipo restituito del metodo è più restrittivo rispetto al tipo restituito del delegato. In questo modo si garantisce la possibilità di eseguire in modo sicuro il cast del valore restituito del metodo nel tipo restituito del delegato.  
  
 Ad esempio, un delegato con un parametro di tipo <xref:System.Collections.Hashtable> e un tipo restituito <xref:System.Object> può rappresentare un metodo con un parametro di tipo <xref:System.Object> e un valore restituito di tipo <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 In questa sezione sono riportati due esempi di codice. Nel primo esempio illustra i due tipi di delegati che possono essere creati con questo overload del metodo: aprire tramite un metodo di istanza e su un metodo statico.  
  
 Il secondo esempio di codice vengono illustrati i tipi di parametro compatibili e i tipi restituiti.  
  
 **Esempio 1**  
  
 Esempio di codice seguente illustra le due modalità un delegato può essere creato usando questo overload del metodo di <xref:System.Delegate.CreateDelegate%2A> (metodo).  
  
> [!NOTE]
>  Esistono due overload del <xref:System.Delegate.CreateDelegate%2A> metodo che specificano un <xref:System.Reflection.MethodInfo> ma non è un primo argomento; le relative funzionalità è uguale ad eccezione del fatto che uno consente di specificare se si desidera generare un errore di associazione e l'altra genera sempre un'eccezione. Questo esempio di codice Usa entrambi gli overload.  
  
 Nell'esempio viene dichiarata una classe `C` con un metodo statico `M2` e un metodo di istanza `M1`, e due tipi di delegato: `D1` accetta un'istanza di `C` e una stringa, e `D2` accetta una stringa.  
  
 Una seconda classe denominata `Example` contiene il codice che crea i delegati.  
  
-   Un delegato del tipo `D1`, che rappresenta un metodo di istanza aperta, viene creato per il metodo di istanza `M1`. Un'istanza deve essere passata quando viene richiamato il delegato.  
  
-   Un delegato del tipo `D2`, che rappresenta un metodo statico aperto, viene creato per il metodo statico `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Esempio 2**  
  
 Esempio di codice seguente illustra la compatibilità dei tipi di parametro e i tipi restituiti.  
  
> [!NOTE]
>  Questo esempio di codice Usa il <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> overload del metodo. L'utilizzo di altri overload che accettano <xref:System.Reflection.MethodInfo> è simile.  
  
 L'esempio di codice definisce una classe base denominata `Base` e una classe denominata `Derived` che deriva da `Base`. La classe derivata ha un `static` (`Shared` in Visual Basic) metodo denominato `MyMethod` con un parametro di tipo `Base` e un tipo restituito di `Derived`. L'esempio di codice definisce anche un delegato denominato `Example` che ha un parametro di tipo `Derived` e un tipo restituito di `Base`.  
  
 L'esempio di codice viene illustrato che il delegato denominato `Example` può essere utilizzato per rappresentare il metodo `MyMethod`. Il metodo può essere associato al delegato perché:  
  
-   Il tipo di parametro del delegato (`Derived`) è più restrittivo rispetto al tipo di parametro del `MyMethod` (`Base`), in modo che sia sempre possibile passare l'argomento del delegato da `MyMethod`.  
  
-   Il tipo restituito del `MyMethod` (`Derived`) è più restrittivo rispetto al tipo di parametro del delegato (`Base`), in modo che sia sempre possibile eseguire il cast di tipo restituito del metodo per il tipo restituito del delegato.  
  
 L'esempio di codice non genera alcun output.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.  
  
oppure 
 <paramref name="method" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> non eredita <see cref="T:System.MulticastDelegate" />.  
  
oppure 
 <paramref name="type" /> non è un oggetto <see langword="RuntimeType" />. Vedere [Tipi di runtime nella reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
oppure 
 <paramref name="method" /> non può essere associato e <paramref name="throwOnBindFailure" /> è <see langword="true" />.  
  
oppure 
 <paramref name="method" /> non è un oggetto <see langword="RuntimeMethodInfo" />. Vedere [Tipi di runtime nella reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Non è possibile trovare il metodo <see langword="Invoke" /> di <paramref name="type" />.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha le autorizzazioni necessarie per accedere a <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> del delegato da creare.</param>
        <param name="target">Classe <see cref="T:System.Type" /> che rappresenta la classe che implementa il parametro <c>method</c>.</param>
        <param name="method">Nome del metodo statico che deve essere rappresentato dal delegato.</param>
        <summary>Crea un delegato del tipo specificato che rappresenta il metodo statico specificato della classe specificata.</summary>
        <returns>Delegato del tipo specificato che rappresenta il metodo statico specificato della classe specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea i delegati per solo i metodi statici. Un metodo di istanza è un metodo che è associato a un'istanza di una classe. un metodo statico è un metodo che è associato alla classe stessa.  
  
 Questo overload del metodo è equivalente alla chiamata di <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> overload del metodo, specificando `false` per `ignoreCase` e `true` per `throwOnBindFailure`.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a metodi non pubblici se il chiamante sia stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di concessioni dei metodi non pubblici è limitato al chiamante concedere set, oppure un subset della stessa. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.  
  
oppure 
 <paramref name="target" /> è <see langword="null" />.  
  
oppure 
 <paramref name="method" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> non eredita <see cref="T:System.MulticastDelegate" />.  
  
oppure 
 <paramref name="type" /> non è un oggetto <see langword="RuntimeType" />. Vedere [Tipi di runtime nella reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
oppure 
 <paramref name="target" /> non è un oggetto <see langword="RuntimeType" />.  
  
oppure 
 <paramref name="target" /> è un tipo generico aperto. Ciò significa che la proprietà <see cref="P:System.Type.ContainsGenericParameters" /> è <see langword="true" />.  
  
oppure 
 <paramref name="method" /> non è un metodo <see langword="static" /> (metodo <see langword="Shared" /> in Visual Basic).  
  
oppure 
 Non è possibile associare <paramref name="method" />, ad esempio perché non è stato trovato, e <paramref name="throwOnBindFailure" /> è <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è possibile trovare il metodo <see langword="Invoke" /> di <paramref name="type" />.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha le autorizzazioni necessarie per accedere a <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> che rappresenta il tipo di delegato da creare.</param>
        <param name="firstArgument">
          <see cref="T:System.Object" /> che rappresenta il primo argomento del metodo rappresentato dal delegato. Per i metodi di istanza, tale oggetto deve essere compatibile con il tipo di istanza.</param>
        <param name="method">
          <see cref="T:System.Reflection.MethodInfo" /> che descrive il metodo statico o il metodo di istanza che deve essere rappresentato dal delegato.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> per generare un'eccezione se non è possibile associare il parametro<c>method</c>; in caso contrario, <see langword="false" />.</param>
        <summary>Crea un delegato del tipo specificato che rappresenta il metodo statico o il metodo di istanza indicato, con il primo argomento specificato e il funzionamento indicato in caso di errore di associazione.</summary>
        <returns>Delegato del tipo specificato che rappresenta il metodo statico o di istanza specificato oppure <see langword="null" /> se <paramref name="throwOnBindFailure" /> è <see langword="false" /> e non è possibile associare il delegato a <paramref name="method" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del metodo e <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> overload del metodo che genera sempre un'eccezione in caso di errore da associare, specificare il modo più flessibile per creare i delegati. È possibile utilizzarli per creare i delegati per statici o metodi di istanza, con o senza un primo argomento.  
  
> [!NOTE]
>  Se non si fornisce un primo argomento, usare il <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> overload del metodo per ottenere prestazioni migliori.  
  
 Il tipo delegato e il metodo deve avere tipi restituiti compatibili. Vale a dire, il tipo restituito del `method` deve essere assegnabile al tipo restituito di `type`.  
  
 Se `firstArgument` viene fornito, viene passata a `method` ogni volta che viene richiamato il delegato; `firstArgument` viene definito da associare al delegato e il delegato per essere chiuso al primo argomento. Se `method` viene `static` (`Shared` in Visual Basic), l'elenco argomenti fornito quando si richiama il delegato include tutti i parametri tranne il primo; se `method` è un metodo di istanza, quindi `firstArgument` viene passato all'istanza nascosta parametro (rappresentato da `this` in c# o da `Me` in Visual Basic).  
  
 Se `firstArgument` viene fornito, il primo parametro di `method` deve essere un tipo riferimento, e `firstArgument` deve essere compatibile con tale tipo.  
  
> [!IMPORTANT]
>  Se `method` viene `static` (`Shared` in Visual Basic) e il primo parametro è di tipo <xref:System.Object> oppure <xref:System.ValueType>, quindi `firstArgument` può essere un tipo di valore. In questo caso `firstArgument` automaticamente viene sottoposto a boxing. Conversione boxing automatico non avviene per altri argomenti, come in una funzione c# o Visual Basic che chiamasse.  
  
 Se `firstArgument` è un riferimento null e `method` è un metodo di istanza, il risultato dipende dalle firme del tipo delegato `type` e di `method`:  
  
-   Se la firma dei `type` includa in modo esplicito il primo parametro nascosto di `method`, il delegato rappresenta un metodo di istanza aperta. Quando il delegato viene richiamato, il primo argomento nell'elenco di argomenti viene passato al parametro instance nascosta di `method`.  
  
-   Se le firme dei `method` e `type` corrispondenza (vale a dire, tutti i tipi di parametro compatibili), il delegato è associato in modo rigido un riferimento null. Richiamare il delegato è simile a chiamata al metodo di istanza in un'istanza null, che non è un'operazione particolarmente utile da eseguire.  
  
 Se `firstArgument` è un riferimento null e `method` è statica, il risultato dipende dalle firme del tipo delegato `type` e di `method`:  
  
-   Se la firma dei `method` e `type` corrispondenza (vale a dire, tutti i tipi di parametro compatibili), il delegato rappresenta un metodo statico open. Questo è il caso più comune per i metodi statici. In questo caso, è possibile ottenere prestazioni leggermente migliori usando il <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> overload del metodo.  
  
-   Se la firma dei `type` inizia con il secondo parametro di `method` e il resto dei tipi di parametro compatibili, quindi il delegato per essere chiuso un riferimento null. Quando il delegato viene richiamato, viene passato un riferimento null per il primo parametro di `method`.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a metodi non pubblici se il chiamante sia stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di concessioni dei metodi non pubblici è limitato al chiamante concedere set, oppure un subset della stessa. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
## <a name="compatible-parameter-types-and-return-type"></a>I tipi di parametro compatibili e il tipo restituito  
 I tipi di parametro e tipo restituito del delegato deve essere compatibile con i tipi di parametro e tipo restituito del metodo rappresentato dal delegato. i tipi non è in modo che corrispondano esattamente.  
  
> [!NOTE]
>  In .NET Framework versione 1.0 e 1.1 di tipi devono corrispondere esattamente.  
  
 Un parametro di un delegato è compatibile con il parametro di un metodo corrispondente se il tipo del parametro del delegato è più restrittivo rispetto al tipo del parametro del metodo. In questo modo si garantisce che un argomento passato al delegato possa essere passato in modo sicuro al metodo.  
  
 Analogamente, il tipo restituito di un delegato è compatibile con il tipo restituito di un metodo se il tipo restituito del metodo è più restrittivo rispetto al tipo restituito del delegato. In questo modo si garantisce la possibilità di eseguire in modo sicuro il cast del valore restituito del metodo nel tipo restituito del delegato.  
  
 Ad esempio, un delegato con un parametro di tipo <xref:System.Collections.Hashtable> e un tipo restituito <xref:System.Object> può rappresentare un metodo con un parametro di tipo <xref:System.Object> e un valore restituito di tipo <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Determinazione dei metodi che può rappresentare un delegato  
 Un altro modo utile pensare alla flessibilità offerta da questo overload del metodo <xref:System.Delegate.CreateDelegate%2A> è che qualsiasi delegato specificato possa rappresentare quattro diverse combinazioni di firma del metodo e il tipo di metodo (statico o istanza). Si consideri un tipo delegato `D` con un solo argomento di tipo `C`. Di seguito vengono descritti i metodi `D` può rappresentare, ignorando il tipo restituito poiché deve corrispondere in tutti i casi:  
  
-   `D` può rappresentare qualsiasi metodo di istanza che dispone di esattamente un argomento di tipo `C`, indipendentemente dal tipo a cui appartiene il metodo di istanza. Quando <xref:System.Delegate.CreateDelegate%2A> viene chiamato `firstArgument` è un'istanza del tipo `method` appartiene, e il delegato risultante viene definito per essere chiuso in quell'istanza. (In modo rigido `D` può inoltre essere associato un riferimento null se `firstArgument` è `null`.)  
  
-   `D` può rappresentare un metodo di istanza di `C` che non dispone di argomenti. Quando <xref:System.Delegate.CreateDelegate%2A> viene chiamato, `firstArgument` è un riferimento null. Il delegato risultante rappresenta un metodo di istanza aperta e un'istanza di `C` è necessario specificare ogni volta che viene richiamato.  
  
-   `D` può rappresentare un metodo statico che accetta un argomento di tipo `C`, e che può appartenere a qualsiasi tipo. Quando <xref:System.Delegate.CreateDelegate%2A> viene chiamato, `firstArgument` è un riferimento null. Il delegato risultante rappresenta un metodo statico aperto e un'istanza di `C` è necessario specificare ogni volta che viene richiamato.  
  
-   `D` può rappresentare un metodo statico che appartiene al tipo `F` e dispone di due argomenti, di tipo `F` e il tipo `C`. Quando <xref:System.Delegate.CreateDelegate%2A> viene chiamato `firstArgument` è un'istanza di `F`. Il delegato risultante rappresenta un metodo statico che viene chiuso in quell'istanza di `F`. Si noti che nel caso in cui `F` e `C` sono dello stesso tipo, il metodo statico dispone di due argomenti di quel tipo. (In questo caso `D` viene chiuso un riferimento null se `firstArgument` è `null`.)  
  
   
  
## Examples  
 In questa sezione contiene tre esempi di codice. Nel primo esempio illustra i quattro tipi di delegati che possono essere creati: rigido a un metodo di istanza, aprire tramite un metodo di istanza, aprire tramite un metodo statico e chiusa tramite un metodo statico.  
  
 Il secondo esempio di codice vengono illustrati i tipi di parametro compatibili e i tipi restituiti.  
  
 Mostra tutti i metodi che il tipo delegato possono rappresentare il terzo esempio di codice definisce un tipo di delegato unico.  
  
 **Esempio 1**  
  
 Esempio di codice seguente illustra i quattro modi un delegato può essere creato usando l'overload del <xref:System.Delegate.CreateDelegate%2A> (metodo).  
  
> [!NOTE]
>  Esistono due overload del <xref:System.Delegate.CreateDelegate%2A> metodo che specificano `firstArgument` e un <xref:System.Reflection.MethodInfo>; le relative funzionalità è uguale ad eccezione del fatto che uno consente di specificare se si desidera generare un errore di associazione e l'altra genera sempre un'eccezione. Questo esempio di codice Usa entrambi gli overload.  
  
 Nell'esempio viene dichiarata una classe `C` con un metodo statico `M2` e un metodo di istanza `M1`, e tre i tipi di delegato: `D1` accetta un'istanza di `C` e una stringa, `D2` accetta una stringa e `D3`non dispone di argomenti.  
  
 Una seconda classe denominata `Example` contiene il codice che crea i delegati.  
  
-   Un delegato del tipo `D2`, chiuso su un'istanza di `C`, viene creato per il metodo di istanza `M1`. Viene richiamato con stringhe diverse, a indicare che l'istanza associata di `C` viene sempre usato.  
  
-   Un delegato del tipo `D1`, che rappresenta un metodo di istanza aperta, viene creato per il metodo di istanza `M1`. Un'istanza deve essere passata quando viene richiamato il delegato.  
  
-   Un delegato del tipo `D2`, che rappresenta un metodo statico aperto, viene creato per il metodo statico `M2`.  
  
-   Infine, un delegato del tipo `D3`, chiuso in una stringa, viene creato per il metodo statico `M2`. Il metodo viene richiamato per mostrare che usa la stringa associata.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Esempio 2**  
  
 Esempio di codice seguente illustra la compatibilità dei tipi di parametro e i tipi restituiti.  
  
> [!NOTE]
>  Questo esempio di codice Usa il <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> overload del metodo. L'utilizzo di altri overload che accettano <xref:System.Reflection.MethodInfo> è simile.  
  
 L'esempio di codice definisce una classe base denominata `Base` e una classe denominata `Derived` che deriva da `Base`. La classe derivata ha un `static` (`Shared` in Visual Basic) metodo denominato `MyMethod` con un parametro di tipo `Base` e un tipo restituito di `Derived`. L'esempio di codice definisce anche un delegato denominato `Example` che ha un parametro di tipo `Derived` e un tipo restituito di `Base`.  
  
 L'esempio di codice viene illustrato che il delegato denominato `Example` può essere utilizzato per rappresentare il metodo `MyMethod`. Il metodo può essere associato al delegato perché:  
  
-   Il tipo di parametro del delegato (`Derived`) è più restrittivo rispetto al tipo di parametro del `MyMethod` (`Base`), in modo che sia sempre possibile passare l'argomento del delegato da `MyMethod`.  
  
-   Il tipo restituito del `MyMethod` (`Derived`) è più restrittivo rispetto al tipo di parametro del delegato (`Base`), in modo che sia sempre possibile eseguire il cast di tipo restituito del metodo per il tipo restituito del delegato.  
  
 L'esempio di codice non genera alcun output.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Esempio 3**  
  
 Esempio di codice seguente illustra tutti i metodi che può rappresentare un singolo tipo delegato.  
  
> [!NOTE]
>  Esistono due overload del <xref:System.Delegate.CreateDelegate%2A> metodo che specificano `firstArgument` e un <xref:System.Reflection.MethodInfo>; le relative funzionalità è uguale ad eccezione del fatto che uno consente di specificare se si desidera generare un errore di associazione e l'altra genera sempre un'eccezione. Questo esempio di codice Usa entrambi gli overload.  
  
 L'esempio di codice definisce due classi `C` e `F`e un tipo delegato `D` con un solo argomento di tipo `C`. Le classi corrispondenti statici e metodi di istanza `M1`, `M3`, e `M4`e la classe `C` include inoltre un metodo di istanza `M2` che non dispone di argomenti.  
  
 Una terza classe denominata `Example` contiene il codice che crea i delegati.  
  
-   I delegati vengono creati il metodo, ad esempio `M1` di tipo `C` e il tipo `F`; ognuna viene chiuso su un'istanza del rispettivo tipo. Metodo `M1` typu `C` consente di visualizzare il `ID` le proprietà dell'istanza associata e dell'argomento.  
  
-   Viene creato un delegato per il metodo `M2` di tipo `C`. Si tratta di un delegato di istanza aperta, in cui l'argomento del delegato rappresenta il primo argomento nascosto sul metodo di istanza. Il metodo non dispone di altri argomenti.  
  
-   I delegati vengono creati per il metodo statico `M3` typu `C` e il tipo `F`; questi sono aperti i delegati statici.  
  
-   Infine, i delegati vengono creati per il metodo statico `M4` typu `C` e il tipo `F`; ogni metodo presenta il tipo dichiarante come primo argomento e viene fornita un'istanza del tipo, in modo che i delegati vengono chiusi relativi primi argomenti . Metodo `M4` typu `C` consente di visualizzare il `ID` le proprietà dell'istanza associata e dell'argomento.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.  
  
oppure 
 <paramref name="method" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> non eredita <see cref="T:System.MulticastDelegate" />.  
  
oppure 
 <paramref name="type" /> non è un oggetto <see langword="RuntimeType" />. Vedere [Tipi di runtime nella reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
oppure 
 <paramref name="method" /> non può essere associato e <paramref name="throwOnBindFailure" /> è <see langword="true" />.  
  
oppure 
 <paramref name="method" /> non è un oggetto <see langword="RuntimeMethodInfo" />. Vedere [Tipi di runtime nella reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Non è possibile trovare il metodo <see langword="Invoke" /> di <paramref name="type" />.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha le autorizzazioni necessarie per accedere a <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> del delegato da creare.</param>
        <param name="target">Istanza di classe per la quale viene richiamato il parametro <c>method</c>.</param>
        <param name="method">Nome del metodo di istanza che deve essere rappresentato dal delegato.</param>
        <param name="ignoreCase">Valore booleano che indica se ignorare o meno la distinzione tra maiuscole e minuscole al momento di confrontare il nome del metodo.</param>
        <summary>Crea un delegato del tipo specificato che rappresenta il metodo di istanza specificato, per il richiamo dell'istanza di classe specificata, con la distinzione tra maiuscole e minuscole specificata.</summary>
        <returns>Delegato del tipo specificato che rappresenta il metodo di istanza specificato per il richiamo dell'istanza di classe specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea i delegati, ad esempio solo i metodi. Un metodo di istanza è un metodo che è associato a un'istanza di una classe. un metodo statico è un metodo che è associato alla classe stessa.  
  
 Questo overload del metodo è equivalente alla chiamata di <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> overload del metodo, specificando `true` per `throwOnBindFailure`.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a metodi non pubblici se il chiamante sia stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di concessioni dei metodi non pubblici è limitato al chiamante concedere set, oppure un subset della stessa. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.  
  
oppure 
 <paramref name="target" /> è <see langword="null" />.  
  
oppure 
 <paramref name="method" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> non eredita <see cref="T:System.MulticastDelegate" />.  
  
oppure 
 <paramref name="type" /> non è un oggetto <see langword="RuntimeType" />. Vedere [Tipi di runtime nella reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
oppure 
 <paramref name="method" /> non è un metodo di istanza.  
  
oppure 
 Non possibile associare <paramref name="method" />, ad esempio perché non è stato trovato.</exception>
        <exception cref="T:System.MissingMethodException">Non è possibile trovare il metodo <see langword="Invoke" /> di <paramref name="type" />.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha le autorizzazioni necessarie per accedere a <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> del delegato da creare.</param>
        <param name="target">Classe <see cref="T:System.Type" /> che rappresenta la classe che implementa il parametro <c>method</c>.</param>
        <param name="method">Nome del metodo statico che deve essere rappresentato dal delegato.</param>
        <param name="ignoreCase">Valore booleano che indica se ignorare o meno la distinzione tra maiuscole e minuscole al momento di confrontare il nome del metodo.</param>
        <summary>Crea un delegato del tipo indicato che rappresenta il metodo statico specificato della classe indicata, con la distinzione tra maiuscole e minuscole specificata.</summary>
        <returns>Delegato del tipo specificato che rappresenta il metodo statico specificato della classe specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea i delegati per solo i metodi statici. Un metodo di istanza è un metodo che è associato a un'istanza di una classe. un metodo statico è un metodo che è associato alla classe stessa.  
  
 Questo overload del metodo è equivalente alla chiamata di <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> overload del metodo, specificando `true` per `throwOnBindFailure`.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a metodi non pubblici se il chiamante sia stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di concessioni dei metodi non pubblici è limitato al chiamante concedere set, oppure un subset della stessa. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.  
  
oppure 
 <paramref name="target" /> è <see langword="null" />.  
  
oppure 
 <paramref name="method" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> non eredita <see cref="T:System.MulticastDelegate" />.  
  
oppure 
 <paramref name="type" /> non è un oggetto <see langword="RuntimeType" />. Vedere [Tipi di runtime nella reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
oppure 
 <paramref name="target" /> non è un oggetto <see langword="RuntimeType" />.  
  
oppure 
 <paramref name="target" /> è un tipo generico aperto. Ciò significa che la proprietà <see cref="P:System.Type.ContainsGenericParameters" /> è <see langword="true" />.  
  
oppure 
 <paramref name="method" /> non è un metodo <see langword="static" /> (metodo <see langword="Shared" /> in Visual Basic).  
  
oppure 
 Non possibile associare <paramref name="method" />, ad esempio perché non è stato trovato.</exception>
        <exception cref="T:System.MissingMethodException">Non è possibile trovare il metodo <see langword="Invoke" /> di <paramref name="type" />.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha le autorizzazioni necessarie per accedere a <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> del delegato da creare.</param>
        <param name="target">Istanza di classe per la quale viene richiamato il parametro <c>method</c>.</param>
        <param name="method">Nome del metodo di istanza che deve essere rappresentato dal delegato.</param>
        <param name="ignoreCase">Valore booleano che indica se ignorare o meno la distinzione tra maiuscole e minuscole al momento di confrontare il nome del metodo.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> per generare un'eccezione se non è possibile associare il parametro<c>method</c>; in caso contrario, <see langword="false" />.</param>
        <summary>Crea un delegato del tipo specificato che rappresenta il metodo di istanza specificato, per il richiamo dell'istanza di classe specificata, con la distinzione tra maiuscole e minuscole specificata e il funzionamento specificato in caso di errore di associazione.</summary>
        <returns>Delegato del tipo specificato che rappresenta il metodo di istanza specificato per il richiamo dell'istanza di classe specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea i delegati, ad esempio solo i metodi. Un metodo di istanza è un metodo che è associato a un'istanza di una classe. un metodo statico è un metodo che è associato alla classe stessa.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a metodi non pubblici se il chiamante sia stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di concessioni dei metodi non pubblici è limitato al chiamante concedere set, oppure un subset della stessa. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.  
  
oppure 
 <paramref name="target" /> è <see langword="null" />.  
  
oppure 
 <paramref name="method" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> non eredita <see cref="T:System.MulticastDelegate" />.  
  
oppure 
 <paramref name="type" /> non è un oggetto <see langword="RuntimeType" />. Vedere [Tipi di runtime nella reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
oppure 
 <paramref name="method" /> non è un metodo di istanza.  
  
oppure 
 Non è possibile associare <paramref name="method" />, ad esempio perché non è stato trovato, e <paramref name="throwOnBindFailure" /> è <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è possibile trovare il metodo <see langword="Invoke" /> di <paramref name="type" />.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha le autorizzazioni necessarie per accedere a <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> del delegato da creare.</param>
        <param name="target">Classe <see cref="T:System.Type" /> che rappresenta la classe che implementa il parametro <c>method</c>.</param>
        <param name="method">Nome del metodo statico che deve essere rappresentato dal delegato.</param>
        <param name="ignoreCase">Valore booleano che indica se ignorare o meno la distinzione tra maiuscole e minuscole al momento di confrontare il nome del metodo.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> per generare un'eccezione se non è possibile associare il parametro<c>method</c>; in caso contrario, <see langword="false" />.</param>
        <summary>Crea un delegato del tipo specificato che rappresenta il metodo statico indicato della classe specificata, con la distinzione tra maiuscole e minuscole indicata e il funzionamento specificato in caso di errore di associazione.</summary>
        <returns>Delegato del tipo specificato che rappresenta il metodo statico specificato della classe specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea i delegati per solo i metodi statici. Un metodo di istanza è un metodo che è associato a un'istanza di una classe. un metodo statico è un metodo che è associato alla classe stessa.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a metodi non pubblici se il chiamante sia stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di concessioni dei metodi non pubblici è limitato al chiamante concedere set, oppure un subset della stessa. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.  
  
oppure 
 <paramref name="target" /> è <see langword="null" />.  
  
oppure 
 <paramref name="method" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> non eredita <see cref="T:System.MulticastDelegate" />.  
  
oppure 
 <paramref name="type" /> non è un oggetto <see langword="RuntimeType" />. Vedere [Tipi di runtime nella reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
oppure 
 <paramref name="target" /> non è un oggetto <see langword="RuntimeType" />.  
  
oppure 
 <paramref name="target" /> è un tipo generico aperto. Ciò significa che la proprietà <see cref="P:System.Type.ContainsGenericParameters" /> è <see langword="true" />.  
  
oppure 
 <paramref name="method" /> non è un metodo <see langword="static" /> (metodo <see langword="Shared" /> in Visual Basic).  
  
oppure 
 Non è possibile associare <paramref name="method" />, ad esempio perché non è stato trovato, e <paramref name="throwOnBindFailure" /> è <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">Non è possibile trovare il metodo <see langword="Invoke" /> di <paramref name="type" />.</exception>
        <exception cref="T:System.MethodAccessException">Il chiamante non ha le autorizzazioni necessarie per accedere a <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Una matrice di oggetti che sono argomenti da passare al metodo rappresentato dal delegato corrente.  
  
oppure 
 <see langword="null" />, qualora il metodo rappresentato dal delegato corrente non richieda argomenti.</param>
        <summary>Richiama dinamicamente, ovvero ad associazione tardiva, il metodo rappresentato dal delegato corrente.</summary>
        <returns>Oggetto restituito dal metodo rappresentato dal delegato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo chiama il metodo <xref:System.Delegate.DynamicInvokeImpl%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Il chiamante non ha accesso al metodo rappresentato dal delegato, ad esempio se il metodo è privato.  
  
oppure 
Il numero, l'ordine o il tipo di parametro elencato in <paramref name="args" /> non è valido.</exception>
        <exception cref="T:System.ArgumentException">Il metodo rappresentato dal delegato viene richiamato su un oggetto o classe che non lo supporta.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il metodo rappresentato dal delegato è un metodo di istanza e l'oggetto di destinazione è <see langword="null" />.  
  
oppure 
Uno dei metodi incapsulati genera un'eccezione.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">Una matrice di oggetti che sono argomenti da passare al metodo rappresentato dal delegato corrente.  
  
oppure 
 <see langword="null" />, qualora il metodo rappresentato dal delegato corrente non richieda argomenti.</param>
        <summary>Richiama dinamicamente, ovvero ad associazione tardiva, il metodo rappresentato dal delegato corrente.</summary>
        <returns>Oggetto restituito dal metodo rappresentato dal delegato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo implementa il metodo <xref:System.Delegate.DynamicInvoke%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Il chiamante non ha accesso al metodo rappresentato dal delegato, ad esempio se il metodo è privato.  
  
oppure 
Il numero, l'ordine o il tipo di parametro elencato in <paramref name="args" /> non è valido.</exception>
        <exception cref="T:System.ArgumentException">Il metodo rappresentato dal delegato viene richiamato su un oggetto o classe che non lo supporta.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Il metodo rappresentato dal delegato è un metodo di istanza e l'oggetto di destinazione è <see langword="null" />.  
  
oppure 
Uno dei metodi incapsulati genera un'eccezione.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da confrontare con il delegato corrente.</param>
        <summary>Determina se l'oggetto specificato e il delegato corrente sono dello stesso tipo e condividono gli stessi metodi e destinazioni e lo stesso elenco chiamate.</summary>
        <returns>
          <see langword="true" /> se <paramref name="obj" /> e il delegato corrente condividono le stesse destinazioni, gli stessi metodi e lo stesso elenco di chiamate; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se i due delegati non sono dello stesso tipo, non sono considerati uguali.  
  
> [!IMPORTANT]
>  In .NET Framework versioni 1.0 e 1.1, due delegati sono stati considerati uguali se le destinazioni, metodi ed elenco di chiamate, anche se sono stati i delegati di tipo diverso.  
  
 I metodi e le destinazioni vengono confrontate per verificarne l'uguaglianza come indicato di seguito:  
  
-   Se i due metodi da confrontare sono statici e non il metodo di stesso nella stessa classe, i metodi sono considerati uguali e anche le destinazioni sono considerate uguali.  
  
-   Se i due metodi da confrontare sono metodi di istanza e lo stesso metodo di stesso oggetto, i metodi sono considerati uguali e anche le destinazioni sono considerate uguali.  
  
-   In caso contrario, i metodi non sono considerati uguali e le destinazioni sono inoltre non considerate uguali.  
  
 Due elenchi chiamate verranno considerati identici solo se hanno lo stesso ordine e gli elementi corrispondenti dagli elenchi di due rappresentano il metodo di stesso e destinazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Il chiamante non ha accesso al metodo rappresentato dal delegato, ad esempio se il metodo è privato.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il codice hash per il delegato.</summary>
        <returns>Codice hash per il delegato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito di questo metodo non deve essere persistente per due motivi. In primo luogo, la funzione hash di una classe può essere modificata per generare una migliore distribuzione, il rendering di tutti i valori da funzione hash precedente diventa inutilizzabile. In secondo luogo, l'implementazione predefinita di questa classe non garantisce che lo stesso valore verrà restituito da istanze diverse.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce l'elenco chiamate del delegato.</summary>
        <returns>Matrice di delegati che rappresentano l'elenco chiamate del delegato corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni delegato nella matrice rappresenta esattamente un metodo.  
  
 L'ordine dei delegati nella matrice è lo stesso ordine in cui il delegato corrente richiama i metodi che rappresentano i delegati.  
  
   
  
## Examples  
 L'esempio seguente assegna tre metodi a un delegato. Chiama quindi il <xref:System.Delegate.GetInvocationList%2A> metodo per ottenere un conteggio totale dei metodi assegnato al delegato, eseguire i delegati in ordine inverso di esecuzione dei metodi il cui nome non includono la sottostringa "File".  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene il metodo static rappresentato dal delegato corrente.</summary>
        <returns>
          <see cref="T:System.Reflection.MethodInfo" /> che descrive il metodo static rappresentato dal delegato corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo si applica solo se il delegato corrente rappresenta un metodo statico.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Il chiamante non ha accesso al metodo rappresentato dal delegato, ad esempio se il metodo è privato.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Non supportato.</param>
        <param name="context">Non supportato.</param>
        <summary>Non supportato.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Questo metodo non è supportato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il metodo rappresentato dal delegato.</summary>
        <value>
          <see cref="T:System.Reflection.MethodInfo" /> in cui è descritto il metodo rappresentato dal delegato.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">Il chiamante non ha accesso al metodo rappresentato dal delegato, ad esempio se il metodo è privato.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">Primo delegato da confrontare.</param>
        <param name="d2">Secondo delegato da confrontare.</param>
        <summary>Determina se i delegati specificati sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="d1" /> è uguale a <paramref name="d2" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Due delegati dello stesso tipo con le stesse destinazioni, metodi e degli elenchi chiamate sono considerati uguali.  
  
 Se i due delegati non sono dello stesso tipo, non sono considerati uguali.  
  
> [!IMPORTANT]
>  In .NET Framework versioni 1.0 e 1.1, due delegati sono stati considerati uguali se le destinazioni, metodi ed elenco di chiamate, anche se sono stati i delegati di tipo diverso.  
  
 I metodi e le destinazioni vengono confrontate per verificarne l'uguaglianza come indicato di seguito:  
  
-   Se i due metodi da confrontare sono statici e non il metodo di stesso nella stessa classe, i metodi sono considerati uguali e anche le destinazioni sono considerate uguali.  
  
-   Se i due metodi da confrontare sono metodi di istanza e lo stesso metodo di stesso oggetto, i metodi sono considerati uguali e anche le destinazioni sono considerate uguali.  
  
-   In caso contrario, i metodi non sono considerati uguali e le destinazioni sono inoltre non considerate uguali.  
  
 Due elenchi chiamate verranno considerati identici se hanno lo stesso ordine e gli elementi corrispondenti dagli elenchi di due rappresentano il metodo di stesso e destinazione.  
  
 È il metodo equivalente per l'operatore <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">Primo delegato da confrontare.</param>
        <param name="d2">Secondo delegato da confrontare.</param>
        <summary>Determina se i delegati specificati non sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="d1" /> non è uguale a <paramref name="d2" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Due delegati non sono uguali se sono di tipi diversi, oppure dispone di diversi metodi, destinazioni diverse o diversi elenchi chiamate.  
  
 Se i due delegati non sono dello stesso tipo, non sono considerati uguali.  
  
> [!IMPORTANT]
>  In .NET Framework versioni 1.0 e 1.1, due delegati vengono considerati uguali se le destinazioni, metodi ed elenco di chiamate, anche se sono stati i delegati di tipo diverso.  
  
 I metodi e le destinazioni vengono confrontate per verificarne l'uguaglianza come indicato di seguito:  
  
-   Se i due metodi da confrontare sono statici e non il metodo di stesso nella stessa classe, i metodi sono considerati uguali e anche le destinazioni sono considerate uguali.  
  
-   Se i due metodi da confrontare sono metodi di istanza e lo stesso metodo di stesso oggetto, i metodi sono considerati uguali e anche le destinazioni sono considerate uguali.  
  
-   In caso contrario, i metodi non sono considerati uguali e le destinazioni sono inoltre non considerate uguali.  
  
 Due elenchi chiamate non sono uguali se hanno dimensioni diverse, se sono ordinati in modo diverso, o se almeno un elemento da un elenco rappresenta un metodo o destinazione che è diverso da quello rappresentato dall'elemento corrispondente in altro elenco.  
  
 È il metodo equivalente per l'operatore <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Delegato dal quale rimuovere l'elenco di chiamate di <c>value</c>.</param>
        <param name="value">Delegato che specifica l'elenco di chiamate da rimuovere dall'elenco di chiamate di <c>source</c>.</param>
        <summary>Rimuove l'ultima occorrenza dell'elenco chiamate di un delegato dall'elenco chiamate di un altro delegato.</summary>
        <returns>Nuovo delegato con un elenco chiamate formato partendo dall'elenco chiamate di <paramref name="source" /> e rimuovendo l'ultima occorrenza dell'elenco chiamate di <paramref name="value" />, se l'elenco chiamate di <paramref name="value" /> si trova all'interno dell'elenco chiamate di <paramref name="source" />. Restituisce <paramref name="source" /> se <paramref name="value" /> è <see langword="null" /> o se l'elenco chiamate di <paramref name="value" /> non viene trovato all'interno dell'elenco chiamate di <paramref name="source" />. Restituisce un riferimento null se l'elenco chiamate di <paramref name="value" /> è uguale all'elenco chiamate di <paramref name="source" /> o se <paramref name="source" /> è un riferimento null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'elenco chiamate di `value` corrisponde a un set di elementi nell'elenco chiamate di contiguo `source`, quindi l'elenco chiamate di `value` ha luogo all'interno dell'elenco chiamate di `source`. Se l'elenco chiamate di `value` si verifica più volte nell'elenco chiamate di `source`, viene rimossa l'ultima occorrenza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Il chiamante non ha accesso al metodo rappresentato dal delegato, ad esempio se il metodo è privato.</exception>
        <exception cref="T:System.ArgumentException">I tipi dei delegati non corrispondono.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Delegato dal quale rimuovere l'elenco di chiamate di <c>value</c>.</param>
        <param name="value">Delegato che specifica l'elenco di chiamate da rimuovere dall'elenco di chiamate di <c>source</c>.</param>
        <summary>Rimuove tutte le occorrenze dell'elenco chiamate di un delegato dall'elenco chiamate di un altro delegato.</summary>
        <returns>Nuovo delegato con un elenco chiamate formato partendo dall'elenco chiamate di <paramref name="source" /> e rimuovendo tutte le occorrenze dell'elenco chiamate di <paramref name="value" />, se l'elenco chiamate di <paramref name="value" /> si trova all'interno dell'elenco chiamate di <paramref name="source" />. Restituisce <paramref name="source" /> se <paramref name="value" /> è <see langword="null" /> o se l'elenco chiamate di <paramref name="value" /> non viene trovato all'interno dell'elenco chiamate di <paramref name="source" />. Restituisce un riferimento null se l'elenco chiamate di <paramref name="value" /> è uguale all'elenco chiamate di <paramref name="source" />, se <paramref name="source" /> contiene solo una serie di elenchi chiamate uguali all'elenco chiamate di <paramref name="value" /> o se <paramref name="source" /> è un riferimento null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'elenco chiamate di `value` corrisponde a un set di elementi nell'elenco chiamate di contiguo `source`, quindi l'elenco chiamate di `value` ha luogo all'interno dell'elenco chiamate di `source`. Se l'elenco chiamate di `value` si verifica più volte nell'elenco chiamate di `source`, vengono rimosse tutte le occorrenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Il chiamante non ha accesso al metodo rappresentato dal delegato, ad esempio se il metodo è privato.</exception>
        <exception cref="T:System.ArgumentException">I tipi dei delegati non corrispondono.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">Delegato che fornisce l'elenco chiamate da rimuovere dall'elenco chiamate del delegato corrente.</param>
        <summary>Rimuove l'elenco chiamate di un delegato dall'elenco chiamate di un altro delegato.</summary>
        <returns>Nuovo delegato con un elenco chiamate formato partendo dall'elenco chiamate del delegato corrente e rimuovendo l'elenco chiamate di <paramref name="value" />, qualora l'elenco chiamate di <paramref name="value" /> venga trovato all'interno dell'elenco chiamate del delegato corrente. Restituisce il delegato corrente se <paramref name="value" /> è <see langword="null" /> o se l'elenco chiamate di <paramref name="value" /> non viene trovato all'interno dell'elenco chiamate del delegato corrente. Restituisce <see langword="null" /> se l'elenco chiamate di <paramref name="value" /> è uguale all'elenco chiamate del delegato corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'elenco chiamate di `value` corrisponde a un insieme di elementi nell'elenco chiamate del delegato corrente, quindi l'elenco chiamate di `value` ha luogo all'interno di elenco chiamate del delegato corrente. Se l'elenco chiamate di `value` presente più volte nell'elenco chiamate del delegato corrente, viene rimossa l'ultima occorrenza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Il chiamante non ha accesso al metodo rappresentato dal delegato, ad esempio se il metodo è privato.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'istanza di classe sulla quale il metodo di istanza viene richiamato dal delegato corrente.</summary>
        <value>Oggetto sul quale il metodo di istanza viene richiamato dal delegato corrente, se il delegato rappresenta un metodo di istanza; <see langword="null" /> se il delegato rappresenta un metodo statico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un metodo di istanza è un metodo che è associato a un'istanza di una classe. un metodo statico è un metodo che è associato alla classe stessa.  
  
 Se uno o più metodi di istanza viene richiamato il delegato, questa proprietà restituisce la destinazione di quest'ultimo metodo di istanza nell'elenco chiamate.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>