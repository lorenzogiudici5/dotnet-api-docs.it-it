<Type Name="Delegate" FullName="System.Delegate">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7d0456aa37bceeab49a6fac813bdba77750d99b8" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37481530" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a delegate, which is a data structure that refers to a static method or to a class instance and an instance method of that class.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Delegate> classe è la classe base per i tipi delegati. Tuttavia, solo il sistema e i compilatori possono derivare in modo esplicito il <xref:System.Delegate> classe o dal <xref:System.MulticastDelegate> classe. Non è inoltre possibile derivare un nuovo tipo da un tipo delegato. Il <xref:System.Delegate> classe non viene considerata un tipo delegato, ovvero una classe utilizzata per derivare i tipi delegati.  
  
 Implementano la maggior parte dei linguaggi una `delegate` parola chiave e i compilatori di tali linguaggi sono in grado di derivare dal <xref:System.MulticastDelegate> classe; pertanto, gli utenti devono usare il `delegate` parola chiave del linguaggio.  
  
> [!NOTE]
>  Common language runtime fornisce un `Invoke` metodo per ogni tipo di delegato, con la stessa firma del delegato. Non è necessario chiamare questo metodo in modo esplicito dal codice c#, Visual Basic o Visual C++, perché i compilatori chiamano automaticamente. Il `Invoke` metodo è utile negli [reflection](~/docs/framework/reflection-and-codedom/reflection.md) quando si desidera trovare la firma del tipo delegato.  
  
 Common language runtime fornisce ogni tipo di delegato con `BeginInvoke` e `EndInvoke` nei metodi per abilitare la chiamata asincrona del delegato. Per altre informazioni su questi metodi, vedere [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 La dichiarazione di un tipo delegato stabilisce un contratto che specifica la firma di uno o più metodi. Un delegato è un'istanza di un tipo delegato che contiene riferimenti a:  
  
-   Un metodo di istanza di un tipo e un oggetto di destinazione può essere assegnato a tale tipo.  
  
-   Un metodo di istanza di un tipo, con nascosto `this` parametro esposto nell'elenco di parametri formali. Il delegato è associato a un'istanza aperta di delegato.  
  
-   Un metodo statico.  
  
-   Un metodo statico e un oggetto di destinazione può essere assegnato al primo parametro del metodo. Il delegato per essere chiuso al primo argomento.  
  
 Per ulteriori informazioni sull'associazione di delegati, vedere il <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> overload del metodo.  
  
> [!NOTE]
>  Nelle versioni 1.0 e 1.1 di .NET Framework, un delegato può rappresentare un metodo solo se la firma del metodo corrisponde esattamente alla firma specificata dal tipo di delegato. Di conseguenza, è supportato solo il primo e il terzo punto dell'elenco precedente, e al primo punto richiede una corrispondenza di tipo esatto.  
  
 Quando un delegato rappresenta un metodo di istanza chiuso al primo argomento (il caso più comune), viene archiviato un riferimento al punto di ingresso del metodo e un riferimento a un oggetto, denominato destinazione, che è un tipo assegnabile al tipo di cui è definito il metodo. Quando un delegato rappresenta un metodo di istanza aperta, archivia un riferimento al punto di ingresso del metodo. La firma del delegato deve includere nascosto `this` parametro nel relativo elenco di parametri formali; in questo caso, il delegato non è un riferimento a un oggetto di destinazione, e un oggetto di destinazione deve essere specificato quando viene richiamato il delegato.  
  
 Quando un delegato rappresenta un metodo statico, il delegato archivia un riferimento al punto di ingresso del metodo. Quando un delegato rappresenta un metodo statico chiuso al primo argomento, il delegato archivia un riferimento al punto di ingresso del metodo e un riferimento a un oggetto di destinazione può essere assegnato al tipo del primo argomento del metodo. Quando il delegato viene richiamato, il primo argomento del metodo statico riceve l'oggetto di destinazione.  
  
 L'elenco chiamate di un delegato è un set ordinato di delegati in cui ogni elemento dell'elenco richiama esattamente uno dei metodi rappresentati dal delegato. Un elenco di chiamate può contenere metodi duplicati. Durante una chiamata, i metodi vengono richiamati nell'ordine in cui vengono visualizzati nell'elenco chiamate. Un delegato tenta di richiamare ogni metodo nell'elenco chiamate; una volta per ogni volta che vengono visualizzati nell'elenco chiamate, vengono richiamati i duplicati. I delegati sono immutabili. una volta creato, non modifica l'elenco chiamate di un delegato.  
  
 I delegati vengono definiti come multicast o combinabile, perché un delegato può richiamare uno o più metodi e può essere usato in combinazione di operazioni.  
  
 La combinazione di operazioni, ad esempio <xref:System.Delegate.Combine%2A> e <xref:System.Delegate.Remove%2A>, delegati esistenti non verranno modificati. Al contrario, questa operazione restituisce un nuovo delegato che contiene i risultati dell'operazione, un delegato invariato o `null`. Restituisce un'operazione di combinazione `null` quando il risultato dell'operazione è un delegato che non fa riferimento ad almeno un metodo. Un'operazione di combinazione restituisce un delegato invariato durante l'operazione richiesta non ha alcun effetto.  
  
> [!NOTE]
>  Linguaggi gestiti utilizzano le <xref:System.Delegate.Combine%2A> e <xref:System.Delegate.Remove%2A> metodi per implementare le operazioni di delegato. Gli esempi includono la `AddHandler` e `RemoveHandler` istruzioni in Visual Basic e gli operatori + = e -= in tipi delegati in c#.  
  
 A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], tipi delegati generici possono avere parametri di tipo variante. Parametri di tipo controvariante possono essere utilizzati come tipi di parametro del delegato e un parametro di tipo covariante può essere utilizzato come tipo restituito. Questa funzionalità consente di delegato generico tipi costruiti dalla stessa definizione di tipo generico per essere compatibili con l'assegnazione se i relativi argomenti di tipo sono tipi di riferimento con una relazione di ereditarietà, come spiegato in [covarianza e La controvarianza](~/docs/standard/generics/covariance-and-contravariance.md).  
  
> [!NOTE]
>  I delegati generici che sono compatibili con l'assegnazione a causa della varianza non sono necessariamente combinabili. Per essere combinabili, i tipi devono corrispondere esattamente. Ad esempio, si supponga che una classe denominata `Derived` deriva da una classe denominata `Base`. Un delegato del tipo `Action<Base>` (`Action(Of Base)` in Visual Basic) può essere assegnato a una variabile di tipo `Action<Derived>`, ma non è possibile combinare le due delegati perché i tipi non corrispondono esattamente.  
  
 Se un metodo richiamato genera un'eccezione, il metodo viene arrestata l'esecuzione, l'eccezione viene passata al chiamante del delegato e non vengono richiamati i metodi rimanenti nell'elenco chiamate. Rilevare l'eccezione nel chiamante non modificare questo comportamento.  
  
 Quando la firma dei metodi richiamati da un delegato include un valore restituito, il delegato restituisce il valore restituito dell'ultimo elemento nell'elenco chiamate. Quando la firma include un parametro che viene passato per riferimento, il valore finale del parametro è il risultato di ogni metodo nell'elenco chiamate in esecuzione in modo sequenziale e aggiornare il valore del parametro.  
  
 L'equivalente più vicino di un delegato in C o C++ è un puntatore a funzione. Un delegato può rappresentare un metodo statico o un metodo di istanza. Quando il delegato rappresenta un metodo di istanza, il delegato archivia non solo un riferimento al punto di ingresso del metodo, ma anche un riferimento all'istanza della classe. A differenza dei puntatori a funzione, i delegati sono orientate a oggetti e indipendente dai tipi.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come definire un delegato denominato `myMethodDelegate`. Vengono create istanze di questo delegato per un metodo di istanza e un metodo statico di annidata `mySampleClass` classe. Il delegato per il metodo di istanza richiede un'istanza di `mySampleClass`. Il `mySampleClass` istanza viene salvata in una variabile denominata `mySC`.  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new delegate.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">The class instance on which the delegate invokes <c>method</c>.</param>
        <param name="method">The name of the instance method that the delegate represents.</param>
        <summary>Initializes a delegate that invokes the specified instance method on the specified class instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore non può essere utilizzato nel codice dell'applicazione. Per creare un delegato che specifica il nome di un metodo di istanza, usare un overload del <xref:System.Delegate.CreateDelegate%2A> metodo che specifica un nome di metodo e un oggetto di destinazione. Ad esempio, il <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> overload del metodo crea un delegato per un metodo di istanza con un nome specificato.  
  
 Questo costruttore crea i delegati, ad esempio solo i metodi. Un metodo di istanza è un metodo che è associato a un'istanza di una classe. un metodo statico è un metodo che è associato alla classe stessa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">There was an error binding to the target method.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">The <see cref="T:System.Type" /> representing the class that defines <c>method</c>.</param>
        <param name="method">The name of the static method that the delegate represents.</param>
        <summary>Initializes a delegate that invokes the specified static method from the specified class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore non può essere utilizzato nel codice dell'applicazione. Per creare un delegato che specifica il nome di un metodo statico, usare un overload del <xref:System.Delegate.CreateDelegate%2A> metodo che specifica un nome di metodo, ma non specifica un oggetto di destinazione. Ad esempio, il <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> overload del metodo crea un delegato per un metodo statico con un nome specificato.  
  
 Questo costruttore crea i delegati per solo i metodi statici. Un metodo di istanza è un metodo che è associato a un'istanza di una classe. un metodo statico è un metodo che è associato alla classe stessa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="target" /> represents an open generic type.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a shallow copy of the delegate.</summary>
        <returns>A shallow copy of the delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clonazione presenta lo stesso <xref:System.Type>, elenco di destinazione, metodo e nella chiamata del delegato dell'originale.  
  
 Una copia superficiale crea una nuova istanza dello stesso tipo dell'oggetto originale e copia quindi i campi non statici dell'oggetto originale. Se il campo è un tipo di valore, viene eseguita una copia bit per bit del campo. Se il campo è un tipo riferimento, il riferimento è copiato ma l'oggetto di cui viene fatto riferimento non; Pertanto, il riferimento nell'oggetto originale e il riferimento nel clone puntare allo stesso oggetto. Al contrario, una copia completa di un oggetto consente di duplicare tutti gli elementi direttamente o indirettamente fa riferimento i campi nell'oggetto.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatenates the invocation lists of the specified multicast (combinable) delegates.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">The array of delegates to combine.</param>
        <summary>Concatenates the invocation lists of an array of delegates.</summary>
        <returns>A new delegate with an invocation list that concatenates the invocation lists of the delegates in the <paramref name="delegates" /> array. Returns <see langword="null" /> if <paramref name="delegates" /> is <see langword="null" />, if <paramref name="delegates" /> contains zero elements, or if every entry in <paramref name="delegates" /> is <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il `delegates` matrice contiene voci che sono `null`, tali voci vengono ignorate.  
  
 L'elenco chiamate può contenere le voci duplicate; vale a dire, le voci che fanno riferimento al metodo di stesso sullo stesso oggetto.  
  
> [!NOTE]
>  I delegati generici che sono compatibili con l'assegnazione a causa della varianza non sono necessariamente combinabili. Per essere combinabili, i tipi devono corrispondere esattamente. Ad esempio, si supponga che una classe denominata `Derived` deriva da una classe denominata `Base`. Un delegato del tipo `Action<Base>` (`Action(Of Base)` in Visual Basic) può essere assegnato a una variabile di tipo `Action<Derived>`, come illustrato in [covarianza e controvarianza](~/docs/standard/generics/covariance-and-contravariance.md), ma i due delegati non possono essere combinati in quanto i tipi non corrispondono esattamente.  
  
 <xref:System.Delegate.Combine%2A> è utile per la creazione di gestori di eventi che si verifica più metodi ogni volta un evento di chiamata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Not all the non-null entries in <paramref name="delegates" /> are instances of the same delegate type.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">The delegate whose invocation list comes first.</param>
        <param name="b">The delegate whose invocation list comes last.</param>
        <summary>Concatenates the invocation lists of two delegates.</summary>
        <returns>A new delegate with an invocation list that concatenates the invocation lists of <paramref name="a" /> and <paramref name="b" /> in that order. Returns <paramref name="a" /> if <paramref name="b" /> is <see langword="null" />, returns <paramref name="b" /> if <paramref name="a" /> is a null reference, and returns a null reference if both <paramref name="a" /> and <paramref name="b" /> are null references.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'elenco chiamate può contenere le voci duplicate; vale a dire, le voci che fanno riferimento al metodo di stesso sullo stesso oggetto.  
  
> [!NOTE]
>  I delegati generici che sono compatibili con l'assegnazione a causa della varianza non sono necessariamente combinabili. Per essere combinabili, i tipi devono corrispondere esattamente. Ad esempio, si supponga che una classe denominata `Derived` deriva da una classe denominata `Base`. Un delegato del tipo `Action<Base>` (`Action(Of Base)` in Visual Basic) può essere assegnato a una variabile di tipo `Action<Derived>`, come illustrato in [covarianza e controvarianza](~/docs/standard/generics/covariance-and-contravariance.md), ma i due delegati non possono essere combinati in quanto i tipi non corrispondono esattamente.  
  
 <xref:System.Delegate.Combine%2A> è utile per la creazione di gestori di eventi che si verifica più metodi ogni volta un evento di chiamata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Both <paramref name="a" /> and <paramref name="b" /> are not <see langword="null" />, and <paramref name="a" /> and <paramref name="b" /> are not instances of the same delegate type.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">The multicast (combinable) delegate whose invocation list to append to the end of the invocation list of the current multicast (combinable) delegate.</param>
        <summary>Concatenates the invocation lists of the specified multicast (combinable) delegate and the current multicast (combinable) delegate.</summary>
        <returns>A new multicast (combinable) delegate with an invocation list that concatenates the invocation list of the current multicast (combinable) delegate and the invocation list of <paramref name="d" />, or the current multicast (combinable) delegate if <paramref name="d" /> is <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo si applica solo se il delegato corrente è multicast, o combinabile.  
  
 L'implementazione corrente genera semplicemente un <xref:System.MulticastNotSupportedException>.  
  
 L'elenco chiamate può contenere le voci duplicate; vale a dire, le voci che fanno riferimento al metodo di stesso sullo stesso oggetto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">Always thrown.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a delegate of the specified type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent. Only static methods are supported in the .NET Framework version 1.0 and 1.1.</param>
        <summary>Creates a delegate of the specified type to represent the specified static method.</summary>
        <returns>A delegate of the specified type to represent the specified static method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework versioni 1.0 e 1.1, questo overload del metodo consente di creare i delegati per solo i metodi statici. In .NET Framework versione 2.0, questo overload del metodo anche può creare Apri istanza metodo i delegati; metodi di istanza, ovvero i delegati che forniscono in modo esplicito il primo argomento di nascosto. Per informazioni dettagliate, vedere il metodo più generico <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> overload del metodo, che consente di creare tutte le combinazioni dei delegati chiusi o aperti per l'istanza o metodi statici e, facoltativamente, specificare un primo argomento.  
  
> [!NOTE]
>  Questo overload del metodo deve essere utilizzato quando il delegato non viene chiusa al primo argomento, perché in tal caso è leggermente più veloce.  
  
 Questo overload del metodo è equivalente alla chiamata di <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> overload del metodo e specificando `true` per `throwOnBindFailure`.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a metodi non pubblici se il chiamante sia stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di concessioni dei metodi non pubblici è limitato al chiamante concedere set, oppure un subset della stessa. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
## <a name="compatible-parameter-types-and-return-type"></a>I tipi di parametro compatibili e il tipo restituito  
 In .NET Framework versione 2.0, i tipi di parametro e tipo restituito del delegato creato usando questo overload del metodo deve essere compatibile con i tipi di parametro e tipo restituito del metodo rappresentato dal delegato. i tipi non è in modo che corrispondano esattamente. Rappresenta un minore rigidità del comportamento di associazione in .NET Framework versioni 1.0 e 1.1, in cui i tipi devono corrispondere esattamente.  
  
 Un parametro di un delegato è compatibile con il parametro di un metodo corrispondente se il tipo del parametro del delegato è più restrittivo rispetto al tipo del parametro del metodo. In questo modo si garantisce che un argomento passato al delegato possa essere passato in modo sicuro al metodo.  
  
 Analogamente, il tipo restituito di un delegato è compatibile con il tipo restituito di un metodo se il tipo restituito del metodo è più restrittivo rispetto al tipo restituito del delegato. In questo modo si garantisce la possibilità di eseguire in modo sicuro il cast del valore restituito del metodo nel tipo restituito del delegato.  
  
 Ad esempio, un delegato con un parametro di tipo <xref:System.Collections.Hashtable> e un tipo restituito <xref:System.Object> può rappresentare un metodo con un parametro di tipo <xref:System.Object> e un valore restituito di tipo <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 In questa sezione sono riportati due esempi di codice. Nel primo esempio illustra i due tipi di delegati che possono essere creati con questo overload del metodo: aprire tramite un metodo di istanza e su un metodo statico.  
  
 Il secondo esempio di codice vengono illustrati i tipi di parametro compatibili e i tipi restituiti.  
  
 **Esempio 1**  
  
 Esempio di codice seguente illustra le due modalità un delegato può essere creato usando questo overload del metodo di <xref:System.Delegate.CreateDelegate%2A> (metodo).  
  
> [!NOTE]
>  Esistono due overload del <xref:System.Delegate.CreateDelegate%2A> metodo che specificano un <xref:System.Reflection.MethodInfo> ma non è un primo argomento; le relative funzionalità è uguale ad eccezione del fatto che uno consente di specificare se si desidera generare un errore di associazione e l'altra genera sempre un'eccezione. Questo esempio di codice Usa entrambi gli overload.  
  
 Nell'esempio viene dichiarata una classe `C` con un metodo statico `M2` e un metodo di istanza `M1`, e due tipi di delegato: `D1` accetta un'istanza di `C` e una stringa, e `D2` accetta una stringa.  
  
 Una seconda classe denominata `Example` contiene il codice che crea i delegati.  
  
-   Un delegato del tipo `D1`, che rappresenta un metodo di istanza aperta, viene creato per il metodo di istanza `M1`. Un'istanza deve essere passata quando viene richiamato il delegato.  
  
-   Un delegato del tipo `D2`, che rappresenta un metodo statico aperto, viene creato per il metodo statico `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Esempio 2**  
  
 Esempio di codice seguente illustra la compatibilità dei tipi di parametro e i tipi restituiti.  
  
 L'esempio di codice definisce una classe base denominata `Base` e una classe denominata `Derived` che deriva da `Base`. La classe derivata ha un `static` (`Shared` in Visual Basic) metodo denominato `MyMethod` con un parametro di tipo `Base` e un tipo restituito di `Derived`. L'esempio di codice definisce anche un delegato denominato `Example` che ha un parametro di tipo `Derived` e un tipo restituito di `Base`.  
  
 L'esempio di codice viene illustrato che il delegato denominato `Example` può essere utilizzato per rappresentare il metodo `MyMethod`. Il metodo può essere associato al delegato perché:  
  
-   Il tipo di parametro del delegato (`Derived`) è più restrittivo rispetto al tipo di parametro del `MyMethod` (`Base`), in modo che sia sempre possibile passare l'argomento del delegato da `MyMethod`.  
  
-   Il tipo restituito del `MyMethod` (`Derived`) è più restrittivo rispetto al tipo di parametro del delegato (`Base`), in modo che sia sempre possibile eseguire il cast di tipo restituito del metodo per il tipo restituito del delegato.  
  
 L'esempio di codice non genera alcun output.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> is not a static method, and the .NET Framework version is 1.0 or 1.1.  -or-  <paramref name="method" /> cannot be bound.  -or-  <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="firstArgument">The object to which the delegate is bound, or <see langword="null" /> to treat <c>method</c> as <see langword="static" /> (<see langword="Shared" /> in Visual Basic).</param>
        <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</param>
        <summary>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument.</summary>
        <returns>A delegate of the specified type that represents the specified static or instance method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo overload del metodo è equivalente alla chiamata di <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> overload del metodo e specificando `true` per `throwOnBindFailure`. Questi due overload forniscono il modo più flessibile per creare i delegati. È possibile usarli per creare i delegati per statici o metodi di istanza e, facoltativamente, specificare il primo argomento.  
  
> [!NOTE]
>  Se non si fornisce un primo argomento, usare il <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> overload del metodo per ottenere prestazioni migliori.  
  
 Il tipo delegato e il metodo deve avere tipi restituiti compatibili. Vale a dire, il tipo restituito del `method` deve essere assegnabile al tipo restituito di `type`.  
  
 Se `firstArgument` viene fornito, viene passata a `method` ogni volta che viene richiamato il delegato; `firstArgument` viene definito da associare al delegato e il delegato per essere chiuso al primo argomento. Se `method` viene `static` (`Shared` in Visual Basic), l'elenco argomenti fornito quando si richiama il delegato include tutti i parametri tranne il primo; se `method` è un metodo di istanza, quindi `firstArgument` viene passato all'istanza nascosta parametro (rappresentato da `this` in c# o da `Me` in Visual Basic).  
  
 Se `firstArgument` viene fornito, il primo parametro di `method` deve essere un tipo riferimento, e `firstArgument` deve essere compatibile con tale tipo.  
  
> [!IMPORTANT]
>  Se `method` viene `static` (`Shared` in Visual Basic) e il primo parametro è di tipo <xref:System.Object> oppure <xref:System.ValueType>, quindi `firstArgument` può essere un tipo di valore. In questo caso `firstArgument` automaticamente viene sottoposto a boxing. Conversione boxing automatico non avviene per altri argomenti, come in una funzione c# o Visual Basic che chiamasse.  
  
 Se `firstArgument` è un riferimento null e `method` è un metodo di istanza, il risultato dipende dalle firme del tipo delegato `type` e di `method`:  
  
-   Se la firma dei `type` includa in modo esplicito il primo parametro nascosto di `method`, il delegato rappresenta un metodo di istanza aperta. Quando il delegato viene richiamato, il primo argomento nell'elenco di argomenti viene passato al parametro instance nascosta di `method`.  
  
-   Se le firme dei `method` e `type` corrispondenza (vale a dire, tutti i tipi di parametro compatibili), il delegato è associato in modo rigido un riferimento null. Richiamare il delegato è simile a chiamata al metodo di istanza in un'istanza null, che non è un'operazione particolarmente utile da eseguire.  
  
 Se `firstArgument` è un riferimento null e `method` è statica, il risultato dipende dalle firme del tipo delegato `type` e di `method`:  
  
-   Se la firma dei `method` e `type` corrispondenza (vale a dire, tutti i tipi di parametro compatibili), il delegato rappresenta un metodo statico open. Questo è il caso più comune per i metodi statici. In questo caso, è possibile ottenere prestazioni leggermente migliori usando il <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> overload del metodo.  
  
-   Se la firma dei `type` inizia con il secondo parametro di `method` e il resto dei tipi di parametro compatibili, quindi il delegato per essere chiuso un riferimento null. Quando il delegato viene richiamato, viene passato un riferimento null per il primo parametro di `method`.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a metodi non pubblici se il chiamante sia stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di concessioni dei metodi non pubblici è limitato al chiamante concedere set, oppure un subset della stessa. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
## <a name="compatible-parameter-types-and-return-type"></a>I tipi di parametro compatibili e il tipo restituito  
 I tipi di parametro e tipo restituito del delegato deve essere compatibile con i tipi di parametro e tipo restituito del metodo rappresentato dal delegato. i tipi non è in modo che corrispondano esattamente.  
  
> [!NOTE]
>  In .NET Framework versioni 1.0 e 1.1, i tipi devono corrispondere esattamente.  
  
 Un parametro di un delegato è compatibile con il parametro di un metodo corrispondente se il tipo del parametro del delegato è più restrittivo rispetto al tipo del parametro del metodo. In questo modo si garantisce che un argomento passato al delegato possa essere passato in modo sicuro al metodo.  
  
 Analogamente, il tipo restituito di un delegato è compatibile con il tipo restituito di un metodo se il tipo restituito del metodo è più restrittivo rispetto al tipo restituito del delegato. In questo modo si garantisce la possibilità di eseguire in modo sicuro il cast del valore restituito del metodo nel tipo restituito del delegato.  
  
 Ad esempio, un delegato con un parametro di tipo <xref:System.Collections.Hashtable> e un tipo restituito <xref:System.Object> può rappresentare un metodo con un parametro di tipo <xref:System.Object> e un valore restituito di tipo <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Determinazione dei metodi che può rappresentare un delegato  
 Un altro modo utile pensare alla flessibilità offerta da questo overload del metodo <xref:System.Delegate.CreateDelegate%2A> è che qualsiasi delegato specificato possa rappresentare quattro diverse combinazioni di firma del metodo e il tipo di metodo (statico o istanza). Si consideri un tipo delegato `D` con un solo argomento di tipo `C`. Di seguito vengono descritti i metodi `D` può rappresentare, ignorando il tipo restituito poiché deve corrispondere in tutti i casi:  
  
-   `D` può rappresentare qualsiasi metodo di istanza che dispone di esattamente un argomento di tipo `C`, indipendentemente dal tipo a cui appartiene il metodo di istanza. Quando <xref:System.Delegate.CreateDelegate%2A> viene chiamato `firstArgument` è un'istanza del tipo `method` appartiene, e il delegato risultante viene definito per essere chiuso in quell'istanza. (In modo rigido `D` può inoltre essere associato un riferimento null se `firstArgument` è un riferimento null.)  
  
-   `D` può rappresentare un metodo di istanza di `C` che non dispone di argomenti. Quando <xref:System.Delegate.CreateDelegate%2A> viene chiamato, `firstArgument` è un riferimento null. Il delegato risultante rappresenta un metodo di istanza aperta e un'istanza di `C` è necessario specificare ogni volta che viene richiamato.  
  
-   `D` può rappresentare un metodo statico che accetta un argomento di tipo `C`, e che può appartenere a qualsiasi tipo. Quando <xref:System.Delegate.CreateDelegate%2A> viene chiamato, `firstArgument` è un riferimento null. Il delegato risultante rappresenta un metodo statico aperto e un'istanza di `C` è necessario specificare ogni volta che viene richiamato.  
  
-   `D` può rappresentare un metodo statico che appartiene al tipo `F` e dispone di due argomenti, di tipo `F` e il tipo `C`. Quando <xref:System.Delegate.CreateDelegate%2A> viene chiamato `firstArgument` è un'istanza di `F`. Il delegato risultante rappresenta un metodo statico che viene chiuso in quell'istanza di `F`. Si noti che nel caso in cui `F` e `C` sono dello stesso tipo, il metodo statico dispone di due argomenti di quel tipo. (In questo caso `D` viene chiuso un riferimento null se `firstArgument` è un riferimento null.)  
  
   
  
## Examples  
 In questa sezione contiene tre esempi di codice. Nel primo esempio illustra i quattro tipi di delegati che possono essere creati: rigido a un metodo di istanza, aprire tramite un metodo di istanza, aprire tramite un metodo statico e chiusa tramite un metodo statico.  
  
 Il secondo esempio di codice vengono illustrati i tipi di parametro compatibili e i tipi restituiti.  
  
 Mostra tutti i metodi che il tipo delegato possono rappresentare il terzo esempio di codice definisce un tipo di delegato unico.  
  
 **Esempio 1**  
  
 Esempio di codice seguente illustra i quattro modi un delegato può essere creato usando l'overload del <xref:System.Delegate.CreateDelegate%2A> (metodo).  
  
> [!NOTE]
>  Esistono due overload del <xref:System.Delegate.CreateDelegate%2A> metodo che specificano `firstArgument` e un <xref:System.Reflection.MethodInfo>; le relative funzionalità è uguale ad eccezione del fatto che uno consente di specificare se si desidera generare un errore di associazione e l'altra genera sempre un'eccezione. Questo esempio di codice Usa entrambi gli overload.  
  
 Nell'esempio viene dichiarata una classe `C` con un metodo statico `M2` e un metodo di istanza `M1`, e tre i tipi di delegato: `D1` accetta un'istanza di `C` e una stringa, `D2` accetta una stringa e `D3`non dispone di argomenti.  
  
 Una seconda classe denominata `Example` contiene il codice che crea i delegati.  
  
-   Un delegato del tipo `D2`, chiuso su un'istanza di `C`, viene creato per il metodo di istanza `M1`. Viene richiamato con stringhe diverse, a indicare che l'istanza associata di `C` viene sempre usato.  
  
-   Un delegato del tipo `D1`, che rappresenta un metodo di istanza aperta, viene creato per il metodo di istanza `M1`. Un'istanza deve essere passata quando viene richiamato il delegato.  
  
-   Un delegato del tipo `D2`, che rappresenta un metodo statico aperto, viene creato per il metodo statico `M2`.  
  
-   Infine, un delegato del tipo `D3`, chiuso in una stringa, viene creato per il metodo statico `M2`. Il metodo viene richiamato per mostrare che usa la stringa associata.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Esempio 2**  
  
 Esempio di codice seguente illustra la compatibilità dei tipi di parametro e i tipi restituiti.  
  
> [!NOTE]
>  Questo esempio di codice Usa il <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> overload del metodo. L'utilizzo di altri overload che accettano <xref:System.Reflection.MethodInfo> è simile.  
  
 L'esempio di codice definisce una classe base denominata `Base` e una classe denominata `Derived` che deriva da `Base`. La classe derivata ha un `static` (`Shared` in Visual Basic) metodo denominato `MyMethod` con un parametro di tipo `Base` e un tipo restituito di `Derived`. L'esempio di codice definisce anche un delegato denominato `Example` che ha un parametro di tipo `Derived` e un tipo restituito di `Base`.  
  
 L'esempio di codice viene illustrato che il delegato denominato `Example` può essere utilizzato per rappresentare il metodo `MyMethod`. Il metodo può essere associato al delegato perché:  
  
-   Il tipo di parametro del delegato (`Derived`) è più restrittivo rispetto al tipo di parametro del `MyMethod` (`Base`), in modo che sia sempre possibile passare l'argomento del delegato da `MyMethod`.  
  
-   Il tipo restituito del `MyMethod` (`Derived`) è più restrittivo rispetto al tipo di parametro del delegato (`Base`), in modo che sia sempre possibile eseguire il cast di tipo restituito del metodo per il tipo restituito del delegato.  
  
 L'esempio di codice non genera alcun output.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Esempio 3**  
  
 Esempio di codice seguente illustra tutti i metodi rappresenta un singolo tipo delegato, usando il <xref:System.Delegate.CreateDelegate%2A> metodo per creare i delegati.  
  
> [!NOTE]
>  Esistono due overload del <xref:System.Delegate.CreateDelegate%2A> metodo che specificano `firstArgument` e un <xref:System.Reflection.MethodInfo>; le relative funzionalità è uguale ad eccezione del fatto che uno consente di specificare se si desidera generare un errore di associazione e l'altra genera sempre un'eccezione. Questo esempio di codice Usa entrambi gli overload.  
  
 L'esempio di codice definisce due classi `C` e `F`e un tipo delegato `D` con un solo argomento di tipo `C`. Le classi corrispondenti statici e metodi di istanza `M1`, `M3`, e `M4`e la classe `C` include inoltre un metodo di istanza `M2` che non dispone di argomenti.  
  
 Una terza classe denominata `Example` contiene il codice che crea i delegati.  
  
-   I delegati vengono creati il metodo, ad esempio `M1` di tipo `C` e il tipo `F`; ognuna viene chiuso su un'istanza del rispettivo tipo. Metodo `M1` typu `C` consente di visualizzare il `ID` le proprietà dell'istanza associata e dell'argomento.  
  
-   Viene creato un delegato per il metodo `M2` di tipo `C`. Si tratta di un delegato di istanza aperta, in cui l'argomento del delegato rappresenta il primo argomento nascosto sul metodo di istanza. Il metodo non dispone di altri argomenti. Viene chiamato come se fosse un metodo statico.  
  
-   I delegati vengono creati per il metodo statico `M3` typu `C` e il tipo `F`; questi sono aperti i delegati statici.  
  
-   Infine, i delegati vengono creati per il metodo statico `M4` typu `C` e il tipo `F`; ogni metodo presenta il tipo dichiarante come primo argomento e viene fornita un'istanza del tipo, in modo che i delegati vengono chiusi relativi primi argomenti . Metodo `M4` typu `C` consente di visualizzare il `ID` le proprietà dell'istanza associata e dell'argomento.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> cannot be bound.  -or-  <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The class instance on which <c>method</c> is invoked.</param>
        <param name="method">The name of the instance method that the delegate is to represent.</param>
        <summary>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</summary>
        <returns>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea i delegati, ad esempio solo i metodi. Un metodo di istanza è un metodo che è associato a un'istanza di una classe. un metodo statico è un metodo che è associato alla classe stessa.  
  
 Questo overload del metodo è equivalente alla chiamata di <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> overload del metodo, specificando `false` per `ignoreCase` e `true` per `throwOnBindFailure`.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a metodi non pubblici se il chiamante sia stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di concessioni dei metodi non pubblici è limitato al chiamante concedere set, oppure un subset della stessa. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> is not an instance method.  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</param>
        <summary>Creates a delegate of the specified type to represent the specified static method, with the specified behavior on failure to bind.</summary>
        <returns>A delegate of the specified type to represent the specified static method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del metodo è possibile creare delegati del metodo statico open e aprire i delegati del metodo di istanza, vale a dire, i delegati che espongono il primo argomento nascosto dei metodi di istanza. Per informazioni dettagliate, vedere il metodo più generico <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> overload del metodo che consente di creare, ad esempio tutte le combinazioni dei delegati aperte o chiuse o i metodi statici.  
  
> [!NOTE]
>  Questo overload del metodo deve essere utilizzato quando il delegato non viene chiusa al primo argomento, perché in tal caso è leggermente più veloce.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a metodi non pubblici se il chiamante sia stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di concessioni dei metodi non pubblici è limitato al chiamante concedere set, oppure un subset della stessa. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
## <a name="compatible-parameter-types-and-return-type"></a>I tipi di parametro compatibili e il tipo restituito  
 I tipi di parametro e tipo restituito del delegato deve essere compatibile con i tipi di parametro e tipo restituito del metodo rappresentato dal delegato. i tipi non è in modo che corrispondano esattamente.  
  
> [!NOTE]
>  In .NET Framework versioni 1.0 e 1.1, i tipi devono corrispondere esattamente.  
  
 Un parametro di un delegato è compatibile con il parametro di un metodo corrispondente se il tipo del parametro del delegato è più restrittivo rispetto al tipo del parametro del metodo. In questo modo si garantisce che un argomento passato al delegato possa essere passato in modo sicuro al metodo.  
  
 Analogamente, il tipo restituito di un delegato è compatibile con il tipo restituito di un metodo se il tipo restituito del metodo è più restrittivo rispetto al tipo restituito del delegato. In questo modo si garantisce la possibilità di eseguire in modo sicuro il cast del valore restituito del metodo nel tipo restituito del delegato.  
  
 Ad esempio, un delegato con un parametro di tipo <xref:System.Collections.Hashtable> e un tipo restituito <xref:System.Object> può rappresentare un metodo con un parametro di tipo <xref:System.Object> e un valore restituito di tipo <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 In questa sezione sono riportati due esempi di codice. Nel primo esempio illustra i due tipi di delegati che possono essere creati con questo overload del metodo: aprire tramite un metodo di istanza e su un metodo statico.  
  
 Il secondo esempio di codice vengono illustrati i tipi di parametro compatibili e i tipi restituiti.  
  
 **Esempio 1**  
  
 Esempio di codice seguente illustra le due modalità un delegato può essere creato usando questo overload del metodo di <xref:System.Delegate.CreateDelegate%2A> (metodo).  
  
> [!NOTE]
>  Esistono due overload del <xref:System.Delegate.CreateDelegate%2A> metodo che specificano un <xref:System.Reflection.MethodInfo> ma non è un primo argomento; le relative funzionalità è uguale ad eccezione del fatto che uno consente di specificare se si desidera generare un errore di associazione e l'altra genera sempre un'eccezione. Questo esempio di codice Usa entrambi gli overload.  
  
 Nell'esempio viene dichiarata una classe `C` con un metodo statico `M2` e un metodo di istanza `M1`, e due tipi di delegato: `D1` accetta un'istanza di `C` e una stringa, e `D2` accetta una stringa.  
  
 Una seconda classe denominata `Example` contiene il codice che crea i delegati.  
  
-   Un delegato del tipo `D1`, che rappresenta un metodo di istanza aperta, viene creato per il metodo di istanza `M1`. Un'istanza deve essere passata quando viene richiamato il delegato.  
  
-   Un delegato del tipo `D2`, che rappresenta un metodo statico aperto, viene creato per il metodo statico `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Esempio 2**  
  
 Esempio di codice seguente illustra la compatibilità dei tipi di parametro e i tipi restituiti.  
  
> [!NOTE]
>  Questo esempio di codice Usa il <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> overload del metodo. L'utilizzo di altri overload che accettano <xref:System.Reflection.MethodInfo> è simile.  
  
 L'esempio di codice definisce una classe base denominata `Base` e una classe denominata `Derived` che deriva da `Base`. La classe derivata ha un `static` (`Shared` in Visual Basic) metodo denominato `MyMethod` con un parametro di tipo `Base` e un tipo restituito di `Derived`. L'esempio di codice definisce anche un delegato denominato `Example` che ha un parametro di tipo `Derived` e un tipo restituito di `Base`.  
  
 L'esempio di codice viene illustrato che il delegato denominato `Example` può essere utilizzato per rappresentare il metodo `MyMethod`. Il metodo può essere associato al delegato perché:  
  
-   Il tipo di parametro del delegato (`Derived`) è più restrittivo rispetto al tipo di parametro del `MyMethod` (`Base`), in modo che sia sempre possibile passare l'argomento del delegato da `MyMethod`.  
  
-   Il tipo restituito del `MyMethod` (`Derived`) è più restrittivo rispetto al tipo di parametro del delegato (`Base`), in modo che sia sempre possibile eseguire il cast di tipo restituito del metodo per il tipo restituito del delegato.  
  
 L'esempio di codice non genera alcun output.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> cannot be bound, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The <see cref="T:System.Type" /> representing the class that implements <c>method</c>.</param>
        <param name="method">The name of the static method that the delegate is to represent.</param>
        <summary>Creates a delegate of the specified type that represents the specified static method of the specified class.</summary>
        <returns>A delegate of the specified type that represents the specified static method of the specified class.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea i delegati per solo i metodi statici. Un metodo di istanza è un metodo che è associato a un'istanza di una classe. un metodo statico è un metodo che è associato alla classe stessa.  
  
 Questo overload del metodo è equivalente alla chiamata di <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> overload del metodo, specificando `false` per `ignoreCase` e `true` per `throwOnBindFailure`.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a metodi non pubblici se il chiamante sia stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di concessioni dei metodi non pubblici è limitato al chiamante concedere set, oppure un subset della stessa. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="target" /> is not a <see langword="RuntimeType" />.  -or-  <paramref name="target" /> is an open generic type. That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> representing the type of delegate to create.</param>
        <param name="firstArgument">An <see cref="T:System.Object" /> that is the first argument of the method the delegate represents. For instance methods, it must be compatible with the instance type.</param>
        <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</param>
        <summary>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument and the specified behavior on failure to bind.</summary>
        <returns>A delegate of the specified type that represents the specified static or instance method, or <see langword="null" /> if <paramref name="throwOnBindFailure" /> is <see langword="false" /> and the delegate cannot be bound to <paramref name="method" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload del metodo e <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> overload del metodo che genera sempre un'eccezione in caso di errore da associare, specificare il modo più flessibile per creare i delegati. È possibile utilizzarli per creare i delegati per statici o metodi di istanza, con o senza un primo argomento.  
  
> [!NOTE]
>  Se non si fornisce un primo argomento, usare il <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> overload del metodo per ottenere prestazioni migliori.  
  
 Il tipo delegato e il metodo deve avere tipi restituiti compatibili. Vale a dire, il tipo restituito del `method` deve essere assegnabile al tipo restituito di `type`.  
  
 Se `firstArgument` viene fornito, viene passata a `method` ogni volta che viene richiamato il delegato; `firstArgument` viene definito da associare al delegato e il delegato per essere chiuso al primo argomento. Se `method` viene `static` (`Shared` in Visual Basic), l'elenco argomenti fornito quando si richiama il delegato include tutti i parametri tranne il primo; se `method` è un metodo di istanza, quindi `firstArgument` viene passato all'istanza nascosta parametro (rappresentato da `this` in c# o da `Me` in Visual Basic).  
  
 Se `firstArgument` viene fornito, il primo parametro di `method` deve essere un tipo riferimento, e `firstArgument` deve essere compatibile con tale tipo.  
  
> [!IMPORTANT]
>  Se `method` viene `static` (`Shared` in Visual Basic) e il primo parametro è di tipo <xref:System.Object> oppure <xref:System.ValueType>, quindi `firstArgument` può essere un tipo di valore. In questo caso `firstArgument` automaticamente viene sottoposto a boxing. Conversione boxing automatico non avviene per altri argomenti, come in una funzione c# o Visual Basic che chiamasse.  
  
 Se `firstArgument` è un riferimento null e `method` è un metodo di istanza, il risultato dipende dalle firme del tipo delegato `type` e di `method`:  
  
-   Se la firma dei `type` includa in modo esplicito il primo parametro nascosto di `method`, il delegato rappresenta un metodo di istanza aperta. Quando il delegato viene richiamato, il primo argomento nell'elenco di argomenti viene passato al parametro instance nascosta di `method`.  
  
-   Se le firme dei `method` e `type` corrispondenza (vale a dire, tutti i tipi di parametro compatibili), il delegato è associato in modo rigido un riferimento null. Richiamare il delegato è simile a chiamata al metodo di istanza in un'istanza null, che non è un'operazione particolarmente utile da eseguire.  
  
 Se `firstArgument` è un riferimento null e `method` è statica, il risultato dipende dalle firme del tipo delegato `type` e di `method`:  
  
-   Se la firma dei `method` e `type` corrispondenza (vale a dire, tutti i tipi di parametro compatibili), il delegato rappresenta un metodo statico open. Questo è il caso più comune per i metodi statici. In questo caso, è possibile ottenere prestazioni leggermente migliori usando il <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> overload del metodo.  
  
-   Se la firma dei `type` inizia con il secondo parametro di `method` e il resto dei tipi di parametro compatibili, quindi il delegato per essere chiuso un riferimento null. Quando il delegato viene richiamato, viene passato un riferimento null per il primo parametro di `method`.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a metodi non pubblici se il chiamante sia stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di concessioni dei metodi non pubblici è limitato al chiamante concedere set, oppure un subset della stessa. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
## <a name="compatible-parameter-types-and-return-type"></a>I tipi di parametro compatibili e il tipo restituito  
 I tipi di parametro e tipo restituito del delegato deve essere compatibile con i tipi di parametro e tipo restituito del metodo rappresentato dal delegato. i tipi non è in modo che corrispondano esattamente.  
  
> [!NOTE]
>  In .NET Framework versione 1.0 e 1.1 di tipi devono corrispondere esattamente.  
  
 Un parametro di un delegato è compatibile con il parametro di un metodo corrispondente se il tipo del parametro del delegato è più restrittivo rispetto al tipo del parametro del metodo. In questo modo si garantisce che un argomento passato al delegato possa essere passato in modo sicuro al metodo.  
  
 Analogamente, il tipo restituito di un delegato è compatibile con il tipo restituito di un metodo se il tipo restituito del metodo è più restrittivo rispetto al tipo restituito del delegato. In questo modo si garantisce la possibilità di eseguire in modo sicuro il cast del valore restituito del metodo nel tipo restituito del delegato.  
  
 Ad esempio, un delegato con un parametro di tipo <xref:System.Collections.Hashtable> e un tipo restituito <xref:System.Object> può rappresentare un metodo con un parametro di tipo <xref:System.Object> e un valore restituito di tipo <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Determinazione dei metodi che può rappresentare un delegato  
 Un altro modo utile pensare alla flessibilità offerta da questo overload del metodo <xref:System.Delegate.CreateDelegate%2A> è che qualsiasi delegato specificato possa rappresentare quattro diverse combinazioni di firma del metodo e il tipo di metodo (statico o istanza). Si consideri un tipo delegato `D` con un solo argomento di tipo `C`. Di seguito vengono descritti i metodi `D` può rappresentare, ignorando il tipo restituito poiché deve corrispondere in tutti i casi:  
  
-   `D` può rappresentare qualsiasi metodo di istanza che dispone di esattamente un argomento di tipo `C`, indipendentemente dal tipo a cui appartiene il metodo di istanza. Quando <xref:System.Delegate.CreateDelegate%2A> viene chiamato `firstArgument` è un'istanza del tipo `method` appartiene, e il delegato risultante viene definito per essere chiuso in quell'istanza. (In modo rigido `D` può inoltre essere associato un riferimento null se `firstArgument` è `null`.)  
  
-   `D` può rappresentare un metodo di istanza di `C` che non dispone di argomenti. Quando <xref:System.Delegate.CreateDelegate%2A> viene chiamato, `firstArgument` è un riferimento null. Il delegato risultante rappresenta un metodo di istanza aperta e un'istanza di `C` è necessario specificare ogni volta che viene richiamato.  
  
-   `D` può rappresentare un metodo statico che accetta un argomento di tipo `C`, e che può appartenere a qualsiasi tipo. Quando <xref:System.Delegate.CreateDelegate%2A> viene chiamato, `firstArgument` è un riferimento null. Il delegato risultante rappresenta un metodo statico aperto e un'istanza di `C` è necessario specificare ogni volta che viene richiamato.  
  
-   `D` può rappresentare un metodo statico che appartiene al tipo `F` e dispone di due argomenti, di tipo `F` e il tipo `C`. Quando <xref:System.Delegate.CreateDelegate%2A> viene chiamato `firstArgument` è un'istanza di `F`. Il delegato risultante rappresenta un metodo statico che viene chiuso in quell'istanza di `F`. Si noti che nel caso in cui `F` e `C` sono dello stesso tipo, il metodo statico dispone di due argomenti di quel tipo. (In questo caso `D` viene chiuso un riferimento null se `firstArgument` è `null`.)  
  
   
  
## Examples  
 In questa sezione contiene tre esempi di codice. Nel primo esempio illustra i quattro tipi di delegati che possono essere creati: rigido a un metodo di istanza, aprire tramite un metodo di istanza, aprire tramite un metodo statico e chiusa tramite un metodo statico.  
  
 Il secondo esempio di codice vengono illustrati i tipi di parametro compatibili e i tipi restituiti.  
  
 Mostra tutti i metodi che il tipo delegato possono rappresentare il terzo esempio di codice definisce un tipo di delegato unico.  
  
 **Esempio 1**  
  
 Esempio di codice seguente illustra i quattro modi un delegato può essere creato usando l'overload del <xref:System.Delegate.CreateDelegate%2A> (metodo).  
  
> [!NOTE]
>  Esistono due overload del <xref:System.Delegate.CreateDelegate%2A> metodo che specificano `firstArgument` e un <xref:System.Reflection.MethodInfo>; le relative funzionalità è uguale ad eccezione del fatto che uno consente di specificare se si desidera generare un errore di associazione e l'altra genera sempre un'eccezione. Questo esempio di codice Usa entrambi gli overload.  
  
 Nell'esempio viene dichiarata una classe `C` con un metodo statico `M2` e un metodo di istanza `M1`, e tre i tipi di delegato: `D1` accetta un'istanza di `C` e una stringa, `D2` accetta una stringa e `D3`non dispone di argomenti.  
  
 Una seconda classe denominata `Example` contiene il codice che crea i delegati.  
  
-   Un delegato del tipo `D2`, chiuso su un'istanza di `C`, viene creato per il metodo di istanza `M1`. Viene richiamato con stringhe diverse, a indicare che l'istanza associata di `C` viene sempre usato.  
  
-   Un delegato del tipo `D1`, che rappresenta un metodo di istanza aperta, viene creato per il metodo di istanza `M1`. Un'istanza deve essere passata quando viene richiamato il delegato.  
  
-   Un delegato del tipo `D2`, che rappresenta un metodo statico aperto, viene creato per il metodo statico `M2`.  
  
-   Infine, un delegato del tipo `D3`, chiuso in una stringa, viene creato per il metodo statico `M2`. Il metodo viene richiamato per mostrare che usa la stringa associata.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Esempio 2**  
  
 Esempio di codice seguente illustra la compatibilità dei tipi di parametro e i tipi restituiti.  
  
> [!NOTE]
>  Questo esempio di codice Usa il <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> overload del metodo. L'utilizzo di altri overload che accettano <xref:System.Reflection.MethodInfo> è simile.  
  
 L'esempio di codice definisce una classe base denominata `Base` e una classe denominata `Derived` che deriva da `Base`. La classe derivata ha un `static` (`Shared` in Visual Basic) metodo denominato `MyMethod` con un parametro di tipo `Base` e un tipo restituito di `Derived`. L'esempio di codice definisce anche un delegato denominato `Example` che ha un parametro di tipo `Derived` e un tipo restituito di `Base`.  
  
 L'esempio di codice viene illustrato che il delegato denominato `Example` può essere utilizzato per rappresentare il metodo `MyMethod`. Il metodo può essere associato al delegato perché:  
  
-   Il tipo di parametro del delegato (`Derived`) è più restrittivo rispetto al tipo di parametro del `MyMethod` (`Base`), in modo che sia sempre possibile passare l'argomento del delegato da `MyMethod`.  
  
-   Il tipo restituito del `MyMethod` (`Derived`) è più restrittivo rispetto al tipo di parametro del delegato (`Base`), in modo che sia sempre possibile eseguire il cast di tipo restituito del metodo per il tipo restituito del delegato.  
  
 L'esempio di codice non genera alcun output.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Esempio 3**  
  
 Esempio di codice seguente illustra tutti i metodi che può rappresentare un singolo tipo delegato.  
  
> [!NOTE]
>  Esistono due overload del <xref:System.Delegate.CreateDelegate%2A> metodo che specificano `firstArgument` e un <xref:System.Reflection.MethodInfo>; le relative funzionalità è uguale ad eccezione del fatto che uno consente di specificare se si desidera generare un errore di associazione e l'altra genera sempre un'eccezione. Questo esempio di codice Usa entrambi gli overload.  
  
 L'esempio di codice definisce due classi `C` e `F`e un tipo delegato `D` con un solo argomento di tipo `C`. Le classi corrispondenti statici e metodi di istanza `M1`, `M3`, e `M4`e la classe `C` include inoltre un metodo di istanza `M2` che non dispone di argomenti.  
  
 Una terza classe denominata `Example` contiene il codice che crea i delegati.  
  
-   I delegati vengono creati il metodo, ad esempio `M1` di tipo `C` e il tipo `F`; ognuna viene chiuso su un'istanza del rispettivo tipo. Metodo `M1` typu `C` consente di visualizzare il `ID` le proprietà dell'istanza associata e dell'argomento.  
  
-   Viene creato un delegato per il metodo `M2` di tipo `C`. Si tratta di un delegato di istanza aperta, in cui l'argomento del delegato rappresenta il primo argomento nascosto sul metodo di istanza. Il metodo non dispone di altri argomenti.  
  
-   I delegati vengono creati per il metodo statico `M3` typu `C` e il tipo `F`; questi sono aperti i delegati statici.  
  
-   Infine, i delegati vengono creati per il metodo statico `M4` typu `C` e il tipo `F`; ogni metodo presenta il tipo dichiarante come primo argomento e viene fornita un'istanza del tipo, in modo che i delegati vengono chiusi relativi primi argomenti . Metodo `M4` typu `C` consente di visualizzare il `ID` le proprietà dell'istanza associata e dell'argomento.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> cannot be bound, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The class instance on which <c>method</c> is invoked.</param>
        <param name="method">The name of the instance method that the delegate is to represent.</param>
        <param name="ignoreCase">A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
        <summary>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance with the specified case-sensitivity.</summary>
        <returns>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea i delegati, ad esempio solo i metodi. Un metodo di istanza è un metodo che è associato a un'istanza di una classe. un metodo statico è un metodo che è associato alla classe stessa.  
  
 Questo overload del metodo è equivalente alla chiamata di <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> overload del metodo, specificando `true` per `throwOnBindFailure`.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a metodi non pubblici se il chiamante sia stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di concessioni dei metodi non pubblici è limitato al chiamante concedere set, oppure un subset della stessa. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> is not an instance method.  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The <see cref="T:System.Type" /> representing the class that implements <c>method</c>.</param>
        <param name="method">The name of the static method that the delegate is to represent.</param>
        <param name="ignoreCase">A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
        <summary>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity.</summary>
        <returns>A delegate of the specified type that represents the specified static method of the specified class.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea i delegati per solo i metodi statici. Un metodo di istanza è un metodo che è associato a un'istanza di una classe. un metodo statico è un metodo che è associato alla classe stessa.  
  
 Questo overload del metodo è equivalente alla chiamata di <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> overload del metodo, specificando `true` per `throwOnBindFailure`.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a metodi non pubblici se il chiamante sia stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di concessioni dei metodi non pubblici è limitato al chiamante concedere set, oppure un subset della stessa. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="target" /> is not a <see langword="RuntimeType" />.  -or-  <paramref name="target" /> is an open generic type. That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The class instance on which <c>method</c> is invoked.</param>
        <param name="method">The name of the instance method that the delegate is to represent.</param>
        <param name="ignoreCase">A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</param>
        <summary>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance, with the specified case-sensitivity and the specified behavior on failure to bind.</summary>
        <returns>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea i delegati, ad esempio solo i metodi. Un metodo di istanza è un metodo che è associato a un'istanza di una classe. un metodo statico è un metodo che è associato alla classe stessa.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a metodi non pubblici se il chiamante sia stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di concessioni dei metodi non pubblici è limitato al chiamante concedere set, oppure un subset della stessa. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> is not an instance method.  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The <see cref="T:System.Type" /> representing the class that implements <c>method</c>.</param>
        <param name="method">The name of the static method that the delegate is to represent.</param>
        <param name="ignoreCase">A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</param>
        <summary>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity and the specified behavior on failure to bind.</summary>
        <returns>A delegate of the specified type that represents the specified static method of the specified class.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo crea i delegati per solo i metodi statici. Un metodo di istanza è un metodo che è associato a un'istanza di una classe. un metodo statico è un metodo che è associato alla classe stessa.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a metodi non pubblici se il chiamante sia stata concessa <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di concessioni dei metodi non pubblici è limitato al chiamante concedere set, oppure un subset della stessa. (Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="target" /> is not a <see langword="RuntimeType" />.  -or-  <paramref name="target" /> is an open generic type. That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">An array of objects that are the arguments to pass to the method represented by the current delegate.  -or-  <see langword="null" />, if the method represented by the current delegate does not require arguments.</param>
        <summary>Dynamically invokes (late-bound) the method represented by the current delegate.</summary>
        <returns>The object returned by the method represented by the delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo chiama il metodo <xref:System.Delegate.DynamicInvokeImpl%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).  -or-  The number, order, or type of parameters listed in <paramref name="args" /> is invalid.</exception>
        <exception cref="T:System.ArgumentException">The method represented by the delegate is invoked on an object or a class that does not support it.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">The method represented by the delegate is an instance method and the target object is <see langword="null" />.  -or-  One of the encapsulated methods throws an exception.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">An array of objects that are the arguments to pass to the method represented by the current delegate.  -or-  <see langword="null" />, if the method represented by the current delegate does not require arguments.</param>
        <summary>Dynamically invokes (late-bound) the method represented by the current delegate.</summary>
        <returns>The object returned by the method represented by the delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo implementa il metodo <xref:System.Delegate.DynamicInvoke%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).  -or-  The number, order, or type of parameters listed in <paramref name="args" /> is invalid.</exception>
        <exception cref="T:System.ArgumentException">The method represented by the delegate is invoked on an object or a class that does not support it.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">The method represented by the delegate is an instance method and the target object is <see langword="null" />.  -or-  One of the encapsulated methods throws an exception.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The object to compare with the current delegate.</param>
        <summary>Determines whether the specified object and the current delegate are of the same type and share the same targets, methods, and invocation list.</summary>
        <returns>
          <see langword="true" /> if <paramref name="obj" /> and the current delegate have the same targets, methods, and invocation list; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se i due delegati non sono dello stesso tipo, non sono considerati uguali.  
  
> [!IMPORTANT]
>  In .NET Framework versioni 1.0 e 1.1, due delegati sono stati considerati uguali se le destinazioni, metodi ed elenco di chiamate, anche se sono stati i delegati di tipo diverso.  
  
 I metodi e le destinazioni vengono confrontate per verificarne l'uguaglianza come indicato di seguito:  
  
-   Se i due metodi da confrontare sono statici e non il metodo di stesso nella stessa classe, i metodi sono considerati uguali e anche le destinazioni sono considerate uguali.  
  
-   Se i due metodi da confrontare sono metodi di istanza e lo stesso metodo di stesso oggetto, i metodi sono considerati uguali e anche le destinazioni sono considerate uguali.  
  
-   In caso contrario, i metodi non sono considerati uguali e le destinazioni sono inoltre non considerate uguali.  
  
 Due elenchi chiamate verranno considerati identici solo se hanno lo stesso ordine e gli elementi corrispondenti dagli elenchi di due rappresentano il metodo di stesso e destinazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a hash code for the delegate.</summary>
        <returns>A hash code for the delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito di questo metodo non deve essere persistente per due motivi. In primo luogo, la funzione hash di una classe può essere modificata per generare una migliore distribuzione, il rendering di tutti i valori da funzione hash precedente diventa inutilizzabile. In secondo luogo, l'implementazione predefinita di questa classe non garantisce che lo stesso valore verrà restituito da istanze diverse.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the invocation list of the delegate.</summary>
        <returns>An array of delegates representing the invocation list of the current delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni delegato nella matrice rappresenta esattamente un metodo.  
  
 L'ordine dei delegati nella matrice è lo stesso ordine in cui il delegato corrente richiama i metodi che rappresentano i delegati.  
  
   
  
## Examples  
 L'esempio seguente assegna tre metodi a un delegato. Chiama quindi il <xref:System.Delegate.GetInvocationList%2A> metodo per ottenere un conteggio totale dei metodi assegnato al delegato, eseguire i delegati in ordine inverso di esecuzione dei metodi il cui nome non includono la sottostringa "File".  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the static method represented by the current delegate.</summary>
        <returns>A <see cref="T:System.Reflection.MethodInfo" /> describing the static method represented by the current delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo si applica solo se il delegato corrente rappresenta un metodo statico.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Not supported.</param>
        <param name="context">Not supported.</param>
        <summary>Not supported.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">This method is not supported.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the method represented by the delegate.</summary>
        <value>Oggetto <see cref="T:System.Reflection.MethodInfo" /> che descrive il metodo rappresentato dal delegato.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">The first delegate to compare.</param>
        <param name="d2">The second delegate to compare.</param>
        <summary>Determines whether the specified delegates are equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="d1" /> is equal to <paramref name="d2" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Due delegati dello stesso tipo con le stesse destinazioni, metodi e degli elenchi chiamate sono considerati uguali.  
  
 Se i due delegati non sono dello stesso tipo, non sono considerati uguali.  
  
> [!IMPORTANT]
>  In .NET Framework versioni 1.0 e 1.1, due delegati sono stati considerati uguali se le destinazioni, metodi ed elenco di chiamate, anche se sono stati i delegati di tipo diverso.  
  
 I metodi e le destinazioni vengono confrontate per verificarne l'uguaglianza come indicato di seguito:  
  
-   Se i due metodi da confrontare sono statici e non il metodo di stesso nella stessa classe, i metodi sono considerati uguali e anche le destinazioni sono considerate uguali.  
  
-   Se i due metodi da confrontare sono metodi di istanza e lo stesso metodo di stesso oggetto, i metodi sono considerati uguali e anche le destinazioni sono considerate uguali.  
  
-   In caso contrario, i metodi non sono considerati uguali e le destinazioni sono inoltre non considerate uguali.  
  
 Due elenchi chiamate verranno considerati identici se hanno lo stesso ordine e gli elementi corrispondenti dagli elenchi di due rappresentano il metodo di stesso e destinazione.  
  
 È il metodo equivalente per l'operatore <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">The first delegate to compare.</param>
        <param name="d2">The second delegate to compare.</param>
        <summary>Determines whether the specified delegates are not equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="d1" /> is not equal to <paramref name="d2" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Due delegati non sono uguali se sono di tipi diversi, oppure dispone di diversi metodi, destinazioni diverse o diversi elenchi chiamate.  
  
 Se i due delegati non sono dello stesso tipo, non sono considerati uguali.  
  
> [!IMPORTANT]
>  In .NET Framework versioni 1.0 e 1.1, due delegati vengono considerati uguali se le destinazioni, metodi ed elenco di chiamate, anche se sono stati i delegati di tipo diverso.  
  
 I metodi e le destinazioni vengono confrontate per verificarne l'uguaglianza come indicato di seguito:  
  
-   Se i due metodi da confrontare sono statici e non il metodo di stesso nella stessa classe, i metodi sono considerati uguali e anche le destinazioni sono considerate uguali.  
  
-   Se i due metodi da confrontare sono metodi di istanza e lo stesso metodo di stesso oggetto, i metodi sono considerati uguali e anche le destinazioni sono considerate uguali.  
  
-   In caso contrario, i metodi non sono considerati uguali e le destinazioni sono inoltre non considerate uguali.  
  
 Due elenchi chiamate non sono uguali se hanno dimensioni diverse, se sono ordinati in modo diverso, o se almeno un elemento da un elenco rappresenta un metodo o destinazione che è diverso da quello rappresentato dall'elemento corrispondente in altro elenco.  
  
 È il metodo equivalente per l'operatore <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">The delegate from which to remove the invocation list of <c>value</c>.</param>
        <param name="value">The delegate that supplies the invocation list to remove from the invocation list of <c>source</c>.</param>
        <summary>Removes the last occurrence of the invocation list of a delegate from the invocation list of another delegate.</summary>
        <returns>A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing the last occurrence of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />. Returns <paramref name="source" /> if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />. Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" /> or if <paramref name="source" /> is a null reference.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'elenco chiamate di `value` corrisponde a un set di elementi nell'elenco chiamate di contiguo `source`, quindi l'elenco chiamate di `value` ha luogo all'interno dell'elenco chiamate di `source`. Se l'elenco chiamate di `value` si verifica più volte nell'elenco chiamate di `source`, viene rimossa l'ultima occorrenza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <exception cref="T:System.ArgumentException">The delegate types do not match.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">The delegate from which to remove the invocation list of <c>value</c>.</param>
        <param name="value">The delegate that supplies the invocation list to remove from the invocation list of <c>source</c>.</param>
        <summary>Removes all occurrences of the invocation list of a delegate from the invocation list of another delegate.</summary>
        <returns>A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing all occurrences of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />. Returns <paramref name="source" /> if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />. Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" />, if <paramref name="source" /> contains only a series of invocation lists that are equal to the invocation list of <paramref name="value" />, or if <paramref name="source" /> is a null reference.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'elenco chiamate di `value` corrisponde a un set di elementi nell'elenco chiamate di contiguo `source`, quindi l'elenco chiamate di `value` ha luogo all'interno dell'elenco chiamate di `source`. Se l'elenco chiamate di `value` si verifica più volte nell'elenco chiamate di `source`, vengono rimosse tutte le occorrenze.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <exception cref="T:System.ArgumentException">The delegate types do not match.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">The delegate that supplies the invocation list to remove from the invocation list of the current delegate.</param>
        <summary>Removes the invocation list of a delegate from the invocation list of another delegate.</summary>
        <returns>A new delegate with an invocation list formed by taking the invocation list of the current delegate and removing the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the current delegate's invocation list. Returns the current delegate if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the current delegate's invocation list. Returns <see langword="null" /> if the invocation list of <paramref name="value" /> is equal to the current delegate's invocation list.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'elenco chiamate di `value` corrisponde a un insieme di elementi nell'elenco chiamate del delegato corrente, quindi l'elenco chiamate di `value` ha luogo all'interno di elenco chiamate del delegato corrente. Se l'elenco chiamate di `value` presente più volte nell'elenco chiamate del delegato corrente, viene rimossa l'ultima occorrenza.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the class instance on which the current delegate invokes the instance method.</summary>
        <value>L'oggetto in cui il delegato corrente richiama il metodo di istanza, se il delegato rappresenta un metodo di istanza. <see langword="null" /> se il delegato rappresenta un metodo statico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un metodo di istanza è un metodo che è associato a un'istanza di una classe. un metodo statico è un metodo che è associato alla classe stessa.  
  
 Se uno o più metodi di istanza viene richiamato il delegato, questa proprietà restituisce la destinazione di quest'ultimo metodo di istanza nell'elenco chiamate.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Quando viene richiamato con associazione tardiva mediante meccanismi come <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>