<Type Name="Lazy&lt;T&gt;" FullName="System.Lazy&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ad53c03faf661b5a698d5ef0c4fcd9d0451bbc14" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30729865" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Lazy&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Lazy`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Lazy`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Lazy(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Lazy" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.System_LazyDebugView`1))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Tipo di oggetto che viene inizializzato in modo differito.</typeparam>
    <summary>Fornisce il supporto per l'inizializzazione differita.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare l'inizializzazione differita per rinviare la creazione di un oggetto di grandi dimensioni o risorse o l'esecuzione di un'attività a elevato utilizzo di risorse, in particolare quando tale creazione o esecuzione potrebbe non verificarsi durante la durata del programma.  
  
 Per preparare per l'inizializzazione differita, si crea un'istanza di <xref:System.Lazy%601>. L'argomento del tipo di <xref:System.Lazy%601> che l'oggetto creato specifica il tipo di oggetto che si desidera inizializzare in modo differito. Il costruttore che consente di creare il <xref:System.Lazy%601> oggetto determina le caratteristiche dell'inizializzazione. L'inizializzazione differita viene eseguita la prima volta che si accede alla proprietà <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType>.  
  
 Nella maggior parte dei casi, la scelta di un costruttore dipende le risposte alle due domande:  
  
-   Verrà eseguito l'oggetto inizializzato in modo differito da più thread? In questo caso, il <xref:System.Lazy%601> oggetto potrebbe creare in qualsiasi thread. È possibile utilizzare uno dei costruttori semplici il cui comportamento predefinito consiste nel creare un thread-safe <xref:System.Lazy%601> dell'oggetto, quindi viene creata solo un'istanza dell'oggetto in modo differito creata un'istanza indipendentemente dal numero di thread tenta di accedervi. Per creare un <xref:System.Lazy%601> oggetto che non è thread-safe, è necessario utilizzare un costruttore che consente di non specificare di thread-safe.  
  
    > [!CAUTION]
    >  Effettua il <xref:System.Lazy%601> affidabile oggetto non consente di proteggere l'oggetto con inizializzazione differita. Se più thread può accedere all'oggetto con inizializzazione differita, è necessario apportare le proprietà e metodi sicuri per l'accesso multithreading.  
  
-   L'inizializzazione differita richiede una grande quantità di codice o l'oggetto con inizializzazione differita privo di un costruttore predefinito che esegue tutti gli elementi necessari e non genera eccezioni? Se è necessario scrivere codice di inizializzazione o se le eccezioni devono essere gestite, utilizzare uno dei costruttori che accettano un metodo factory. Scrivere il codice di inizializzazione nel metodo factory.  
  
 La tabella seguente illustra il costruttore di scegliere, in base a questi due fattori:  
  
|Oggetto accederanno|Se è richiesto alcun codice di inizializzazione (costruttore predefinito), usare|Se il codice di inizializzazione è necessario, utilizzare|  
|--------------------------------|------------------------------------------------------------------------|---------------------------------------------|  
|Più thread|<xref:System.Lazy%601.%23ctor>|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>|  
|Un thread|<xref:System.Lazy%601.%23ctor%28System.Boolean%29> con `isThreadSafe` impostato su `false`.|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> con `isThreadSafe` impostato su `false`.|  
  
 È possibile utilizzare un'espressione lambda per specificare il metodo factory. In questo modo tutto il codice di inizializzazione in un'unica posizione. L'espressione lambda acquisisce il contesto, inclusi gli eventuali argomenti passati al costruttore dell'oggetto con inizializzazione differita.  
  
 **La memorizzazione nella cache di eccezione** quando si utilizzano metodi factory, le eccezioni vengono memorizzati nella cache. Ovvero, se il metodo factory genera un'ora la prima eccezione un thread tenta di accedere il <xref:System.Lazy%601.Value%2A> proprietà del <xref:System.Lazy%601> dell'oggetto, la stessa eccezione viene generata a ogni tentativo successivo. Ciò garantisce che ogni chiamata al <xref:System.Lazy%601.Value%2A> proprietà produce lo stesso risultato, evitando errori difficili da rilevare che potrebbero verificarsi se diversi thread ottengano risultati diversi. Il <xref:System.Lazy%601> sostituisce una vera e propria `T` che in caso contrario sarebbe sono stati inizializzati in precedenza, in genere durante l'avvio. È in genere irreversibile un errore al momento precedente. Se è presente un potenziale di un errore reversibile, è consigliabile compilare la logica di riesecuzione in routine di inizializzazione (in questo caso, il metodo factory), così come accadrebbe se non è stato utilizzato l'inizializzazione differita.  
  
 **In alternativa al blocco** In alcuni casi, si potrebbe voler evitare il sovraccarico dovuto il <xref:System.Lazy%601> dell'oggetto predefinito di comportamento di blocco. In rari casi, potrebbe esserci un rischio di deadlock. In questi casi, è possibile utilizzare il <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> o <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> costruttore e specificare <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. In questo modo il <xref:System.Lazy%601> oggetto per creare una copia dell'oggetto con inizializzazione differita in ognuno dei diversi thread se il thread chiama il <xref:System.Lazy%601.Value%2A> proprietà contemporaneamente. Il <xref:System.Lazy%601> oggetto assicura che tutti i thread di utilizzare la stessa istanza dell'oggetto inizializzato in modalità differita ed Elimina le istanze che non vengono utilizzate. Pertanto, il costo di ridurre l'overhead dei blocchi è che il programma potrebbe talvolta creare e rimuovere le copie aggiuntive di un oggetto dispendioso. Nella maggior parte dei casi, è improbabile che ciò. Gli esempi per il <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> e <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> costruttori illustrano questo comportamento.  
  
> [!IMPORTANT]
>  Quando si specifica <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, le eccezioni non vengono mai memorizzati nella cache, anche se si specifica un metodo factory.  
  
 **Costruttori equivalenti** oltre a consentire l'utilizzo di <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> e <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> costruttori possono duplicare la funzionalità degli altri costruttori. Nella tabella seguente vengono illustrati i valori di parametro che producono un comportamento equivalente.  
  
|Per creare un <xref:System.Lazy%601> oggetto|Per i costruttori che hanno un `LazyThreadSafetyMode` `mode` parametro, impostare `mode` per|Per i costruttori che dispongono di un valore booleano `isThreadSafe` parametro, impostare `isThreadSafe` per|Per i costruttori senza parametri di thread safety|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|-------------------------------------------------------|  
|Completamente thread-safe. utilizza il blocco per garantire che un solo thread Inizializza il valore.|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|Tutti questi costruttori sono completamente thread-safe.|  
|Non i thread-safe.|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|Non applicabile.|  
|Completamente thread-safe. i thread concorrono per inizializzare il valore.|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|Non applicabile.|Non applicabile.|  
  
 **Altre funzionalità** per informazioni sull'utilizzo di <xref:System.Lazy%601> con i campi statici thread o come archivio di backup per le proprietà, vedere [l'inizializzazione differita](~/docs/framework/performance/lazy-initialization.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.Lazy%601> classe per fornire l'inizializzazione differita, con accesso da più thread.  
  
> [!NOTE]
>  Nell'esempio viene utilizzato il <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> costruttore. Viene inoltre illustrato l'utilizzo del <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> costruttore (specificando `true` per `isThreadSafe`) e <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> costruttore (specificando <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> per `mode`). Per passare a un costruttore diverso, è sufficiente modificare costruttori sono impostate come commento.  
>   
>  Per un esempio che illustra l'eccezione di memorizzazione nella cache utilizzando il costruttore stesso, vedere il <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> costruttore.  
  
 Nell'esempio viene definita una classe `LargeObject` che verrà inizializzata in modo differito da uno dei diversi thread. Le quattro sezioni principali del codice vengono illustrate la creazione di inizializzatore, il metodo factory, effettiva inizializzazione e il costruttore del `LargeObject` (classe), che visualizza un messaggio quando viene creato l'oggetto. All'inizio del metodo `Main`, viene creato un inizializzatore thread-safe differito per `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#newlazy)]  
  
 Il metodo factory illustra la creazione dell'oggetto, con un segnaposto per un'ulteriore inizializzazione:  
  
 [!code-csharp[System.Lazy\`1#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#factoryfunc)]  
  
 Si noti che le sezioni di codice primi due possono essere combinate tramite una funzione lambda, come illustrato di seguito:  
  
 [!code-csharp[System.Lazy\`1#InitWithLambda](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/lambda.cs#initwithlambda)]
 [!code-vb[System.Lazy\`1#InitWithLambda](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/lambda.vb#initwithlambda)]  
  
 Nell'esempio viene sospeso, per indicare che un periodo di tempo indeterminato potrebbe trascorrere prima che venga eseguita l'inizializzazione differita. Quando si preme il **invio** chiave, l'esempio crea e avvia tre thread. Il `ThreadProc` metodo utilizzato da tutte le chiamate tre thread di <xref:System.Lazy%601.Value%2A> proprietà. La prima volta in questo caso, il `LargeObject` viene creata l'istanza:  
  
 [!code-csharp[System.Lazy\`1#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#valueprop)]  
  
 Il costruttore del `LargeObject` (classe), che include l'ultima chiave sezione di codice, viene visualizzato un messaggio e registra l'identità del thread durante l'inizializzazione. L'output del programma viene visualizzato alla fine del listato di codice completo.  
  
 [!code-csharp[System.Lazy\`1#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#largector)]  
  
> [!NOTE]
>  Per semplicità, in questo esempio viene utilizzata un'istanza globale di <xref:System.Lazy%601> e tutti i metodi sono `static` (`Shared` in Visual Basic). Questi non sono requisiti per l'uso di inizializzazione differita.  
  
 [!code-csharp[System.Lazy\`1#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#all)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Per impostazione predefinita, tutti i membri pubblici e protetti della <see cref="T:System.Lazy`1" /> classe sono thread-safe e possono essere utilizzati contemporaneamente da più thread. Facoltativamente e per ogni istanza, utilizzando i parametri nei costruttori del tipo, è possibile rimuovere le garanzie di thread safety.</threadsafe>
    <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Lazy`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Lazy`1" />. Quando si verifica l'inizializzazione differita, viene usato il costruttore predefinito del tipo di destinazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'istanza che viene creata con questo costruttore può essere utilizzata contemporaneamente da più thread.  
  
 La modalità thread safety di un <xref:System.Lazy%601> istanza che viene inizializzato con questo costruttore è <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. La modalità thread safety viene descritto il comportamento quando più thread tentano di inizializzare il <xref:System.Lazy%601> istanza.  
  
 Oggetto <xref:System.Lazy%601> istanza che viene creato con questo costruttore non memorizzato nella cache di eccezioni. Per ulteriori informazioni, vedere la classe <xref:System.Lazy%601> o l'enumerazione <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del costruttore. Viene inoltre illustrato l'utilizzo del <xref:System.Lazy%601.%23ctor%28System.Boolean%29> costruttore (specificando `true` per `isThreadSafe`) e <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> costruttore (specificando <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> per `mode`). Per passare a un costruttore diverso, è sufficiente modificare costruttori sono impostate come commento.  
  
 Nell'esempio viene definita una classe `LargeObject` che verrà inizializzata in modo differito da uno dei diversi thread. Le due chiavi righe di codice in questo esempio sono la creazione di inizializzatore e l'inizializzazione effettivo. All'inizio del metodo `Main`, viene creato un inizializzatore thread-safe differito per `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#newlazy)]  
  
 L'esempio crea e avvia tre thread che bloccano su un <xref:System.Threading.ManualResetEvent> dell'oggetto, in modo che l'esempio è possibile rilasciare i thread in una sola volta. Il `ThreadProc` metodo utilizzato da tutte le chiamate tre thread di <xref:System.Lazy%601.Value%2A> proprietà da ottenere il `LargeObject` istanza:  
  
 [!code-csharp[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#valueprop)]  
  
 Il <xref:System.Lazy%601> classe fornisce il blocco, in modo che è consentito un solo thread per creare il `LargeObject` istanza. Nell'esempio viene illustrato che il thread tutti ottengano la stessa istanza.  
  
> [!NOTE]
>  Per semplicità, in questo esempio viene utilizzata un'istanza globale di <xref:System.Lazy%601> e tutti i metodi sono `static` (`Shared` in Visual Basic). Questi non sono requisiti per l'uso di inizializzazione differita.  
  
 [!code-csharp[System.Lazy\`1.ctor#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctor#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(bool isThreadSafe);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isThreadSafe">
          <see langword="true" /> per far sì che l'istanza sia utilizzabile contemporaneamente da più thread; <see langword="false" /> per far sì che l'istanza sia utilizzabile da un solo thread alla volta.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Lazy`1" />. Quando si verifica l'inizializzazione differita, vengono usati il costruttore predefinito del tipo di destinazione e la modalità di inizializzazione specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La modalità thread safety di un <xref:System.Lazy%601> istanza che viene inizializzato con questo costruttore è <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> se `isThreadSafe` è `true`; in caso contrario, la modalità è <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. La modalità thread safety viene descritto il comportamento quando più thread tentano di inizializzare il <xref:System.Lazy%601> istanza. Per specificare il <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> modalità, utilizzare il <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> o <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> costruttore.  
  
 Oggetto <xref:System.Lazy%601> istanza che viene creato con questo costruttore non memorizzato nella cache di eccezioni. Per ulteriori informazioni, vedere la classe <xref:System.Lazy%601> o l'enumerazione <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questo costruttore per creare un inizializzatore lazy che non è thread-safe, per gli scenari in cui si verifica ogni accesso all'oggetto con inizializzazione differita sullo stesso thread. Viene inoltre illustrato l'utilizzo del <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> costruttore (specificando <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> per `mode`. Per passare a un costruttore diverso, è sufficiente modificare il costruttore viene impostata come commento.  
  
> [!NOTE]
>  Per il codice viene illustrato come utilizzare questo costruttore negli scenari multithreading (specificando `true` per `isThreadSafe`), vedere l'esempio per il <xref:System.Lazy%601.%23ctor> costruttore.  
  
 Nell'esempio viene definito un `LargeObject` classe che verrà inizializzata in modo differito. Nel `Main` (metodo), nell'esempio viene creato un <xref:System.Lazy%601> istanza e quindi si verifica una sospensione. Quando si preme il **invio** chiave, nell'esempio si accede di <xref:System.Lazy%601.Value%2A> proprietà del <xref:System.Lazy%601> istanza, che provoca l'inizializzazione di. Il costruttore del `LargeObject` classe viene visualizzato un messaggio di console.  
  
> [!NOTE]
>  Per semplicità, in questo esempio viene utilizzata un'istanza globale di <xref:System.Lazy%601> e tutti i metodi sono `static` (`Shared` in Visual Basic). Questi non sono requisiti per l'uso di inizializzazione differita.  
  
 [!code-csharp[System.Lazy\`1.ctorBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Delegato richiamato per produrre il valore inizializzato in modalità differita quando è necessario.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Lazy`1" />. Quando si verifica l'inizializzazione differita, viene usata la funzione specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'istanza che viene creata con questo costruttore può essere utilizzata contemporaneamente da più thread.  
  
 La modalità thread safety di un <xref:System.Lazy%601> istanza che viene inizializzato con questo costruttore è <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. La modalità thread safety viene descritto il comportamento quando più thread tentano di inizializzare il <xref:System.Lazy%601> istanza.  
  
 Le eccezioni generate da `valueFactory` vengono memorizzati nella cache. Per ulteriori informazioni, vedere la classe <xref:System.Lazy%601> o l'enumerazione <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questo costruttore per fornire l'inizializzazione differita, con la memorizzazione nella cache di eccezione. Viene inoltre illustrato l'utilizzo del <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> costruttore (specificando `true` per `isThreadSafe`) e <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> costruttore (specificando <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> per `mode`). Per passare a un costruttore diverso, è sufficiente modificare costruttori sono impostate come commento.  
  
 Nell'esempio viene definita una classe `LargeObject` che verrà inizializzata in modo differito da uno dei diversi thread. Le tre sezioni principali del codice vengono illustrate la creazione di inizializzatore effettiva inizializzazione e il costruttore del `LargeObject` (classe), che illustra la memorizzazione nella cache di eccezione. All'inizio del metodo `Main`, viene creato un inizializzatore thread-safe differito per `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#newlazy)]  
  
 L'esempio crea e avvia tre thread. Il `ThreadProc` metodo utilizzato da tutte le chiamate tre thread di <xref:System.Lazy%601.Value%2A> proprietà da ottenere il `LargeObject` istanza:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#valueprop)]  
  
 Nel costruttore del `LargeObject` (classe), la terza sezione chiave del codice genera un'eccezione la prima volta un `LargeObject` viene creata l'istanza, ma successivamente consente la creazione di istanze di:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#largector)]  
  
 Quando si esegue l'esempio, il primo thread che tenta di creare un'istanza di `LargeObject` ha esito negativo e l'eccezione viene intercettata. Si potrebbe pensare che il thread successivo deve creare correttamente un'istanza, ma la <xref:System.Lazy%601> oggetto ha memorizzato nella cache l'eccezione. Per questo motivo, tutti i thread generata un'eccezione.  
  
> [!NOTE]
>  Per semplicità, in questo esempio viene utilizzata un'istanza globale di <xref:System.Lazy%601> e tutti i metodi sono `static` (`Shared` in Visual Basic). Questi non sono requisiti per l'uso di inizializzazione differita.  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFunc#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="valueFactory" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(System::Threading::LazyThreadSafetyMode mode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="mode">Uno dei valori di enumerazione che specifica la modalità thread safety.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Lazy`1" /> che utilizza il costruttore predefinito di <paramref name="T" /> e la modalità di thread safety specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La modalità thread safety di un <xref:System.Lazy%601> istanza viene descritto il comportamento quando più thread tentano di inizializzare il <xref:System.Lazy%601> istanza.  
  
 Oggetto <xref:System.Lazy%601> istanza che viene creato con questo costruttore non memorizzato nella cache di eccezioni. Per ulteriori informazioni, vedere la classe <xref:System.Lazy%601> o l'enumerazione <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questo costruttore per creare un inizializzatore lazy che consente a più thread per situazioni di race per creare un oggetto in modo differito. Più thread riesca nella creazione di istanze, ma l'istanza è stata creata prima di utilizzare tutti i thread.  
  
> [!NOTE]
>  Per un esempio che illustra come utilizzare questo costruttore in scenari a thread singolo (specificando <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> per `mode`), vedere il <xref:System.Lazy%601.%23ctor%28System.Boolean%29> costruttore. Per un esempio che illustra come utilizzare questo costruttore per fornire il blocco anziché race condition in scenari con multithreading (specificando <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> per `mode`), vedere il <xref:System.Lazy%601.%23ctor> costruttore.  
  
 Nell'esempio viene definito un `LargeObject` classe che verrà inizializzata in modo differito da uno dei diversi thread. Le tre sezioni principali del codice vengono illustrate la creazione di inizializzatore di, l'effettiva inizializzazione e il costruttore e il finalizzatore della `LargeObject` classe. All'inizio del `Main` (metodo), nell'esempio viene creata la <xref:System.Lazy%601> oggetto che esegue l'inizializzazione differita del `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#newlazy)]  
  
 L'esempio crea e avvia tre thread che bloccano su un <xref:System.Threading.ManualResetEvent> dell'oggetto, in modo che l'esempio è possibile rilasciare i thread in una sola volta. Nel `ThreadProc` metodo utilizzato da tutti i thread, la chiamata di <xref:System.Lazy%601.Value%2A> proprietà crea la `LargeObject` istanza:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#valueprop)]  
  
 Poiché il costruttore per il <xref:System.Lazy%601> istanza specificata <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, tutti i thread sono autorizzati a creare `LargeObject` istanze. Nell'esempio viene illustrato questo visualizzando i messaggi della console nel costruttore e nel finalizzatore del `LargeObject` classe:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#ctorfinalizer)]  
  
 Tuttavia, il <xref:System.Lazy%601> oggetto garantisce che solo un'istanza viene utilizzata da tutti i thread. L'output dell'esempio mostra che tutti i thread utilizzano la stessa istanza e mostra inoltre che le due istanze possono essere recuperate tramite garbage collection.  
  
> [!NOTE]
>  Per semplicità, in questo esempio viene utilizzata un'istanza globale di <xref:System.Lazy%601> e tutti i metodi sono `static` (`Shared` in Visual Basic). Questi non sono requisiti per l'uso di inizializzazione differita.  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contiene un valore non valido.</exception>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(T value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, bool isThreadSafe);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Delegato richiamato per produrre il valore inizializzato in modalità differita quando è necessario.</param>
        <param name="isThreadSafe">
          <see langword="true" /> per far sì che l'istanza sia utilizzabile contemporaneamente da più thread; <see langword="false" /> per far sì che l'istanza sia utilizzabile da un solo thread alla volta.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Lazy`1" />. Quando si verifica l'inizializzazione differita, vengono usate la funzione e la modalità di inizializzazione specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La modalità thread safety di un <xref:System.Lazy%601> istanza che viene inizializzato con questo costruttore è <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> se `isThreadSafe` è `true`; in caso contrario, la modalità è <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. La modalità thread safety viene descritto il comportamento quando più thread tentano di inizializzare il <xref:System.Lazy%601> istanza.  
  
 Per specificare il <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> modalità, utilizzare il <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> o <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> costruttore.  
  
 Le eccezioni generate da `valueFactory` vengono memorizzati nella cache. Per ulteriori informazioni, vedere la classe <xref:System.Lazy%601> o l'enumerazione <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questo costruttore per fornire l'inizializzazione differita, tranne la memorizzazione nella cache, in uno scenario con un singolo thread. Viene inoltre illustrato l'utilizzo del <xref:System.Lazy%601.%23ctor%2A> costruttore (specificando <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> per `mode`). Per passare al costruttore, è sufficiente modificare il costruttore viene impostata come commento.  
  
> [!NOTE]
>  Per il codice viene illustrato come utilizzare questo costruttore negli scenari multithreading (specificando `true` per `isThreadSafe`), vedere l'esempio per il <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> costruttore.  
  
 Nell'esempio viene definita una classe `LargeObject` che verrà inizializzata in modo differito da uno dei diversi thread. Le tre sezioni principali del codice vengono illustrate la creazione di inizializzatore effettiva inizializzazione e il costruttore del `LargeObject` (classe), che illustra la memorizzazione nella cache di eccezione. All'inizio del metodo `Main`, viene creato un inizializzatore thread-safe differito per `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#newlazy)]  
  
 Nella chiamata al costruttore, il `isThreadSafe` parametro `false`, pertanto il <xref:System.Lazy%601> non è thread-safe. Perché non è thread-safe, nell'esempio viene chiamato il <xref:System.Lazy%601.Value%2A> proprietà tre volte sullo stesso thread:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#valueprop)]  
  
 Nel costruttore del `LargeObject` (classe), la terza sezione chiave del codice genera un'eccezione la prima volta un `LargeObject` viene creata l'istanza, ma successivamente consente la creazione di istanze di:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#largector)]  
  
 Quando si esegue l'esempio, il primo tentativo di creare un'istanza di `LargeObject` ha esito negativo e l'eccezione viene intercettata. Si potrebbe pensare che al successivo tentativo di esito positivo, ma la <xref:System.Lazy%601> oggetto ha memorizzato nella cache l'eccezione. Per questo motivo, tutti i tentativi generata un'eccezione.  
  
> [!NOTE]
>  Per semplicità, in questo esempio viene utilizzata un'istanza globale di <xref:System.Lazy%601> e tutti i metodi sono `static` (`Shared` in Visual Basic). Questi non sono requisiti per l'uso di inizializzazione differita.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="valueFactory" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, System::Threading::LazyThreadSafetyMode mode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Delegato richiamato per produrre il valore inizializzato in modalità differita quando è necessario.</param>
        <param name="mode">Uno dei valori di enumerazione che specifica la modalità thread safety.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Lazy`1" /> che utilizza la funzione di inizializzazione e la modalità di thread safety specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La modalità thread safety di un <xref:System.Lazy%601> istanza viene descritto il comportamento quando più thread tentano di inizializzare il <xref:System.Lazy%601> istanza.  
  
 Le eccezioni generate da `valueFactory` vengono memorizzati nella cache, a meno che non `mode` è <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Per ulteriori informazioni, vedere la classe <xref:System.Lazy%601> o l'enumerazione <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questo costruttore per creare un inizializzatore lazy che consente a più thread per situazioni di race per creare un oggetto in modo differito. Più thread riesca nella creazione di istanze, ma l'istanza è stata creata prima di utilizzare tutti i thread. Inoltre, nell'esempio viene illustrato che le eccezioni non vengono mai memorizzati nella cache quando si specifica <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, anche se l'inizializzazione viene eseguita da una funzione anziché dal costruttore predefinito del tipo creato in modo differito.  
  
> [!NOTE]
>  Per un esempio che illustra come utilizzare questo costruttore in scenari a thread singolo (specificando <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> per `mode`), vedere il <xref:System.Lazy%601.%23ctor%28System.Boolean%29> costruttore. Per un esempio che illustra come utilizzare questo costruttore per fornire il blocco anziché race condition in scenari con multithreading (specificando <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> per `mode`), vedere il <xref:System.Lazy%601.%23ctor> costruttore.  
  
 Nell'esempio viene definito un `LargeObject` classe che verrà inizializzata in modo differito da uno dei diversi thread. Le quattro sezioni principali del codice vengono illustrate la creazione di inizializzatore di, l'effettiva inizializzazione, la funzione di inizializzazione e il costruttore e il finalizzatore della `LargeObject` classe. All'inizio del `Main` (metodo), nell'esempio viene creata la <xref:System.Lazy%601> oggetto che esegue l'inizializzazione differita del `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#newlazy)]  
  
 L'inizializzatore lazy utilizza una funzione per eseguire l'inizializzazione. In questo caso, una funzione è necessario perché è presente alcun costruttore predefinito per il `LargeObject` classe.  
  
 L'esempio crea e avvia tre thread che bloccano su un <xref:System.Threading.ManualResetEvent> dell'oggetto, in modo che l'esempio è possibile rilasciare i thread in una sola volta. Nel `ThreadProc` metodo utilizzato da tutti i thread, la chiamata di <xref:System.Lazy%601.Value%2A> proprietà crea la `LargeObject` istanza:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#valueprop)]  
  
 Nella terza sezione chiave del codice, viene chiamata la funzione di inizializzazione differita per creare il `LargeObject` istanza. La funzione genera un'ora di eccezione, il primo che viene chiamato:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#factoryfunc)]  
  
 Con qualsiasi altro <xref:System.Threading.LazyThreadSafetyMode> impostazione, un'eccezione non gestita nella funzione di inizializzazione potrebbe essere memorizzato nella cache. Tuttavia, <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> evita la memorizzazione nella cache di eccezione. L'output dell'esempio viene illustrato che un successivo tentativo di inizializzare l'oggetto ha esito positivo.  
  
> [!NOTE]
>  In genere viene visualizzato il messaggio di eccezione dopo i messaggi che indicano che altri thread è inizializzati correttamente l'oggetto. Equivale a causa del ritardo introdotto da generare e intercettare l'eccezione.  
  
 Poiché il costruttore per il <xref:System.Lazy%601> istanza specificata <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, tutti i thread sono autorizzati a creare `LargeObject` istanze. Nell'esempio viene illustrato questo visualizzando i messaggi della console nel costruttore e nel finalizzatore del `LargeObject` classe:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#ctorfinalizer)]  
  
 Il <xref:System.Lazy%601> oggetto garantisce che solo un'istanza viene utilizzata da tutti i thread (eccetto il thread in cui la funzione di inizializzazione genera un'eccezione). L'output di esempio illustrata questa operazione.  
  
> [!NOTE]
>  Per semplicità, in questo esempio viene utilizzata un'istanza globale di <xref:System.Lazy%601> e tutti i metodi sono `static` (`Shared` in Visual Basic). Questi non sono requisiti per l'uso di inizializzazione differita.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contiene un valore non valido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="valueFactory" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsValueCreated">
      <MemberSignature Language="C#" Value="public bool IsValueCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueCreated" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.IsValueCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueCreated { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se per questa istanza di <see cref="T:System.Lazy`1" /> è stato creato un valore.</summary>
        <value>
          <see langword="true" /> se per questa istanza di <see cref="T:System.Lazy`1" /> è stato creato un valore; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando l'inizializzazione differita si verifica per un <xref:System.Lazy%601> istanza potrebbe restituire un valore che viene creato o viene generata un'eccezione. Se un'eccezione generato, i successivo comportamento del <xref:System.Lazy%601> istanza varia a seconda che la memorizzazione nella cache di eccezione attiva. Se il <xref:System.Lazy%601> istanza sia stata creata utilizzando un costruttore che non specifica una funzione di inizializzazione, quindi la memorizzazione nella cache di eccezione non è attiva. Un successivo tentativo di inizializzare il <xref:System.Lazy%601> potrebbe avere esito positivo e dopo l'inizializzazione ha esito positivo di <xref:System.Lazy%601.IsValueCreated%2A> restituisce proprietà `true`. Se il <xref:System.Lazy%601> istanza è stata creata con una funzione di inizializzazione (specificato da di `valueFactory` parametro del <xref:System.Lazy%601> costruttore), quindi la memorizzazione nella cache di eccezione è controllata per la modalità thread safety.  
  
-   Se la modalità è <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> o <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, non c'è alcuna possibilità di secondo per inizializzare il <xref:System.Lazy%601> istanza. Se si verifica un'eccezione non gestita nella funzione di inizializzazione, tale eccezione nella cache e generata di nuovo gli accessi successivi del <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> proprietà. Se viene generata un'eccezione, in tali casi, viene creato alcun valore <xref:System.Lazy%601.IsValueCreated%2A> restituisce `false`.  
  
-   Se la modalità è <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, il primo thread che riesce a eseguire la funzione di inizializzazione (o il costruttore predefinito) crea il valore per il <xref:System.Lazy%601> istanza. Se la funzione di inizializzazione genera un'eccezione in un unico thread, altri thread può ancora tentare di inizializzare il <xref:System.Lazy%601> istanza. Fino a quando il valore viene creato, il <xref:System.Lazy%601.IsValueCreated%2A> restituisce proprietà `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea e restituisce una rappresentazione di stringa della proprietà <see cref="P:System.Lazy`1.Value" /> per questa istanza.</summary>
        <returns>Risultato della chiamata al metodo <see cref="M:System.Object.ToString" /> sulla proprietà <see cref="P:System.Lazy`1.Value" /> per questa istanza, se il valore è stato creato (ossia se la proprietà <see cref="P:System.Lazy`1.IsValueCreated" /> restituisce <see langword="true" />). In caso contrario, stringa indicante che il valore non è stato creato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo non causa l'inizializzazione.  
  
 Il <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> proprietà può essere `null` dopo l'inizializzazione differita, se il metodo factory che è stato specificato per il `valueFactory` parametro del <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, o <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> costruttore restituisce `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">La proprietà <see cref="P:System.Lazy`1.Value" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public T Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Value" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T Value { T get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il valore inizializzato in modalità differita dell'istanza di <see cref="T:System.Lazy`1" /> corrente.</summary>
        <value>Valore inizializzato in modalità differita dell'istanza di <see cref="T:System.Lazy`1" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Lazy%601.IsValueCreated%2A?displayProperty=nameWithType> proprietà `false`, l'accesso al <xref:System.Lazy%601.Value%2A> proprietà forza l'inizializzazione.  
  
 Oltre le eccezioni che sono elencate il <xref:System.Lazy%601.Value%2A> proprietà può generare qualsiasi eccezione non gestita generata dal metodo factory che è stato passato il `valueFactory` parametro del <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, o <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> costruttore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">L'istanza <see cref="T:System.Lazy`1" /> viene inizializzata per l'utilizzo del costruttore predefinito del tipo che viene inizializzato in modalità differita e non si dispone delle autorizzazioni di accesso al costruttore.</exception>
        <exception cref="T:System.MissingMemberException">L'istanza <see cref="T:System.Lazy`1" /> viene inizializzata per l'utilizzo del costruttore predefinito del tipo che viene inizializzato in modalità differita e tale tipo non dispone di un costruttore pubblico senza parametri.</exception>
        <exception cref="T:System.InvalidOperationException">La funzione di inizializzazione tenta di accedere alla proprietà <see cref="P:System.Lazy`1.Value" /> su questa istanza.</exception>
      </Docs>
    </Member>
  </Members>
</Type>