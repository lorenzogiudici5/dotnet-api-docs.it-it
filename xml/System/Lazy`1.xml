<Type Name="Lazy&lt;T&gt;" FullName="System.Lazy&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="18f7acfe9be295d345b133ff0702748156b3ca30" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36429896" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Lazy&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Lazy`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Lazy`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Lazy(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Lazy" />
  <TypeSignature Language="F#" Value="type Lazy&lt;'T&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.System_LazyDebugView`1))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Tipo di oggetto che viene inizializzato in modo differito.</typeparam>
    <summary>Fornisce il supporto per l'inizializzazione differita.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare l'inizializzazione differita per rinviare la creazione di un oggetto di grandi dimensioni o risorse o l'esecuzione di un'attività a elevato utilizzo di risorse, in particolare quando la creazione o l'esecuzione di questo tipo potrebbe non verificarsi nel corso della durata del programma.  
  
 Per preparare per l'inizializzazione differita, si crea un'istanza di <xref:System.Lazy%601>. L'argomento del tipo di <xref:System.Lazy%601> oggetto creato specifica il tipo di oggetto che si desidera inizializzare in modo differito. Il costruttore che consente di creare il <xref:System.Lazy%601> oggetto determina le caratteristiche dell'inizializzazione. L'inizializzazione differita viene eseguita la prima volta che si accede alla proprietà <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType>.  
  
 Nella maggior parte dei casi, la scelta di un costruttore dipende le risposte alle due domande:  
  
-   Verrà eseguito l'oggetto inizializzato in modo differito da più thread? In tal caso, il <xref:System.Lazy%601> oggetto potrebbe crearla in qualsiasi thread. È possibile utilizzare uno dei costruttori semplici il cui comportamento predefinito consiste nel creare un thread-safe <xref:System.Lazy%601> dell'oggetto, in modo che solo un'istanza dell'oggetto in modo differito creata un'istanza viene creata indipendentemente da quante thread tentano di accedervi. Per creare un <xref:System.Lazy%601> oggetto che non è thread-safe, è necessario utilizzare un costruttore che consente di non specificare alcun thread-safe.  
  
    > [!CAUTION]
    >  Effettua il <xref:System.Lazy%601> affidabile oggetto non consente di proteggere l'oggetto inizializzato in modalità differita. Se più thread può accedere all'oggetto inizializzato in modalità differita, è necessario apportare le proprietà e metodi sicuri per l'accesso multithreading.  
  
-   L'inizializzazione differita richiede una grande quantità di codice o l'oggetto inizializzato in modalità differita dispone di un costruttore predefinito che esegue tutti gli elementi necessari e non genera eccezioni? Se è necessario scrivere codice di inizializzazione o se le eccezioni devono essere gestiti, utilizzare uno dei costruttori che accettano un metodo factory. Scrivere il codice di inizializzazione nel metodo factory.  
  
 Nella tabella seguente viene illustrato quale costruttore scegliere, in base a questi due fattori:  
  
|Oggetto eseguiranno l'accesso a|Se è richiesto alcun codice di inizializzazione (costruttore predefinito), usare|Se il codice di inizializzazione è necessario, utilizzare|  
|--------------------------------|------------------------------------------------------------------------|---------------------------------------------|  
|Più thread|<xref:System.Lazy%601.%23ctor>|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>|  
|Un thread|<xref:System.Lazy%601.%23ctor%28System.Boolean%29> con `isThreadSafe` impostato su `false`.|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> con `isThreadSafe` impostato su `false`.|  
  
 È possibile utilizzare un'espressione lambda per specificare il metodo factory. In questo modo tutto il codice di inizializzazione in un'unica posizione. L'espressione lambda acquisisce il contesto, inclusi gli eventuali argomenti passati al costruttore dell'oggetto inizializzato in modalità differita.  
  
 **La memorizzazione nella cache di eccezione** quando si utilizzano metodi factory, le eccezioni vengono memorizzati nella cache. Vale a dire, se il metodo factory genera un'ora la prima eccezione un thread tenta di accedere il <xref:System.Lazy%601.Value%2A> proprietà del <xref:System.Lazy%601> dell'oggetto, la stessa eccezione viene generata a ogni tentativo successivo. Ciò garantisce che ogni chiamata al <xref:System.Lazy%601.Value%2A> proprietà produce lo stesso risultato e consente di evitare errori difficili da rilevare che potrebbero verificarsi se diversi thread ottengano risultati diversi. Il <xref:System.Lazy%601> è l'acronimo di una vera e propria `T` che in caso contrario, verrebbe sono state inizializzate in un determinato momento precedente, in genere durante l'avvio. È in genere irreversibile un errore al momento precedente. Se è presente un potenziale di un errore reversibile, è consigliabile compilare la logica di riesecuzione in routine di inizializzazione (in questo caso, il metodo factory), esattamente come si farebbe se non è stato utilizzato l'inizializzazione differita.  
  
 **In alternativa al blocco** In determinate situazioni, è possibile evitare l'overhead del <xref:System.Lazy%601> comportamento di blocco predefinito dell'oggetto. In rari casi, potrebbe esserci un potenziale per i deadlock. In questi casi, è possibile usare il <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> oppure <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> costruttore e specificare <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. In questo modo, il <xref:System.Lazy%601> oggetto per creare una copia dell'oggetto inizializzato in modalità differita in ognuno dei diversi thread se il thread chiama il <xref:System.Lazy%601.Value%2A> proprietà contemporaneamente. Il <xref:System.Lazy%601> oggetto assicura che tutti i thread di utilizzare la stessa istanza dell'oggetto inizializzato in modalità differita ed Elimina le istanze che non vengono utilizzate. Di conseguenza, il costo di ridurre l'overhead dei blocchi è che il programma potrebbe essere a volte creare e annullare copie aggiuntive di un oggetto dispendioso. Nella maggior parte dei casi, è improbabile che ciò. Gli esempi per il <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> e <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> costruttori illustrano questo comportamento.  
  
> [!IMPORTANT]
>  Quando si specifica <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, le eccezioni non vengono mai memorizzati nella cache, anche se si specifica un metodo factory.  
  
 **Costruttori equivalenti** oltre a consentire l'utilizzo di <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, la <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> e <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> costruttori possono duplicare la funzionalità degli altri costruttori. Nella tabella seguente mostra i valori dei parametri che producono un comportamento equivalente.  
  
|Per creare un <xref:System.Lazy%601> oggetto|Per i costruttori che dispongono di un `LazyThreadSafetyMode` `mode` parametro, impostare `mode` a|Per i costruttori che dispongono di un valore booleano `isThreadSafe` parametro, impostare `isThreadSafe` a|Per i costruttori senza parametri di thread safety|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|-------------------------------------------------------|  
|Completamente thread-safe. viene utilizzato il blocco per garantire che un solo thread Inizializza il valore.|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|Tutti i costruttori di questo tipo sono pienamente thread-safe.|  
|Non i thread-safe.|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|Non applicabile.|  
|Completamente thread-safe. race condition di thread per inizializzare il valore.|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|Non applicabile.|Non applicabile.|  
  
 **Altre funzionalità** per informazioni sull'utilizzo delle <xref:System.Lazy%601> con i campi statici thread o come archivio di backup per le proprietà, vedere [l'inizializzazione differita](~/docs/framework/performance/lazy-initialization.md).  
  
   
  
## Examples  
 Nell'esempio seguente illustra l'uso del <xref:System.Lazy%601> classe per fornire l'accesso da più thread l'inizializzazione differita.  
  
> [!NOTE]
>  Nell'esempio viene utilizzato il <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> costruttore. Viene inoltre illustrato l'utilizzo del <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> costruttore (specificando `true` per `isThreadSafe`) e il <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> costruttore (specificando <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> per `mode`). Per passare a un costruttore diverso, modificare solo costruttori vengono impostate come commento.  
>   
>  Per un esempio che illustra eccezione la memorizzazione nella cache utilizzando il costruttore stesso, vedere il <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> costruttore.  
  
 Nell'esempio viene definita una classe `LargeObject` che verrà inizializzata in modo differito da uno dei diversi thread. Le quattro sezioni principali del codice vengono illustrate la creazione di inizializzatore, al metodo factory, l'effettiva inizializzazione e il costruttore del `LargeObject` (classe), che visualizza un messaggio quando viene creato l'oggetto. All'inizio del metodo `Main`, viene creato un inizializzatore thread-safe differito per `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#newlazy)]  
  
 Il metodo factory viene illustrata la creazione dell'oggetto, con un segnaposto per un'ulteriore inizializzazione:  
  
 [!code-csharp[System.Lazy\`1#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#factoryfunc)]  
  
 Si noti che le sezioni di codice primi due possono essere combinate usando una funzione lambda, come illustrato di seguito:  
  
 [!code-csharp[System.Lazy\`1#InitWithLambda](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/lambda.cs#initwithlambda)]
 [!code-vb[System.Lazy\`1#InitWithLambda](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/lambda.vb#initwithlambda)]  
  
 Nell'esempio viene sospeso, per indicare che un periodo di tempo indeterminato potrebbe trascorrere prima che venga eseguita l'inizializzazione differita. Quando si preme il **invio** chiave, l'esempio crea e avvia tre thread. Il `ThreadProc` metodo utilizzato da tutte le chiamate di tre thread il <xref:System.Lazy%601.Value%2A> proprietà. La prima volta in questo caso, il `LargeObject` creazione dell'istanza:  
  
 [!code-csharp[System.Lazy\`1#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#valueprop)]  
  
 Il costruttore del `LargeObject` (classe), che include l'ultima sezione chiave del codice, viene visualizzato un messaggio e registra l'identità del thread durante l'inizializzazione. L'output del programma viene visualizzato alla fine del listato di codice completo.  
  
 [!code-csharp[System.Lazy\`1#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#largector)]  
  
> [!NOTE]
>  Per semplicità, in questo esempio viene utilizzata un'istanza globale di <xref:System.Lazy%601> e tutti i metodi sono `static` (`Shared` in Visual Basic). Questi non sono requisiti per l'uso di inizializzazione differita.  
  
 [!code-csharp[System.Lazy\`1#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#all)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Per impostazione predefinita, tutti i membri pubblici e protetti della <see cref="T:System.Lazy`1" /> classe sono thread-safe e possono essere utilizzate contemporaneamente da più thread. Le garanzie di thread safety potrebbero venire rimosso facoltativamente e per ogni istanza, utilizzando i parametri nei costruttori del tipo.</threadsafe>
    <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Lazy`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Lazy`1" />. Quando si verifica l'inizializzazione differita, viene usato il costruttore predefinito del tipo di destinazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'istanza che viene creata con questo costruttore può essere utilizzata contemporaneamente da più thread.  
  
 La modalità thread safety di un <xref:System.Lazy%601> istanza che viene inizializzato con questo costruttore è <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. La modalità thread safety viene descritto il comportamento quando più thread tentano di inizializzare il <xref:System.Lazy%601> istanza.  
  
 Oggetto <xref:System.Lazy%601> istanza che viene creato con questo costruttore non memorizza nella cache le eccezioni. Per ulteriori informazioni, vedere la classe <xref:System.Lazy%601> o l'enumerazione <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questo costruttore. Viene inoltre illustrato l'utilizzo del <xref:System.Lazy%601.%23ctor%28System.Boolean%29> costruttore (specificando `true` per `isThreadSafe`) e il <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> costruttore (specificando <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> per `mode`). Per passare a un costruttore diverso, modificare solo costruttori vengono impostate come commento.  
  
 Nell'esempio viene definita una classe `LargeObject` che verrà inizializzata in modo differito da uno dei diversi thread. Le due righe di chiave del codice in questo esempio sono rappresentati dalla creazione dell'inizializzatore e l'effettiva inizializzazione. All'inizio del metodo `Main`, viene creato un inizializzatore thread-safe differito per `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#newlazy)]  
  
 L'esempio crea e avvia tre thread che bloccarsi su un <xref:System.Threading.ManualResetEvent> dell'oggetto, in modo che l'esempio può rilasciare i thread tutti contemporaneamente. Il `ThreadProc` metodo utilizzato da tutte le chiamate di tre thread il <xref:System.Lazy%601.Value%2A> proprietà da ottenere la `LargeObject` istanza:  
  
 [!code-csharp[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#valueprop)]  
  
 Il <xref:System.Lazy%601> fornisce il blocco, in modo che è consentito un solo thread per creare il `LargeObject` istanza. Nell'esempio viene illustrato che altri thread tutti ottengano la stessa istanza.  
  
> [!NOTE]
>  Per semplicità, in questo esempio viene utilizzata un'istanza globale di <xref:System.Lazy%601> e tutti i metodi sono `static` (`Shared` in Visual Basic). Questi non sono requisiti per l'uso di inizializzazione differita.  
  
 [!code-csharp[System.Lazy\`1.ctor#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctor#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; isThreadSafe" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isThreadSafe">
          <see langword="true" /> per far sì che l'istanza sia utilizzabile contemporaneamente da più thread; <see langword="false" /> per far sì che l'istanza sia utilizzabile da un solo thread alla volta.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Lazy`1" />. Quando si verifica l'inizializzazione differita, vengono usati il costruttore predefinito del tipo di destinazione e la modalità di inizializzazione specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La modalità thread safety di un <xref:System.Lazy%601> istanza che viene inizializzato con questo costruttore viene <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> se `isThreadSafe` viene `true`; in caso contrario, la modalità è <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. La modalità thread safety viene descritto il comportamento quando più thread tentano di inizializzare il <xref:System.Lazy%601> istanza. Per specificare il <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> modalità, usare il <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> o <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> costruttore.  
  
 Oggetto <xref:System.Lazy%601> istanza che viene creato con questo costruttore non memorizza nella cache le eccezioni. Per ulteriori informazioni, vedere la classe <xref:System.Lazy%601> o l'enumerazione <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questo costruttore per creare un inizializzatore differito che non è thread-safe, per gli scenari in cui si è completamente l'accesso all'oggetto inizializzato in modalità differita sullo stesso thread. Viene inoltre illustrato l'utilizzo del <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> costruttore (specificando <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> per `mode`. Per passare a un costruttore diverso, è sufficiente modificare il costruttore impostato come commento.  
  
> [!NOTE]
>  Per il codice viene illustrato come utilizzare questo costruttore in scenari a thread multipli (specificando `true` per `isThreadSafe`), vedere l'esempio per il <xref:System.Lazy%601.%23ctor> costruttore.  
  
 Nell'esempio viene definito un `LargeObject` classe che verrà inizializzata in modo differito. Nel `Main` (metodo), nell'esempio viene creato un <xref:System.Lazy%601> istanza e quindi verifica una sospensione. Quando si preme il **invio** chiave, nell'esempio si accede il <xref:System.Lazy%601.Value%2A> proprietà del <xref:System.Lazy%601> istanza, che fa sì che l'inizializzazione di. Il costruttore del `LargeObject` classe viene visualizzato un messaggio di console.  
  
> [!NOTE]
>  Per semplicità, in questo esempio viene utilizzata un'istanza globale di <xref:System.Lazy%601> e tutti i metodi sono `static` (`Shared` in Visual Basic). Questi non sono requisiti per l'uso di inizializzazione differita.  
  
 [!code-csharp[System.Lazy\`1.ctorBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; valueFactory" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Delegato richiamato per produrre il valore inizializzato in modalità differita quando è necessario.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Lazy`1" />. Quando si verifica l'inizializzazione differita, viene usata la funzione specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'istanza che viene creata con questo costruttore può essere utilizzata contemporaneamente da più thread.  
  
 La modalità thread safety di un <xref:System.Lazy%601> istanza che viene inizializzato con questo costruttore è <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. La modalità thread safety viene descritto il comportamento quando più thread tentano di inizializzare il <xref:System.Lazy%601> istanza.  
  
 Le eccezioni generate da `valueFactory` vengono memorizzati nella cache. Per ulteriori informazioni, vedere la classe <xref:System.Lazy%601> o l'enumerazione <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questo costruttore per fornire l'inizializzazione differita con la memorizzazione nella cache di eccezione. Viene inoltre illustrato l'utilizzo del <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> costruttore (specificando `true` per `isThreadSafe`) e il <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> costruttore (specificando <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> per `mode`). Per passare a un costruttore diverso, modificare solo costruttori vengono impostate come commento.  
  
 Nell'esempio viene definita una classe `LargeObject` che verrà inizializzata in modo differito da uno dei diversi thread. Le tre sezioni principali del codice vengono illustrate la creazione di inizializzatore effettiva inizializzazione e il costruttore del `LargeObject` (classe), che illustra la memorizzazione nella cache di eccezione. All'inizio del metodo `Main`, viene creato un inizializzatore thread-safe differito per `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#newlazy)]  
  
 L'esempio crea e avvia tre thread. Il `ThreadProc` metodo utilizzato da tutte le chiamate di tre thread il <xref:System.Lazy%601.Value%2A> proprietà da ottenere la `LargeObject` istanza:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#valueprop)]  
  
 Nel costruttore della `LargeObject` (classe), la terza sezione chiave del codice genera un'eccezione la prima volta un `LargeObject` viene creata l'istanza, ma successivamente consente la creazione dell'istanza di:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#largector)]  
  
 Quando viene eseguito l'esempio, il primo thread che tenta di creare un'istanza di `LargeObject` ha esito negativo e l'eccezione viene intercettata. Si potrebbe aspettare che il successivo thread correttamente creerebbe un'istanza, ma la <xref:System.Lazy%601> oggetto ha memorizzato nella cache l'eccezione. Per questo motivo, tutti i thread generata un'eccezione.  
  
> [!NOTE]
>  Per semplicità, in questo esempio viene utilizzata un'istanza globale di <xref:System.Lazy%601> e tutti i metodi sono `static` (`Shared` in Visual Basic). Questi non sono requisiti per l'uso di inizializzazione differita.  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFunc#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="valueFactory" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; mode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="mode">Uno dei valori di enumerazione che specifica la modalità thread safety.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Lazy`1" /> che utilizza il costruttore predefinito di <paramref name="T" /> e la modalità di thread safety specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La modalità thread safety di un <xref:System.Lazy%601> istanza viene descritto il comportamento quando più thread tentano di inizializzare il <xref:System.Lazy%601> istanza.  
  
 Oggetto <xref:System.Lazy%601> istanza che viene creato con questo costruttore non memorizza nella cache le eccezioni. Per ulteriori informazioni, vedere la classe <xref:System.Lazy%601> o l'enumerazione <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questo costruttore per creare un inizializzatore differito che permette a più thread per situazioni di race per creare un oggetto in modo differito. Più thread potrebbe avere esito positivo nella creazione di istanze, ma l'istanza è stata creata prima di utilizzare tutti i thread.  
  
> [!NOTE]
>  Per un esempio che illustra come utilizzare questo costruttore in scenari a thread singolo (specificando <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> per `mode`), vedere il <xref:System.Lazy%601.%23ctor%28System.Boolean%29> costruttore. Per un esempio che illustra come utilizzare questo costruttore per fornire il blocco anziché race condition in scenari a thread multipli (specificando <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> per `mode`), vedere il <xref:System.Lazy%601.%23ctor> costruttore.  
  
 Nell'esempio viene definito un `LargeObject` classe che verrà inizializzata in modo differito da uno qualsiasi dei diversi thread. Le tre sezioni principali del codice vengono illustrate la creazione di inizializzatore di effettiva inizializzazione e il costruttore e il finalizzatore della `LargeObject` classe. All'inizio della `Main` (metodo), nell'esempio viene creata la <xref:System.Lazy%601> oggetto che esegue l'inizializzazione differita del `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#newlazy)]  
  
 L'esempio crea e avvia tre thread che bloccarsi su un <xref:System.Threading.ManualResetEvent> dell'oggetto, in modo che l'esempio può rilasciare i thread tutti contemporaneamente. Nel `ThreadProc` metodo impiegato da tutti i thread, la chiamata di <xref:System.Lazy%601.Value%2A> proprietà crea la `LargeObject` istanza:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#valueprop)]  
  
 Poiché il costruttore per il <xref:System.Lazy%601> istanza specificata <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, tutti i thread sono autorizzati a creare `LargeObject` istanze. Nell'esempio viene illustrato quanto descritto visualizzando i messaggi della console nel costruttore e nel finalizzatore del `LargeObject` classe:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#ctorfinalizer)]  
  
 Tuttavia, il <xref:System.Lazy%601> oggetto assicura che solo un'istanza sia usata da tutti i thread. L'output dell'esempio mostra che tutti i tre thread usano la stessa istanza e mostra inoltre che le due istanze possono essere recuperate tramite garbage collection.  
  
> [!NOTE]
>  Per semplicità, in questo esempio viene utilizzata un'istanza globale di <xref:System.Lazy%601> e tutti i metodi sono `static` (`Shared` in Visual Basic). Questi non sono requisiti per l'uso di inizializzazione differita.  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contiene un valore non valido.</exception>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(T value);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : 'T -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, isThreadSafe)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Delegato richiamato per produrre il valore inizializzato in modalità differita quando è necessario.</param>
        <param name="isThreadSafe">
          <see langword="true" /> per far sì che l'istanza sia utilizzabile contemporaneamente da più thread; <see langword="false" /> per far sì che l'istanza sia utilizzabile da un solo thread alla volta.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Lazy`1" />. Quando si verifica l'inizializzazione differita, vengono usate la funzione e la modalità di inizializzazione specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La modalità thread safety di un <xref:System.Lazy%601> istanza che viene inizializzato con questo costruttore viene <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> se `isThreadSafe` viene `true`; in caso contrario, la modalità è <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. La modalità thread safety viene descritto il comportamento quando più thread tentano di inizializzare il <xref:System.Lazy%601> istanza.  
  
 Per specificare il <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> modalità, usare il <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> o <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> costruttore.  
  
 Le eccezioni generate da `valueFactory` vengono memorizzati nella cache. Per ulteriori informazioni, vedere la classe <xref:System.Lazy%601> o l'enumerazione <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questo costruttore per fornire l'inizializzazione differita con eccezione la memorizzazione nella cache, in uno scenario con un singolo thread. Viene inoltre illustrato l'utilizzo del <xref:System.Lazy%601.%23ctor%2A> costruttore (specificando <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> per `mode`). Per passare al costruttore, cambiando il costruttore impostato come commento.  
  
> [!NOTE]
>  Per il codice viene illustrato come utilizzare questo costruttore in scenari a thread multipli (specificando `true` per `isThreadSafe`), vedere l'esempio per il <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> costruttore.  
  
 Nell'esempio viene definita una classe `LargeObject` che verrà inizializzata in modo differito da uno dei diversi thread. Le tre sezioni principali del codice vengono illustrate la creazione di inizializzatore effettiva inizializzazione e il costruttore del `LargeObject` (classe), che illustra la memorizzazione nella cache di eccezione. All'inizio del metodo `Main`, viene creato un inizializzatore thread-safe differito per `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#newlazy)]  
  
 Nella chiamata al costruttore, il `isThreadSafe` parametro `false`, pertanto il <xref:System.Lazy%601> non è thread-safe. Perché non è thread-safe, nell'esempio viene chiamato il <xref:System.Lazy%601.Value%2A> proprietà tre volte sullo stesso thread:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#valueprop)]  
  
 Nel costruttore della `LargeObject` (classe), la terza sezione chiave del codice genera un'eccezione la prima volta un `LargeObject` viene creata l'istanza, ma successivamente consente la creazione dell'istanza di:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#largector)]  
  
 Quando viene eseguito l'esempio, al primo tentativo di creare un'istanza di `LargeObject` ha esito negativo e l'eccezione viene intercettata. Si potrebbe aspettare che al successivo tentativo di esito positivo, ma la <xref:System.Lazy%601> oggetto ha memorizzato nella cache l'eccezione. Per questo motivo, tutti i tre tentativi generata un'eccezione.  
  
> [!NOTE]
>  Per semplicità, in questo esempio viene utilizzata un'istanza globale di <xref:System.Lazy%601> e tutti i metodi sono `static` (`Shared` in Visual Basic). Questi non sono requisiti per l'uso di inizializzazione differita.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="valueFactory" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Delegato richiamato per produrre il valore inizializzato in modalità differita quando è necessario.</param>
        <param name="mode">Uno dei valori di enumerazione che specifica la modalità thread safety.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Lazy`1" /> che utilizza la funzione di inizializzazione e la modalità di thread safety specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La modalità thread safety di un <xref:System.Lazy%601> istanza viene descritto il comportamento quando più thread tentano di inizializzare il <xref:System.Lazy%601> istanza.  
  
 Le eccezioni generate da `valueFactory` vengono memorizzati nella cache, a meno che non `mode` è <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Per ulteriori informazioni, vedere la classe <xref:System.Lazy%601> o l'enumerazione <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questo costruttore per creare un inizializzatore differito che permette a più thread per situazioni di race per creare un oggetto in modo differito. Più thread potrebbe avere esito positivo nella creazione di istanze, ma l'istanza è stata creata prima di utilizzare tutti i thread. Inoltre, nell'esempio viene illustrato che le eccezioni non sono mai memorizzati nella cache quando si specifica <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, anche se l'inizializzazione viene eseguita da una funzione anziché dal costruttore predefinito del tipo creato in modo differito.  
  
> [!NOTE]
>  Per un esempio che illustra come utilizzare questo costruttore in scenari a thread singolo (specificando <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> per `mode`), vedere il <xref:System.Lazy%601.%23ctor%28System.Boolean%29> costruttore. Per un esempio che illustra come utilizzare questo costruttore per fornire il blocco anziché race condition in scenari a thread multipli (specificando <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> per `mode`), vedere il <xref:System.Lazy%601.%23ctor> costruttore.  
  
 Nell'esempio viene definito un `LargeObject` classe che verrà inizializzata in modo differito da uno qualsiasi dei diversi thread. Le quattro sezioni principali del codice vengono illustrate la creazione dell'inizializzatore, l'effettiva inizializzazione, la funzione di inizializzazione e il costruttore e il finalizzatore del `LargeObject` classe. All'inizio della `Main` (metodo), nell'esempio viene creata la <xref:System.Lazy%601> oggetto che esegue l'inizializzazione differita del `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#newlazy)]  
  
 L'inizializzatore lazy utilizza una funzione per eseguire l'inizializzazione. In questo caso, una funzione è obbligatoria perché è presente alcun costruttore predefinito per il `LargeObject` classe.  
  
 L'esempio crea e avvia tre thread che bloccarsi su un <xref:System.Threading.ManualResetEvent> dell'oggetto, in modo che l'esempio può rilasciare i thread tutti contemporaneamente. Nel `ThreadProc` metodo impiegato da tutti i thread, la chiamata di <xref:System.Lazy%601.Value%2A> proprietà crea la `LargeObject` istanza:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#valueprop)]  
  
 Nella terza sezione chiave del codice, viene chiamata la funzione di inizializzazione differita per creare il `LargeObject` istanza. La funzione genera un volta la prima eccezione che viene chiamato:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#factoryfunc)]  
  
 Con qualsiasi altro <xref:System.Threading.LazyThreadSafetyMode> impostazione, un'eccezione non gestita nella funzione di inizializzazione potrebbe essere memorizzato nella cache. Tuttavia, <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> evita la memorizzazione nella cache di eccezione. L'output dell'esempio viene illustrato che un successivo tentativo di inizializzare l'oggetto ha esito positivo.  
  
> [!NOTE]
>  In genere viene visualizzato il messaggio di eccezione dopo messaggi che indichino che altri thread è inizializzati correttamente l'oggetto. Equivale a causa del ritardo introdotto generando e rilevando l'eccezione.  
  
 Poiché il costruttore per il <xref:System.Lazy%601> istanza specificata <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, tutti i thread sono autorizzati a creare `LargeObject` istanze. Nell'esempio viene illustrato quanto descritto visualizzando i messaggi della console nel costruttore e nel finalizzatore del `LargeObject` classe:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#ctorfinalizer)]  
  
 Il <xref:System.Lazy%601> oggetto assicura che solo un'istanza sia usata da tutti i thread (eccetto il thread in cui la funzione di inizializzazione genera un'eccezione). L'output dell'esempio viene illustrata questa operazione.  
  
> [!NOTE]
>  Per semplicità, in questo esempio viene utilizzata un'istanza globale di <xref:System.Lazy%601> e tutti i metodi sono `static` (`Shared` in Visual Basic). Questi non sono requisiti per l'uso di inizializzazione differita.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contiene un valore non valido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="valueFactory" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsValueCreated">
      <MemberSignature Language="C#" Value="public bool IsValueCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueCreated" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.IsValueCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueCreated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueCreated : bool" Usage="System.Lazy&lt;'T&gt;.IsValueCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se per questa istanza di <see cref="T:System.Lazy`1" /> è stato creato un valore.</summary>
        <value>
          <see langword="true" /> se per questa istanza di <see cref="T:System.Lazy`1" /> è stato creato un valore; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si verifica l'inizializzazione differita per un <xref:System.Lazy%601> istanza, può comportare un valore viene creato o viene generata un'eccezione. Se un'eccezione generato, i successivo comportamento del <xref:System.Lazy%601> istanza varia a seconda che la memorizzazione nella cache di eccezione attiva. Se il <xref:System.Lazy%601> istanza sia stata creata utilizzando un costruttore che non specifica una funzione di inizializzazione, quindi la memorizzazione nella cache di eccezione non è attiva. Un successivo tentativo di inizializzare il <xref:System.Lazy%601> potrebbe avere esito positivo e dopo l'inizializzazione ha esito positivo il <xref:System.Lazy%601.IsValueCreated%2A> restituisce proprietà `true`. Se il <xref:System.Lazy%601> istanza è stata creata con una funzione di inizializzazione (specificato per il `valueFactory` parametro del <xref:System.Lazy%601> costruttore), quindi la memorizzazione nella cache di eccezione è controllata per la modalità thread safety.  
  
-   Se la modalità <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> oppure <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, non c'è alcuna possibilità di secondo per inizializzare il <xref:System.Lazy%601> istanza. Se si verifica un'eccezione non gestita nella funzione di inizializzazione, tale eccezione nella cache e generata di nuovo gli accessi successivi del <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> proprietà. Viene creato alcun valore se viene generata un'eccezione, in tali casi <xref:System.Lazy%601.IsValueCreated%2A> restituisce `false`.  
  
-   Se la modalità <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, il primo thread che riesce a eseguire la funzione di inizializzazione (o il costruttore predefinito) crea il valore per il <xref:System.Lazy%601> istanza. Se la funzione di inizializzazione genera un'eccezione in un unico thread, altri thread può ancora provare a inizializzare il <xref:System.Lazy%601> istanza. Fino a quando non viene creato il valore, il <xref:System.Lazy%601.IsValueCreated%2A> restituisce proprietà `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="lazy.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea e restituisce una rappresentazione di stringa della proprietà <see cref="P:System.Lazy`1.Value" /> per questa istanza.</summary>
        <returns>Risultato della chiamata al metodo <see cref="M:System.Object.ToString" /> sulla proprietà <see cref="P:System.Lazy`1.Value" /> per questa istanza, se il valore è stato creato (ossia se la proprietà <see cref="P:System.Lazy`1.IsValueCreated" /> restituisce <see langword="true" />). In caso contrario, stringa indicante che il valore non è stato creato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo non causa l'inizializzazione.  
  
 Il <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> proprietà può essere `null` dopo l'inizializzazione differita se il metodo factory che è stato specificato per il `valueFactory` parametro del <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, o <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> costruttore restituisce `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">La proprietà <see cref="P:System.Lazy`1.Value" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public T Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Value" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T Value { T get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : 'T" Usage="System.Lazy&lt;'T&gt;.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il valore inizializzato in modalità differita dell'istanza di <see cref="T:System.Lazy`1" /> corrente.</summary>
        <value>Valore inizializzato in modalità differita dell'istanza di <see cref="T:System.Lazy`1" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Lazy%601.IsValueCreated%2A?displayProperty=nameWithType> proprietà è `false`, l'accesso al <xref:System.Lazy%601.Value%2A> proprietà forza l'inizializzazione.  
  
 Oltre alle eccezioni elencate, il <xref:System.Lazy%601.Value%2A> proprietà può generare qualsiasi eccezione non gestita generata dal metodo factory che è stato passato al `valueFactory` parametro del <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, o <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> costruttore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">L'istanza <see cref="T:System.Lazy`1" /> viene inizializzata per l'utilizzo del costruttore predefinito del tipo che viene inizializzato in modalità differita e non si dispone delle autorizzazioni di accesso al costruttore.</exception>
        <exception cref="T:System.MissingMemberException">L'istanza <see cref="T:System.Lazy`1" /> viene inizializzata per l'utilizzo del costruttore predefinito del tipo che viene inizializzato in modalità differita e tale tipo non dispone di un costruttore pubblico senza parametri.</exception>
        <exception cref="T:System.InvalidOperationException">La funzione di inizializzazione tenta di accedere alla proprietà <see cref="P:System.Lazy`1.Value" /> su questa istanza.</exception>
      </Docs>
    </Member>
  </Members>
</Type>