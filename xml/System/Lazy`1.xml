<Type Name="Lazy&lt;T&gt;" FullName="System.Lazy&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8a08e490433f3e23816cdfd6030b67d5925db996" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52590400" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Lazy&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Lazy`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Lazy`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Lazy(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Lazy" />
  <TypeSignature Language="F#" Value="type Lazy&lt;'T&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.System_LazyDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Tipo di oggetto che viene inizializzato in modo differito.</typeparam>
    <summary>Fornisce il supporto per l'inizializzazione differita.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare l'inizializzazione differita per rinviare la creazione di un oggetto di grandi dimensioni o a elevato utilizzo di risorse o l'esecuzione di un'attività a elevato utilizzo di risorse, in particolare quando tale creazione o esecuzione potrebbe non verificarsi nel corso della durata del programma.  
  
 Per preparare per l'inizializzazione differita, si crea un'istanza di <xref:System.Lazy%601>. L'argomento del tipo di <xref:System.Lazy%601> oggetto creato specifica il tipo di oggetto che si desidera inizializzare in modo differito. Il costruttore utilizzato per creare il <xref:System.Lazy%601> oggetto determina le caratteristiche dell'inizializzazione. L'inizializzazione differita viene eseguita la prima volta che si accede alla proprietà <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType>.  
  
 Nella maggior parte dei casi, la scelta di un costruttore dipende le risposte alle due domande:  
  
-   L'oggetto inizializzato in modo differito sarà accessibili da più di un thread? In questo caso, il <xref:System.Lazy%601> oggetto possibile crearlo in qualsiasi thread. È possibile usare uno dei costruttori di semplice il cui comportamento predefinito consiste nel creare un thread-safe <xref:System.Lazy%601> dell'oggetto, in modo che solo un'istanza dell'oggetto in modo differito creata un'istanza viene creata indipendentemente dal numero di thread tenta di accedervi. Per creare un <xref:System.Lazy%601> oggetto che non è thread-safe, è necessario usare un costruttore che consente di non specificare alcun thread-safe.  
  
    > [!CAUTION]
    >  Effettua il <xref:System.Lazy%601> affidabile oggetto ma non protegge l'oggetto inizializzato in modo differito. Se più thread possono accedere all'oggetto inizializzato in modalità differita, è necessario apportare relativi metodi e proprietà sicuri per l'accesso a thread multipli.  
  
-   L'oggetto inizializzato in modo differito dispone un costruttore predefinito che esegue tutto ciò che è necessario e non genera eccezioni o l'inizializzazione differita richiede una grande quantità di codice? Se è necessario scrivere codice di inizializzazione o se le eccezioni devono essere gestiti, usare uno dei costruttori che accettano un metodo factory. Scrivere il codice di inizializzazione nel metodo factory.  
  
 La tabella seguente illustra il costruttore di scegliere, in base a questi due fattori:  
  
|Oggetto eseguiranno l'accesso a|Se è necessario alcun codice di inizializzazione (costruttore predefinito), usare|Se il codice di inizializzazione è necessario, utilizzare|  
|--------------------------------|------------------------------------------------------------------------|---------------------------------------------|  
|Più thread|<xref:System.Lazy%601.%23ctor>|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>|  
|Un thread|<xref:System.Lazy%601.%23ctor%28System.Boolean%29> con `isThreadSafe` impostato su `false`.|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> con `isThreadSafe` impostato su `false`.|  
  
 È possibile usare un'espressione lambda per specificare il metodo factory. In questo modo tutto il codice di inizializzazione in un'unica posizione. L'espressione lambda acquisisce il contesto, inclusi gli eventuali argomenti passati al costruttore dell'oggetto inizializzato in modalità differita.  
  
 **La memorizzazione nella cache di eccezione** quando si utilizzano metodi factory, le eccezioni vengono memorizzate nella cache. Vale a dire, se il metodo factory genera ora un'eccezione al primo un thread tenta di accedere il <xref:System.Lazy%601.Value%2A> proprietà del <xref:System.Lazy%601> dell'oggetto, la stessa eccezione viene generata in tutti i tentativi successivi. Ciò garantisce che ogni chiamata al <xref:System.Lazy%601.Value%2A> proprietà produce lo stesso risultato e consente di evitare errori che potrebbero verificarsi se diversi thread ottengano risultati diversi. Il <xref:System.Lazy%601> sostituisce un vero e proprio `T` che in caso contrario, verrebbe sono state inizializzate in precedenza, in genere durante l'avvio. È in genere irreversibile un errore in tale punto precedente. Se è presente un potenziale di un errore reversibile, è consigliabile compilare la logica di ripetizione dei tentativi nelle routine di inizializzazione (in questo caso il metodo factory), esattamente come farebbe se non è stato usato l'inizializzazione differita.  
  
 **In alternativa al blocco** In alcuni casi, si potrebbe voler evitare l'overhead del <xref:System.Lazy%601> comportamento di blocco predefinito dell'oggetto. In rari casi, potrebbero esserci può causare un deadlock. In questi casi, è possibile usare la <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> oppure <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> costruttore e specificare <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. In questo modo, il <xref:System.Lazy%601> oggetto per creare una copia dell'oggetto inizializzato in modo differito in ognuno dei diversi thread se il thread chiama il <xref:System.Lazy%601.Value%2A> proprietà contemporaneamente. Il <xref:System.Lazy%601> oggetto assicura che tutti i thread di usare la stessa istanza dell'oggetto inizializzato in modo differito ed Elimina le istanze che non vengono usate. Di conseguenza, il costo di ridurre l'overhead dei blocchi è che il programma potrebbe a volte creare e rimuovere copie aggiuntive di un oggetto dispendioso. Nella maggior parte dei casi, è improbabile che ciò. Gli esempi per la <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> e <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> costruttori dimostrano questo comportamento.  
  
> [!IMPORTANT]
>  Quando si specifica <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, le eccezioni non vengono mai memorizzati nella cache, anche se si specifica un metodo factory.  
  
 **Costruttori equivalenti** oltre a consentire l'uso di <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, il <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> e <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> costruttori possono duplicano la funzionalità di altri costruttori. Nella tabella seguente mostra i valori dei parametri che producono un comportamento equivalente.  
  
|Per creare un <xref:System.Lazy%601> oggetto|Per i costruttori che hanno una `LazyThreadSafetyMode` `mode` set di parametri, `mode` a|Per i costruttori che hanno un valore booleano `isThreadSafe` set di parametri, `isThreadSafe` a|Per i costruttori senza parametri di thread safety|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|-------------------------------------------------------|  
|Completamente thread-safe. Usa il blocco per garantire che un solo thread Inizializza il valore.|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|Tutti questi costruttori sono completamente thread-safe.|  
|Non i thread-safe.|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|Non applicabile.|  
|Completamente thread-safe. competizione di thread per inizializzare il valore.|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|Non applicabile.|Non applicabile.|  
  
 **Altre funzionalità** per informazioni sull'uso dello <xref:System.Lazy%601> con i campi di thread statiche o archivio di backup per le proprietà, vedere [inizializzazione differita](~/docs/framework/performance/lazy-initialization.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.Lazy%601> classe per fornire l'inizializzazione differita con accesso da più thread.  
  
> [!NOTE]
>  Nell'esempio viene usato il <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> costruttore. Viene inoltre illustrato l'utilizzo dei <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> costruttore (che specifica `true` per `isThreadSafe`) e il <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> costruttore (che specifica <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> per `mode`). Per passare a un costruttore diverso, è sufficiente modificare costruttori impostare come commento.  
>   
>  Per un esempio che illustra l'eccezione di memorizzazione nella cache usando i costruttori stesso, vedere il <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> costruttore.  
  
 Nell'esempio viene definita una classe `LargeObject` che verrà inizializzata in modo differito da uno dei diversi thread. Le quattro sezioni principali di codice illustrano la creazione di inizializzatore, al metodo factory, l'effettiva inizializzazione e il costruttore del `LargeObject` (classe), che visualizza un messaggio quando viene creato l'oggetto. All'inizio del metodo `Main`, viene creato un inizializzatore thread-safe differito per `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#newlazy)]  
  
 Il metodo factory illustra la creazione dell'oggetto, con un segnaposto per un'ulteriore inizializzazione:  
  
 [!code-csharp[System.Lazy\`1#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#factoryfunc)]  
  
 Si noti che le sezioni di codice prima di tutto due possono essere combinate usando una funzione lambda, come illustrato di seguito:  
  
 [!code-csharp[System.Lazy\`1#InitWithLambda](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/lambda.cs#initwithlambda)]
 [!code-vb[System.Lazy\`1#InitWithLambda](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/lambda.vb#initwithlambda)]  
  
 Nell'esempio viene sospeso, per indicare che può intercorrere un periodo di tempo indeterminato prima che venga eseguita l'inizializzazione differita. Quando si preme il **invio** chiave, l'esempio crea e avvia tre thread. Il `ThreadProc` metodo usato da tutte le chiamate di tre thread di <xref:System.Lazy%601.Value%2A> proprietà. La prima volta in questo caso, il `LargeObject` istanza viene creata:  
  
 [!code-csharp[System.Lazy\`1#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#valueprop)]  
  
 Il costruttore del `LargeObject` (classe), che include l'ultima sezione chiave del codice, viene visualizzato un messaggio e registra l'identità del thread durante l'inizializzazione. L'output del programma viene visualizzato alla fine del listato di codice completo.  
  
 [!code-csharp[System.Lazy\`1#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#largector)]  
  
> [!NOTE]
>  Per semplicità, in questo esempio viene utilizzata un'istanza globale di <xref:System.Lazy%601> e tutti i metodi sono `static` (`Shared` in Visual Basic). Questi non sono requisiti per l'uso di inizializzazione differita.  
  
 [!code-csharp[System.Lazy\`1#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#all)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Per impostazione predefinita, tutti i membri pubblici e protetti del <see cref="T:System.Lazy`1" /> classe sono thread-safe e possono essere utilizzati contemporaneamente da più thread. Facoltativamente e per ogni istanza, utilizzando i parametri nei costruttori del tipo, è possibile rimuovere queste garanzie di thread safety.</threadsafe>
    <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
    <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inizializzazione differita</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Lazy`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Lazy`1" />. Quando si verifica l'inizializzazione differita, viene usato il costruttore predefinito del tipo di destinazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'istanza che viene creata con questo costruttore può essere utilizzata contemporaneamente da più thread.  
  
 La modalità thread safety di un <xref:System.Lazy%601> istanza viene inizializzata con questo costruttore è <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. La modalità thread safety viene descritto il comportamento quando più thread tentano di inizializzare il <xref:System.Lazy%601> istanza.  
  
 Oggetto <xref:System.Lazy%601> istanza che viene creato con questo costruttore non memorizza nella cache delle eccezioni. Per ulteriori informazioni, vedere la classe <xref:System.Lazy%601> o l'enumerazione <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questo costruttore. Viene inoltre illustrato l'utilizzo dei <xref:System.Lazy%601.%23ctor%28System.Boolean%29> costruttore (che specifica `true` per `isThreadSafe`) e il <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> costruttore (che specifica <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> per `mode`). Per passare a un costruttore diverso, è sufficiente modificare costruttori impostare come commento.  
  
 Nell'esempio viene definita una classe `LargeObject` che verrà inizializzata in modo differito da uno dei diversi thread. Le due righe chiave del codice in questo esempio sono rappresentati dalla creazione dell'inizializzatore e l'inizializzazione effettiva. All'inizio del metodo `Main`, viene creato un inizializzatore thread-safe differito per `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#newlazy)]  
  
 L'esempio crea e avvia tre thread che bloccarsi su una <xref:System.Threading.ManualResetEvent> dell'oggetto, in modo che l'esempio può rilasciare i thread in una sola volta. Il `ThreadProc` metodo usato da tutte le chiamate di tre thread di <xref:System.Lazy%601.Value%2A> proprietà da ottenere la `LargeObject` istanza:  
  
 [!code-csharp[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#valueprop)]  
  
 Il <xref:System.Lazy%601> classe fornisce il blocco, in modo che è consentito un solo thread per creare il `LargeObject` istanza. L'esempio dimostra che gli altri thread tutti ottengano la stessa istanza.  
  
> [!NOTE]
>  Per semplicità, in questo esempio viene utilizzata un'istanza globale di <xref:System.Lazy%601> e tutti i metodi sono `static` (`Shared` in Visual Basic). Questi non sono requisiti per l'uso di inizializzazione differita.  
  
 [!code-csharp[System.Lazy\`1.ctor#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctor#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inizializzazione differita</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; isThreadSafe" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isThreadSafe">
          <see langword="true" /> per rendere questa istanza utilizzabile contemporaneamente da più thread. <see langword="false" /> per rendere l'istanza utilizzabile da un solo thread alla volta.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Lazy`1" />. Quando si verifica l'inizializzazione differita, vengono usati il costruttore predefinito del tipo di destinazione e la modalità di inizializzazione specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La modalità thread safety di un <xref:System.Lazy%601> istanza viene inizializzata con questo costruttore viene <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> se `isThreadSafe` viene `true`; in caso contrario, la modalità di <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. La modalità thread safety viene descritto il comportamento quando più thread tentano di inizializzare il <xref:System.Lazy%601> istanza. Per specificare il <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> modalità, usare il <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> o <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> costruttore.  
  
 Oggetto <xref:System.Lazy%601> istanza che viene creato con questo costruttore non memorizza nella cache delle eccezioni. Per ulteriori informazioni, vedere la classe <xref:System.Lazy%601> o l'enumerazione <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questo costruttore per creare un inizializzatore di tipo lazy che non è thread-safe, per gli scenari in cui tutti gli accessi per l'oggetto inizializzato in modo differito si verifica nello stesso thread. Viene inoltre illustrato l'utilizzo dei <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> costruttore (che specifica <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> per `mode`. Per passare a un costruttore diverso, è sufficiente modificare il costruttore viene impostata come commento.  
  
> [!NOTE]
>  Per il codice viene illustrato come utilizzare questo costruttore in scenari con multithreading (specificando `true` per `isThreadSafe`), vedere l'esempio per il <xref:System.Lazy%601.%23ctor> costruttore.  
  
 L'esempio definisce un `LargeObject` classe che verrà inizializzata in modo differito. Nel `Main` metodo, l'esempio crea un <xref:System.Lazy%601> istanza e quindi mette in pausa. Quando si preme il **invio** principali, nell'esempio si accede il <xref:System.Lazy%601.Value%2A> proprietà del <xref:System.Lazy%601> istanza che fa in modo che si verificano l'inizializzazione. Il costruttore del `LargeObject` classe visualizza un messaggio della console.  
  
> [!NOTE]
>  Per semplicità, in questo esempio viene utilizzata un'istanza globale di <xref:System.Lazy%601> e tutti i metodi sono `static` (`Shared` in Visual Basic). Questi non sono requisiti per l'uso di inizializzazione differita.  
  
 [!code-csharp[System.Lazy\`1.ctorBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inizializzazione differita</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; valueFactory" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Delegato richiamato per produrre il valore inizializzato in modalità differita quando è necessario.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Lazy`1" />. Quando si verifica l'inizializzazione differita, viene usata la funzione specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'istanza che viene creata con questo costruttore può essere utilizzata contemporaneamente da più thread.  
  
 La modalità thread safety di un <xref:System.Lazy%601> istanza viene inizializzata con questo costruttore è <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. La modalità thread safety viene descritto il comportamento quando più thread tentano di inizializzare il <xref:System.Lazy%601> istanza.  
  
 Le eccezioni generate da `valueFactory` vengono memorizzati nella cache. Per ulteriori informazioni, vedere la classe <xref:System.Lazy%601> o l'enumerazione <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questo costruttore per fornire l'inizializzazione differita con la memorizzazione nella cache di eccezione. Viene inoltre illustrato l'utilizzo dei <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> costruttore (che specifica `true` per `isThreadSafe`) e il <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> costruttore (che specifica <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> per `mode`). Per passare a un costruttore diverso, è sufficiente modificare costruttori impostare come commento.  
  
 Nell'esempio viene definita una classe `LargeObject` che verrà inizializzata in modo differito da uno dei diversi thread. Le tre sezioni principali di codice illustrano la creazione di inizializzatore, l'effettiva inizializzazione e il costruttore del `LargeObject` (classe), che illustra la memorizzazione nella cache di eccezione. All'inizio del metodo `Main`, viene creato un inizializzatore thread-safe differito per `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#newlazy)]  
  
 L'esempio crea e avvia tre thread. Il `ThreadProc` metodo usato da tutte le chiamate di tre thread di <xref:System.Lazy%601.Value%2A> proprietà da ottenere la `LargeObject` istanza:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#valueprop)]  
  
 Nel costruttore della `LargeObject` (classe), la terza sezione chiave del codice genera un'eccezione la prima volta un `LargeObject` istanza viene creata, ma successivamente consente la creazione di istanze si verifichi:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#largector)]  
  
 Quando viene eseguito l'esempio, il primo thread che tenta di creare un'istanza di `LargeObject` ha esito negativo e l'eccezione viene intercettata. Si potrebbe pensare che il thread successivo correttamente creerebbe un'istanza, ma il <xref:System.Lazy%601> oggetto ha memorizzato nella cache l'eccezione. Per questo motivo, tutti i thread generano l'eccezione.  
  
> [!NOTE]
>  Per semplicità, in questo esempio viene utilizzata un'istanza globale di <xref:System.Lazy%601> e tutti i metodi sono `static` (`Shared` in Visual Basic). Questi non sono requisiti per l'uso di inizializzazione differita.  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFunc#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="valueFactory" /> è <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inizializzazione differita</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; mode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="mode">Uno dei valori di enumerazione che specifica la modalità thread safety.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Lazy`1" /> che usa il costruttore predefinito di <paramref name="T" /> e la modalità thread safety specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La modalità thread safety di un <xref:System.Lazy%601> istanza viene descritto il comportamento quando più thread tentano di inizializzare il <xref:System.Lazy%601> istanza.  
  
 Oggetto <xref:System.Lazy%601> istanza che viene creato con questo costruttore non memorizza nella cache delle eccezioni. Per ulteriori informazioni, vedere la classe <xref:System.Lazy%601> o l'enumerazione <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questo costruttore per creare un inizializzatore di tipo lazy che abilita più thread competono per creare un oggetto in modo differito. Più thread potrebbero avere esito positivo nella creazione di istanze, ma l'istanza è stata creata prima di usare tutti i thread.  
  
> [!NOTE]
>  Per un esempio che illustra come usare questo costruttore in scenari a thread singolo (specificando <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> per `mode`), vedere il <xref:System.Lazy%601.%23ctor%28System.Boolean%29> costruttore. Per un esempio che illustra come utilizzare questo costruttore per fornire il blocco anziché le race condition in scenari con multithreading (specificando <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> per `mode`), vedere il <xref:System.Lazy%601.%23ctor> costruttore.  
  
 L'esempio definisce un `LargeObject` classe che verrà inizializzata in modo differito da uno qualsiasi dei thread diversi. Le tre sezioni principali di codice illustrano la creazione di inizializzatore, l'effettiva inizializzazione e il costruttore e il finalizzatore del `LargeObject` classe. All'inizio del `Main` metodo, l'esempio crea il <xref:System.Lazy%601> oggetto che esegue l'inizializzazione differita del `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#newlazy)]  
  
 L'esempio crea e avvia tre thread che bloccarsi su una <xref:System.Threading.ManualResetEvent> dell'oggetto, in modo che l'esempio può rilasciare i thread in una sola volta. Nel `ThreadProc` metodo usato da tutti i thread, chiamare il <xref:System.Lazy%601.Value%2A> proprietà comporta la `LargeObject` istanza:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#valueprop)]  
  
 Poiché il costruttore per la <xref:System.Lazy%601> istanza specificata <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, tutti i thread sono autorizzati a creare `LargeObject` istanze. Nell'esempio viene illustrata questa visualizzando i messaggi della console nel costruttore e nel finalizzatore del `LargeObject` classe:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#ctorfinalizer)]  
  
 Tuttavia, il <xref:System.Lazy%601> oggetto assicura che solo un'istanza viene usata da tutti i thread. L'output dell'esempio mostra che tutti i tre thread di usare la stessa istanza e mostra inoltre che le due istanze possono essere recuperate da garbage collection.  
  
> [!NOTE]
>  Per semplicità, in questo esempio viene utilizzata un'istanza globale di <xref:System.Lazy%601> e tutti i metodi sono `static` (`Shared` in Visual Basic). Questi non sono requisiti per l'uso di inizializzazione differita.  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contiene un valore non valido.</exception>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inizializzazione differita</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(T value);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : 'T -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, isThreadSafe)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Delegato richiamato per produrre il valore inizializzato in modalità differita quando è necessario.</param>
        <param name="isThreadSafe">
          <see langword="true" /> per rendere questa istanza utilizzabile contemporaneamente da più thread; <see langword="false" /> per rendere questa istanza utilizzabile da un solo thread alla volta.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Lazy`1" />. Quando si verifica l'inizializzazione differita, vengono usate la funzione e la modalità di inizializzazione specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La modalità thread safety di un <xref:System.Lazy%601> istanza viene inizializzata con questo costruttore viene <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> se `isThreadSafe` viene `true`; in caso contrario, la modalità di <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. La modalità thread safety viene descritto il comportamento quando più thread tentano di inizializzare il <xref:System.Lazy%601> istanza.  
  
 Per specificare il <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> modalità, usare il <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> o <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> costruttore.  
  
 Le eccezioni generate da `valueFactory` vengono memorizzati nella cache. Per ulteriori informazioni, vedere la classe <xref:System.Lazy%601> o l'enumerazione <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questo costruttore per fornire l'inizializzazione differita con eccezione la memorizzazione nella cache, in uno scenario con un singolo thread. Viene inoltre illustrato l'utilizzo dei <xref:System.Lazy%601.%23ctor%2A> costruttore (che specifica <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> per `mode`). Per passare a tale costruttore, è sufficiente modificare il costruttore viene impostata come commento.  
  
> [!NOTE]
>  Per il codice viene illustrato come utilizzare questo costruttore in scenari con multithreading (specificando `true` per `isThreadSafe`), vedere l'esempio per il <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> costruttore.  
  
 Nell'esempio viene definita una classe `LargeObject` che verrà inizializzata in modo differito da uno dei diversi thread. Le tre sezioni principali di codice illustrano la creazione di inizializzatore, l'effettiva inizializzazione e il costruttore del `LargeObject` (classe), che illustra la memorizzazione nella cache di eccezione. All'inizio del metodo `Main`, viene creato un inizializzatore thread-safe differito per `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#newlazy)]  
  
 Nella chiamata al costruttore, il `isThreadSafe` parametro è `false`, pertanto il <xref:System.Lazy%601> non è thread-safe. Perché non è thread-safe, nell'esempio viene chiamato il <xref:System.Lazy%601.Value%2A> proprietà tre volte sullo stesso thread:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#valueprop)]  
  
 Nel costruttore della `LargeObject` (classe), la terza sezione chiave del codice genera un'eccezione la prima volta un `LargeObject` istanza viene creata, ma successivamente consente la creazione di istanze si verifichi:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#largector)]  
  
 Quando viene eseguito l'esempio, il primo tentativo di creare un'istanza di `LargeObject` ha esito negativo e l'eccezione viene intercettata. Si potrebbe pensare che il tentativo successivo potrebbe avere esito positivo, ma il <xref:System.Lazy%601> oggetto ha memorizzato nella cache l'eccezione. Per questo motivo, i tre tentativi generano l'eccezione.  
  
> [!NOTE]
>  Per semplicità, in questo esempio viene utilizzata un'istanza globale di <xref:System.Lazy%601> e tutti i metodi sono `static` (`Shared` in Visual Basic). Questi non sono requisiti per l'uso di inizializzazione differita.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="valueFactory" /> è <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inizializzazione differita</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Delegato richiamato per produrre il valore inizializzato in modalità differita quando è necessario.</param>
        <param name="mode">Uno dei valori di enumerazione che specifica la modalità thread safety.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Lazy`1" /> che usa la funzione di inizializzazione e la modalità thread safety specificate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La modalità thread safety di un <xref:System.Lazy%601> istanza viene descritto il comportamento quando più thread tentano di inizializzare il <xref:System.Lazy%601> istanza.  
  
 Le eccezioni generate dai `valueFactory` vengono memorizzati nella cache, a meno che `mode` è <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Per ulteriori informazioni, vedere la classe <xref:System.Lazy%601> o l'enumerazione <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di questo costruttore per creare un inizializzatore di tipo lazy che abilita più thread competono per creare un oggetto in modo differito. Più thread potrebbero avere esito positivo nella creazione di istanze, ma l'istanza è stata creata prima di usare tutti i thread. Inoltre, nell'esempio viene illustrato che le eccezioni non vengono mai memorizzati nella cache quando si specificano <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, anche se l'inizializzazione viene eseguita da una funzione anziché dal costruttore predefinito del tipo creato in modo differito.  
  
> [!NOTE]
>  Per un esempio che illustra come usare questo costruttore in scenari a thread singolo (specificando <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> per `mode`), vedere il <xref:System.Lazy%601.%23ctor%28System.Boolean%29> costruttore. Per un esempio che illustra come utilizzare questo costruttore per fornire il blocco anziché le race condition in scenari con multithreading (specificando <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> per `mode`), vedere il <xref:System.Lazy%601.%23ctor> costruttore.  
  
 L'esempio definisce un `LargeObject` classe che verrà inizializzata in modo differito da uno qualsiasi dei thread diversi. Le quattro sezioni principali di codice illustrano la creazione dell'inizializzatore, l'effettiva inizializzazione, la funzione di inizializzazione e il costruttore e il finalizzatore del `LargeObject` classe. All'inizio del `Main` metodo, l'esempio crea il <xref:System.Lazy%601> oggetto che esegue l'inizializzazione differita del `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#newlazy)]  
  
 L'inizializzatore lazy utilizza una funzione per eseguire l'inizializzazione. In questo caso, una funzione è necessaria perché non vi è alcun costruttore predefinito per il `LargeObject` classe.  
  
 L'esempio crea e avvia tre thread che bloccarsi su una <xref:System.Threading.ManualResetEvent> dell'oggetto, in modo che l'esempio può rilasciare i thread in una sola volta. Nel `ThreadProc` metodo usato da tutti i thread, chiamare il <xref:System.Lazy%601.Value%2A> proprietà comporta la `LargeObject` istanza:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#valueprop)]  
  
 Nella terza sezione chiave del codice, la funzione di inizializzazione differita viene chiamata per creare il `LargeObject` istanza. La funzione genera un volta la prima eccezione che viene chiamato:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#factoryfunc)]  
  
 Con qualsiasi altro <xref:System.Threading.LazyThreadSafetyMode> impostazione, un'eccezione non gestita nella funzione di inizializzazione potrebbe essere memorizzato nella cache. Tuttavia, <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> evita la memorizzazione nella cache di eccezione. L'output dell'esempio viene illustrato che un successivo tentativo di inizializzare l'oggetto ha esito positivo.  
  
> [!NOTE]
>  In genere viene visualizzato il messaggio di eccezione dopo i messaggi che indica che altri thread è inizializzati correttamente l'oggetto. Ciò è dovuto il ritardo introdotto generando e rilevando l'eccezione.  
  
 Poiché il costruttore per la <xref:System.Lazy%601> istanza specificata <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, tutti i thread sono autorizzati a creare `LargeObject` istanze. Nell'esempio viene illustrata questa visualizzando i messaggi della console nel costruttore e nel finalizzatore del `LargeObject` classe:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#ctorfinalizer)]  
  
 Il <xref:System.Lazy%601> oggetto assicura che solo un'istanza viene usata da tutti i thread (ad eccezione del thread in cui la funzione di inizializzazione genera un'eccezione). L'output dell'esempio viene illustrato questo.  
  
> [!NOTE]
>  Per semplicità, in questo esempio viene utilizzata un'istanza globale di <xref:System.Lazy%601> e tutti i metodi sono `static` (`Shared` in Visual Basic). Questi non sono requisiti per l'uso di inizializzazione differita.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contiene un valore non valido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="valueFactory" /> è <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inizializzazione differita</related>
      </Docs>
    </Member>
    <Member MemberName="IsValueCreated">
      <MemberSignature Language="C#" Value="public bool IsValueCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueCreated" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.IsValueCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueCreated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueCreated : bool" Usage="System.Lazy&lt;'T&gt;.IsValueCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se è stato creato un valore per l'istanza di <see cref="T:System.Lazy`1" />.</summary>
        <value>
          <see langword="true" /> se è stato creato un valore per l'istanza di <see cref="T:System.Lazy`1" />. In caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si verifica l'inizializzazione differita per un <xref:System.Lazy%601> istanza, può comportare un valore viene creato o viene generata un'eccezione. Se un'eccezione viene generato, le successivo il comportamento del <xref:System.Lazy%601> istanza varia a seconda che la memorizzazione nella cache di eccezione attiva. Se il <xref:System.Lazy%601> usando un costruttore che non specifica una funzione di inizializzazione è stata creata l'istanza, quindi la memorizzazione nella cache di eccezione non è attiva. Un successivo tentativo di inizializzare il <xref:System.Lazy%601> potrebbe avere esito positivo e dopo l'inizializzazione ha esito positivo il <xref:System.Lazy%601.IsValueCreated%2A> restituisce proprietà `true`. Se il <xref:System.Lazy%601> istanza è stata creata con una funzione di inizializzazione (specificato dal `valueFactory` parametro del <xref:System.Lazy%601> costruttore), quindi la memorizzazione nella cache di eccezione viene controllata per la modalità thread safety.  
  
-   Se è la modalità <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> oppure <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, senza possibilità di secondo per inizializzare il <xref:System.Lazy%601> istanza. Se si verifica un'eccezione non gestita nella funzione di inizializzazione, tale eccezione viene memorizzato nella cache e generata di nuovo gli accessi successivi del <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> proprietà. Viene creato alcun valore se viene generata un'eccezione, quindi, in questi casi <xref:System.Lazy%601.IsValueCreated%2A> restituisce `false`.  
  
-   Se è la modalità <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, il primo thread che riesce a eseguire la funzione di inizializzazione (o il costruttore predefinito) consente di creare il valore per il <xref:System.Lazy%601> istanza. Se la funzione di inizializzazione genera un'eccezione in un unico thread, altri thread, è comunque possibile provare a inizializzare il <xref:System.Lazy%601> istanza. Fino a quando il valore viene creato, il <xref:System.Lazy%601.IsValueCreated%2A> restituisce proprietà `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inizializzazione differita</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="lazy.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea e restituisce una rappresentazione di stringa della proprietà <see cref="P:System.Lazy`1.Value" /> per questa istanza.</summary>
        <returns>Risultato della chiamata al metodo <see cref="M:System.Object.ToString" /> sulla proprietà <see cref="P:System.Lazy`1.Value" /> per questa istanza, se il valore è stato creato (ovvero, se la proprietà <see cref="P:System.Lazy`1.IsValueCreated" /> restituisce <see langword="true" />). In caso contrario, stringa indicante che il valore non è stato creato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo non provoca l'inizializzazione.  
  
 Il <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> proprietà può essere `null` dopo l'inizializzazione differita se il metodo factory che è stato specificato per il `valueFactory` parametri del <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, o <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> costruttore restituisce `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">La proprietà <see cref="P:System.Lazy`1.Value" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public T Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Value" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T Value { T get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : 'T" Usage="System.Lazy&lt;'T&gt;.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il valore con inizializzazione differita dell'istanza corrente di <see cref="T:System.Lazy`1" />.</summary>
        <value>Valore con inizializzazione differita dell'istanza corrente di <see cref="T:System.Lazy`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il <xref:System.Lazy%601.IsValueCreated%2A?displayProperty=nameWithType> proprietà viene `false`, l'accesso al <xref:System.Lazy%601.Value%2A> proprietà forza l'inizializzazione.  
  
 Oltre che le eccezioni elencate, il <xref:System.Lazy%601.Value%2A> proprietà possibile generare qualsiasi eccezione non gestita generata dal metodo factory che è stato passato al `valueFactory` parametro delle <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, o <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> costruttore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">L'istanza di <see cref="T:System.Lazy`1" /> viene inizializzata per l'uso del costruttore predefinito del tipo con inizializzazione differita e mancano le autorizzazioni per accedere al costruttore.</exception>
        <exception cref="T:System.MissingMemberException">L'istanza di <see cref="T:System.Lazy`1" /> viene inizializzata per l'uso del costruttore predefinito del tipo con inizializzazione differita e tale tipo non dispone di un costruttore pubblico senza parametri.</exception>
        <exception cref="T:System.InvalidOperationException">La funzione di inizializzazione tenta di accedere a <see cref="P:System.Lazy`1.Value" /> in questa istanza.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inizializzazione differita</related>
      </Docs>
    </Member>
  </Members>
</Type>