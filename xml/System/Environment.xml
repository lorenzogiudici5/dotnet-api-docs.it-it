<Type Name="Environment" FullName="System.Environment">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="90a97c862b41234e8dce6d1b6bd2e75a974fb8e4" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39821892" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Environment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Environment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Environment" />
  <TypeSignature Language="VB.NET" Value="Public Class Environment" />
  <TypeSignature Language="C++ CLI" Value="public ref class Environment abstract sealed" />
  <TypeSignature Language="F#" Value="type Environment = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce informazioni e mezzi per manipolare l'ambiente e la piattaforma correnti. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.Environment> classe da cui recuperare informazioni quali gli argomenti della riga di comando, il codice di uscita, le impostazioni di variabile di ambiente, contenuto dello stack di chiamate, tempo trascorso dall'ultimo avvio del sistema e la versione di common language runtime.  
  
   
  
## Examples  
 Nell'esempio seguente viene visualizzato un elenco di informazioni sull'ambiente corrente.  
  
 [!code-cpp[environment.class#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.class/CPP/env0.cpp#1)]
 [!code-csharp[environment.class#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.class/CS/env0.cs#1)]
 [!code-vb[environment.class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.class/VB/env0.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CommandLine">
      <MemberSignature Language="C#" Value="public static string CommandLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommandLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CommandLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommandLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommandLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandLine : string" Usage="System.Environment.CommandLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la riga di comando per questo processo.</summary>
        <value>Stringa contenente gli argomenti della riga di comando.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà fornisce l'accesso a tutti gli argomenti specificati nella riga di comando quando è stato avviato il processo corrente e il nome del programma.  
  
 Il nome del programma può includere le informazioni sul percorso, ma non è necessario eseguire questa operazione. Uso di <xref:System.Environment.GetCommandLineArgs%2A> analizzato e archiviato in una matrice di stringhe di metodo per recuperare le informazioni della riga di comando.  
  
 Le dimensioni massime del buffer della riga di comando non sono impostata su un numero specifico di caratteri. varia a seconda del sistema operativo Windows è in esecuzione nel computer.  
  
   
  
## Examples  
 Nell'esempio seguente consente di visualizzare la propria riga di comando.  
  
 [!code-cpp[environment.commandline#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.CommandLine/CPP/commandline.cpp#1)]
 [!code-csharp[environment.commandline#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.CommandLine/CS/commandline.cs#1)]
 [!code-vb[environment.commandline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.CommandLine/VB/commandline.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">accesso in lettura alla variabile di ambiente PATH. Enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="System.Environment.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il percorso completo della directory di lavoro corrente.</summary>
        <value>Stringa che contiene un percorso di directory.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per definizione, se questo processo inizia nella directory radice di una variabile locale o di unità di rete, il valore di questa proprietà è il nome di unità seguito da una barra finale (ad esempio, "c:\\"). Se questo processo viene avviato in una sottodirectory, il valore di questa proprietà è il percorso di unità e sottodirectory, senza una barra finale (ad esempio, "C:\mySubDirectory").  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrata l'impostazione di <xref:System.Environment.CurrentDirectory%2A> proprietà.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è provato a impostare su una stringa vuota ("").</exception>
        <exception cref="T:System.ArgumentNullException">Si è provato a impostare su <see langword="null." />.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Si è provato a impostare un percorso locale che non è stato trovato.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non ha l'autorizzazione appropriata.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per la scrittura di file o directory in un'operazione set. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni del percorso in un'operazione get. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentManagedThreadId">
      <MemberSignature Language="C#" Value="public static int CurrentManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CurrentManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CurrentManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentManagedThreadId : int" Usage="System.Environment.CurrentManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un identificatore univoco per il thread gestito corrente.</summary>
        <value>Intero che rappresenta un identificatore univoco per il thread gestito.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.Exit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(int exitCode);" />
      <MemberSignature Language="F#" Value="static member Exit : int -&gt; unit" Usage="System.Environment.Exit exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">Codice di uscita da restituire al sistema operativo. Usare 0 (zero) per indicare che il processo è stato completato correttamente.</param>
        <summary>Termina questo processo e restituisce un codice di uscita al sistema operativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per il `exitCode` parametro, il numero di utilizzare un diverso da zero per indicare un errore. Nell'applicazione, è possibile definire i propri codici di errore in un'enumerazione e restituire il codice di errore appropriato sulla base dello scenario. Ad esempio, restituiscono un valore pari a 1 per indicare che il file richiesto non è presente e il valore 2 per indicare che il file è in formato non corretto. Per un elenco dei codici di uscita usata dal sistema operativo Windows, vedere [codici di errore di sistema](http://msdn.microsoft.com/library/ms681381.aspx) nella documentazione di Windows.  
  
 Chiama il <xref:System.Environment.Exit%2A> metodo si differenzia da usando il linguaggio di programmazione `return` istruzione nei modi seguenti:  
  
-   <xref:System.Environment.Exit%2A> termina sempre un'applicazione. Usando il `return` istruzione può terminare un'applicazione solo se viene utilizzato nel punto di ingresso dell'applicazione, ad esempio nel `Main` (metodo).  
  
-   <xref:System.Environment.Exit%2A> un'applicazione termina immediatamente, anche se altri thread è in esecuzione. Se il `return` istruzione viene chiamata nel punto di ingresso dell'applicazione, fa sì che un'applicazione da terminare solo dopo che tutti i thread in primo piano sono terminati.  
  
-   <xref:System.Environment.Exit%2A> richiede che il chiamante è autorizzato a chiamare codice non gestito. Il `return` istruzione non lo fa.  
  
-   Se <xref:System.Environment.Exit%2A> viene chiamato da un `try` oppure `catch` blocca, il codice in qualsiasi `finally` blocco non viene eseguito. Se il `return` viene utilizzata l'istruzione, il codice nel `finally` eseguire blocca.  
  
-   Se <xref:System.Environment.Exit%2A> viene chiamato quando Scrivi codice in un [area a esecuzione vincolata](~/docs/framework/performance/constrained-execution-regions.md) (CER) è in esecuzione, l'area a esecuzione vincolata non verrà completata l'esecuzione. Se il `return` viene utilizzata l'istruzione, l'area a esecuzione vincolata completa l'esecuzione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante non ha autorizzazioni di sicurezza sufficienti per eseguire questa funzione.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public static int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.Environment.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il codice di uscita del processo.</summary>
        <value>Intero con segno a 32 bit contenente il codice di uscita. Il valore predefinito è 0 (zero), che indica che il processo è stato completato con successo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il `Main` restituzione del metodo `void`, è possibile usare questa proprietà per impostare il codice di uscita che verrà restituito all'ambiente chiamante. Se `Main` non restituisce `void`, questa proprietà viene ignorata. Il valore iniziale di questa proprietà è zero.  
  
> [!WARNING]
>  Il <xref:System.Environment.ExitCode%2A> proprietà è un intero con segno a 32 bit. Per impedire che la proprietà restituiscano un codice di uscita negativo, non utilizzare i valori maggiori o uguali a 0x80000000.  
  
 Usare un numero diverso da zero per indicare un errore. Nell'applicazione, è possibile definire i propri codici di errore in un'enumerazione e restituire il codice di errore appropriato sulla base dello scenario. Ad esempio, restituire un valore pari a 1 per indicare che il file richiesto non è presente e il valore 2 per indicare che il file è in formato non corretto. Per un elenco dei codici di uscita usata dal sistema operativo Windows, vedere [codici di errore di sistema](http://msdn.microsoft.com/library/ms681381\(v=vs.85\)) nella documentazione di Windows.  
  
   
  
## Examples  
 Di seguito è una semplice app denominata Double.exe che raddoppia il valore intero passato come argomento della riga di comando. Il valore assegna i codici di errore per il <xref:System.Environment.ExitCode%2A> proprietà per indicare le condizioni di errore. Si noti che è necessario aggiungere un riferimento all'assembly System.Numerics.dll per compilare correttamente l'esempio.  
  
 [!code-csharp[System.Environment.ExitCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double.cs#1)]
 [!code-vb[System.Environment.ExitCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double.vb#1)]  
  
 L'esempio può quindi essere richiamato da un file batch, ad esempio il seguente, che rende accessibili i relativi codici di errore usando il `ERRORLEVEL` comando.  
  
```  
  
echo off  
Double.exe %1  
If errorlevel 1639 goto NoArg   
if errorlevel 534 goto Overflow  
if errorlevel 160 goto BadArg  
if errorlevel 0 echo Completed Successfully   
goto :EOF  
  
:NoArg  
echo Missing argument  
goto :EOF  
  
: Overflow  
echo Arithmetic overflow  
goto :EOF  
  
:BadArg  
echo Invalid argument  
goto :EOF  
  
```  
  
 Di seguito viene illustrato un esempio di output generato richiamando il file batch.  
  
```Output  
  
>getdouble 123>echo offResult: 246Completed Successfully>getdouble 5912323109093>echo offArithmetic overflow>getdouble>echo offMissing argument>getdouble "a string">echo offInvalid argument  
  
```  
  
 Si noti che il codice per Double.exe è identico nella funzione all'esempio seguente, ad eccezione del fatto che il primo definisce un punto di ingresso denominato `Main` che non restituisce alcun valore, mentre in questo esempio definisce un punto di ingresso denominato `Main` che restituisce un valore integer.  
  
 [!code-csharp[System.Environment.ExitCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double1.cs#2)]
 [!code-vb[System.Environment.ExitCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static string ExpandEnvironmentVariables (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ExpandEnvironmentVariables(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.ExpandEnvironmentVariables(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExpandEnvironmentVariables (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ExpandEnvironmentVariables(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member ExpandEnvironmentVariables : string -&gt; string" Usage="System.Environment.ExpandEnvironmentVariables name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene i nomi di zero o più variabili di ambiente. Ogni variabile di ambiente è inserita tra apici con il simbolo di percentuale (%).</param>
        <summary>Sostituisce il nome di ogni variabile di ambiente incorporata nella stringa specificata con l'equivalente di stringa del valore della variabile, quindi restituisce la stringa risultante.</summary>
        <returns>Stringa in cui ogni variabile di ambiente viene sostituita dal relativo valore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Interoperabilità COM viene utilizzato per recuperare le variabili di ambiente dal sistema operativo. Se le variabili di ambiente non possono essere recuperate a causa di un errore COM, il valore HRESULT che descrive la causa dell'errore viene utilizzato per generare una delle numerose eccezioni possibili; vale a dire, l'eccezione dipende dal valore HRESULT. Per altre informazioni sulle modalità di elaborazione HRESULT, vedere la sezione Osservazioni del <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A?displayProperty=nameWithType> (metodo).  
  
 Sostituzione avviene solo per le variabili di ambiente impostate. Ad esempio supponga `name` è "MyENV = % MyENV %". Se la variabile di ambiente, MyENV, viene impostata su 42, questo metodo restituisce "MyENV = 42". Se non è impostata MyENV, si verifica alcun cambiamento; Questo metodo restituisce "MyENV = % MyENV %".  
  
 Le dimensioni del valore restituito sono 32 KB.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come ottenere l'unità di sistema e variabili di sistema radice.  
  
 [!code-cpp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CPP/expandenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CS/expandenvironmentvariables.cs#1)]
 [!code-vb[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/VB/expandenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">la possibilità di accedere alle variabili di ambiente <paramref name="name" />. Enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FailFast">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Interrompe immediatamente un processo dopo aver scritto un messaggio nel log eventi dell'applicazione di Windows. Quindi, include il messaggio e le informazioni facoltative sull'eccezione nella segnalazione errori da inviare a Microsoft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FailFast (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member FailFast : string -&gt; unit" Usage="System.Environment.FailFast message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Messaggio in cui viene indicato il motivo dell'interruzione del processo o <see langword="null" /> se non è fornita alcuna spiegazione.</param>
        <summary>Interrompe immediatamente un processo dopo aver scritto un messaggio nel registro eventi dell'applicazione di Windows. Quindi, include il messaggio nella segnalazione errori da inviare a Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo interrompe un processo senza eseguire attive `try` / `finally` blocchi o i finalizzatori.  
  
 Il <xref:System.Environment.FailFast%2A> metodo scrive il `message` stringa nel registro eventi applicazioni di Windows, viene creato un dump dell'applicazione e quindi termina il processo corrente. Il `message` stringa è incluso anche nella segnalazione errori a Microsoft.  
  
 Usare il <xref:System.Environment.FailFast%2A> invece del metodo di <xref:System.Environment.Exit%2A> metodo per interrompere l'applicazione se lo stato dell'applicazione è danneggiato e l'esecuzione dell'applicazione `try` / `finally` blocchi e dei finalizzatori danneggerà risorse del programma.  
  
 Informazioni viene segnalate a Microsoft tramite segnalazione errori Windows. Per altre informazioni, vedere [segnalazione errori Windows: Guida introduttiva](http://msdn.microsoft.com/library/windows/hardware/dn641144.aspx).  
  
   
  
## Examples  
 Nell'esempio seguente scrive una voce di log per il registro eventi applicazioni di Windows e termina il processo corrente.  
  
 [!code-csharp[environment.FailFast#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.FailFast/cs/ff.cs#1)]
 [!code-vb[environment.FailFast#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.FailFast/vb/ff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message, Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message, class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String,System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message, Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FailFast : string * Exception -&gt; unit" Usage="System.Environment.FailFast (message, exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Messaggio in cui viene indicato il motivo dell'interruzione del processo o <see langword="null" /> se non è fornita alcuna spiegazione.</param>
        <param name="exception">Eccezione che rappresenta l'errore che ha causato l'interruzione. In genere si tratta di un'eccezione in un blocco <see langword="catch" />.</param>
        <summary>Interrompe immediatamente un processo dopo aver scritto un messaggio nel registro eventi dell'applicazione di Windows. Quindi, include il messaggio e informazioni sull'eccezione nella segnalazione errori da inviare a Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo termina il processo senza eseguire attive `try` / `finally` blocchi o i finalizzatori.  
  
 Il <xref:System.Environment.FailFast%2A> metodo scrive il `message` stringa nel registro eventi applicazioni di Windows, viene creato un dump dell'applicazione e quindi termina il processo corrente.  
  
 Informazioni viene segnalate a Microsoft tramite segnalazione errori Windows. Per altre informazioni, vedere [segnalazione errori Windows: Guida introduttiva](http://msdn.microsoft.com/library/windows/hardware/dn641144.aspx). Segnalazione errori a Microsoft comprende `message` e `exception` informazioni, che fornisce i dettagli usati per classificare l'errore. Sebbene `exception` non sia gestiti perché il processo viene terminato, viene ottenute comunque le informazioni contestuali che ha generato l'eccezione.  
  
 Se `exception` viene `null`, o se `exception` non è viene generata, questo metodo opera allo stesso modo di <xref:System.Environment.FailFast%28System.String%29> overload del metodo.  
  
 Usare il <xref:System.Environment.FailFast%2A> invece del metodo di <xref:System.Environment.Exit%2A> metodo per interrompere l'applicazione se lo stato dell'applicazione è danneggiato e l'esecuzione dell'applicazione `try` / `finally` blocchi e dei finalizzatori danneggerà risorse del programma.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCommandLineArgs">
      <MemberSignature Language="C#" Value="public static string[] GetCommandLineArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetCommandLineArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetCommandLineArgs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCommandLineArgs () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetCommandLineArgs();" />
      <MemberSignature Language="F#" Value="static member GetCommandLineArgs : unit -&gt; string[]" Usage="System.Environment.GetCommandLineArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una matrice di stringa che contiene gli argomenti della riga di comando per il processo corrente.</summary>
        <returns>Una matrice di stringa in cui ogni elemento contiene un argomento della riga di comando. Il primo elemento è il nome del file eseguibile, mentre i successivi zero o più elementi contengono i restanti argomenti della riga di comando.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il primo elemento nella matrice contiene il nome del file di programma in esecuzione. Se il nome del file non è disponibile, il primo elemento è uguale a <xref:System.String.Empty?displayProperty=nameWithType>. Gli elementi restanti contengono token aggiuntivi inserite nella riga di comando.  
  
 Il nome file del programma può, ma non è necessario per includere le informazioni sul percorso.  
  
 Argomenti della riga di comando sono delimitati da spazi. È possibile utilizzare le virgolette doppie (") per includere gli spazi all'interno di un argomento. La virgoletta singola ('), tuttavia, non fornisce questa funzionalità.  
  
 Se due o un numero pari di barre rovesciate è seguito un segno di virgolette doppie, viene sostituito ogni coppia di barra rovesciata di procedere con una barra rovesciata e le virgolette doppie viene rimosso. Se un segno di virgolette doppie segue un numero dispari di barre rovesciate, inclusa una sola, ogni coppia precedente viene sostituita con una barra rovesciata e barra rovesciata rimanente viene rimosso; Tuttavia, in questo caso le virgolette doppie non viene rimosso.  
  
 Nella tabella seguente viene illustrato come argomenti della riga di comando possono essere delimitati e presuppone `MyApp` corrente dell'applicazione in esecuzione.  
  
|Nella riga di comando di input|Argomenti della riga di comando risultante|  
|-------------------------------|--------------------------------------|  
|`MyApp alpha beta`|`MyApp, alpha, beta`|  
|`MyApp "alpha with spaces" "beta with spaces"`|`MyApp, alpha with spaces, beta with spaces`|  
|`MyApp 'alpha with spaces' beta`|`MyApp, 'alpha, with, spaces', beta`|  
|`MyApp \\\alpha \\\\"beta`|`MyApp, \\\alpha, \\beta`|  
|`MyApp \\\\\"alpha \"beta`|`MyApp, \\"alpha, "beta`|  
  
 Per ottenere la riga di comando come un'unica stringa, usare il <xref:System.Environment.CommandLine%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente consente di visualizzare gli argomenti della riga di comando dell'applicazione.  
  
 [!code-cpp[Environment.GetCommandLineArgs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CPP/getcommandlineargs.cpp#1)]
 [!code-csharp[Environment.GetCommandLineArgs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CS/getcommandlineargs.cs#1)]
 [!code-vb[Environment.GetCommandLineArgs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetCommandLineArgs/VB/getcommandlineargs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il sistema non supporta gli argomenti della riga di comando.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">accesso in lettura alla variabile di ambiente PATH. Enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.CommandLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera il valore di una variabile di ambiente.</summary>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string -&gt; string" Usage="System.Environment.GetEnvironmentVariable variable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">Nome della variabile di ambiente.</param>
        <summary>Recupera dal processo corrente il valore di una variabile di ambiente.</summary>
        <returns>Valore della variabile di ambiente specificata nel parametro <paramref name="variable" /> o <see langword="null" /> se la variabile di ambiente non viene trovata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Il <xref:System.Environment.GetEnvironmentVariable%28System.String%29> metodo consente di recuperare una variabile di ambiente dal blocco di ambiente del solo processo corrente. È equivalente alla chiamata di <xref:System.Environment.GetEnvironmentVariable%28System.String%2CSystem.EnvironmentVariableTarget%29> metodo con un `target` pari a <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. 

Per recuperare tutte le variabili di ambiente con i rispettivi valori, chiamare il <xref:System.Environment.GetEnvironmentVariables%2A> (metodo).  
  
I nomi delle variabili di ambiente sono tra maiuscole e minuscole in Linux e macOS, ma non sono tra maiuscole e minuscole in Windows.  
 
### <a name="on-windows-systems"></a>Nei sistemi Windows

 Nei sistemi Windows, il blocco di ambiente del processo corrente include:
 
- Tutte le variabili di ambiente fornite dal processo padre che l'ha creata. Ad esempio, un'applicazione .NET avviata da una finestra della console eredita tutte le variabili di ambiente della finestra della console. 

  Se è presente alcun processo padre, vengono utilizzate variabili di ambiente per computer e per ogni utente. Ad esempio, una nuova finestra della console con variabili di ambiente per computer e per ogni utente tutte definite al momento che è stata avviata.

- Tutte le variabili aggiunte per il blocco process mentre il processo è in esecuzione tramite la chiamata al <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> metodo o il <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metodo con un `target` pari a <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Queste variabili di ambiente è persist finché non termina l'applicazione .NET.  
  
Se le variabili di ambiente vengono create dopo l'avvio del processo, è possibile usare questo metodo per recuperare solo le variabili che sono state create chiamando il <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> metodo o il <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metodo con un `target` pari a.<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  

### <a name="on-macos-and-linux-systems"></a>Nei sistemi Linux e macOS

In macOS e Linux, il blocco di ambiente del processo corrente include le variabili di ambiente seguenti:

- Tutte le variabili di ambiente fornite dal processo padre che l'ha creata. Per le applicazioni .NET avviate da una shell, incluse tutte le variabili di ambiente definite nella shell.

- Tutte le variabili aggiunte per il blocco process mentre il processo è in esecuzione tramite la chiamata al <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> metodo o il <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metodo con un `target` pari a <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Queste variabili di ambiente è persist finché non termina l'applicazione .NET.  

.NET core su macOS e Linux non supporta le variabili di ambiente per computer o per singolo utente.   
  
## Examples  
 L'esempio seguente usa il <xref:System.Environment.GetEnvironmentVariable%2A> metodo per recuperare il `windir` variabile di ambiente, che contiene il percorso della directory Windows.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 Nell'esempio seguente tenta di recuperare il valore della variabile di ambiente denominata `Test1` dal blocco di ambiente del processo. Se la variabile non esiste, l'esempio crea relativo e recupera il valore. L'esempio visualizza il valore della variabile. Se nell'esempio viene creata la variabile, chiama anche il <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> con ogni membro del metodo di <xref:System.EnvironmentVariableTarget> enumerazione per stabilire che la variabile può essere recuperata solo dal blocco di ambiente processo corrente. Infine, se nell'esempio viene creata la variabile, la Elimina.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non ha l'autorizzazione richiesta per eseguire questa operazione.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">la possibilità di leggere il valore di <paramref name="variable" />. Enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String, target As EnvironmentVariableTarget) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string * EnvironmentVariableTarget -&gt; string" Usage="System.Environment.GetEnvironmentVariable (variable, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">Nome di una variabile di ambiente.</param>
        <param name="target">Uno dei valori di <see cref="T:System.EnvironmentVariableTarget" />.</param>
        <summary>Recupera il valore di una variabile di ambiente dal processo corrente o dalla chiave del Registro del sistema operativo Windows per l'utente corrente o per il computer locale.</summary>
        <returns>Valore della variabile di ambiente specificata nei parametri <paramref name="variable" /> e <paramref name="target" /> oppure <see langword="null" /> se la variabile di ambiente non viene trovata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks 

Per recuperare tutte le variabili di ambiente con i rispettivi valori, chiamare il <xref:System.Environment.GetEnvironmentVariables%2A> (metodo).  
  
I nomi delle variabili di ambiente sono tra maiuscole e minuscole in Linux e macOS, ma non sono tra maiuscole e minuscole in Windows. 

### <a name="on-windows-systems"></a>Nei sistemi Windows

In Windows, il `target` parametro specifica se la variabile di ambiente viene recuperata dal processo corrente o dalla chiave del Registro di sistema del sistema operativo Windows per l'utente corrente o computer locale. Tutte le variabili di ambiente per ogni utente e per computer vengono copiate automaticamente nel blocco di ambiente del processo corrente, come altre variabili di ambiente che sono disponibili per il processo padre che ha creato il processo di .NET. Tuttavia, le variabili di ambiente aggiunto solo al blocco di ambiente del processo corrente tramite la chiamata al <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> (metodo) o il <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metodo con un `target` pari a <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> rimangono valide solo per la durata del processo.  
  
### <a name="on-macos-and-linux-systems"></a>Nei sistemi Linux e macOS

In macOS e Linux, il `GetEnvironmentVariable(String, EnvironmentVariableTarget)` metodo supporta un `target` pari a <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithtype> solo. Le chiamate con un `target` valore del <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithtype> oppure <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithtype> non sono supportati e restituire `null`. 

Variabili di ambiente per ogni processo sono:

- Quelli ereditati dal processo padre, in genere la shell usata per richiamare `dotnet.exe` o per avviare l'applicazione .NET.

- Quelle definite tramite la chiamata ai <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> metodo o il <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metodo con un `target` pari a <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Queste variabili di ambiente vengono mantenute solo fino il `dotnet` Termina processo o l'applicazione .NET.   
  
## Examples  
 L'esempio seguente crea le variabili di ambiente per le destinazioni di processo, utenti e computer, controlla se il Registro di sistema operativo contiene le variabili di ambiente utente e computer, dopodiché Elimina le variabili di ambiente.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> non è un valore valido di <see cref="T:System.EnvironmentVariableTarget" />.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non ha l'autorizzazione richiesta per eseguire questa operazione.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">la possibilità di leggere il valore del <paramref name="variable" /> se <paramref name="target" /> viene <see cref="F:System.EnvironmentVariableTarget.Process" /> (enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), 
oppure 
per l'accesso completo alle variabili di ambiente se <paramref name="target" /> viene <see cref="F:System.EnvironmentVariableTarget.User" /> oppure <see cref="F:System.EnvironmentVariableTarget.Machine" /> (enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariables">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera tutti i nomi delle variabili di ambiente e i rispettivi valori.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables();" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : unit -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera tutti i nomi delle variabili di ambiente e i rispettivi valori dal processo corrente.</summary>
        <returns>Dizionario contenente tutti i nomi delle variabili di ambiente e i rispettivi valori, se presenti; in caso contrario, se non viene trovata alcuna variabile di ambiente, verrà restituito un dizionario vuoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I nomi e valori per le variabili di ambiente vengono archiviati come coppie chiave-valore nell'oggetto restituito <xref:System.Collections.IDictionary>.  
  
### <a name="on-windows-systems"></a>Nei sistemi Windows

Nei sistemi Windows, il `GetEnvironmentVariables` metodo restituisce le variabili di ambiente seguenti:
  
- Tutti i computer le variabili di ambiente che vengono definite al momento della che creazione, il processo con i rispettivi valori.  
  
- Tutte le variabili di ambiente per ogni utente che vengono definite al momento il processo viene creato, insieme ai relativi valori.  

- Tutte le variabili ereditate dal processo padre da cui è stata avviata o aggiunto per il blocco process durante l'esecuzione del processo dell'applicazione .NET. Le variabili di ambiente vengono aggiunti durante il processo di esecuzione tramite la chiamata al <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> metodo o il <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metodo con un `target` pari a <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  

### <a name="on-macos-and-linux-systems"></a>Nei sistemi Linux e macOS

In MacOS e Linux, il `GetEnvironmentVariables` metodo recupera il nome e il valore di tutte le variabili di ambiente che vengono ereditati dal processo padre che ha avviato la `dotnet` definiti nell'ambito del processo o che il `dotnet` elabora se stesso. Una volta il `dotnet` processo termina, queste variabili di ambiente quest'ultimo cessa di esistere. 

.NET core non supporta le variabili di ambiente per computer o per singolo utente.   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Environment.GetEnvironmentVariables%2A> (metodo).  
  
 [!code-cpp[Environment.GetEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CPP/getenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.GetEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CS/getenvironmentvariables.cs#1)]
 [!code-vb[Environment.GetEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetEnvironmentVariables/VB/getenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante non ha l'autorizzazione richiesta per eseguire questa operazione.</exception>
        <exception cref="T:System.OutOfMemoryException">La memoria del buffer è insufficiente.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">la possibilità di leggere i nomi e valori delle variabili di ambiente. Enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables (EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables(valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables (target As EnvironmentVariableTarget) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables(EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : EnvironmentVariableTarget -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="target">Uno dei valori di <see cref="T:System.EnvironmentVariableTarget" />.</param>
        <summary>Recupera tutti i nomi delle variabili di ambiente e i rispettivi valori dal processo corrente o dalla chiave del Registro del sistema operativo Windows per l'utente corrente o per il computer locale.</summary>
        <returns>Dizionario contenente tutti i nomi delle variabili di ambiente e i rispettivi valori ricavati dall'origine specificata dal parametro <paramref name="target" />, se presenti; in caso contrario, se non viene trovata alcuna variabile di ambiente, verrà restituito un dizionario vuoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

I nomi e valori delle variabili di ambiente vengono archiviati come coppie chiave/valore nell'oggetto restituito <xref:System.Collections.IDictionary> oggetto.  

### <a name="on-windows-systems"></a>Nei sistemi Windows

Nei sistemi Windows, il `target` parametro specifica se l'origine è il processo corrente, la chiave del Registro di sistema per l'utente corrente o la chiave del Registro di sistema per il computer locale.  

### <a name="on-macos-and-linux-systems"></a>Nei sistemi Linux e macOS

In macOS e Linux, solo una `target` pari a <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> è supportata. Le variabili di ambiente per ogni processo vengono ereditate dal processo padre (in genere la shell) usato per avviare il `dotnet` elaborare o definiti all'interno dell'ambito del `dotnet` elabora se stesso. Una volta il processo termina dotnet, queste variabili di ambiente quest'ultimo cessano di esistere.  

Variabili di ambiente per computer e utente non sono supportate. Oggetto `target` valore del <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> o <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> restituisce una matrice vuota.
  
## Examples  
 L'esempio seguente crea le variabili di ambiente per le destinazioni di processo, utenti e computer, controlla se il Registro di sistema operativo contiene le variabili di ambiente utente e computer, dopodiché Elimina le variabili di ambiente.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta per eseguire questa operazione relativamente al valore specificato per il parametro <paramref name="target" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> contiene un valore non valido.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">la possibilità di leggere i nomi e valori delle variabili di ambiente se <paramref name="target" /> viene <see cref="F:System.EnvironmentVariableTarget.Process" /> (enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), 
oppure 
per l'accesso completo alle variabili di ambiente se <paramref name="target" /> viene <see cref="F:System.EnvironmentVariableTarget.User" /> oppure <see cref="F:System.EnvironmentVariableTarget.Machine" /> (enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFolderPath">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene il percorso della cartella speciale di sistema identificata dall'enumerazione specificata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder -&gt; string" Usage="System.Environment.GetFolderPath folder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
      </Parameters>
      <Docs>
        <param name="folder">Costante enumerata che identifica una cartella speciale di sistema.</param>
        <summary>Ottiene il percorso della cartella speciale di sistema identificata dall'enumerazione specificata.</summary>
        <returns>Percorso della cartella speciale di sistema specificata, se tale cartella è fisicamente presente nel computer. In caso contrario, stringa vuota ("").  
  
Una cartella non è fisicamente esistente se non è stata creata dal sistema operativo o se è stata eliminata, oppure se si tratta di una directory virtuale, come Risorse del computer, che non corrisponde a un percorso fisico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo recupera il percorso in una cartella speciale di sistema, ad esempio i file di programma, programmi, sistema o avvio, che può essere utilizzato per accedere alle informazioni comuni. Cartelle speciali vengono impostate per impostazione predefinita dal sistema oppure in modo esplicito dall'utente, quando si installa una versione di Windows.  
  
 Il `folder` parametro indica la cartella speciale per il recupero e deve essere uno dei valori nel <xref:System.Environment.SpecialFolder> enumerazione; qualsiasi altro valore genera un'eccezione.  
  
 Per altre informazioni sulle cartelle speciali, vedere la [CSIDL eventualmente incluse](http://go.microsoft.com/fwlink/?LinkId=116664) argomento di valori.  
  
   
  
## Examples  
 L'esempio seguente illustra come usare il <xref:System.Environment.GetFolderPath%2A> metodo per restituire e visualizzare il percorso associato di `folder` parametro.  
  
 [!code-cpp[Environment.GetFolderPath#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetFolderPath/CPP/getfolderpath.cpp#1)]
 [!code-csharp[Environment.GetFolderPath#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetFolderPath/CS/getfolderpath.cs#1)]
 [!code-vb[Environment.GetFolderPath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetFolderPath/VB/getfolderpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="folder" /> non è un membro di <see cref="T:System.Environment.SpecialFolder" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La piattaforma corrente non è supportata.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni presenti nel percorso stesso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder, Environment.SpecialFolderOption option);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder, valuetype System.Environment/SpecialFolderOption option) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder,System.Environment.SpecialFolderOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder, option As Environment.SpecialFolderOption) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder, Environment::SpecialFolderOption option);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder * Environment.SpecialFolderOption -&gt; string" Usage="System.Environment.GetFolderPath (folder, option)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
        <Parameter Name="option" Type="System.Environment+SpecialFolderOption" />
      </Parameters>
      <Docs>
        <param name="folder">Costante enumerata che identifica una cartella speciale di sistema.</param>
        <param name="option">Specifica opzioni da usare per l'accesso a una cartella speciale.</param>
        <summary>Ottiene il percorso della cartella speciale di sistema identificata dall'enumerazione specificata e usa un'opzione specificata per l'accesso a cartelle speciali.</summary>
        <returns>Percorso della cartella speciale di sistema specificata, se tale cartella è fisicamente presente nel computer. In caso contrario, stringa vuota ("").  
  
Una cartella non è fisicamente esistente se non è stata creata dal sistema operativo o se è stata eliminata, oppure se si tratta di una directory virtuale, come Risorse del computer, che non corrisponde a un percorso fisico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo recupera il percorso in una cartella speciale di sistema, ad esempio i file di programma, programmi, sistema o avvio, che può essere utilizzato per accedere alle informazioni comuni. Cartelle speciali vengono impostate per impostazione predefinita dal sistema oppure in modo esplicito dall'utente, quando si installa una versione di Windows.  
  
 Il `folder` parametro indica la cartella speciale per il recupero e deve essere uno dei valori nel <xref:System.Environment.SpecialFolder> enumerazione; qualsiasi altro valore genera un'eccezione.  
  
 Per altre informazioni sulle cartelle speciali, vedere la [CSIDL eventualmente incluse](http://go.microsoft.com/fwlink/?LinkId=116664) argomento di valori.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="folder" /> non è un membro di <see cref="T:System.Environment.SpecialFolder" /></exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.PlatformNotSupportedException" />
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni presenti nel percorso stesso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.Environment.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una matrice di stringa che contiene i nomi delle unità logiche sul computer corrente.</summary>
        <returns>Matrice di stringhe in cui ogni elemento contiene il nome di un'unità logica. Ad esempio, se il disco rigido del computer è la prima unità logica, il primo elemento restituito è "C:\\".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come visualizzare le unità logiche del computer corrente usando il <xref:System.Environment.GetLogicalDrives%2A> (metodo).  
  
 [!code-cpp[Environment.GetLogicalDrives#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetLogicalDrives/CPP/getlogicaldrives.cpp#1)]
 [!code-csharp[Environment.GetLogicalDrives#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetLogicalDrives/CS/getlogicaldrives.cs#1)]
 [!code-vb[Environment.GetLogicalDrives#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetLogicalDrives/VB/getlogicaldrives.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Si è verificato un errore di I/O.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non ha le autorizzazioni richieste.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">per l'accesso completo alla risorsa protetta da questa autorizzazione. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public static bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Environment.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Environment.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se si sta scaricando il dominio applicazione corrente o se è in corso la chiusura di Common Language Runtime (CLR).</summary>
        <value>
          <see langword="true" /> se il dominio dell'applicazione corrente è in fase di scaricamento o Common Language Runtime è in fase di chiusura; in caso contrario, <see langword="false." /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando CLR viene scaricato un dominio dell'applicazione, esegue i finalizzatori per tutti gli oggetti che hanno un metodo del finalizzatore in tale dominio dell'applicazione. Quando CLR viene arrestato, viene avviato il thread del finalizzatore in tutti gli oggetti che hanno un metodo del finalizzatore. Il <xref:System.Environment.HasShutdownStarted%2A> restituisce proprietà `true` solo dopo che è stato avviato il thread del finalizzatore. Quando la proprietà restituisce `true`, è possibile determinare se un dominio dell'applicazione è in corso lo scaricamento o Common Language Runtime stesso è in corso l'arresto chiamando il <xref:System.AppDomain.IsFinalizingForUnload%2A?displayProperty=nameWithType> (metodo). Questo metodo restituisce `true` se vengono chiamati i finalizzatori in quanto lo scaricamento del dominio applicazione o `false` se CLR viene arrestato verso il basso.  
  
 Il <xref:System.Environment.HasShutdownStarted%2A> restituisce proprietà `false` se il thread del finalizzatore non è stato avviato.  
  
 Usando questa proprietà, è possibile determinare se si desidera accedere alle variabili statiche nel codice di finalizzazione. Se un dominio dell'applicazione o il CLR è in corso l'arresto, sarà possibile accedere in modo affidabile qualsiasi oggetto che ha un metodo di finalizzazione e che fa riferimento un campo statico. Questo avviene perché questi oggetti potrebbero essere già stati finalizzati.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsFinalizingForUnload" />
      </Docs>
    </Member>
    <Member MemberName="Is64BitOperatingSystem">
      <MemberSignature Language="C#" Value="public static bool Is64BitOperatingSystem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitOperatingSystem" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitOperatingSystem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitOperatingSystem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitOperatingSystem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitOperatingSystem : bool" Usage="System.Environment.Is64BitOperatingSystem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determina se il sistema operativo corrente è un sistema operativo a 64 bit.</summary>
        <value>
          <see langword="true" /> se il sistema operativo è a 64 bit. In caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Is64BitProcess">
      <MemberSignature Language="C#" Value="public static bool Is64BitProcess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitProcess" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitProcess As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitProcess { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitProcess : bool" Usage="System.Environment.Is64BitProcess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determina se il processo corrente è un processo a 64 bit.</summary>
        <value>
          <see langword="true" /> se il processo è a 64 bit; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public static string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Environment.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome NetBIOS del computer locale.</summary>
        <value>Stringa che contiene il nome di questo computer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il nome del computer viene stabilito all'avvio del sistema quando il nome viene letto dal Registro di sistema. Se questo computer è un nodo in un cluster, viene restituito il nome del nodo.  
  
   
  
## Examples  
 Nell'esempio seguente visualizza il nome del computer che esegue l'esempio di codice. (Il nome del computer viene omesso nell'output di esempio per motivi di sicurezza).  
  
 [!code-cpp[environment.machinename#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.MachineName/CPP/machinename.cpp#1)]
 [!code-csharp[environment.machinename#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.MachineName/CS/machinename.cs#1)]
 [!code-vb[environment.machinename#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.MachineName/VB/machinename.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Non è possibile ottenere il nome del computer.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">accesso in lettura alla variabile di ambiente COMPUTERNAME. Enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public static string NewLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ NewLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string" Usage="System.Environment.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la stringa della nuova riga definita per questo ambiente.</summary>
        <value>Stringa che contiene "\r\n" per le piattaforme non Unix o "\n" per le piattaforme Unix.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore della proprietà <xref:System.Environment.NewLine%2A> è una costante personalizzata in modo specifico per la piattaforma corrente e l'implementazione di .NET Framework. Per altre informazioni sui caratteri di escape nel valore della proprietà, vedere [caratteri di escape](~/docs/standard/base-types/character-escapes-in-regular-expressions.md).  
  
 La funzionalità fornita da <xref:System.Environment.NewLine%2A> è spesso il significato di termini nuova, avanzamento riga, interruzione di riga, ritorno a capo, CRLF, e fine della riga.  
  
 <xref:System.Environment.NewLine%2A> può essere usato in combinazione con il supporto di nuova riga specifiche del linguaggio, ad esempio i caratteri di escape '\r' e '\n' in Microsoft c# e C/C++, o `vbCrLf` in Microsoft Visual Basic.  
  
 <xref:System.Environment.NewLine%2A> viene aggiunto automaticamente al testo elaborato dal <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> e <xref:System.Text.StringBuilder.AppendLine%2A?displayProperty=nameWithType> metodi.  
  
   
  
## Examples  
 Nell'esempio seguente mostra tre righe separate da caratteri di nuova riga.  
  
 [!code-cpp[environment.newline#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.NewLine/CPP/newline.cpp#1)]
 [!code-csharp[environment.newline#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.NewLine/CS/newline.cs#1)]
 [!code-vb[environment.newline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.NewLine/VB/newline.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSVersion">
      <MemberSignature Language="C#" Value="public static OperatingSystem OSVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.OperatingSystem OSVersion" />
      <MemberSignature Language="DocId" Value="P:System.Environment.OSVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSVersion As OperatingSystem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property OperatingSystem ^ OSVersion { OperatingSystem ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OSVersion : OperatingSystem" Usage="System.Environment.OSVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.OperatingSystem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.OperatingSystem" /> che contiene l'identificatore e il numero di versione della piattaforma corrente.</summary>
        <value>Oggetto contenente l'identificatore e il numero di versione della piattaforma.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  A partire da Windows 8, il <xref:System.Environment.OSVersion%2A> proprietà restituisce gli stessi numeri di versione principale e secondaria per tutte le piattaforme Windows. Pertanto, non è consigliabile che recuperare il valore di questa proprietà per determinare la versione del sistema operativo.  
  
 In genere, il <xref:System.Environment.OSVersion%2A> proprietà viene usata per assicurarsi che un'app è in esecuzione in una versione di base di un sistema operativo in cui è stata introdotta una determinata funzionalità. Quando questo è il caso, è consigliabile eseguire un controllo della versione verificando se la versione corrente del sistema operativo restituito dal <xref:System.Environment.OSVersion%2A> proprietà è lo stesso nome, o maggiore, la versione del sistema operativo di base. Per altre informazioni, vedere il <xref:System.Version> argomento relativo alla classe.  
  
 Tramite Windows 8, il <xref:System.Environment.OSVersion%2A> viene restituita la versione indicata in di Windows [GetVersionEx](http://msdn.microsoft.com/library/windows/desktop/ms724451\(v=vs.85\).aspx) (funzione). Per un elenco di versioni di sistema operativo desktop Windows e i relativi numeri di versione, vedere [versione del sistema operativo](https://msdn.microsoft.com/library/windows/desktop/ms724832.aspx) in Windows Dev Center.  
  
> [!NOTE]
>  Il <xref:System.Environment.OSVersion%2A> proprietà segnala lo stesso numero di versione (6.2.0.0) per entrambi [!INCLUDE[win8](~/includes/win8-md.md)] e [!INCLUDE[win81](~/includes/win81-md.md)] e lo stesso numero di versione principale e secondaria per Windows 10.  
  
 In alcuni casi, il <xref:System.Environment.OSVersion%2A> proprietà potrebbe non restituire la versione del sistema operativo che corrisponde alla versione specificata per la funzionalità in modalità compatibilità dei programmi Windows.  
  
   
  
## Examples  
 L'esempio seguente mostra l'identificatore di piattaforma e il numero di versione del computer che esegue l'esempio di codice.  
  
 [!code-cpp[environment.osversion#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.OSVersion/CPP/osversion.cpp#1)]
 [!code-csharp[environment.osversion#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.OSVersion/CS/osversion.cs#1)]
 [!code-vb[environment.osversion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.OSVersion/VB/osversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa proprietà non è riuscita a ottenere la versione del sistema.  
  
oppure 
L'identificatore di piattaforma ottenuto non è un membro di <see cref="T:System.PlatformID" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessorCount">
      <MemberSignature Language="C#" Value="public static int ProcessorCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ProcessorCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ProcessorCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessorCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ProcessorCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorCount : int" Usage="System.Environment.ProcessorCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di processori sul computer corrente.</summary>
        <value>Intero con segno a 32 bit che specifica il numero di processori sul computer corrente. Non è prevista alcuna impostazione predefinita. Se il computer corrente contiene più gruppi di processori, questa proprietà restituisce il numero di processori logici disponibili per l'uso da parte di Common Language Runtime (CLR).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per altre informazioni sui gruppi di processori e processori logici, vedere [gruppi di processori](http://msdn.microsoft.com/library/windows/desktop/dd405503.aspx).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Environment.ProcessorCount%2A> proprietà.  
  
 [!code-cpp[environment.processorcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.processorcount/CPP/pc.cpp#1)]
 [!code-csharp[environment.processorcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.processorcount/CS/pc.cs#1)]
 [!code-vb[environment.processorcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.processorcount/VB/pc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea, modifica o elimina una variabile di ambiente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">Nome di una variabile di ambiente.</param>
        <param name="value">Valore da assegnare all'oggetto <c>variable</c>.</param>
        <summary>Crea, modifica o elimina una variabile di ambiente archiviata nel processo corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo è equivalente alla chiamata di <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> rapporto di overload con il valore <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> per il `target` argomento.  
  
 Se il `value` dell'argomento non è vuoto (vedere la discussione dell'eliminazione di una variabile di ambiente più avanti in questa sezione per la definizione di un valore vuoto) e la variabile di ambiente denominata dal `variable` parametro non esiste, l'ambiente viene creata e assegnata il contenuto della variabile `value`. Se esiste, il relativo valore viene modificato. Poiché la variabile di ambiente è definita nel blocco di ambiente del solo processo corrente, non viene mantenuto dopo il processo è terminato.  
  
 Se `variable` contiene un valore esadecimale non iniziale carattere zero, i caratteri prima che il carattere zero vengono considerati il nome di variabile di ambiente e tutti i caratteri successivi vengono ignorati.  
  
 Se `value` contiene un valore esadecimale non iniziale carattere zero, i caratteri prima che il carattere zero vengono assegnati alla variabile di ambiente e tutti i caratteri successivi vengono ignorati.  
  
 Se `value` è vuoto e la variabile di ambiente denominata da `variable` esiste, viene eliminata la variabile di ambiente. Se `variable` non esiste, verrà generato alcun errore anche se non è possibile eseguire l'operazione. `value` viene considerato vuoto in presenza delle condizioni seguenti:  
  
-   Si tratta di `null`.  
  
-   Si tratta di <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   È costituito da un singolo carattere il cui valore è u+0000.  
  
   
  
## Examples  
 Nell'esempio seguente verifica se una variabile di ambiente denominata `APPDOMAIN` esiste nel processo corrente. In caso contrario, lo crea e imposta il valore su "True". Se il valore della `APPDOMAIN` variabile di ambiente è "True", viene chiamato il `Message.Display` metodo in un nuovo dominio applicazione. In caso contrario, viene eseguito il `Message.Display` (metodo) nel dominio dell'applicazione corrente.  
  
 [!code-csharp[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/cs/setenvironmentvariable1.cs#1)]
 [!code-vb[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/vb/setenvironmentvariable1.vb#1)]  
  
 Se si esegue l'esempio per la prima volta, nella console viene visualizzato il messaggio "Durante l'esecuzione nel dominio dominio 2". Se si imposta la variabile di ambiente dalla riga di comando usando il comando:  
  
 `Set AppDomain=False`  
  
 Nell'esempio viene visualizzato il messaggio "l'esecuzione nel dominio *exeName*.exe", dove *exeName* è il nome del file eseguibile.  
  
 Nell'esempio seguente tenta di recuperare il valore della variabile di ambiente denominata `Test1` dal blocco di ambiente del processo. Se la variabile non esiste, l'esempio crea la variabile e recupera il relativo valore. L'esempio visualizza il valore della variabile. Se nell'esempio viene creata la variabile, chiama anche il <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> con ogni membro del metodo di <xref:System.EnvironmentVariableTarget> enumerazione per stabilire che la variabile può essere recuperata solo dal blocco di ambiente processo corrente. Infine, se nell'esempio viene creata la variabile, la Elimina.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="variable" /> contiene una stringa di lunghezza zero, un carattere iniziale esadecimale uguale a zero (0x00) o il segno di uguale ("=").  
  
oppure 
la lunghezza del parametro <paramref name="variable" /> o del parametro <paramref name="value" /> è maggiore o uguale a 32.767 caratteri.  
  
oppure 
Si è verificato un errore durante l'esecuzione dell'operazione.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non ha l'autorizzazione richiesta per eseguire questa operazione.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">per l'accesso completo alle variabili di ambiente. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </Member>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String, target As EnvironmentVariableTarget)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string * EnvironmentVariableTarget -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">Nome di una variabile di ambiente.</param>
        <param name="value">Valore da assegnare all'oggetto <c>variable</c>.</param>
        <param name="target">Uno dei valori di enumerazione che specifica la posizione della variabile di ambiente.</param>
        <summary>Crea, modifica o elimina una variabile di ambiente archiviata nel processo corrente o nella chiave del Registro del sistema operativo Windows riservata all'utente corrente o al computer locale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Il <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metodo consente di definire una variabile di ambiente che sia disponibile per il processo corrente (la <xref:System.EnvironmentVariableTarget.Process> valore). Le variabili di ambiente che sono univoche per il blocco di ambiente corrente del processo mantenute solo fino alla fine del processo.

Inoltre, nei sistemi Windows, solo il <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metodo consente di definire una variabile di ambiente che è disponibile per tutti i processi che vengono eseguiti in un computer (la <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> valore) e a tutti i processi eseguiti da un utente (il <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> valore). Variabili di ambiente per computer e per utente vengono copiate nel blocco di ambiente del processo corrente.  
 
In .NET Core in maxOS e i sistemi Linux, le chiamate al <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metodo con un valore di <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> valore) o <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> vengono ignorati. 
  
 Se il `value` dell'argomento non è vuoto (vedere la discussione dell'eliminazione di una variabile di ambiente più avanti in questa sezione per la definizione di un valore vuoto) e la variabile di ambiente denominata dal `variable` argomento inesistente, l'ambiente viene creata e assegnata il contenuto della variabile `value`.  Se esiste, il relativo valore viene modificato.  
  
 Se `variable` contiene un valore esadecimale non iniziale carattere zero, i caratteri prima che il carattere zero vengono considerati il nome di variabile di ambiente e tutti i caratteri successivi vengono ignorati.  
  
 Se `value` contiene un valore esadecimale non iniziale carattere zero, i caratteri prima che il carattere zero vengono assegnati alla variabile di ambiente e tutti i caratteri successivi vengono ignorati.  
  
 Se `value` è vuoto e la variabile di ambiente denominata da `variable` esiste, viene eliminata la variabile di ambiente. `value` viene considerato vuoto in presenza delle condizioni seguenti:  
  
-   Si tratta di `null`.  
  
-   Si tratta di <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   È costituito da un singolo carattere il cui valore è u+0000.  
  
 Se `variable` non esiste, verrà generato alcun errore anche se non è possibile eseguire l'operazione. Prestare attenzione quando `target` è <xref:System.EnvironmentVariableTarget.Machine>, in quanto è possibile eliminare accidentalmente una variabile di ambiente che interessa tutto il computer locale, non solo il processo corrente o l'utente.  

### <a name="environmentvariabletargetmachine-and-environmentvariabletargetuser-on-windows-systems"></a>EnvironmentVariableTarget.Machine ed EnvironmentVariableTarget.User nei sistemi Windows

Se `target` è <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, la variabile di ambiente viene archiviata nella chiave HKEY_CURRENT_USER\Environment del Registro di sistema del computer locale. Viene inoltre copiato a istanze di Esplora File che sono in esecuzione come utente corrente. La variabile di ambiente viene quindi ereditata da tutti i nuovi processi che l'utente viene avviata da Esplora File.  
  
 Analogamente, se `target` è <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, la variabile di ambiente viene archiviata nella chiave HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment. del Registro di sistema del computer locale. Viene inoltre copiato a tutte le istanze di Esplora File. La variabile di ambiente viene quindi ereditata da tutti i nuovi processi avviati da Esplora File.  
  
 Se `target` viene <xref:System.EnvironmentVariableTarget.User> oppure <xref:System.EnvironmentVariableTarget.Machine>, le altre applicazioni ricevono una notifica dell'operazione di impostazione tramite un Windows `WM_SETTINGCHANGE` messaggio.  
  
 Se `target` viene <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> oppure <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, è consigliabile che la lunghezza di `value` da meno di 2048 caratteri.  
  
## Examples  
 L'esempio seguente crea le variabili di ambiente per il <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, e <xref:System.EnvironmentVariableTarget.Machine> ha come destinazione, viene controllato se il Registro di sistema operativo contiene l'utente e le variabili di ambiente del computer, quindi Elimina l'ambiente variabili.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="variable" /> contiene una stringa di lunghezza zero, un carattere iniziale esadecimale uguale a zero (0x00) o il segno di uguale ("=").  
  
oppure 
la lunghezza del parametro <paramref name="variable" /> è maggiore o uguale a 32.767 caratteri.  
  
oppure 
 <paramref name="target" /> non è un membro dell'enumerazione <see cref="T:System.EnvironmentVariableTarget" />.  
  
oppure 
 Il parametro <paramref name="target" /> è <see cref="F:System.EnvironmentVariableTarget.Machine" /> o <see cref="F:System.EnvironmentVariableTarget.User" /> e la lunghezza del parametro <paramref name="variable" /> è maggiore o uguale a 255.  
  
oppure 
 il parametro <paramref name="target" /> è <see cref="F:System.EnvironmentVariableTarget.Process" /> e la lunghezza del parametro <paramref name="value" /> è maggiore o uguale a 32.767 caratteri.  
  
oppure 
Si è verificato un errore durante l'esecuzione dell'operazione.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non ha l'autorizzazione richiesta per eseguire questa operazione.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">per l'accesso completo alle variabili di ambiente. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public static string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Environment.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Environment.StackTrace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene informazioni sull'analisi dello stack corrente.</summary>
        <value>Stringa che contiene informazioni sull'analisi dello stack. Il valore può essere <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Environment.StackTrace%2A> elenchi di proprietà di chiamate al metodo in ordine cronologico inverso, vale a dire, la chiamata al metodo più recente è descritta prima di tutto e viene elencata una riga delle informazioni di traccia dello stack per ogni chiamata al metodo nello stack. Tuttavia, il <xref:System.Environment.StackTrace%2A> proprietà potrebbe non segnalare il numero di chiamate di metodo come previsto a causa di trasformazioni del codice che si verificano durante l'ottimizzazione.  
  
> [!NOTE]
>  Per ottenere una visualizzazione gerarchica delle informazioni di traccia dello stack dalla classe, usare il <xref:System.Diagnostics.StackTrace> classe.  
  
 Il <xref:System.Environment.StackTrace%2A> proprietà formatta le informazioni di traccia dello stack per ogni chiamata al metodo come indicato di seguito:  
  
 "nella `FullClassName`.`MethodName` (`MethodParams`) nel `FileName` : riga `LineNumber` "  
  
 Il valore letterale "non operativi" è preceduto da tre spazi e l'intera sottostringa che inizia con "in" viene omesso se non sono disponibili i simboli di debug. I segnaposto `FullClassName`, `MethodName`, `MethodParams`, `FileName`, e `LineNumber`, vengono sostituiti dai valori effettivi e sono definiti come segue:  
  
 FullClassName  
 Il nome completo della classe, incluso lo spazio dei nomi.  
  
 `MethodName`  
 Nome del metodo.  
  
 `MethodParams`  
 Elenco di coppie nome/tipo del parametro. Ogni coppia è separato da una virgola (","). Queste informazioni viene omesso se `MethodName` non accetta parametri.  
  
 `FileName`  
 Il nome dell'origine del file in cui il `MethodName` metodo viene dichiarato. Queste informazioni viene omesso se non sono disponibili i simboli di debug.  
  
 `LineNumber`  
 Il numero di riga `FileName` che contiene il codice sorgente da `MethodName` per l'istruzione che è nello stack di chiamate. Queste informazioni viene omesso se non sono disponibili i simboli di debug.  
  
 Il <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> stringa consente di terminare ogni riga della traccia dello stack.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Environment.StackTrace%2A> proprietà.  
  
 [!code-cpp[environment.stacktrace#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.StackTrace/CPP/stacktrace.cpp#1)]
 [!code-csharp[environment.stacktrace#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.StackTrace/CS/stacktrace.cs#1)]
 [!code-vb[environment.stacktrace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.StackTrace/VB/stacktrace.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">per l'accesso completo alla risorsa protetta dall'autorizzazione. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemDirectory">
      <MemberSignature Language="C#" Value="public static string SystemDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string SystemDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SystemDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemDirectory : string" Usage="System.Environment.SystemDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il percorso completo della directory di sistema.</summary>
        <value>Stringa che contiene un percorso di directory.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un esempio del valore restituito è la stringa "C:\Winnt\System32.".  
  
   
  
## Examples  
 Nell'esempio seguente viene visualizzata la directory di sistema del computer che esegue l'esempio di codice. (La directory di sistema viene omesso nell'output di esempio per motivi di sicurezza).  
  
 [!code-cpp[environment.systemdirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.SystemDirectory/CPP/systemdirectory.cpp#1)]
 [!code-csharp[environment.systemdirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.SystemDirectory/CS/systemdirectory.cs#1)]
 [!code-vb[environment.systemdirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.SystemDirectory/VB/systemdirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni presenti nel percorso stesso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemPageSize">
      <MemberSignature Language="C#" Value="public static int SystemPageSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 SystemPageSize" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemPageSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemPageSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int SystemPageSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemPageSize : int" Usage="System.Environment.SystemPageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di byte nella pagina di memoria del sistema operativo.</summary>
        <value>Numero di byte in una pagina di memoria di sistema.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Queste informazioni possono essere utili quando si determina se utilizzare il <xref:System.IO.MemoryMappedFiles.MemoryMappedFileOptions.DelayAllocatePages?displayProperty=nameWithType> opzione quando si lavora con file mappati alla memoria.  
  
 In Windows, questo valore è il `dwPageSize` membro nel `SYSTEM_INFO` struttura.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Per accedere alle variabili di ambiente del sistema e utente. Eccezione associata: 
 <see cref="P:System.Security.SecurityException.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TickCount">
      <MemberSignature Language="C#" Value="public static int TickCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 TickCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int TickCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount : int" Usage="System.Environment.TickCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di millisecondi trascorsi dall'avvio del sistema.</summary>
        <value>Intero con segno a 32 bit contenente il tempo espresso in millisecondi che sono trascorsi dall'ultimo avvio del computer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa proprietà è derivato dal timer di sistema e viene archiviato come un intero con segno a 32 bit. Si noti che, poiché deriva da timer di sistema, la risoluzione del <xref:System.Environment.TickCount%2A> proprietà è limitata per la risoluzione del timer di sistema, che in genere è compreso nell'intervallo di 10 a 16 millisecondi.  
  
> [!IMPORTANT]
>  Perché il valore del <xref:System.Environment.TickCount%2A> valore della proprietà è un intero con segno a 32 bit, se il sistema viene eseguito in modo continuo, <xref:System.Environment.TickCount%2A> compreso tra zero e incrementa <xref:System.Int32.MaxValue?displayProperty=nameWithType> circa 24,9 giorni, quindi passare alla <xref:System.Int32.MinValue?displayProperty=nameWithType>, che è un numero negativo, quindi incremento su zero durante i prossimi giorni 24,9. È possibile risolvere questo problema tramite la chiamata di Windows [GetTickCount](https://msdn.microsoft.com/library/windows/desktop/ms724408.aspx) funzione, che viene reimpostato su zero dopo circa 49 giorni oppure chiamando il [GetTickCount64](https://msdn.microsoft.com/library/windows/desktop/ms724411.aspx) (funzione).  
  
 <xref:System.Environment.TickCount%2A> è diverso dal <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType> proprietà, ovvero il numero di intervalli di 100 nanosecondi trascorsi dal 1/1 / ° gennaio 0001 12:00 am.  
  
 Usare il <xref:System.DateTime.Now%2A?displayProperty=nameWithType> proprietà per ottenere la data locale corrente e l'ora nel computer.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come recuperare l'intervallo dei valori restituiti da positivo il <xref:System.Environment.TickCount%2A> proprietà. Il <xref:System.Environment.TickCount%2A> proprietà cicli tra <xref:System.Int32.MinValue?displayProperty=nameWithType>, ovvero un numero negativo, e <xref:System.Int32.MaxValue?displayProperty=nameWithType> ogni 49,8 giorni. Questo esempio di codice rimuove il bit di segno per ottenere un numero non negativo che passa ciclicamente da zero e <xref:System.Int32.MaxValue> ogni 24,9 giorni.  
  
 [!code-cpp[environment.tickcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.TickCount/CPP/tickcount.cpp#1)]
 [!code-csharp[environment.tickcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.TickCount/CS/tickcount.cs#1)]
 [!code-vb[environment.tickcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.TickCount/VB/tickcount.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDomainName">
      <MemberSignature Language="C#" Value="public static string UserDomainName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserDomainName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserDomainName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserDomainName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserDomainName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserDomainName : string" Usage="System.Environment.UserDomainName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome del dominio di rete associato all'utente corrente.</summary>
        <value>Nome di dominio della rete associato all'utente corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le credenziali dell'account di dominio per un utente sono formattati come nome di dominio dell'utente, il '\\' carattere e il nome utente. Usare la <xref:System.Environment.UserDomainName%2A> proprietà da ottenere il nome del dominio dell'utente senza il nome utente e il <xref:System.Environment.UserName%2A> proprietà per ottenere il nome utente senza il nome di dominio.  Se il nome di dominio e nome utente di un utente sono CORPORATENETWORK\john, ad esempio il <xref:System.Environment.UserDomainName%2A> proprietà restituisce "CORPORATENETWORK".  
  
 Il <xref:System.Environment.UserDomainName%2A> proprietà tenta innanzitutto di ottenere il componente nome di dominio del nome dell'account di Windows per l'utente corrente. Se il tentativo ha esito negativo, questa proprietà tenta di ottenere il nome di dominio associato con il nome utente specificato per il <xref:System.Environment.UserName%2A> proprietà. Se tale tentativo ha esito negativo perché il computer host non è unito a un dominio, viene restituito il nome del computer host.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Il sistema operativo non supporta il recupero del nome del dominio di rete.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile recuperare il nome del dominio di rete.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">accesso in lettura alla variabile di ambiente USERDOMAIN. Enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserName" />
      </Docs>
    </Member>
    <Member MemberName="UserInteractive">
      <MemberSignature Language="C#" Value="public static bool UserInteractive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UserInteractive" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserInteractive" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserInteractive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UserInteractive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInteractive : bool" Usage="System.Environment.UserInteractive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il processo corrente viene eseguito in modalità interattiva utente.</summary>
        <value>
          <see langword="true" /> se il processo corrente viene eseguito in modalità interattiva utente; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Environment.UserInteractive%2A> proprietà report `false` per un processo di Windows o un servizio, ad esempio IIS in cui viene eseguito senza un'interfaccia utente. Se questa proprietà è `false`, non vengono visualizzate le finestre di dialogo modale o perché non vi è alcuna interfaccia utente grafica per l'utente può interagire con le finestre di messaggio.  
  
   
  
## Examples  
 Nell'esempio seguente indica se il processo corrente è in esecuzione in modalità interattiva utente.  
  
 [!code-cpp[Environment.UserInteractive#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserInteractive/CPP/userinteractive.cpp#1)]
 [!code-csharp[Environment.UserInteractive#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserInteractive/CS/userinteractive.cs#1)]
 [!code-vb[Environment.UserInteractive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserInteractive/VB/userinteractive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public static string UserName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserName : string" Usage="System.Environment.UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome utente della persona attualmente connessa al sistema operativo.</summary>
        <value>Il nome utente della persona che esegue l'accesso al sistema operativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare il <xref:System.Environment.UserName%2A> proprietà per identificare l'utente nel thread corrente, al sistema e applicazione per la sicurezza o accesso. Può anche essere utilizzato per personalizzare un'applicazione specifica per ogni utente.  
 
 In Windows il <xref:System.Environment.UserName%2A> proprietà esegue il wrapping di una chiamata a di Windows [GetUserName](http://msdn.microsoft.com/library/windows/desktop/ms724432.aspx) (funzione). Le credenziali dell'account di dominio per un utente sono formattati come nome di dominio dell'utente, il '\\' carattere e il nome utente. Usare la <xref:System.Environment.UserDomainName%2A> proprietà per ottenere il nome di dominio dell'utente e la <xref:System.Environment.UserName%2A> proprietà per ottenere il nome utente.  
 
 Nelle piattaforme Unix il <xref:System.Environment.UserName%2A> proprietà esegue il wrapping di una chiamata al `getpwuid_r` (funzione).
 
 Se un'applicazione ASP.NET in esecuzione in un ambiente di sviluppo di <xref:System.Environment.UserName%2A> proprietà restituisce il nome dell'utente corrente. In un'applicazione ASP.NET pubblicata, questa proprietà restituisce il nome dell'account del pool di applicazioni (ad esempio, pool di applicazioni predefinito).  
  
   
  
## Examples  
 Nell'esempio seguente visualizza il nome utente della persona che ha avviato il thread corrente.  
  
 [!code-cpp[Environment.UserName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserName/CPP/username.cpp#1)]
 [!code-csharp[Environment.UserName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserName/CS/username.cs#1)]
 [!code-vb[Environment.UserName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserName/VB/username.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">accesso in lettura alla variabile di ambiente USERNAME. Enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserDomainName" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public static Version Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Version" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Version ^ Version { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : Version" Usage="System.Environment.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Version" /> che descrive i numeri di versione principale, di versione secondaria, di build e di revisione di Common Language Runtime.</summary>
        <value>Oggetto che visualizza la versione di Common Language Runtime.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per le versioni 4, 4.5, 4.5.1 e 4.5.2 di .NET Framework, la proprietà <xref:System.Environment.Version%2A?displayProperty=nameWithType> restituisce un oggetto <xref:System.Version> la cui rappresentazione di stringa ha il formato `4.0.30319.xxxxx`. Per .NET Framework 4.6 e versioni successive, ha il formato `4.0.30319.42000`.  
  
> [!WARNING]
>  Per il [!INCLUDE[net_v45](~/includes/net-v45-md.md)] e versioni successive, non è consigliabile usare il <xref:System.Environment.Version%2A> proprietà per rilevare la versione del runtime; in alternativa, è possibile determinare la versione di common language runtime eseguendo una query nel Registro di sistema. Per altre informazioni, vedere [procedura: determinare quali .NET Framework versioni installate](~/docs/framework/migration-guide/how-to-determine-which-versions-are-installed.md).  
  
 Per altre informazioni sulla versione di common language runtime che viene installato con ogni versione di .NET Framework, vedere [versioni e dipendenze](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 L'esempio seguente mostra la versione di common language runtime. (La versione viene omesso nell'output di esempio per motivi di sicurezza).  
  
 [!code-cpp[Environment.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.Version/CPP/version.cpp#1)]
 [!code-csharp[Environment.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.Version/CS/version.cs#1)]
 [!code-vb[Environment.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.Version/VB/version.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public static long WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Environment.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property WorkingSet As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long WorkingSet { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int64" Usage="System.Environment.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la quantità di memoria fisica associata al contesto del processo.</summary>
        <value>Intero con segno a 64 bit contenente il numero di byte di memoria fisica associata al contesto del processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente visualizza la dimensione del working set di computer che esegue l'esempio di codice.  
  
 [!code-cpp[Environment.WorkingSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.WorkingSet/CPP/workingset.cpp#1)]
 [!code-csharp[Environment.WorkingSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.WorkingSet/CS/workingset.cs#1)]
 [!code-vb[Environment.WorkingSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.WorkingSet/VB/workingset.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">per l'accesso completo alla risorsa protetta da questa autorizzazione. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>