<Type Name="Environment" FullName="System.Environment">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ee38aecf8b92514f99bd30fc6610189253e474c8" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37729408" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Environment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Environment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Environment" />
  <TypeSignature Language="VB.NET" Value="Public Class Environment" />
  <TypeSignature Language="C++ CLI" Value="public ref class Environment abstract sealed" />
  <TypeSignature Language="F#" Value="type Environment = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides information about, and means to manipulate, the current environment and platform. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.Environment> classe da cui recuperare informazioni quali gli argomenti della riga di comando, il codice di uscita, le impostazioni di variabile di ambiente, contenuto dello stack di chiamate, tempo trascorso dall'ultimo avvio del sistema e la versione di common language runtime.  
  
   
  
## Examples  
 Nell'esempio seguente viene visualizzato un elenco di informazioni sull'ambiente corrente.  
  
 [!code-cpp[environment.class#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.class/CPP/env0.cpp#1)]
 [!code-csharp[environment.class#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.class/CS/env0.cs#1)]
 [!code-vb[environment.class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.class/VB/env0.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CommandLine">
      <MemberSignature Language="C#" Value="public static string CommandLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommandLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CommandLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommandLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommandLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandLine : string" Usage="System.Environment.CommandLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the command line for this process.</summary>
        <value>Stringa contenente gli argomenti della riga di comando.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà fornisce l'accesso a tutti gli argomenti specificati nella riga di comando quando è stato avviato il processo corrente e il nome del programma.  
  
 Il nome del programma può includere le informazioni sul percorso, ma non è necessario eseguire questa operazione. Uso di <xref:System.Environment.GetCommandLineArgs%2A> analizzato e archiviato in una matrice di stringhe di metodo per recuperare le informazioni della riga di comando.  
  
 Le dimensioni massime del buffer della riga di comando non sono impostata su un numero specifico di caratteri. varia a seconda del sistema operativo Windows è in esecuzione nel computer.  
  
   
  
## Examples  
 Nell'esempio seguente consente di visualizzare la propria riga di comando.  
  
 [!code-cpp[environment.commandline#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.CommandLine/CPP/commandline.cpp#1)]
 [!code-csharp[environment.commandline#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.CommandLine/CS/commandline.cs#1)]
 [!code-vb[environment.commandline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.CommandLine/VB/commandline.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">accesso in lettura alla variabile di ambiente PATH. Enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="System.Environment.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the fully qualified path of the current working directory.</summary>
        <value>Stringa che contiene un percorso di directory.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per definizione, se questo processo inizia nella directory radice di una variabile locale o di unità di rete, il valore di questa proprietà è il nome di unità seguito da una barra finale (ad esempio, "c:\\"). Se questo processo viene avviato in una sottodirectory, il valore di questa proprietà è il percorso di unità e sottodirectory, senza una barra finale (ad esempio, "C:\mySubDirectory").  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrata l'impostazione di <xref:System.Environment.CurrentDirectory%2A> proprietà.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Attempted to set to an empty string ("").</exception>
        <exception cref="T:System.ArgumentNullException">Attempted to set to <see langword="null." /></exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Attempted to set a local path that cannot be found.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the appropriate permission.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per la scrittura di file o directory in un'operazione set. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni del percorso in un'operazione get. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentManagedThreadId">
      <MemberSignature Language="C#" Value="public static int CurrentManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CurrentManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CurrentManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentManagedThreadId : int" Usage="System.Environment.CurrentManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a unique identifier for the current managed thread.</summary>
        <value>Intero che rappresenta un identificatore univoco per il thread gestito.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.Exit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(int exitCode);" />
      <MemberSignature Language="F#" Value="static member Exit : int -&gt; unit" Usage="System.Environment.Exit exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">The exit code to return to the operating system. Use 0 (zero) to indicate that the process completed successfully.</param>
        <summary>Terminates this process and returns an exit code to the operating system.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per il `exitCode` parametro, il numero di utilizzare un diverso da zero per indicare un errore. Nell'applicazione, è possibile definire i propri codici di errore in un'enumerazione e restituire il codice di errore appropriato sulla base dello scenario. Ad esempio, restituiscono un valore pari a 1 per indicare che il file richiesto non è presente e il valore 2 per indicare che il file è in formato non corretto. Per un elenco dei codici di uscita usata dal sistema operativo Windows, vedere [codici di errore di sistema](http://msdn.microsoft.com/library/ms681381.aspx) nella documentazione di Windows.  
  
 Chiama il <xref:System.Environment.Exit%2A> metodo si differenzia da usando il linguaggio di programmazione `return` istruzione nei modi seguenti:  
  
-   <xref:System.Environment.Exit%2A> termina sempre un'applicazione. Usando il `return` istruzione può terminare un'applicazione solo se viene utilizzato nel punto di ingresso dell'applicazione, ad esempio nel `Main` (metodo).  
  
-   <xref:System.Environment.Exit%2A> un'applicazione termina immediatamente, anche se altri thread è in esecuzione. Se il `return` istruzione viene chiamata nel punto di ingresso dell'applicazione, fa sì che un'applicazione da terminare solo dopo che tutti i thread in primo piano sono terminati.  
  
-   <xref:System.Environment.Exit%2A> richiede che il chiamante è autorizzato a chiamare codice non gestito. Il `return` istruzione non lo fa.  
  
-   Se <xref:System.Environment.Exit%2A> viene chiamato da un `try` oppure `catch` blocca, il codice in qualsiasi `finally` blocco non viene eseguito. Se il `return` viene utilizzata l'istruzione, il codice nel `finally` eseguire blocca.  
  
-   Se <xref:System.Environment.Exit%2A> viene chiamato quando Scrivi codice in un [area a esecuzione vincolata](~/docs/framework/performance/constrained-execution-regions.md) (CER) è in esecuzione, l'area a esecuzione vincolata non verrà completata l'esecuzione. Se il `return` viene utilizzata l'istruzione, l'area a esecuzione vincolata completa l'esecuzione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The caller does not have sufficient security permission to perform this function.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public static int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.Environment.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the exit code of the process.</summary>
        <value>Intero con segno a 32 bit contenente il codice di uscita. Il valore predefinito è 0 (zero), che indica che il processo è stato completato con successo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il `Main` restituzione del metodo `void`, è possibile usare questa proprietà per impostare il codice di uscita che verrà restituito all'ambiente chiamante. Se `Main` non restituisce `void`, questa proprietà viene ignorata. Il valore iniziale di questa proprietà è zero.  
  
> [!WARNING]
>  Il <xref:System.Environment.ExitCode%2A> proprietà è un intero con segno a 32 bit. Per impedire che la proprietà restituiscano un codice di uscita negativo, non utilizzare i valori maggiori o uguali a 0x80000000.  
  
 Usare un numero diverso da zero per indicare un errore. Nell'applicazione, è possibile definire i propri codici di errore in un'enumerazione e restituire il codice di errore appropriato sulla base dello scenario. Ad esempio, restituire un valore pari a 1 per indicare che il file richiesto non è presente e il valore 2 per indicare che il file è in formato non corretto. Per un elenco dei codici di uscita usata dal sistema operativo Windows, vedere [codici di errore di sistema](http://msdn.microsoft.com/library/ms681381\(v=vs.85\)) nella documentazione di Windows.  
  
   
  
## Examples  
 Di seguito è una semplice app denominata Double.exe che raddoppia il valore intero passato come argomento della riga di comando. Il valore assegna i codici di errore per il <xref:System.Environment.ExitCode%2A> proprietà per indicare le condizioni di errore. Si noti che è necessario aggiungere un riferimento all'assembly System.Numerics.dll per compilare correttamente l'esempio.  
  
 [!code-csharp[System.Environment.ExitCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double.cs#1)]
 [!code-vb[System.Environment.ExitCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double.vb#1)]  
  
 L'esempio può quindi essere richiamato da un file batch, ad esempio il seguente, che rende accessibili i relativi codici di errore usando il `ERRORLEVEL` comando.  
  
```  
  
echo off  
Double.exe %1  
If errorlevel 1639 goto NoArg   
if errorlevel 534 goto Overflow  
if errorlevel 160 goto BadArg  
if errorlevel 0 echo Completed Successfully   
goto :EOF  
  
:NoArg  
echo Missing argument  
goto :EOF  
  
: Overflow  
echo Arithmetic overflow  
goto :EOF  
  
:BadArg  
echo Invalid argument  
goto :EOF  
  
```  
  
 Di seguito viene illustrato un esempio di output generato richiamando il file batch.  
  
```Output  
  
>getdouble 123>echo offResult: 246Completed Successfully>getdouble 5912323109093>echo offArithmetic overflow>getdouble>echo offMissing argument>getdouble "a string">echo offInvalid argument  
  
```  
  
 Si noti che il codice per Double.exe è identico nella funzione all'esempio seguente, ad eccezione del fatto che il primo definisce un punto di ingresso denominato `Main` che non restituisce alcun valore, mentre in questo esempio definisce un punto di ingresso denominato `Main` che restituisce un valore integer.  
  
 [!code-csharp[System.Environment.ExitCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double1.cs#2)]
 [!code-vb[System.Environment.ExitCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static string ExpandEnvironmentVariables (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ExpandEnvironmentVariables(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.ExpandEnvironmentVariables(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExpandEnvironmentVariables (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ExpandEnvironmentVariables(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member ExpandEnvironmentVariables : string -&gt; string" Usage="System.Environment.ExpandEnvironmentVariables name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A string containing the names of zero or more environment variables. Each environment variable is quoted with the percent sign character (%).</param>
        <summary>Replaces the name of each environment variable embedded in the specified string with the string equivalent of the value of the variable, then returns the resulting string.</summary>
        <returns>A string with each environment variable replaced by its value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Interoperabilità COM viene utilizzato per recuperare le variabili di ambiente dal sistema operativo. Se le variabili di ambiente non possono essere recuperate a causa di un errore COM, il valore HRESULT che descrive la causa dell'errore viene utilizzato per generare una delle numerose eccezioni possibili; vale a dire, l'eccezione dipende dal valore HRESULT. Per altre informazioni sulle modalità di elaborazione HRESULT, vedere la sezione Osservazioni del <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A?displayProperty=nameWithType> (metodo).  
  
 Sostituzione avviene solo per le variabili di ambiente impostate. Ad esempio supponga `name` è "MyENV = % MyENV %". Se la variabile di ambiente, MyENV, viene impostata su 42, questo metodo restituisce "MyENV = 42". Se non è impostata MyENV, si verifica alcun cambiamento; Questo metodo restituisce "MyENV = % MyENV %".  
  
 Le dimensioni del valore restituito sono 32 KB.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come ottenere l'unità di sistema e variabili di sistema radice.  
  
 [!code-cpp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CPP/expandenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CS/expandenvironmentvariables.cs#1)]
 [!code-vb[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/VB/expandenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">la possibilità di accedere alle variabili di ambiente <paramref name="name" />. Enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FailFast">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Immediately terminates a process after writing a message to the Windows Application event log, and then includes the message and optional exception information in error reporting to Microsoft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FailFast (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member FailFast : string -&gt; unit" Usage="System.Environment.FailFast message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">A message that explains why the process was terminated, or <see langword="null" /> if no explanation is provided.</param>
        <summary>Immediately terminates a process after writing a message to the Windows Application event log, and then includes the message in error reporting to Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo interrompe un processo senza eseguire attive `try` / `finally` blocchi o i finalizzatori.  
  
 Il <xref:System.Environment.FailFast%2A> metodo scrive il `message` stringa nel registro eventi applicazioni di Windows, viene creato un dump dell'applicazione e quindi termina il processo corrente. Il `message` stringa è incluso anche nella segnalazione errori a Microsoft.  
  
 Usare il <xref:System.Environment.FailFast%2A> invece del metodo di <xref:System.Environment.Exit%2A> metodo per interrompere l'applicazione se lo stato dell'applicazione è danneggiato e l'esecuzione dell'applicazione `try` / `finally` blocchi e dei finalizzatori danneggerà risorse del programma.  
  
 Informazioni viene segnalate a Microsoft tramite segnalazione errori Windows. Per altre informazioni, vedere [segnalazione errori Windows: Guida introduttiva](http://msdn.microsoft.com/library/windows/hardware/dn641144.aspx).  
  
   
  
## Examples  
 Nell'esempio seguente scrive una voce di log per il registro eventi applicazioni di Windows e termina il processo corrente.  
  
 [!code-csharp[environment.FailFast#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.FailFast/cs/ff.cs#1)]
 [!code-vb[environment.FailFast#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.FailFast/vb/ff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message, Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message, class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String,System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message, Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FailFast : string * Exception -&gt; unit" Usage="System.Environment.FailFast (message, exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">A message that explains why the process was terminated, or <see langword="null" /> if no explanation is provided.</param>
        <param name="exception">An exception that represents the error that caused the termination. This is typically the exception in a <see langword="catch" /> block.</param>
        <summary>Immediately terminates a process after writing a message to the Windows Application event log, and then includes the message and exception information in error reporting to Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo termina il processo senza eseguire attive `try` / `finally` blocchi o i finalizzatori.  
  
 Il <xref:System.Environment.FailFast%2A> metodo scrive il `message` stringa nel registro eventi applicazioni di Windows, viene creato un dump dell'applicazione e quindi termina il processo corrente.  
  
 Informazioni viene segnalate a Microsoft tramite segnalazione errori Windows. Per altre informazioni, vedere [segnalazione errori Windows: Guida introduttiva](http://msdn.microsoft.com/library/windows/hardware/dn641144.aspx). Segnalazione errori a Microsoft comprende `message` e `exception` informazioni, che fornisce i dettagli usati per classificare l'errore. Sebbene `exception` non sia gestiti perché il processo viene terminato, viene ottenute comunque le informazioni contestuali che ha generato l'eccezione.  
  
 Se `exception` viene `null`, o se `exception` non è viene generata, questo metodo opera allo stesso modo di <xref:System.Environment.FailFast%28System.String%29> overload del metodo.  
  
 Usare il <xref:System.Environment.FailFast%2A> invece del metodo di <xref:System.Environment.Exit%2A> metodo per interrompere l'applicazione se lo stato dell'applicazione è danneggiato e l'esecuzione dell'applicazione `try` / `finally` blocchi e dei finalizzatori danneggerà risorse del programma.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCommandLineArgs">
      <MemberSignature Language="C#" Value="public static string[] GetCommandLineArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetCommandLineArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetCommandLineArgs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCommandLineArgs () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetCommandLineArgs();" />
      <MemberSignature Language="F#" Value="static member GetCommandLineArgs : unit -&gt; string[]" Usage="System.Environment.GetCommandLineArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a string array containing the command-line arguments for the current process.</summary>
        <returns>An array of string where each element contains a command-line argument. The first element is the executable file name, and the following zero or more elements contain the remaining command-line arguments.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il primo elemento nella matrice contiene il nome del file di programma in esecuzione. Se il nome del file non è disponibile, il primo elemento è uguale a <xref:System.String.Empty?displayProperty=nameWithType>. Gli elementi restanti contengono token aggiuntivi inserite nella riga di comando.  
  
 Il nome file del programma può, ma non è necessario per includere le informazioni sul percorso.  
  
 Argomenti della riga di comando sono delimitati da spazi. È possibile utilizzare le virgolette doppie (") per includere gli spazi all'interno di un argomento. La virgoletta singola ('), tuttavia, non fornisce questa funzionalità.  
  
 Se due o un numero pari di barre rovesciate è seguito un segno di virgolette doppie, viene sostituito ogni coppia di barra rovesciata di procedere con una barra rovesciata e le virgolette doppie viene rimosso. Se un segno di virgolette doppie segue un numero dispari di barre rovesciate, inclusa una sola, ogni coppia precedente viene sostituita con una barra rovesciata e barra rovesciata rimanente viene rimosso; Tuttavia, in questo caso le virgolette doppie non viene rimosso.  
  
 Nella tabella seguente viene illustrato come argomenti della riga di comando possono essere delimitati e presuppone `MyApp` corrente dell'applicazione in esecuzione.  
  
|Nella riga di comando di input|Argomenti della riga di comando risultante|  
|-------------------------------|--------------------------------------|  
|`MyApp alpha beta`|`MyApp, alpha, beta`|  
|`MyApp "alpha with spaces" "beta with spaces"`|`MyApp, alpha with spaces, beta with spaces`|  
|`MyApp 'alpha with spaces' beta`|`MyApp, 'alpha, with, spaces', beta`|  
|`MyApp \\\alpha \\\\"beta`|`MyApp, \\\alpha, \\beta`|  
|`MyApp \\\\\"alpha \"beta`|`MyApp, \\"alpha, "beta`|  
  
 Per ottenere la riga di comando come un'unica stringa, usare il <xref:System.Environment.CommandLine%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente consente di visualizzare gli argomenti della riga di comando dell'applicazione.  
  
 [!code-cpp[Environment.GetCommandLineArgs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CPP/getcommandlineargs.cpp#1)]
 [!code-csharp[Environment.GetCommandLineArgs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CS/getcommandlineargs.cs#1)]
 [!code-vb[Environment.GetCommandLineArgs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetCommandLineArgs/VB/getcommandlineargs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The system does not support command-line arguments.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">accesso in lettura alla variabile di ambiente PATH. Enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.CommandLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retrieves the value of an environment variable.</summary>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string -&gt; string" Usage="System.Environment.GetEnvironmentVariable variable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">The name of the environment variable.</param>
        <summary>Retrieves the value of an environment variable from the current process.</summary>
        <returns>The value of the environment variable specified by <paramref name="variable" />, or <see langword="null" /> if the environment variable is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Environment.GetEnvironmentVariable%28System.String%29> metodo consente di recuperare una variabile di ambiente dal blocco di ambiente del solo processo corrente. È equivalente alla chiamata di <xref:System.Environment.GetEnvironmentVariable%28System.String%2CSystem.EnvironmentVariableTarget%29> metodo con un `target` pari a <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Il blocco di ambiente del processo corrente include le variabili di ambiente seguenti:  
  
-   Tutti i computer le variabili di ambiente che vengono definite al momento della che creazione, il processo con i rispettivi valori.  
  
-   Tutte le variabili di ambiente per ogni utente che vengono definite al momento il processo viene creato, insieme ai relativi valori.  
  
-   Tutte le variabili aggiunte per il blocco process mentre il processo è in esecuzione tramite la chiamata al <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> metodo o il <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metodo con un `target` pari a <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  
  
 Se le variabili di ambiente vengono create dopo l'avvio del processo, è possibile usare questo metodo per recuperare solo le variabili che sono state create chiamando il <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> metodo o il <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metodo con un `target` pari a.<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  
  
 Per recuperare tutte le variabili di ambiente con i rispettivi valori, chiamare il <xref:System.Environment.GetEnvironmentVariables%2A> (metodo).  
  
 I nomi delle variabili di ambiente non sono tra maiuscole e minuscole.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Environment.GetEnvironmentVariable%2A> metodo per recuperare il `windir` variabile di ambiente, che contiene il percorso della directory Windows.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 Nell'esempio seguente tenta di recuperare il valore della variabile di ambiente denominata `Test1` dal blocco di ambiente del processo. Se la variabile non esiste, l'esempio crea relativo e recupera il valore. L'esempio visualizza il valore della variabile. Se nell'esempio viene creata la variabile, chiama anche il <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> con ogni membro del metodo di <xref:System.EnvironmentVariableTarget> enumerazione per stabilire che la variabile può essere recuperata solo dal blocco di ambiente processo corrente. Infine, se nell'esempio viene creata la variabile, la Elimina.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">la possibilità di leggere il valore di <paramref name="variable" />. Enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String, target As EnvironmentVariableTarget) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string * EnvironmentVariableTarget -&gt; string" Usage="System.Environment.GetEnvironmentVariable (variable, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">The name of an environment variable.</param>
        <param name="target">One of the <see cref="T:System.EnvironmentVariableTarget" /> values.</param>
        <summary>Retrieves the value of an environment variable from the current process or from the Windows operating system registry key for the current user or local machine.</summary>
        <returns>The value of the environment variable specified by the <paramref name="variable" /> and <paramref name="target" /> parameters, or <see langword="null" /> if the environment variable is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `target` parametro specifica se la variabile di ambiente viene recuperata dal processo corrente o dalla chiave del Registro di sistema del sistema operativo Windows per l'utente corrente o computer locale. Tutte le variabili di ambiente per ogni utente e per computer vengono copiate automaticamente nel blocco di ambiente del processo corrente. Tuttavia, solo per la durata del processo di rendere persistenti le variabili di ambiente aggiunte solo al blocco di ambiente del processo corrente.  
  
 Per recuperare tutte le variabili di ambiente con i rispettivi valori, chiamare il <xref:System.Environment.GetEnvironmentVariables%2A> (metodo).  
  
 I nomi delle variabili di ambiente non sono tra maiuscole e minuscole.  
  
   
  
## Examples  
 L'esempio seguente crea le variabili di ambiente per le destinazioni di processo, utenti e computer, controlla se il Registro di sistema operativo contiene le variabili di ambiente utente e computer, dopodiché Elimina le variabili di ambiente.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> is not a valid <see cref="T:System.EnvironmentVariableTarget" /> value.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">la possibilità di leggere il valore del <paramref name="variable" /> se <paramref name="target" /> viene <see cref="F:System.EnvironmentVariableTarget.Process" /> (enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), o per l'accesso completo alle variabili di ambiente se <paramref name="target" /> viene <see cref="F:System.EnvironmentVariableTarget.User" /> o <see cref="F:System.EnvironmentVariableTarget.Machine" /> (associata enumerazione: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariables">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retrieves all environment variable names and their values.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables();" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : unit -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves all environment variable names and their values from the current process.</summary>
        <returns>A dictionary that contains all environment variable names and their values; otherwise, an empty dictionary if no environment variables are found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I nomi e valori per le variabili di ambiente vengono archiviati come coppie chiave-valore nell'oggetto restituito <xref:System.Collections.IDictionary>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Environment.GetEnvironmentVariables%2A> (metodo).  
  
 [!code-cpp[Environment.GetEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CPP/getenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.GetEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CS/getenvironmentvariables.cs#1)]
 [!code-vb[Environment.GetEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetEnvironmentVariables/VB/getenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <exception cref="T:System.OutOfMemoryException">The buffer is out of memory.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">la possibilità di leggere i nomi e valori delle variabili di ambiente. Enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables (EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables(valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables (target As EnvironmentVariableTarget) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables(EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : EnvironmentVariableTarget -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="target">One of the <see cref="T:System.EnvironmentVariableTarget" /> values.</param>
        <summary>Retrieves all environment variable names and their values from the current process, or from the Windows operating system registry key for the current user or local machine.</summary>
        <returns>A dictionary that contains all environment variable names and their values from the source specified by the <paramref name="target" /> parameter; otherwise, an empty dictionary if no environment variables are found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `target` parametro specifica se l'origine è il processo corrente, la chiave del Registro di sistema per l'utente corrente o la chiave del Registro di sistema per il computer locale.  
  
 I nomi e valori delle variabili di ambiente vengono archiviati come coppie chiave/valore nell'oggetto restituito <xref:System.Collections.IDictionary> oggetto.  
  
   
  
## Examples  
 L'esempio seguente crea le variabili di ambiente per le destinazioni di processo, utenti e computer, controlla se il Registro di sistema operativo contiene le variabili di ambiente utente e computer, dopodiché Elimina le variabili di ambiente.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation for the specified value of <paramref name="target" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> contains an illegal value.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">la possibilità di leggere i nomi e valori delle variabili di ambiente se <paramref name="target" /> viene <see cref="F:System.EnvironmentVariableTarget.Process" /> (enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), o per l'accesso completo alle variabili di ambiente se <paramref name="target" /> viene <see cref="F:System.EnvironmentVariableTarget.User" /> o <see cref="F:System.EnvironmentVariableTarget.Machine" /> ( Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFolderPath">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets the path to the system special folder that is identified by the specified enumeration.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder -&gt; string" Usage="System.Environment.GetFolderPath folder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
      </Parameters>
      <Docs>
        <param name="folder">An enumerated constant that identifies a system special folder.</param>
        <summary>Gets the path to the system special folder that is identified by the specified enumeration.</summary>
        <returns>The path to the specified system special folder, if that folder physically exists on your computer; otherwise, an empty string ("").  A folder will not physically exist if the operating system did not create it, the existing folder was deleted, or the folder is a virtual directory, such as My Computer, which does not correspond to a physical path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo recupera il percorso in una cartella speciale di sistema, ad esempio i file di programma, programmi, sistema o avvio, che può essere utilizzato per accedere alle informazioni comuni. Cartelle speciali vengono impostate per impostazione predefinita dal sistema oppure in modo esplicito dall'utente, quando si installa una versione di Windows.  
  
 Il `folder` parametro indica la cartella speciale per il recupero e deve essere uno dei valori nel <xref:System.Environment.SpecialFolder> enumerazione; qualsiasi altro valore genera un'eccezione.  
  
 Per altre informazioni sulle cartelle speciali, vedere la [CSIDL eventualmente incluse](http://go.microsoft.com/fwlink/?LinkId=116664) argomento di valori.  
  
   
  
## Examples  
 L'esempio seguente illustra come usare il <xref:System.Environment.GetFolderPath%2A> metodo per restituire e visualizzare il percorso associato di `folder` parametro.  
  
 [!code-cpp[Environment.GetFolderPath#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetFolderPath/CPP/getfolderpath.cpp#1)]
 [!code-csharp[Environment.GetFolderPath#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetFolderPath/CS/getfolderpath.cs#1)]
 [!code-vb[Environment.GetFolderPath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetFolderPath/VB/getfolderpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="folder" /> is not a member of <see cref="T:System.Environment.SpecialFolder" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The current platform is not supported.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni presenti nel percorso stesso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder, Environment.SpecialFolderOption option);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder, valuetype System.Environment/SpecialFolderOption option) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder,System.Environment.SpecialFolderOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder, option As Environment.SpecialFolderOption) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder, Environment::SpecialFolderOption option);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder * Environment.SpecialFolderOption -&gt; string" Usage="System.Environment.GetFolderPath (folder, option)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
        <Parameter Name="option" Type="System.Environment+SpecialFolderOption" />
      </Parameters>
      <Docs>
        <param name="folder">An enumerated constant that identifies a system special folder.</param>
        <param name="option">Specifies options to use for accessing a special folder.</param>
        <summary>Gets the path to the system special folder that is identified by the specified enumeration, and uses a specified option for accessing special folders.</summary>
        <returns>The path to the specified system special folder, if that folder physically exists on your computer; otherwise, an empty string ("").  A folder will not physically exist if the operating system did not create it, the existing folder was deleted, or the folder is a virtual directory, such as My Computer, which does not correspond to a physical path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo recupera il percorso in una cartella speciale di sistema, ad esempio i file di programma, programmi, sistema o avvio, che può essere utilizzato per accedere alle informazioni comuni. Cartelle speciali vengono impostate per impostazione predefinita dal sistema oppure in modo esplicito dall'utente, quando si installa una versione di Windows.  
  
 Il `folder` parametro indica la cartella speciale per il recupero e deve essere uno dei valori nel <xref:System.Environment.SpecialFolder> enumerazione; qualsiasi altro valore genera un'eccezione.  
  
 Per altre informazioni sulle cartelle speciali, vedere la [CSIDL eventualmente incluse](http://go.microsoft.com/fwlink/?LinkId=116664) argomento di valori.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="folder" /> is not a member of <see cref="T:System.Environment.SpecialFolder" /></exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.PlatformNotSupportedException" />
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni presenti nel percorso stesso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.Environment.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an array of string containing the names of the logical drives on the current computer.</summary>
        <returns>An array of strings where each element contains the name of a logical drive. For example, if the computer's hard drive is the first logical drive, the first element returned is "C:\\".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come visualizzare le unità logiche del computer corrente usando il <xref:System.Environment.GetLogicalDrives%2A> (metodo).  
  
 [!code-cpp[Environment.GetLogicalDrives#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetLogicalDrives/CPP/getlogicaldrives.cpp#1)]
 [!code-csharp[Environment.GetLogicalDrives#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetLogicalDrives/CS/getlogicaldrives.cs#1)]
 [!code-vb[Environment.GetLogicalDrives#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetLogicalDrives/VB/getlogicaldrives.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permissions.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">per l'accesso completo alla risorsa protetta da questa autorizzazione. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public static bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Environment.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Environment.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the current application domain is being unloaded or the common language runtime (CLR) is shutting down.</summary>
        <value>
          <see langword="true" /> se il dominio dell'applicazione corrente è in fase di scaricamento o Common Language Runtime è in fase di chiusura; in caso contrario, <see langword="false." /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando CLR viene scaricato un dominio dell'applicazione, esegue i finalizzatori per tutti gli oggetti che hanno un metodo del finalizzatore in tale dominio dell'applicazione. Quando CLR viene arrestato, viene avviato il thread del finalizzatore in tutti gli oggetti che hanno un metodo del finalizzatore. Il <xref:System.Environment.HasShutdownStarted%2A> restituisce proprietà `true` solo dopo che è stato avviato il thread del finalizzatore. Quando la proprietà restituisce `true`, è possibile determinare se un dominio dell'applicazione è in corso lo scaricamento o Common Language Runtime stesso è in corso l'arresto chiamando il <xref:System.AppDomain.IsFinalizingForUnload%2A?displayProperty=nameWithType> (metodo). Questo metodo restituisce `true` se vengono chiamati i finalizzatori in quanto lo scaricamento del dominio applicazione o `false` se CLR viene arrestato verso il basso.  
  
 Il <xref:System.Environment.HasShutdownStarted%2A> restituisce proprietà `false` se il thread del finalizzatore non è stato avviato.  
  
 Usando questa proprietà, è possibile determinare se si desidera accedere alle variabili statiche nel codice di finalizzazione. Se un dominio dell'applicazione o il CLR è in corso l'arresto, sarà possibile accedere in modo affidabile qualsiasi oggetto che ha un metodo di finalizzazione e che fa riferimento un campo statico. Questo avviene perché questi oggetti potrebbero essere già stati finalizzati.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsFinalizingForUnload" />
      </Docs>
    </Member>
    <Member MemberName="Is64BitOperatingSystem">
      <MemberSignature Language="C#" Value="public static bool Is64BitOperatingSystem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitOperatingSystem" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitOperatingSystem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitOperatingSystem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitOperatingSystem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitOperatingSystem : bool" Usage="System.Environment.Is64BitOperatingSystem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the current operating system is a 64-bit operating system.</summary>
        <value>
          <see langword="true" /> se il sistema operativo è a 64 bit; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Is64BitProcess">
      <MemberSignature Language="C#" Value="public static bool Is64BitProcess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitProcess" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitProcess As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitProcess { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitProcess : bool" Usage="System.Environment.Is64BitProcess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the current process is a 64-bit process.</summary>
        <value>
          <see langword="true" /> se il processo è a 64 bit; in caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public static string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Environment.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the NetBIOS name of this local computer.</summary>
        <value>Stringa che contiene il nome di questo computer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il nome del computer viene stabilito all'avvio del sistema quando il nome viene letto dal Registro di sistema. Se questo computer è un nodo in un cluster, viene restituito il nome del nodo.  
  
   
  
## Examples  
 Nell'esempio seguente visualizza il nome del computer che esegue l'esempio di codice. (Il nome del computer viene omesso nell'output di esempio per motivi di sicurezza).  
  
 [!code-cpp[environment.machinename#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.MachineName/CPP/machinename.cpp#1)]
 [!code-csharp[environment.machinename#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.MachineName/CS/machinename.cs#1)]
 [!code-vb[environment.machinename#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.MachineName/VB/machinename.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The name of this computer cannot be obtained.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">accesso in lettura alla variabile di ambiente COMPUTERNAME. Enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public static string NewLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ NewLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string" Usage="System.Environment.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the newline string defined for this environment.</summary>
        <value>Stringa che contiene "\r\n" per le piattaforme non Unix o "\n" per le piattaforme Unix.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore della proprietà <xref:System.Environment.NewLine%2A> è una costante personalizzata in modo specifico per la piattaforma corrente e l'implementazione di .NET Framework. Per altre informazioni sui caratteri di escape nel valore della proprietà, vedere [caratteri di escape](~/docs/standard/base-types/character-escapes-in-regular-expressions.md).  
  
 La funzionalità fornita da <xref:System.Environment.NewLine%2A> è spesso il significato di termini nuova, avanzamento riga, interruzione di riga, ritorno a capo, CRLF, e fine della riga.  
  
 <xref:System.Environment.NewLine%2A> può essere usato in combinazione con il supporto di nuova riga specifiche del linguaggio, ad esempio i caratteri di escape '\r' e '\n' in Microsoft c# e C/C++, o `vbCrLf` in Microsoft Visual Basic.  
  
 <xref:System.Environment.NewLine%2A> viene aggiunto automaticamente al testo elaborato dal <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> e <xref:System.Text.StringBuilder.AppendLine%2A?displayProperty=nameWithType> metodi.  
  
   
  
## Examples  
 Nell'esempio seguente mostra tre righe separate da caratteri di nuova riga.  
  
 [!code-cpp[environment.newline#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.NewLine/CPP/newline.cpp#1)]
 [!code-csharp[environment.newline#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.NewLine/CS/newline.cs#1)]
 [!code-vb[environment.newline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.NewLine/VB/newline.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSVersion">
      <MemberSignature Language="C#" Value="public static OperatingSystem OSVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.OperatingSystem OSVersion" />
      <MemberSignature Language="DocId" Value="P:System.Environment.OSVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSVersion As OperatingSystem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property OperatingSystem ^ OSVersion { OperatingSystem ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OSVersion : OperatingSystem" Usage="System.Environment.OSVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.OperatingSystem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an <see cref="T:System.OperatingSystem" /> object that contains the current platform identifier and version number.</summary>
        <value>Oggetto contenente l'identificatore e il numero di versione della piattaforma.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  A partire da Windows 8, il <xref:System.Environment.OSVersion%2A> proprietà restituisce gli stessi numeri di versione principale e secondaria per tutte le piattaforme Windows. Pertanto, non è consigliabile che recuperare il valore di questa proprietà per determinare la versione del sistema operativo.  
  
 In genere, il <xref:System.Environment.OSVersion%2A> proprietà viene usata per assicurarsi che un'app è in esecuzione in una versione di base di un sistema operativo in cui è stata introdotta una determinata funzionalità. Quando questo è il caso, è consigliabile eseguire un controllo della versione verificando se la versione corrente del sistema operativo restituito dal <xref:System.Environment.OSVersion%2A> proprietà è lo stesso nome, o maggiore, la versione del sistema operativo di base. Il valore della <xref:System.Version> parametro è negativo e non è uguale a .  
  
 Tramite Windows 8, il <xref:System.Environment.OSVersion%2A> viene restituita la versione indicata in di Windows [GetVersionEx](http://msdn.microsoft.com/library/windows/desktop/ms724451\(v=vs.85\).aspx) (funzione). Per un elenco di versioni di sistema operativo desktop Windows e i relativi numeri di versione, vedere [versione del sistema operativo](https://msdn.microsoft.com/library/windows/desktop/ms724832.aspx) in Windows Dev Center.  
  
> [!NOTE]
>  Il <xref:System.Environment.OSVersion%2A> proprietà segnala lo stesso numero di versione (6.2.0.0) per entrambi [!INCLUDE[win8](~/includes/win8-md.md)] e [!INCLUDE[win81](~/includes/win81-md.md)] e lo stesso numero di versione principale e secondaria per Windows 10.  
  
 In alcuni casi, il <xref:System.Environment.OSVersion%2A> proprietà potrebbe non restituire la versione del sistema operativo che corrisponde alla versione specificata per la funzionalità in modalità compatibilità dei programmi Windows.  
  
   
  
## Examples  
 L'esempio seguente mostra l'identificatore di piattaforma e il numero di versione del computer che esegue l'esempio di codice.  
  
 [!code-cpp[environment.osversion#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.OSVersion/CPP/osversion.cpp#1)]
 [!code-csharp[environment.osversion#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.OSVersion/CS/osversion.cs#1)]
 [!code-vb[environment.osversion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.OSVersion/VB/osversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was unable to obtain the system version.  -or-  The obtained platform identifier is not a member of <see cref="T:System.PlatformID" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessorCount">
      <MemberSignature Language="C#" Value="public static int ProcessorCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ProcessorCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ProcessorCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessorCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ProcessorCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorCount : int" Usage="System.Environment.ProcessorCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of processors on the current machine.</summary>
        <value>Intero con segno a 32 bit che specifica il numero di processori sul computer corrente. Non è prevista alcuna impostazione predefinita. Se il computer corrente contiene più gruppi di processori, questa proprietà restituisce il numero di processori logici disponibili per l'uso da parte di Common Language Runtime (CLR).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per altre informazioni sui gruppi di processori e processori logici, vedere [gruppi di processori](http://msdn.microsoft.com/library/windows/desktop/dd405503.aspx).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Environment.ProcessorCount%2A> proprietà.  
  
 [!code-cpp[environment.processorcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.processorcount/CPP/pc.cpp#1)]
 [!code-csharp[environment.processorcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.processorcount/CS/pc.cs#1)]
 [!code-vb[environment.processorcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.processorcount/VB/pc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates, modifies, or deletes an environment variable.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">The name of an environment variable.</param>
        <param name="value">A value to assign to <c>variable</c>.</param>
        <summary>Creates, modifies, or deletes an environment variable stored in the current process.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo metodo è equivalente alla chiamata di <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> rapporto di overload con il valore <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> per il `target` argomento.  
  
 Se il `value` dell'argomento non è vuoto (vedere la discussione dell'eliminazione di una variabile di ambiente più avanti in questa sezione per la definizione di un valore vuoto) e la variabile di ambiente denominata dal `variable` parametro non esiste, l'ambiente viene creata e assegnata il contenuto della variabile `value`. Se esiste, il relativo valore viene modificato. Poiché la variabile di ambiente è definita nel blocco di ambiente del solo processo corrente, non viene mantenuto dopo il processo è terminato.  
  
 Se `variable` contiene un valore esadecimale non iniziale carattere zero, i caratteri prima che il carattere zero vengono considerati il nome di variabile di ambiente e tutti i caratteri successivi vengono ignorati.  
  
 Se `value` contiene un valore esadecimale non iniziale carattere zero, i caratteri prima che il carattere zero vengono assegnati alla variabile di ambiente e tutti i caratteri successivi vengono ignorati.  
  
 Se `value` è vuoto e la variabile di ambiente denominata da `variable` esiste, viene eliminata la variabile di ambiente. Se `variable` non esiste, verrà generato alcun errore anche se non è possibile eseguire l'operazione. `value` viene considerato vuoto in presenza delle condizioni seguenti:  
  
-   Si tratta di `null`.  
  
-   Si tratta di <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   È costituito da un singolo carattere il cui valore è u+0000.  
  
   
  
## Examples  
 Nell'esempio seguente verifica se una variabile di ambiente denominata `APPDOMAIN` esiste nel processo corrente. In caso contrario, lo crea e imposta il valore su "True". Se il valore della `APPDOMAIN` variabile di ambiente è "True", viene chiamato il `Message.Display` metodo in un nuovo dominio applicazione. In caso contrario, viene eseguito il `Message.Display` (metodo) nel dominio dell'applicazione corrente.  
  
 [!code-csharp[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/cs/setenvironmentvariable1.cs#1)]
 [!code-vb[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/vb/setenvironmentvariable1.vb#1)]  
  
 Se si esegue l'esempio per la prima volta, nella console viene visualizzato il messaggio "Durante l'esecuzione nel dominio dominio 2". Se si imposta la variabile di ambiente dalla riga di comando usando il comando:  
  
 `Set AppDomain=False`  
  
 Nell'esempio viene visualizzato il messaggio "l'esecuzione nel dominio *exeName*.exe", dove *exeName* è il nome del file eseguibile.  
  
 Nell'esempio seguente tenta di recuperare il valore della variabile di ambiente denominata `Test1` dal blocco di ambiente del processo. Se la variabile non esiste, l'esempio crea la variabile e recupera il relativo valore. L'esempio visualizza il valore della variabile. Se nell'esempio viene creata la variabile, chiama anche il <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> con ogni membro del metodo di <xref:System.EnvironmentVariableTarget> enumerazione per stabilire che la variabile può essere recuperata solo dal blocco di ambiente processo corrente. Infine, se nell'esempio viene creata la variabile, la Elimina.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variable" /> contains a zero-length string, an initial hexadecimal zero character (0x00), or an equal sign ("=").  -or-  The length of <paramref name="variable" /> or <paramref name="value" /> is greater than or equal to 32,767 characters.  -or-  An error occurred during the execution of this operation.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">per l'accesso completo alle variabili di ambiente. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </Member>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String, target As EnvironmentVariableTarget)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string * EnvironmentVariableTarget -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">The name of an environment variable.</param>
        <param name="value">A value to assign to <c>variable</c>.</param>
        <param name="target">One of the enumeration values that specifies the location of the environment variable.</param>
        <summary>Creates, modifies, or deletes an environment variable stored in the current process or in the Windows operating system registry key reserved for the current user or local machine.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> metodo consente di definire una variabile di ambiente che è disponibile per tutti i processi che vengono eseguiti in un computer (la <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> valore), a tutti i processi eseguiti da un utente (il <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> valore), o per il processo corrente (il <xref:System.EnvironmentVariableTarget.Process> valore). Variabili di ambiente per computer e per utente vengono copiate nel blocco di ambiente del processo corrente. Tuttavia, le variabili di ambiente che sono univoche per il blocco di ambiente corrente del processo persistono solo fino alla fine del processo.  
  
 Se il `value` dell'argomento non è vuoto (vedere la discussione dell'eliminazione di una variabile di ambiente più avanti in questa sezione per la definizione di un valore vuoto) e la variabile di ambiente denominata dal `variable` parametro non esiste, l'ambiente viene creata e assegnata il contenuto della variabile `value`.  Se esiste, il relativo valore viene modificato.  
  
 Se `variable` contiene un valore esadecimale non iniziale carattere zero, i caratteri prima che il carattere zero vengono considerati il nome di variabile di ambiente e tutti i caratteri successivi vengono ignorati.  
  
 Se `value` contiene un valore esadecimale non iniziale carattere zero, i caratteri prima che il carattere zero vengono assegnati alla variabile di ambiente e tutti i caratteri successivi vengono ignorati.  
  
 Se `value` è vuoto e la variabile di ambiente denominata da `variable` esiste, viene eliminata la variabile di ambiente. `value` viene considerato vuoto in presenza delle condizioni seguenti:  
  
-   Si tratta di `null`.  
  
-   Si tratta di <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   È costituito da un singolo carattere il cui valore è u+0000.  
  
 Se `variable` non esiste, verrà generato alcun errore anche se non è possibile eseguire l'operazione. Prestare attenzione quando `target` è <xref:System.EnvironmentVariableTarget.Machine>, in quanto è possibile eliminare accidentalmente una variabile di ambiente che interessa tutto il computer locale, non solo il processo corrente o l'utente.  
  
 Se `target` è <xref:System.EnvironmentVariableTarget.User>, la variabile di ambiente viene archiviata nella chiave HKEY_CURRENT_USER\Environment del Registro di sistema del computer locale. Viene inoltre copiato a istanze di Esplora File che sono in esecuzione come utente corrente. La variabile di ambiente viene quindi ereditata da tutti i nuovi processi che l'utente viene avviata da Esplora File.  
  
 Analogamente, se `target` è <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, la variabile di ambiente viene archiviata nella chiave HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment. del Registro di sistema del computer locale. Viene inoltre copiato a tutte le istanze di Esplora File. La variabile di ambiente viene quindi ereditata da tutti i nuovi processi avviati da Esplora File.  
  
 Se `target` viene <xref:System.EnvironmentVariableTarget.User> oppure <xref:System.EnvironmentVariableTarget.Machine>, le altre applicazioni ricevono una notifica dell'operazione di impostazione tramite un Windows `WM_SETTINGCHANGE` messaggio.  
  
 Se `target` viene <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> oppure <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, è consigliabile che la lunghezza di `value` da meno di 2048 caratteri.  
  
   
  
## Examples  
 L'esempio seguente crea le variabili di ambiente per il <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, e <xref:System.EnvironmentVariableTarget.Machine> ha come destinazione, viene controllato se il Registro di sistema operativo contiene l'utente e le variabili di ambiente del computer, quindi Elimina l'ambiente variabili.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variable" /> contains a zero-length string, an initial hexadecimal zero character (0x00), or an equal sign ("=").  -or-  The length of <paramref name="variable" /> is greater than or equal to 32,767 characters.  -or-  <paramref name="target" /> is not a member of the <see cref="T:System.EnvironmentVariableTarget" /> enumeration.  -or-  <paramref name="target" /> is <see cref="F:System.EnvironmentVariableTarget.Machine" /> or <see cref="F:System.EnvironmentVariableTarget.User" />, and the length of <paramref name="variable" /> is greater than or equal to 255.  -or-  <paramref name="target" /> is <see cref="F:System.EnvironmentVariableTarget.Process" /> and the length of <paramref name="value" /> is greater than or equal to 32,767 characters.  -or-  An error occurred during the execution of this operation.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">per l'accesso completo alle variabili di ambiente. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public static string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Environment.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Environment.StackTrace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets current stack trace information.</summary>
        <value>Stringa che contiene informazioni sull'analisi dello stack. Il valore può essere <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Environment.StackTrace%2A> elenchi di proprietà di chiamate al metodo in ordine cronologico inverso, vale a dire, la chiamata al metodo più recente è descritta prima di tutto e viene elencata una riga delle informazioni di traccia dello stack per ogni chiamata al metodo nello stack. Tuttavia, il <xref:System.Environment.StackTrace%2A> proprietà potrebbe non segnalare il numero di chiamate di metodo come previsto a causa di trasformazioni del codice che si verificano durante l'ottimizzazione.  
  
> [!NOTE]
>  Per ottenere una visualizzazione gerarchica delle informazioni di traccia dello stack dalla classe, usare il <xref:System.Diagnostics.StackTrace> classe.  
  
 Il <xref:System.Environment.StackTrace%2A> proprietà formatta le informazioni di traccia dello stack per ogni chiamata al metodo come indicato di seguito:  
  
 "nella `FullClassName`.`MethodName` (`MethodParams`) nel `FileName` : riga `LineNumber` "  
  
 Il valore letterale "non operativi" è preceduto da tre spazi e l'intera sottostringa che inizia con "in" viene omesso se non sono disponibili i simboli di debug. I segnaposto `FullClassName`, `MethodName`, `MethodParams`, `FileName`, e `LineNumber`, vengono sostituiti dai valori effettivi e sono definiti come segue:  
  
 FullClassName  
 Il nome completo della classe, incluso lo spazio dei nomi.  
  
 `MethodName`  
 Nome del metodo.  
  
 `MethodParams`  
 Elenco di coppie nome/tipo del parametro. Ogni coppia è separato da una virgola (","). Queste informazioni viene omesso se `MethodName` non accetta parametri.  
  
 `FileName`  
 Il nome dell'origine del file in cui il `MethodName` metodo viene dichiarato. Queste informazioni viene omesso se non sono disponibili i simboli di debug.  
  
 `LineNumber`  
 Il numero di riga `FileName` che contiene il codice sorgente da `MethodName` per l'istruzione che è nello stack di chiamate. Queste informazioni viene omesso se non sono disponibili i simboli di debug.  
  
 Il <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> stringa consente di terminare ogni riga della traccia dello stack.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Environment.StackTrace%2A> proprietà.  
  
 [!code-cpp[environment.stacktrace#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.StackTrace/CPP/stacktrace.cpp#1)]
 [!code-csharp[environment.stacktrace#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.StackTrace/CS/stacktrace.cs#1)]
 [!code-vb[environment.stacktrace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.StackTrace/VB/stacktrace.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">per l'accesso completo alla risorsa protetta dall'autorizzazione. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemDirectory">
      <MemberSignature Language="C#" Value="public static string SystemDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string SystemDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SystemDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemDirectory : string" Usage="System.Environment.SystemDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the fully qualified path of the system directory.</summary>
        <value>Stringa che contiene un percorso di directory.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un esempio del valore restituito è la stringa "C:\Winnt\System32.".  
  
   
  
## Examples  
 Nell'esempio seguente viene visualizzata la directory di sistema del computer che esegue l'esempio di codice. (La directory di sistema viene omesso nell'output di esempio per motivi di sicurezza).  
  
 [!code-cpp[environment.systemdirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.SystemDirectory/CPP/systemdirectory.cpp#1)]
 [!code-csharp[environment.systemdirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.SystemDirectory/CS/systemdirectory.cs#1)]
 [!code-vb[environment.systemdirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.SystemDirectory/VB/systemdirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Per accedere alle informazioni presenti nel percorso stesso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemPageSize">
      <MemberSignature Language="C#" Value="public static int SystemPageSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 SystemPageSize" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemPageSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemPageSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int SystemPageSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemPageSize : int" Usage="System.Environment.SystemPageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of bytes in the operating system's memory page.</summary>
        <value>Numero di byte in una pagina di memoria di sistema.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Queste informazioni possono essere utili quando si determina se utilizzare il <xref:System.IO.MemoryMappedFiles.MemoryMappedFileOptions.DelayAllocatePages?displayProperty=nameWithType> opzione quando si lavora con file mappati alla memoria.  
  
 In Windows, questo valore è il `dwPageSize` membro nel `SYSTEM_INFO` struttura.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Per accedere alle variabili di ambiente del sistema e utente. Eccezione associata:  <see cref="P:System.Security.SecurityException.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TickCount">
      <MemberSignature Language="C#" Value="public static int TickCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 TickCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int TickCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount : int" Usage="System.Environment.TickCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of milliseconds elapsed since the system started.</summary>
        <value>Intero con segno a 32 bit contenente il tempo espresso in millisecondi che sono trascorsi dall'ultimo avvio del computer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa proprietà è derivato dal timer di sistema e viene archiviato come un intero con segno a 32 bit. Si noti che, poiché deriva da timer di sistema, la risoluzione del <xref:System.Environment.TickCount%2A> proprietà è limitata per la risoluzione del timer di sistema, che in genere è compreso nell'intervallo di 10 a 16 millisecondi.  
  
> [!IMPORTANT]
>  Perché il valore del <xref:System.Environment.TickCount%2A> valore della proprietà è un intero con segno a 32 bit, se il sistema viene eseguito in modo continuo, <xref:System.Environment.TickCount%2A> compreso tra zero e incrementa <xref:System.Int32.MaxValue?displayProperty=nameWithType> circa 24,9 giorni, quindi passare alla <xref:System.Int32.MinValue?displayProperty=nameWithType>, che è un numero negativo, quindi incremento su zero durante i prossimi giorni 24,9. È possibile risolvere questo problema tramite la chiamata di Windows [GetTickCount](https://msdn.microsoft.com/library/windows/desktop/ms724408.aspx) funzione, che viene reimpostato su zero dopo circa 49 giorni oppure chiamando il [GetTickCount64](https://msdn.microsoft.com/library/windows/desktop/ms724411.aspx) (funzione).  
  
 <xref:System.Environment.TickCount%2A> è diverso dal <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType> proprietà, ovvero il numero di intervalli di 100 nanosecondi trascorsi dal 1/1 / ° gennaio 0001 12:00 am.  
  
 Usare il <xref:System.DateTime.Now%2A?displayProperty=nameWithType> proprietà per ottenere la data locale corrente e l'ora nel computer.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come recuperare l'intervallo dei valori restituiti da positivo il <xref:System.Environment.TickCount%2A> proprietà. Il <xref:System.Environment.TickCount%2A> proprietà cicli tra <xref:System.Int32.MinValue?displayProperty=nameWithType>, ovvero un numero negativo, e <xref:System.Int32.MaxValue?displayProperty=nameWithType> ogni 49,8 giorni. Questo esempio di codice rimuove il bit di segno per ottenere un numero non negativo che passa ciclicamente da zero e <xref:System.Int32.MaxValue> ogni 24,9 giorni.  
  
 [!code-cpp[environment.tickcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.TickCount/CPP/tickcount.cpp#1)]
 [!code-csharp[environment.tickcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.TickCount/CS/tickcount.cs#1)]
 [!code-vb[environment.tickcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.TickCount/VB/tickcount.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDomainName">
      <MemberSignature Language="C#" Value="public static string UserDomainName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserDomainName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserDomainName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserDomainName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserDomainName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserDomainName : string" Usage="System.Environment.UserDomainName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the network domain name associated with the current user.</summary>
        <value>Nome di dominio della rete associato all'utente corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le credenziali dell'account di dominio per un utente sono formattati come nome di dominio dell'utente, il '\\' carattere e il nome utente. Usare la <xref:System.Environment.UserDomainName%2A> proprietà da ottenere il nome del dominio dell'utente senza il nome utente e il <xref:System.Environment.UserName%2A> proprietà per ottenere il nome utente senza il nome di dominio.  Se il nome di dominio e nome utente di un utente sono CORPORATENETWORK\john, ad esempio il <xref:System.Environment.UserDomainName%2A> proprietà restituisce "CORPORATENETWORK".  
  
 Il <xref:System.Environment.UserDomainName%2A> proprietà tenta innanzitutto di ottenere il componente nome di dominio del nome dell'account di Windows per l'utente corrente. Se il tentativo ha esito negativo, questa proprietà tenta di ottenere il nome di dominio associato con il nome utente specificato per il <xref:System.Environment.UserName%2A> proprietà. Se tale tentativo ha esito negativo perché il computer host non è unito a un dominio, viene restituito il nome del computer host.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The operating system does not support retrieving the network domain name.</exception>
        <exception cref="T:System.InvalidOperationException">The network domain name cannot be retrieved.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">accesso in lettura alla variabile di ambiente USERDOMAIN. Enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserName" />
      </Docs>
    </Member>
    <Member MemberName="UserInteractive">
      <MemberSignature Language="C#" Value="public static bool UserInteractive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UserInteractive" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserInteractive" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserInteractive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UserInteractive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInteractive : bool" Usage="System.Environment.UserInteractive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the current process is running in user interactive mode.</summary>
        <value>
          <see langword="true" /> se il processo corrente viene eseguito in modalità interattiva utente; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Environment.UserInteractive%2A> proprietà report `false` per un processo di Windows o un servizio, ad esempio IIS in cui viene eseguito senza un'interfaccia utente. Se questa proprietà è `false`, non vengono visualizzate le finestre di dialogo modale o perché non vi è alcuna interfaccia utente grafica per l'utente può interagire con le finestre di messaggio.  
  
   
  
## Examples  
 Nell'esempio seguente indica se il processo corrente è in esecuzione in modalità interattiva utente.  
  
 [!code-cpp[Environment.UserInteractive#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserInteractive/CPP/userinteractive.cpp#1)]
 [!code-csharp[Environment.UserInteractive#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserInteractive/CS/userinteractive.cs#1)]
 [!code-vb[Environment.UserInteractive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserInteractive/VB/userinteractive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public static string UserName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserName : string" Usage="System.Environment.UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the user name of the person who is currently logged on to the operating system.</summary>
        <value>Il nome utente della persona che esegue l'accesso al sistema operativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile usare il <xref:System.Environment.UserName%2A> proprietà per identificare l'utente nel thread corrente, al sistema e applicazione per la sicurezza o accesso. Può anche essere utilizzato per personalizzare un'applicazione specifica per ogni utente.  
 
 In Windows il <xref:System.Environment.UserName%2A> proprietà esegue il wrapping di una chiamata a di Windows [GetUserName](http://msdn.microsoft.com/library/windows/desktop/ms724432.aspx) (funzione). Le credenziali dell'account di dominio per un utente sono formattati come nome di dominio dell'utente, il '\\' carattere e il nome utente. Usare la <xref:System.Environment.UserDomainName%2A> proprietà per ottenere il nome di dominio dell'utente e la <xref:System.Environment.UserName%2A> proprietà per ottenere il nome utente.  
 
 Nelle piattaforme Unix il <xref:System.Environment.UserName%2A> proprietà esegue il wrapping di una chiamata al `getpwuid_r` (funzione).
 
 Se un'applicazione ASP.NET in esecuzione in un ambiente di sviluppo di <xref:System.Environment.UserName%2A> proprietà restituisce il nome dell'utente corrente. In un'applicazione ASP.NET pubblicata, questa proprietà restituisce il nome dell'account del pool di applicazioni (ad esempio, pool di applicazioni predefinito).  
  
   
  
## Examples  
 Nell'esempio seguente visualizza il nome utente della persona che ha avviato il thread corrente.  
  
 [!code-cpp[Environment.UserName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserName/CPP/username.cpp#1)]
 [!code-csharp[Environment.UserName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserName/CS/username.cs#1)]
 [!code-vb[Environment.UserName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserName/VB/username.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">accesso in lettura alla variabile di ambiente USERNAME. Enumerazione associata: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserDomainName" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public static Version Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Version" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Version ^ Version { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : Version" Usage="System.Environment.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Version" /> object that describes the major, minor, build, and revision numbers of the common language runtime.</summary>
        <value>Oggetto che visualizza la versione di Common Language Runtime.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per le versioni 4, 4.5, 4.5.1 e 4.5.2 di .NET Framework, la proprietà <xref:System.Environment.Version%2A?displayProperty=nameWithType> restituisce un oggetto <xref:System.Version> la cui rappresentazione di stringa ha il formato `4.0.30319.xxxxx`. Per .NET Framework 4.6 e versioni successive, ha il formato `4.0.30319.42000`.  
  
> [!WARNING]
>  Per il [!INCLUDE[net_v45](~/includes/net-v45-md.md)] e versioni successive, non è consigliabile usare il <xref:System.Environment.Version%2A> proprietà per rilevare la versione del runtime; in alternativa, è possibile determinare la versione di common language runtime eseguendo una query nel Registro di sistema. Per altre informazioni, vedere [procedura: determinare quali .NET Framework versioni installate](~/docs/framework/migration-guide/how-to-determine-which-versions-are-installed.md).  
  
 Per altre informazioni sulla versione di common language runtime che viene installato con ogni versione di .NET Framework, vedere [versioni e dipendenze](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 L'esempio seguente mostra la versione di common language runtime. (La versione viene omesso nell'output di esempio per motivi di sicurezza).  
  
 [!code-cpp[Environment.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.Version/CPP/version.cpp#1)]
 [!code-csharp[Environment.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.Version/CS/version.cs#1)]
 [!code-vb[Environment.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.Version/VB/version.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public static long WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Environment.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property WorkingSet As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long WorkingSet { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int64" Usage="System.Environment.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of physical memory mapped to the process context.</summary>
        <value>Intero con segno a 64 bit contenente il numero di byte di memoria fisica associata al contesto del processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente visualizza la dimensione del working set di computer che esegue l'esempio di codice.  
  
 [!code-cpp[Environment.WorkingSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.WorkingSet/CPP/workingset.cpp#1)]
 [!code-csharp[Environment.WorkingSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.WorkingSet/CS/workingset.cs#1)]
 [!code-vb[Environment.WorkingSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.WorkingSet/VB/workingset.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">per l'accesso completo alla risorsa protetta da questa autorizzazione. Enumerazione associata: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>