<Type Name="UnhandledExceptionEventArgs" FullName="System.UnhandledExceptionEventArgs">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9811531194d62fd50310ad6baf15b7e5d3024df0" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37727022" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UnhandledExceptionEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UnhandledExceptionEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.UnhandledExceptionEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class UnhandledExceptionEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnhandledExceptionEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type UnhandledExceptionEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce dati relativi all'evento generato quando si verifica un'eccezione non gestita in qualsiasi dominio di applicazione.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UnhandledExceptionEventArgs> fornisce l'accesso per l'oggetto eccezione e un flag che indica se common language runtime sta terminando. Il <xref:System.UnhandledExceptionEventArgs> è uno dei parametri passati <xref:System.UnhandledExceptionEventHandler> per il <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> evento.  
  
 Per altre informazioni sui delegati del gestore eventi, vedere [la gestione e generazione di eventi](~/docs/standard/events/index.md).  
  
 ]]></format>
    </remarks>
    <altmember cref="E:System.AppDomain.UnhandledException" />
    <altmember cref="T:System.UnhandledExceptionEventHandler" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnhandledExceptionEventArgs (object exception, bool isTerminating);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object exception, bool isTerminating) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UnhandledExceptionEventArgs.#ctor(System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (exception As Object, isTerminating As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnhandledExceptionEventArgs(System::Object ^ exception, bool isTerminating);" />
      <MemberSignature Language="F#" Value="new UnhandledExceptionEventArgs : obj * bool -&gt; UnhandledExceptionEventArgs" Usage="new System.UnhandledExceptionEventArgs (exception, isTerminating)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="exception" Type="System.Object" />
        <Parameter Name="isTerminating" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="exception">Eccezione non gestita.</param>
        <param name="isTerminating">
          <see langword="true" /> se la fase di esecuzione sta terminando; in caso contrario <see langword="false" />.</param>
        <summary>Consente di inizializzare una nuova istanza della classe <see cref="T:System.UnhandledExceptionEventArgs" /> con l'oggetto eccezione e un flag di terminazione di Common Language Runtime.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExceptionObject">
      <MemberSignature Language="C#" Value="public object ExceptionObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ExceptionObject" />
      <MemberSignature Language="DocId" Value="P:System.UnhandledExceptionEventArgs.ExceptionObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExceptionObject As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ExceptionObject { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExceptionObject : obj" Usage="System.UnhandledExceptionEventArgs.ExceptionObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto eccezione non gestita.</summary>
        <value>Oggetto eccezione non gestita.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce un oggetto di tipo <xref:System.Object> anziché una derivata da <xref:System.Exception>. Anche se Common Language Specification richiede che tutti i tipi di eccezione derivano da <xref:System.Exception>, è possibile chiamare i metodi generare eccezioni con gli oggetti non derivati da <xref:System.Exception>. È possibile eseguire le operazioni seguenti per lavorare con questa eccezione:  
  
-   Si applicano i <xref:System.Runtime.CompilerServices.RuntimeCompatibilityAttribute> dell'attributo con un <xref:System.Runtime.CompilerServices.RuntimeCompatibilityAttribute.WrapNonExceptionThrows%2A?displayProperty=nameWithType> pari a `true` all'assembly che contiene il gestore dell'evento. Si esegue il wrapping di tutte le eccezioni non derivate dal <xref:System.Exception> classe un <xref:System.Runtime.CompilerServices.RuntimeWrappedException> oggetto. È possibile quindi in modo sicuro il cast (in c#) o convertire (in Visual Basic) l'oggetto restituito da questa proprietà su un <xref:System.Exception> dell'oggetto e recuperare l'oggetto eccezione originale dal <xref:System.Runtime.CompilerServices.RuntimeWrappedException.WrappedException%2A?displayProperty=nameWithType> proprietà. Si noti che alcuni compilatori, ad esempio i compilatori c# e Visual Basic, applicano automaticamente questo attributo.  
  
-   Il cast dell'oggetto restituito da questa proprietà su un <xref:System.Exception> oggetto.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.AppDomain.UnhandledException> evento. Definisce un gestore eventi, `MyHandler`, che viene richiamato ogni volta che viene generata un'eccezione non gestita nel dominio applicazione predefinito. Genera quindi le due eccezioni. Il primo è gestito da un **try/catch** blocco. La seconda non viene gestita e richiama il `MyHandle` routine prima che l'applicazione viene terminata.  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.CompilerServices.RuntimeCompatibilityAttribute" />
        <altmember cref="T:System.Runtime.CompilerServices.RuntimeWrappedException" />
      </Docs>
    </Member>
    <Member MemberName="IsTerminating">
      <MemberSignature Language="C#" Value="public bool IsTerminating { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTerminating" />
      <MemberSignature Language="DocId" Value="P:System.UnhandledExceptionEventArgs.IsTerminating" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTerminating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTerminating { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTerminating : bool" Usage="System.UnhandledExceptionEventArgs.IsTerminating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se Common Language Runtime sta terminando.</summary>
        <value>
          <see langword="true" /> se la fase di esecuzione sta terminando; in caso contrario <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A partire da .NET Framework versione 2.0, questa proprietà restituisce `true` per la maggior parte di eccezioni non gestite, a meno che un flag di compatibilità dell'applicazione viene usato per ripristinare il comportamento delle versioni 1.0 e 1.1. Il motivo è che è consentite proseguire normalmente, più eccezioni non gestite nei thread, tra cui pool di thread, in genere un conseguente chiusura dell'applicazione. Per altre informazioni, incluso un elenco di casi in cui il runtime non viene terminato, vedere [eccezioni in thread gestiti](~/docs/standard/threading/exceptions-in-managed-threads.md).  
  
## <a name="version-information"></a>Informazioni sulla versione  
 Quanto segue si applica alle versioni di .NET Framework 1.0 e 1.1: questa proprietà restituisce `true` quando viene ricevuta in, un'eccezione ma non è gestita da, thread principale di un'applicazione. Questa proprietà restituisce inoltre `true` se un thread non gestito è in esecuzione il codice gestito e riceve un'eccezione non gestita. Infine, questa proprietà restituisce `false` per pool di thread e i thread gestiti creati da un'applicazione, perché le versioni 1.0 e 1.1 intercettare le eccezioni non gestite in tali thread e ignorano.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>