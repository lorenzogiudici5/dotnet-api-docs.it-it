<Type Name="Object" FullName="System.Object">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="15f433904f15b52fc408db54f7fd65e20a71b739" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34174249" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Supporta tutte classi della gerarchia di classi .NET Framework e fornisce servizi di basso livello alle classi derivate. Questa è la principale classe base di tutte le classi di .NET Framework e rappresenta la radice della gerarchia dei tipi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lingue non richiedono in genere una classe di dichiarare l'ereditarietà da <xref:System.Object> perché l'ereditarietà è implicita.  
  
 Poiché tutte le classi in .NET Framework sono derivate da <xref:System.Object>, ogni metodo definito nella <xref:System.Object> classe è disponibile in tutti gli oggetti nel sistema. Le classi derivate possono ed eseguire l'override di alcuni di questi metodi, tra cui:  
  
-   <xref:System.Object.Equals%2A> -Supporta i confronti tra oggetti.  
  
-   <xref:System.Object.Finalize%2A> -Esegue operazioni di pulizia prima che venga recuperato automaticamente un oggetto.  
  
-   <xref:System.Object.GetHashCode%2A> -Genera un numero corrispondente al valore dell'oggetto per supportare l'utilizzo di una tabella hash.  
  
-   <xref:System.Object.ToString%2A> -Produce una stringa di testo leggibile che descrive un'istanza della classe.  
  
## <a name="performance-considerations"></a>Considerazioni sulle prestazioni  
 Se si progetta una classe, ad esempio una raccolta, che deve gestire qualsiasi tipo di oggetto, è possibile creare membri di classe che le istanze di accettano la <xref:System.Object> classe. Tuttavia, il processo di conversione boxing e unboxing di un tipo comporta un calo delle prestazioni. Se si conosce che la nuova classe dovrà gestire frequentemente determinati tipi di valore è possibile utilizzare uno dei due strategie per ridurre al minimo il costo della conversione boxing.  
  
-   Creare un metodo generico che accetta un <xref:System.Object> tipo e un set di overload di metodo specifico del tipo che accettano di ogni tipo di valore si prevede che la classe per gestire frequentemente. Se è presente un metodo specifico del tipo che accetta il tipo di parametro di chiamata, nessuna conversione boxing viene eseguita e viene richiamato il metodo specifico del tipo. Se è presente alcun argomento di metodo che corrisponde al tipo di parametro di chiamata, il parametro è di tipo boxed e viene richiamato il metodo generico.  
  
-   Progettare il tipo e i relativi membri per utilizzare i generics. Common language runtime crea un tipo generico chiuso quando si crea un'istanza della classe e specificare un argomento di tipo generico. Il metodo generico è specifico del tipo e può essere richiamato senza eseguirne il boxing del parametro della chiamata.  
  
 Anche se in alcuni casi è necessario sviluppare classi generiche che accettano e restituiscono <xref:System.Object> tipi, è possibile migliorare le prestazioni fornendo anche una classe specifica del tipo per gestire un tipo usato di frequente. Fornisce una classe specifica di impostazione e recupero di valori booleani, ad esempio, consente di eliminare il costo della conversione boxing e unboxing valori booleani.  
  
   
  
## Examples  
 L'esempio seguente definisce un tipo di punto derivato il <xref:System.Object> classe ed esegue l'override di molti dei metodi virtuali di <xref:System.Object> classe. Inoltre, nell'esempio viene illustrato come chiamare numerosi statica metodi di istanza del <xref:System.Object> classe.  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Statici pubblici (<see langword="Shared" /> in Visual Basic) di questo tipo sono thread-safe. Membri di istanza non sono garantiti come thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Object" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore viene chiamato dai costruttori nelle classi derivate, ma può essere utilizzato anche per creare direttamente un'istanza di <xref:System.Object> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se due istanze di un oggetto sono uguali.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da confrontare con l'oggetto corrente.</param>
        <summary>Determina se l'oggetto specificato è uguale all'oggetto corrente.</summary>
        <returns>
          <see langword="true" /> se l'oggetto specificato è uguale all'oggetto corrente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo di confronto tra l'istanza corrente e `obj` parametro varia a seconda se l'istanza corrente è un tipo riferimento o un tipo di valore.  
  
-   Se l'istanza corrente è un tipo riferimento, il <xref:System.Object.Equals%28System.Object%29> metodo verifica l'uguaglianza di riferimento e una chiamata al <xref:System.Object.Equals%28System.Object%29> equivale a una chiamata al metodo di <xref:System.Object.ReferenceEquals%2A> metodo. L'uguaglianza dei riferimenti significa che le variabili di oggetto che vengono confrontate fanno riferimento allo stesso oggetto. Nell'esempio seguente viene illustrato il risultato di tale confronto. Definisce un `Person` (classe), che è un tipo riferimento, e chiama il `Person` costruttore della classe per creare un'istanza di due nuovi `Person` oggetti, `person1a` e `person2`, che hanno lo stesso valore. Assegna inoltre `person1a` a un'altra variabile di oggetto, `person1b`. Come illustrato nell'esempio, l'output `person1a` e `person1b` sono uguali, in quanto fanno riferimento allo stesso oggetto. Tuttavia, `person1a` e `person2` non sono uguali, anche se hanno lo stesso valore.  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   Se l'istanza corrente è un tipo valore, il <xref:System.Object.Equals%28System.Object%29> metodo verifica l'uguaglianza di valore. L'uguaglianza di valori indica quanto segue:  
  
    -   I due oggetti sono dello stesso tipo. Come illustrato nell'esempio seguente, un <xref:System.Byte> oggetto con un valore pari a 12 non è uguale un <xref:System.Int32> oggetto che ha un valore pari a 12, poiché i due oggetti hanno tipi diversi di run-time.  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   I valori dei campi pubblici e privati di due oggetti sono uguali. Nell'esempio seguente verifica l'uguaglianza di valori. Definisce un `Person` struttura, ovvero un tipo di valore, e chiama il `Person` costruttore della classe per creare un'istanza di due nuovi `Person` oggetti, `person1` e `person2`, che hanno lo stesso valore. Come illustrato nell'output dell'esempio, anche se le due variabili oggetto fare riferimento a oggetti diversi, `person1` e `person2` sono uguali perché hanno lo stesso valore per privato `personName` campo.  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 Poiché il <xref:System.Object> classe è la classe base per tutti i tipi in .NET Framework, il <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metodo fornisce il confronto di uguaglianza predefinito per tutti gli altri tipi. Tuttavia, tipi spesso eseguono l'override di <xref:System.Object.Equals%2A> metodo per implementare l'uguaglianza di valori. Per ulteriori informazioni, vedere le note per i chiamanti e note per le sezioni gli eredi.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Note per il [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Quando si chiama il <xref:System.Object.Equals%28System.Object%29> overload del metodo in una classe di [!INCLUDE[wrt](~/includes/wrt-md.md)], fornisce il comportamento predefinito per le classi che non esegue l'override <xref:System.Object.Equals%28System.Object%29>. Questo aspetto è parte del supporto fornito da .NET Framework per la [!INCLUDE[wrt](~/includes/wrt-md.md)] (vedere [.NET Framework supportano per applicazioni Windows Store e Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Classi di [!INCLUDE[wrt](~/includes/wrt-md.md)] non ereditano <xref:System.Object>e non implementano un <xref:System.Object.Equals%28System.Object%29> metodo. Tuttavia, sembrano disporre <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, e <xref:System.Object.GetHashCode%2A> metodi quando utilizzarle nel codice c# o Visual Basic e .NET Framework fornisce il comportamento predefinito per questi metodi.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] le classi che vengono scritti in c# o Visual Basic possono eseguire l'override di <xref:System.Object.Equals%28System.Object%29> overload del metodo.  
  
## <a name="notes-for-callers"></a>Note per i chiamanti  
 Spesso override dalle classi derivate di <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metodo per implementare l'uguaglianza di valori. Inoltre, i tipi forniscono spesso anche un overload fortemente tipizzato aggiuntivo per il `Equals` (metodo), in genere mediante l'implementazione di <xref:System.IEquatable%601> interfaccia. Quando si chiama il `Equals` metodo per verificare l'uguaglianza, è necessario conoscere se l'istanza corrente sostituisce <xref:System.Object.Equals%2A?displayProperty=nameWithType> e comprendere la modalità di una determinata chiamata a un `Equals` metodo viene risolto. In caso contrario, è possibile eseguire un test di uguaglianza che è diverso da quelli desiderati e il metodo può restituire un valore imprevisto.  
  
 Nell'esempio seguente viene illustrato questo concetto. Crea un'istanza di tre <xref:System.Text.StringBuilder> gli oggetti con stringhe identiche e quindi imposta su quattro chiamate a `Equals` metodi. Il primo metodo di chiamata restituisce `true`e la restituzione di tre rimanenti `false`.  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 Nel primo caso, l'oggetto fortemente tipizzato <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> overload del metodo che verifica l'uguaglianza di valore, viene chiamato. Poiché le stringhe assegnate ai due <xref:System.Text.StringBuilder> oggetti sono uguali, il metodo restituisce `true`. Tuttavia, <xref:System.Text.StringBuilder> non esegue l'override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>. Per questo motivo, quando il <xref:System.Text.StringBuilder> oggetto viene eseguito il cast a un <xref:System.Object>, quando un <xref:System.Text.StringBuilder> istanza viene assegnata a una variabile di tipo <xref:System.Object>e quando il <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> metodo vengono passati due <xref:System.Text.StringBuilder> oggetti, il valore predefinito <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>viene chiamato. Poiché <xref:System.Text.StringBuilder> è un tipo riferimento, questa opzione equivale a passando i due <xref:System.Text.StringBuilder> oggetti per il <xref:System.Object.ReferenceEquals%2A> (metodo). Anche se tutte e tre <xref:System.Text.StringBuilder> gli oggetti contengono stringhe identiche, fare riferimento a tre oggetti distinti. Di conseguenza, questi tre chiamate al metodo restituito `false`.  
  
 È possibile confrontare l'oggetto corrente e un altro oggetto per l'uguaglianza dei riferimenti chiamando il <xref:System.Object.ReferenceEquals%2A> metodo. In Visual Basic, è inoltre possibile utilizzare il `is` (parola chiave) (ad esempio, `If Me Is otherObject Then ...`).  
  
## <a name="notes-for-inheritors"></a>Note per gli eredi  
 Quando si definisce un tipo personalizzato, tale tipo eredita funzionalità definite dal `Equals` metodo del tipo di base. La tabella seguente elenca l'implementazione predefinita del `Equals` metodo per le principali categorie di tipi in .NET Framework.  
  
|Categoria di tipi|Uguaglianza definito da|Commenti|  
|-------------------|-------------------------|--------------|  
|Classe derivata direttamente da <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Uguaglianza dei riferimenti; equivale a chiamare <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.|  
|Struttura|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|Uguaglianza di valore; confronto byte per byte diretto o campo dal confronto tramite reflection.|  
|Enumerazione|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|I valori devono avere lo stesso tipo di enumerazione e lo stesso valore sottostante.|  
|delegato|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|I delegati devono avere lo stesso tipo con elenchi chiamate identici.|  
|Interfaccia|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Uguaglianza dei riferimenti.|  
  
 Per un tipo valore, è necessario sempre eseguire l'override <xref:System.Object.Equals%2A>, perché verifica l'uguaglianza che si basa sulla reflection offre un peggioramento delle prestazioni. È inoltre possibile sostituire l'implementazione predefinita di <xref:System.Object.Equals%2A> per i tipi di riferimento per verificare l'uguaglianza di valore anziché l'uguaglianza di riferimento e di definire il significato esatto di uguaglianza. Tali implementazioni di <xref:System.Object.Equals%2A> restituire `true` se i due oggetti hanno lo stesso valore, anche se non sono la stessa istanza. Responsabile dell'implementazione del tipo decide cosa si intende un valore di oggetto, ma in genere alcuni o tutti i dati archiviati nelle variabili di istanza dell'oggetto. Ad esempio, il valore di un <xref:System.String> oggetto è basato sui caratteri della stringa; il <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> override dei metodi il <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> per restituire `true` per le due istanze che contengono gli stessi caratteri nello stesso ordine di stringa.  
  
 Nell'esempio seguente viene illustrato come eseguire l'override di <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metodo per verificare l'uguaglianza di valore. Esegue l'override di <xref:System.Object.Equals%2A> metodo per la `Person` classe. Se `Person` accettato l'implementazione della classe di base di uguaglianza, due `Person` oggetti sarebbero uguali solo se viene fatto un singolo oggetto. Tuttavia, in questo caso, due `Person` oggetti sono uguali se hanno lo stesso valore per il `Person.Id` proprietà.  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 Oltre a sostituire <xref:System.Object.Equals%2A>, è possibile implementare il <xref:System.IEquatable%601> interfaccia per fornire un test fortemente tipizzata per verificarne l'uguaglianza.  
  
 Le istruzioni seguenti devono essere true per tutte le implementazioni del <xref:System.Object.Equals%28System.Object%29> metodo. Nell'elenco, `x`, `y`, e `z` rappresentano riferimenti a oggetti che non sono **null**.  
  
-   `x.Equals(x)` Restituisce `true`, tranne nei casi in cui tipi a virgola mobile. Vedere ISO/IEC/IEEE 60559:2011, IT - sistemi microprocessore - aritmetica a virgola mobile.  
  
-   `x.Equals(y)` Restituisce lo stesso valore di `y.Equals(x)`.  
  
-   `x.Equals(y)` Restituisce `true` se entrambi `x` e `y` sono `NaN`.  
  
-   Se `(x.Equals(y) && y.Equals(z))` restituisce `true`, quindi `x.Equals(z)` restituisce `true`.  
  
-   Le chiamate successive a `x.Equals(y)` restituire lo stesso valore, purché gli oggetti a cui fa riferimento `x` e `y` non vengono modificati.  
  
-   `x.Equals(null)` restituisce `false`.  
  
 Le implementazioni di <xref:System.Object.Equals%2A> non devono generare eccezioni; restituiscono sempre un valore. Ad esempio, se `obj` è `null`, <xref:System.Object.Equals%2A> metodo dovrebbe restituire `false` anziché generare un <xref:System.ArgumentNullException>.  
  
 Seguire queste linee guida quando si esegue l'override <xref:System.Object.Equals%28System.Object%29>:  
  
-   I tipi che implementano <xref:System.IComparable> deve eseguire l'override <xref:System.Object.Equals%28System.Object%29>.  
  
-   I tipi che eseguono l'override <xref:System.Object.Equals%28System.Object%29> deve anche eseguire l'override <xref:System.Object.GetHashCode%2A>; in caso contrario, le tabelle hash potrebbero non funzionare correttamente.  
  
-   È consigliabile implementare la <xref:System.IEquatable%601> interfaccia per supportare fortemente tipizzata verifica l'uguaglianza. Il <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementazione debba restituire risultati coerenti con <xref:System.Object.Equals%2A>.  
  
-   Se il linguaggio di programmazione supporta l'overload degli operatori e si esegue l'overload di operatore di uguaglianza per un determinato tipo, è inoltre necessario eseguire l'override di <xref:System.Object.Equals%28System.Object%29> per restituire lo stesso risultato dell'operatore di uguaglianza. Ciò consente di garantire che il codice della libreria di classe che utilizza <xref:System.Object.Equals%2A> (ad esempio <xref:System.Collections.ArrayList> e <xref:System.Collections.Hashtable>) si comporta in modo che sia coerenza con il modo in cui viene utilizzato l'operatore di uguaglianza dal codice dell'applicazione.  
  
### <a name="guidelines-for-reference-types"></a>Linee guida per i tipi di riferimento  
 Applicano le linee guida seguenti per eseguire l'override <xref:System.Object.Equals%28System.Object%29> per un tipo di riferimento:  
  
-   Eseguire l'override <xref:System.Object.Equals%2A> se la semantica del tipo è basata sul fatto che il tipo rappresenta dei valori.  
  
-   La maggior parte dei tipi di riferimento devono non eseguire l'overload dell'operatore di uguaglianza, anche se hanno la precedenza su <xref:System.Object.Equals%2A>. Tuttavia, se si implementa un tipo di riferimento destinato alla semantica dei valori, ad esempio un numero complesso di tipo, è necessario eseguire l'override dell'operatore di uguaglianza.  
  
-   Eseguire l'override di <xref:System.Object.Equals%2A> su un tipo di riferimento modificabile. In questo modo si esegue l'override <xref:System.Object.Equals%2A> richiede anche eseguire l'override di <xref:System.Object.GetHashCode%2A> (metodo), come descritto nella sezione precedente. Ciò significa che è possibile modificare il codice hash di un'istanza di un tipo di riferimento modificabile durante la sua durata, che può causare l'oggetto andranno persi in una tabella hash.  
  
### <a name="guidelines-for-value-types"></a>Linee guida per i tipi di valore  
 Applicano le linee guida seguenti per eseguire l'override <xref:System.Object.Equals%28System.Object%29> per un tipo di valore:  
  
-   Se si definisce un tipo di valore che include uno o più campi i cui valori sono i tipi di riferimento, è necessario eseguire l'override <xref:System.Object.Equals%28System.Object%29>. Il <xref:System.Object.Equals%28System.Object%29> implementazione fornita da <xref:System.ValueType> esegue un confronto byte per byte per i tipi di valore il cui campi sono tutti i tipi di valore, ma usa la reflection per eseguire un confronto da campo di tipi di valore i cui campi includono i tipi di riferimento.  
  
-   Se esegue l'override <xref:System.Object.Equals%2A> e il linguaggio di sviluppo supporta l'overload degli operatori, è necessario eseguire l'overload dell'operatore di uguaglianza.  
  
-   È necessario implementare la <xref:System.IEquatable%601> interfaccia. Chiamare l'oggetto fortemente tipizzato <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> metodo consente di evitare la conversione boxing di `obj` argomento.  
  
   
  
## Examples  
 Nell'esempio seguente un `Point` che esegue l'override di <xref:System.Object.Equals%2A> metodo per fornire l'uguaglianza di valori e un `Point3D` classe che deriva da `Point`. Poiché `Point` esegue l'override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> per verificare l'uguaglianza di valore, il <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> non viene chiamato. Tuttavia, `Point3D.Equals` chiamate `Point.Equals` perché `Point` implementa <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> in modo che fornisce l'uguaglianza di valori.  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 Il `Point.Equals` metodo consente di assicurarsi che il `obj` argomento non è **null** e che faccia riferimento a un'istanza dello stesso tipo di questo oggetto. Se il controllo non riesce, il metodo restituisce `false`.  
  
 Il `Point.Equals` chiamate al metodo di <xref:System.Object.GetType%2A> metodo per determinare se i tipi in fase di esecuzione dei due oggetti sono identici. Se il metodo utilizzato un controllo del form `obj is Point` in c# o `TryCast(obj, Point)` in Visual Basic, il controllo restituirà `true` nei casi in cui `obj` è un'istanza di una classe derivata di `Point`, anche se `obj` e corrente istanza non sono dello stesso tipo in fase di esecuzione. Dopo aver verificato che entrambi gli oggetti sono dello stesso tipo, il metodo esegue il cast `obj` al tipo `Point` e restituisce il risultato del confronto tra i campi di istanza dei due oggetti.  
  
 In `Point3D.Equals`, ereditato `Point.Equals` metodo, che esegue l'override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, viene richiamato prima che qualsiasi altra operazione. Poiché `Point3D` è una classe sealed (`NotInheritable` in Visual Basic), un controllo nel modulo `obj is Point` in c# o `TryCast(obj, Point)` in Visual Basic, è sufficiente per garantire che `obj` è un `Point3D` oggetto. Se è un `Point3D` dell'oggetto, ne viene eseguito il cast a un `Point` dell'oggetto e passata all'implementazione della classe di base di <xref:System.Object.Equals%2A>. Solo quando ereditato `Point.Equals` restituisce `true` il metodo di confronto di `z` introdotti nella classe derivata di campi di istanza.  
  
 L'esempio seguente definisce un `Rectangle` classe che implementa internamente un rettangolo come due `Point` oggetti. Il `Rectangle` esegue l'override anche di classe <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> per fornire l'uguaglianza.  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 Alcuni linguaggi come c# e Visual Basic supportano l'overload degli operatori. Quando un tipo esegue l'overload dell'operatore di uguaglianza, deve anche eseguire l'override di <xref:System.Object.Equals%28System.Object%29> metodo per fornire la stessa funzionalità. Questa operazione viene in genere eseguita mediante la scrittura di <xref:System.Object.Equals%28System.Object%29> metodo in termini dell'operatore di uguaglianza, come nell'esempio seguente.  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 Poiché `Complex` è un tipo di valore, non può essere derivata da.  Pertanto, la sostituzione <xref:System.Object.Equals%28System.Object%29> il metodo non è necessario chiamare <xref:System.Object.GetType%2A> per determinare il run-time preciso tipo di ogni oggetto, ma può utilizzare il `is` operatore in c# o `TypeOf` operatore in Visual Basic per controllare il tipo del `obj` parametro.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Primo oggetto da confrontare.</param>
        <param name="objB">Secondo oggetto da confrontare.</param>
        <summary>Determina se le istanze dell'oggetto specificate sono considerate uguali.</summary>
        <returns>
          <see langword="true" /> se gli oggetti sono considerati uguali; in caso contrario, <see langword="false" />. Se <paramref name="objA" /> e <paramref name="objB" /> sono **null**, il metodo restituisce <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo statico <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> metodo indica se due oggetti, `objA` e `objB`, sono uguali. Consente inoltre di verificare gli oggetti il cui valore è **null** per verificarne l'uguaglianza. Confronta `objA` e `objB` per verificarne l'uguaglianza come indicato di seguito:  
  
-   Determina se due oggetti rappresentano lo stesso riferimento di oggetto. Se l'operazione, il metodo restituisce `true`. Questo test è equivalente alla chiamata di <xref:System.Object.ReferenceEquals%2A> metodo. Inoltre, se entrambi `objA` e `objB` sono **null**, il metodo restituisce `true`.  
  
-   Determina se sia `objA` o `objB` è **null**. Se in tal caso, viene restituito `false`.  
  
-   Se i due oggetti non rappresentano lo stesso riferimento di oggetto e nessuno è **null**, chiama `objA`.`Equals` (`objB`) e restituisce il risultato. Questo significa che se `objA` esegue l'override di <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> , questo override del metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> (metodo) e lo confronta con il <xref:System.Object.ReferenceEquals%2A> metodo.  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Consente a un oggetto di effettuare un tentativo di liberare risorse ed eseguire altre operazioni di pulizia prima che venga recuperato da Garbage Collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Object.Finalize%2A> metodo viene utilizzato per eseguire operazioni di pulitura su risorse non gestite bloccate dall'oggetto corrente prima che l'oggetto viene eliminato definitivamente. Il metodo è protetto e pertanto è accessibile solo tramite questa classe o una classe derivata.  
  
 Contenuto della sezione:  
  
-   [Funzionamento di finalizzazione](#How)  
  
-   [Note per gli implementatori](#Notes)  
  
-   [Alternativa SafeHandle](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>Funzionamento di finalizzazione  
 Il <xref:System.Object> classe non fornisce alcuna implementazione per il <xref:System.Object.Finalize%2A> metodo e il garbage collector non contrassegnare i tipi derivati da <xref:System.Object> per la finalizzazione a meno che non hanno la precedenza il <xref:System.Object.Finalize%2A> metodo.  
  
 Se un tipo esegue l'override di <xref:System.Object.Finalize%2A> (metodo), il garbage collector aggiunge una voce per ogni istanza del tipo a una struttura interna denominata coda di finalizzazione. Coda di finalizzazione contiene voci per tutti gli oggetti nell'heap gestito, il cui codice la finalizzazione deve essere eseguito prima che il garbage collector di recuperare la memoria. Il garbage collector chiama quindi il <xref:System.Object.Finalize%2A> metodo automaticamente le seguenti condizioni:  
  
-   Dopo che il garbage collector ha individuato un oggetto non è accessibile, a meno che l'oggetto sia stato esonerato dalla finalizzazione da una chiamata al <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> metodo.  
  
-   Durante l'arresto di un dominio applicazione, a meno che l'oggetto è esente dalla finalizzazione. Durante l'arresto, anche gli oggetti che sono ancora accessibili vengono finalizzati.  
  
 <xref:System.Object.Finalize%2A> viene chiamato automaticamente una sola volta in un'istanza specifica, a meno che l'oggetto è nuovamente registrato con un meccanismo, ad esempio <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> e <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> metodo non è stato chiamato in seguito.  
  
 <xref:System.Object.Finalize%2A> le operazioni presentano le limitazioni seguenti:  
  
-   L'ora esatta in cui viene eseguito il finalizzatore è definito. Per garantire il rilascio deterministico delle risorse per le istanze della classe, implementare un `Close` metodo o fornire un <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementazione.  
  
-   I finalizzatori di due oggetti non sono garantiti per l'esecuzione in un ordine specifico, anche se un oggetto fa riferimento a altro. Ovvero, se l'oggetto ha un riferimento all'oggetto B e prevedono i finalizzatori, oggetto B potrebbe sia già stato completato quando viene avviato il finalizzatore dell'oggetto.  
  
-   Il thread in cui viene eseguito il finalizzatore non è specificato.  
  
 Il <xref:System.Object.Finalize%2A> metodo potrebbe non essere eseguito fino al completamento o potrebbe non essere eseguito affatto eccezionali circostanze seguenti:  
  
-   Se un altro finalizzatore in modo indefinito (consente di spostarsi in un ciclo infinito, tenta di ottenere un blocco non può ottenere e così via). Poiché il runtime tenta di eseguire i finalizzatori fino al completamento, gli altri finalizzatori potrebbero non essere chiamate se un finalizzatore è bloccato per un periodo illimitato.  
  
-   Se il processo viene terminato senza consentirà di pulire il runtime. In questo caso, prima notifica di completamento del processo del runtime è una notifica DLL_PROCESS_DETACH.  
  
 Il runtime continua a finalizzazione degli oggetti durante l'arresto solo quando il numero di oggetti finalizzabili continua a diminuire.  
  
 Se <xref:System.Object.Finalize%2A> o un override di <xref:System.Object.Finalize%2A> genera un'eccezione e il runtime non è ospitata da un'applicazione che sostituisce il criterio predefinito, il runtime termina il processo e nessun blocco `try` / `finally` blocchi o vengono eseguiti i finalizzatori. Questo comportamento assicura l'integrità del processo se il finalizzatore non può liberare o distruggere risorse.  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>Override del metodo Finalize 
 È necessario eseguire l'override <xref:System.Object.Finalize%2A> per una classe che utilizza le risorse non gestite, ad esempio gli handle di file o le connessioni di database che devono essere liberate quando viene eliminato l'oggetto gestito in cui vengono utilizzati durante l'operazione di garbage collection. Non deve implementare un <xref:System.Object.Finalize%2A> metodo per gli oggetti gestiti, poiché il garbage collector di liberare risorse gestite automaticamente.  
  
> [!IMPORTANT]
>  Se un <xref:System.Runtime.InteropServices.SafeHandle> l'oggetto è disponibile che esegue il wrapping della risorsa non gestita, l'alternativa consigliata consiste nell'implementare il modello dispose un handle sicuro e non eseguire l'override <xref:System.Object.Finalize%2A>. Per ulteriori informazioni, vedere [alternativa SafeHandle il](#SafeHandle) sezione.  
  
 Il <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodo non esegue alcuna operazione per impostazione predefinita, ma è necessario eseguire l'override <xref:System.Object.Finalize%2A> solo se necessario e solo per rilasciare le risorse non gestite. Il recupero della memoria tende a durare più a lungo se viene eseguita un'operazione di completamento, perché richiede almeno due operazioni di garbage collection. Inoltre, è necessario eseguire l'override di <xref:System.Object.Finalize%2A> solo i tipi di metodo per riferimento. Common language runtime consente di finalizzare solo i tipi di riferimento. Ignora i finalizzatori sui tipi di valore.  

L'ambito del <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodo `protected`. Quando si esegue l'override del metodo nella classe, è necessario mantenere questo ambito limitato. Mantenendo un <xref:System.Object.Finalize%2A> metodo protetto, con cui si impedisce agli utenti dell'applicazione di chiamare un oggetto <xref:System.Object.Finalize%2A> metodo direttamente.
  
 Ogni implementazione di <xref:System.Object.Finalize%2A> in un tipo derivato deve chiamare l'implementazione del tipo di base di <xref:System.Object.Finalize%2A>. Questo è l'unico caso in cui applicazione è possibile chiamare codice <xref:System.Object.Finalize%2A>. Un oggetto <xref:System.Object.Finalize%2A> metodo non deve chiamare un metodo in tutti gli oggetti diversi da quello della relativa classe di base. Questo avviene perché gli altri oggetti chiamati è possibile raccogliere contemporaneamente dell'oggetto chiamante, ad esempio nel caso di arresto common language runtime. 
  
> [!NOTE]
>  Il compilatore c# non consente di eseguire l'override di <xref:System.Object.Finalize%2A> metodo. Al contrario, si fornisce un finalizzatore implementando un [distruttore](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) per la classe. Un distruttore c# chiama automaticamente il distruttore della relativa classe base.  
>   
>  Visual C++ fornisce anche una sintassi specifica per l'implementazione di <xref:System.Object.Finalize%2A> metodo. Per ulteriori informazioni, vedere la sezione "Distruttori e finalizzatori" di [procedura: definire e usare classi e struct (C + + CLI)](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).  
  
 Poiché l'operazione di garbage collection è non deterministico, non si conoscono con precisione durante la finalizzazione effettuata dal garbage collector. Per rilasciare le risorse immediatamente, è possibile anche scegliere di implementare il [modello dispose](~/docs/standard/design-guidelines/dispose-pattern.md) e <xref:System.IDisposable> interfaccia. Il <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementazione può essere chiamata dal consumer della classe per liberare risorse non gestite e, è possibile utilizzare il <xref:System.Object.Finalize%2A> metodo per liberare risorse non gestite nel caso in cui il <xref:System.IDisposable.Dispose%2A> non viene chiamato.  
  
 <xref:System.Object.Finalize%2A> può richiedere qualsiasi azione, tra cui ripristinare un oggetto (che è, renderlo accessibile nuovo) dopo averlo eliminato durante l'operazione di garbage collection. Tuttavia, l'oggetto può essere ripristinato soltanto una volta. <xref:System.Object.Finalize%2A> non può essere chiamato su oggetti ripristinati durante l'operazione di garbage collection. È un'azione che l'implementazione di <xref:System.Object.Finalize%2A> deve non accettano mai: non deve mai generare un'eccezione. Se tutte le eccezioni generate dai metodi chiamati dal <xref:System.Object.Finalize%2A> gestite dal metodo di <xref:System.Object.Finalize%2A> (metodo), il runtime si presuppone che il <xref:System.Object.Finalize%2A> metodo restituito e continua a chiamare il <xref:System.Object.Finalize%2A> metodi di altri oggetti. 
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>Alternativa SafeHandle  
 Creazione di finalizzatori affidabili è spesso difficile, poiché è possibile basarsi su presupposti sullo stato dell'applicazione e sistema eccezioni non gestite, ad esempio <xref:System.OutOfMemoryException> e <xref:System.StackOverflowException> terminare il finalizzatore. Anziché implementare un finalizzatore per la classe per rilasciare le risorse non gestite, è possibile utilizzare un oggetto derivato dalla <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> classe per eseguire il wrapping delle risorse non gestite e quindi implementare il modello dispose senza un finalizzatore. .NET Framework fornisce le seguenti classi di <xref:Microsoft.Win32?displayProperty=nameWithType> dello spazio dei nomi che derivano da <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> è una classe wrapper per un handle di file.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> è una classe wrapper per gli handle di file mappati alla memoria.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> è una classe wrapper per un puntatore a un blocco di memoria non gestita.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, e <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> sono classi wrapper per gli handle del servizio di crittografia.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> è una classe wrapper per gli handle di pipe.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> è una classe wrapper per un handle a una chiave del Registro di sistema.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> è una classe wrapper per un handle di attesa.  
  
 L'esempio seguente usa il [modello dispose](~/docs/standard/design-guidelines/dispose-pattern.md) con handle sicuri anziché eseguire l'override di <xref:System.Object.Finalize%2A> metodo. Definisce un `FileAssociation` classe che esegue il wrapping delle informazioni del Registro di sistema sull'applicazione che gestisce i file con un'estensione di file specifico. Gli handle del Registro di sistema restituiti come `out` parametri da Windows [RegOpenKeyEx](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) chiamate di funzione vengono passate al <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> costruttore. Il tipo del protetto `Dispose` chiama quindi il `SafeRegistryHandle.Dispose` metodo per liberare gli handle di due.  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 Nell'esempio seguente verifica che il <xref:System.Object.Finalize%2A> metodo viene chiamato quando un oggetto che esegue l'override <xref:System.Object.Finalize%2A> viene eliminato definitivamente. Si noti che, in un'applicazione di produzione di <xref:System.Object.Finalize%2A> potrebbe eseguire l'override di metodo per rilasciare le risorse non gestite utilizzate dall'oggetto. Si noti inoltre che l'esempio c# fornisce un distruttore anziché eseguire l'override di <xref:System.Object.Finalize%2A> metodo.  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 Per un altro esempio che esegue l'override di <xref:System.Object.Finalize%2A> metodo, vedere il <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Funge da funzione hash predefinita.</summary>
        <returns>Codice hash per l'oggetto corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codice hash è un valore numerico utilizzato per inserire e identificare un oggetto in una raccolta basata su hash, ad esempio il <xref:System.Collections.Generic.Dictionary%602> (classe), il <xref:System.Collections.Hashtable> , classe o un tipo derivato dalla <xref:System.Collections.DictionaryBase> classe. Il <xref:System.Object.GetHashCode%2A> metodo fornisce il codice hash per algoritmi che richiedono controlli rapidi di uguaglianza di oggetti.  
  
> [!NOTE]
>  Per informazioni sull'utilizzo di codici hash nelle tabelle hash e alcuni algoritmi di codice hash aggiuntive, vedere il [funzione Hash](https://en.wikipedia.org/wiki/Hash_function) voce di Wikipedia.  
  
 Due oggetti sono codici hash restituito uguali sono uguali. Tuttavia, non è vero il contrario: i codici hash uguale non implicano uguaglianza di oggetti, poiché diversi oggetti (uguali) possono avere i codici hash identici. Inoltre, .NET Framework non garantisce l'implementazione predefinita del <xref:System.Object.GetHashCode%2A> (metodo) e il valore di questo metodo restituisce possono variare tra le versioni di .NET Framework e piattaforme, ad esempio le piattaforme a 32 bit e 64 bit. Per questi motivi, non utilizzare l'implementazione predefinita di questo metodo come identificatore di oggetto univoco per scopi di hash. Due conseguenze seguono da questo oggetto:  
  
-   Non si deve presupporre che i codici hash uguale implicano uguaglianza degli oggetti.  
  
-   È consigliabile mai vengono mantenute o utilizzare un codice hash all'esterno del dominio applicazione in cui è stato creato, perché possono avere hash dello stesso oggetto tra piattaforme, processi e domini applicazione.  
  
> [!WARNING]
>  Codice hash è destinato inserimento efficiente e la ricerca nelle raccolte basate su una tabella hash. Codice hash non è un valore permanente. Per questo motivo:  
>   
>  -   Non serializzare i valori di codice hash o archiviarli nel database.  
> -   Non utilizzare il codice hash come chiave per recuperare un oggetto da una raccolta con chiave.  
> -   Non inviare i codici hash tra i domini applicazioni o processi. In alcuni casi, i codici hash possono essere calcolati in base al dominio per processo o per ogni applicazione.  
> -   Non utilizzare il codice hash anziché un valore restituito da una funzione hash di crittografia, se è necessario un hash crittografico. Per gli hash di crittografia, utilizzare una classe derivata dal <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> o <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> classe.  
> -   Verifica l'uguaglianza dei codici hash per determinare se due oggetti sono uguali. (Oggetti diversi possono avere codici hash identici). Per verificare l'uguaglianza, chiamare il <xref:System.Object.ReferenceEquals%2A> o <xref:System.Object.Equals%2A> metodo.  
  
 Il <xref:System.Object.GetHashCode%2A> metodo può essere sovrascritto da un tipo derivato. Se <xref:System.Object.GetHashCode%2A> è non sottoposto a override, codici hash per i tipi di riferimento vengono calcolati chiamando il <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> metodo della classe base, che calcola un codice hash basato sul riferimento a un oggetto; per ulteriori informazioni, vedere <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>. In altre parole, due oggetti per i quali il <xref:System.Object.ReferenceEquals%2A> restituisce `true` codici hash identici. Se i tipi di valore esegue l'override <xref:System.Object.GetHashCode%2A>, <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> metodo della classe di base utilizza la reflection per calcolare il codice hash in base ai valori dei campi del tipo. In altre parole, i cui campi hanno valori uguali i tipi di valore sono i codici hash uguale. Per ulteriori informazioni sull'override <xref:System.Object.GetHashCode%2A>, vedere la sezione "Note per gli eredi".  
  
> [!WARNING]
>  Se esegue l'override di <xref:System.Object.GetHashCode%2A> metodo, di eseguire l'override <xref:System.Object.Equals%2A>e viceversa. Se sottoposto a override <xref:System.Object.Equals%2A> restituisce `true` quando due oggetti sono testati per verificarne l'uguaglianza, sottoposto a override <xref:System.Object.GetHashCode%2A> metodo deve restituire lo stesso valore per i due oggetti.  
  
 Se un oggetto che viene utilizzato come chiave in una tabella hash non fornisce un'implementazione utile di <xref:System.Object.GetHashCode%2A>, è possibile specificare un provider di codice hash, fornendo un <xref:System.Collections.IEqualityComparer> implementazione a uno degli overload di <xref:System.Collections.Hashtable> costruttore della classe.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Note per il [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Quando si chiama il <xref:System.Object.GetHashCode%2A> metodo in una classe di [!INCLUDE[wrt](~/includes/wrt-md.md)], fornisce il comportamento predefinito per le classi che non esegue l'override <xref:System.Object.GetHashCode%2A>. Questo aspetto è parte del supporto fornito da .NET Framework per la [!INCLUDE[wrt](~/includes/wrt-md.md)] (vedere [.NET Framework supportano per applicazioni Windows Store e Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Classi di [!INCLUDE[wrt](~/includes/wrt-md.md)] non ereditano <xref:System.Object>e non implementano un <xref:System.Object.GetHashCode%2A>. Tuttavia, sembrano disporre <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, e <xref:System.Object.GetHashCode%2A> metodi quando utilizzarle nel codice c# o Visual Basic e .NET Framework fornisce il comportamento predefinito per questi metodi.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] le classi che vengono scritti in c# o Visual Basic possono eseguire l'override di <xref:System.Object.GetHashCode%2A> metodo.  
  
   
  
## Examples  
 Uno dei modi più semplici per calcolare un codice hash per un valore numerico con lo stesso o un intervallo più piccolo rispetto al <xref:System.Int32> tipo è semplicemente restituire tale valore. Nell'esempio seguente viene illustrato tale implementazione per un `Number` struttura.  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 Spesso, un tipo dispone di più campi di dati che possono partecipare alla generazione di codice hash. Per generare un codice hash è possibile combinare questi campi utilizzando un `XOR (eXclusive OR)` operazione, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 L'esempio precedente restituisce lo stesso codice hash per (n1, n2) e (n2, n1) e pertanto può generare più collisioni di è auspicabile. Un numero di soluzioni è disponibile in modo che i codici hash in questi casi non sono identici. Per restituire il codice hash di cui uno è un `Tuple` oggetto che corrisponde all'ordine di ogni campo. Nell'esempio seguente viene illustrata una possibile implementazione che utilizza il <xref:System.Tuple%602> classe. Si noti tuttavia che l'overhead delle prestazioni di un'istanza di un `Tuple` oggetto può influire notevolmente sulle prestazioni complessive di un'applicazione che memorizza un numero elevato di oggetti nelle tabelle hash.  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 Una seconda soluzione alternativa prevede ponderazione i codici hash singoli da spostamento a sinistra i codici hash di successivi campi di bit di due o più. In modo ottimale, invece di essere eliminato, i bit spostati oltre a 31 bit devono eseguire il wrapping intorno anziché ignorati. Poiché bit vengono rimossi dagli operatori di spostamento a sinistra in c# e Visual Basic, questa operazione richiede creazione di un metodo shift a capo sinistro simile al seguente:  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 L'esempio seguente usa quindi questo metodo shift a capo per calcolare il codice hash del `Point` struttura utilizzata negli esempi precedenti.  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Una funzione hash viene utilizzata per generare rapidamente un numero (codice hash) che corrisponde al valore di un oggetto. Le funzioni hash vengono in genere specifiche per ogni tipo e l'univocità, devono utilizzare almeno uno dei campi di istanza come input. I codici hash non può essere calcolati utilizzando i valori dei campi statici.  Per le classi derivate da <see cref="T:System.Object" />, il <see langword="GetHashCode" /> metodo può delegare alla classe di base <see cref="M:System.Object.GetHashCode" /> implementazione solo se la classe derivata definisce l'uguaglianza per l'uguaglianza dei riferimenti. L'implementazione predefinita di <see cref="M:System.Object.GetHashCode" /> per riferimento tipi restituisce un codice hash che corrisponde a quello restituito dal <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> metodo. È possibile eseguire l'override <see cref="M:System.Object.GetHashCode" /> per i tipi di riferimento non modificabile. In generale, per i tipi di riferimento modificabile, è necessario eseguire l'override <see cref="M:System.Object.GetHashCode" /> solo se:: È possibile calcolare il codice hash dai campi che non sono modificabili; o - è possibile assicurarsi che il codice hash di un oggetto modificabile non modificato mentre l'oggetto è contenuto in un collecti in cui si basa sul relativo codice hash.  In caso contrario, si potrebbe pensare che l'oggetto modificabile viene perso nella tabella hash. Se si sceglie di eseguire l'override <see cref="M:System.Object.GetHashCode" /> per un tipo di riferimento modificabile, la documentazione di inoltre deve essere chiaro che gli utenti del tipo non devono modificare i valori di oggetto mentre l'oggetto viene archiviato in una tabella hash.  Per i tipi di valore, <see cref="M:System.ValueType.GetHashCode" /> fornisce un'implementazione di codice hash predefinito che utilizza la reflection. È consigliabile eseguirne l'override per ottenere prestazioni migliori.  <block subset="none" type="note"><para> Per ulteriori informazioni ed esempi che consentono di calcolare i codici hash in diversi modi, vedere la sezione esempi.  </para></block>  Una funzione hash deve avere le proprietà seguenti: - se due oggetti considerati uguali, la <see cref="M:System.Object.GetHashCode" /> metodo per ogni oggetto deve restituire lo stesso valore. Tuttavia, se due oggetti non vengono considerati uguali, la <see cref="M:System.Object.GetHashCode" /> metodi per i due oggetti non sono necessario restituire valori diversi.  -La <see cref="M:System.Object.GetHashCode" /> metodo per un oggetto in modo coerente deve restituire lo stesso codice hash, purché non vi sia alcuna modifica allo stato dell'oggetto che determina il valore restituito dell'oggetto [System.Object.Equals](xref:System.Object.Equals*) metodo. Si noti che questo vale solo per l'esecuzione corrente di un'applicazione e che può essere restituito un codice hash diverso se l'applicazione viene eseguita nuovamente.  -Per ottenere prestazioni ottimali, una funzione hash deve generare una distribuzione uniforme per tutti gli input, tra cui input molto frequentemente in cluster. Un'implicazione è che piccole modifiche allo stato dell'oggetto devono comportare modifiche di grandi dimensioni per il codice hash risultante per ottimizzare le prestazioni di tabella hash.  -Funzioni hash devono essere a basso costo per il calcolo.  -La <see cref="M:System.Object.GetHashCode" /> (metodo) non deve generare eccezioni.  Ad esempio, l'implementazione del <see cref="M:System.String.GetHashCode" /> fornito dal metodo di <see cref="T:System.String" /> classe restituisce codici hash identici per i valori di stringa identica. Pertanto, due <see cref="T:System.String" /> oggetti restituiscono lo stesso codice hash se rappresentano lo stesso valore di stringa. Inoltre, il metodo utilizza tutti i caratteri nella stringa di generare output distribuiti ragionevolmente in modo casuale, anche quando l'input è un indice cluster in determinati intervalli (ad esempio, molti utenti potrebbero avere le stringhe che contengono solo gli inferiore 128 caratteri ASCII, anche se un stringa può contenere i caratteri Unicode 65.535).  Fornisce una funzione hash valida in una classe può influire in modo significativo le prestazioni di aggiunta di tali oggetti in una tabella hash. In una tabella hash con chiavi che forniscono l'implementazione di una funzione hash, la ricerca di un elemento tempo costante (ad esempio, un'operazione o (1)). In una tabella hash con una scarsa implementazione di una funzione hash, le prestazioni di una ricerca dipendono dal numero di elementi nella tabella hash (ad esempio, un'operazione O('n'), in cui "n" è il numero di elementi nella tabella hash). Un utente malintenzionato può immettere dati che consentono di aumentare il numero di conflitti, che può ridurre significativamente le prestazioni delle applicazioni che dipendono da tabelle hash, le condizioni seguenti: - quando le funzioni hash producono frequenti conflitti.  -Quando una proporzione elevata degli oggetti in una tabella hash producono i codici hash che sono uguali o approssimativamente uguale uno a altro.  -Quando gli utenti immettere i dati da cui viene calcolato il codice hash.  Le classi derivate che eseguire l'override <see cref="M:System.Object.GetHashCode" /> deve anche eseguire l'override <see cref="M:System.Object.Equals(System.Object)" /> per garantire che due oggetti considerati uguali abbiano lo stesso codice hash; in caso contrario, il <see cref="T:System.Collections.Hashtable" /> tipo potrebbe non funzionare correttamente.</para>
        </block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Type" /> dell'istanza corrente.</summary>
        <returns>Tipo esatto di runtime dell'istanza corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poiché <xref:System.Object?displayProperty=nameWithType> è la classe base per tutti i tipi nel sistema di tipi .NET Framework, il <xref:System.Object.GetType%2A> metodo può essere utilizzato per restituire <xref:System.Type> gli oggetti che rappresentano tutti i tipi di .NET Framework. .NET Framework riconosce le seguenti cinque categorie di tipi:  
  
-   Classi che derivano da <xref:System.Object?displayProperty=nameWithType>,  
  
-   Valore, i tipi derivati da <xref:System.ValueType?displayProperty=nameWithType>.  
  
-   Interfacce che derivano da <xref:System.Object?displayProperty=nameWithType> a partire da .NET Framework 2.0.  
  
-   Le enumerazioni, che derivano da <xref:System.Enum?displayProperty=nameWithType>.  
  
-   Delegati, che derivano da <xref:System.MulticastDelegate?displayProperty=nameWithType>.  
  
 Per due oggetti `x` e `y` con tipi di runtime identici, `Object.ReferenceEquals(x.GetType(),y.GetType())` restituisce `true`. L'esempio seguente usa il <xref:System.Object.GetType%2A> metodo con il <xref:System.Object.ReferenceEquals%2A> metodo per determinare se un valore numerico è dello stesso tipo altri due valori numerici.  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  Per determinare se un oggetto è un tipo specifico, è possibile utilizzare una parola chiave confronto del tipo del linguaggio o creare. Ad esempio, è possibile utilizzare il `TypeOf…Is` costruire in Visual Basic o `is` (parola chiave) in c#.  
  
 Il <xref:System.Object.GetType%2A> metodo viene ereditato da tutti i tipi che derivano da <xref:System.Object>. Ciò significa che, oltre a utilizzare parole chiave di confronto della lingua, è possibile utilizzare il <xref:System.Object.GetType%2A> metodo per determinare il tipo di un oggetto specifico, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 Il <xref:System.Type> oggetto espone i metadati associati alla classe dell'oggetto corrente <xref:System.Object>.  
  
   
  
## Examples  
 Esempio di codice seguente viene dimostrato che <xref:System.Object.GetType%2A> restituisce il tipo di runtime dell'istanza corrente.  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una copia superficiale dell'oggetto <see cref="T:System.Object" /> corrente.</summary>
        <returns>Copia superficiale dell'oggetto <see cref="T:System.Object" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Object.MemberwiseClone%2A> metodo crea una copia superficiale creando un nuovo oggetto e quindi copiando i campi non statici dell'oggetto corrente al nuovo oggetto. Se un campo è un tipo di valore, viene eseguita una copia bit per bit del campo. Se un campo è un tipo riferimento, il riferimento viene copiato ma l'oggetto cui viene fatto riferimento non; Pertanto, l'oggetto originale e il suo clone fare riferimento allo stesso oggetto.  
  
 Si consideri ad esempio un oggetto denominato X che fa riferimento a oggetti A e B, a sua volta, oggetto references C. Una copia superficiale di X Crea nuovo oggetto X2 che fa riferimento a oggetti A e B. Al contrario, una copia completa di X crea un nuovo oggetto X2 che fa riferimento a nuovi oggetti A2 e B2, che sono copie di e B. B2, fa riferimento a sua volta, il nuovo oggetto C2, che è una copia di C. Nell'esempio viene illustrata la differenza tra un shallow e un'operazione di copia completa.  
  
 Esistono diversi modi per implementare un'operazione di copia completa se eseguire l'operazione di copia dei riferimenti per il <xref:System.Object.MemberwiseClone%2A> metodo non soddisfa le proprie esigenze. tra cui:  
  
-   Chiamare un costruttore di classe dell'oggetto da copiare per creare un secondo oggetto con valori di proprietà ricavati dal primo oggetto. Si presuppone che i valori di un oggetto sono completamente definiti dal costruttore di classe.  
  
-   Chiamare il <xref:System.Object.MemberwiseClone%2A> per creare una copia superficiale di un oggetto e quindi assegnare nuovi oggetti i cui valori sono gli stessi dell'oggetto originale a qualsiasi proprietà o campi i cui valori sono i tipi di riferimento. Il `DeepCopy` metodo nell'esempio riportato di seguito viene illustrato questo approccio.  
  
-   Serializzare l'oggetto verrà approfondito copiati e quindi ripristinare i dati serializzati a una variabile di un oggetto diverso.  
  
-   Per eseguire l'operazione di copia completa, usare la reflection viene utilizzata la ricorsione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Object.MemberwiseClone%2A> metodo. Definisce un `ShallowCopy` metodo che chiama il <xref:System.Object.MemberwiseClone%2A> metodo per eseguire un'operazione di copia dei riferimenti in un `Person` oggetto. Definisce inoltre un `DeepCopy` metodo che esegue un'operazione di copia completa su un `Person` oggetto.  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 In questo esempio, il `Person.IdInfo` proprietà restituisce un `IdInfo` oggetto. Come output illustrato nell'esempio, quando un `Person` oggetto viene duplicato chiamando il <xref:System.Object.MemberwiseClone%2A> (metodo), il duplicato `Person` oggetto è una copia indipendente dell'oggetto originale, ad eccezione del fatto che essi condividono lo stesso `Person.IdInfo` riferimento all'oggetto. Modifica di conseguenza, il clone `Person.IdInfo` modifica di proprietà dell'oggetto originale `Person.IdInfo` proprietà. D'altra parte, quando viene eseguita un'operazione di copia completa, clonato `Person` dell'oggetto, inclusi il relativo `Person.IdInfo` proprietà possono essere modificati senza influire sull'oggetto originale.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Primo oggetto da confrontare.</param>
        <param name="objB">Secondo oggetto da confrontare.</param>
        <summary>Determina se le istanze di <see cref="T:System.Object" /> specificate rappresentano la stessa istanza.</summary>
        <returns>
          <see langword="true" /> se <paramref name="objA" /> è la stessa istanza di <paramref name="objB" /> oppure se entrambe sono **null**; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza di <xref:System.Object.Equals%2A> (metodo) e l'operatore di uguaglianza, il <xref:System.Object.ReferenceEquals%2A> non è possibile eseguire l'override di metodo. Per questo motivo, se si desidera testare due riferimenti per verificarne l'uguaglianza di oggetti e non si conosce l'implementazione del `Equals` (metodo), è possibile chiamare il <xref:System.Object.ReferenceEquals%2A> metodo.  
  
 Tuttavia, il valore restituito di <xref:System.Object.ReferenceEquals%2A> metodo può essere visualizzato come anomali in questi due scenari:  
  
-   Durante il confronto dei tipi di valore. Se `objA` e `objB` sono tipi di valore, vengono sottoposti a boxing prima di essere passati al <xref:System.Object.ReferenceEquals%2A> metodo. Ciò significa che se entrambi `objA` e `objB` rappresentano la stessa istanza di un tipo di valore, il <xref:System.Object.ReferenceEquals%2A> metodo restituisce comunque `false`, come illustrato nell'esempio seguente.  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     Per informazioni sui tipi di valore di conversione boxing, vedere [Boxing e Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).  
  
-   Quando si confrontano le stringhe. Se `objA` e `objB` sono stringhe, il <xref:System.Object.ReferenceEquals%2A> restituisce `true` se la stringa è inserita. Non esegue un test di uguaglianza.  Nell'esempio seguente, `s1` e `s2` sono uguali, in quanto sono due istanze di una singola stringa centralizzata. Tuttavia, `s3` e `s4` non sono uguali, perché anche se hanno valori di stringa identica, tale stringa non è inserita.  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     Per ulteriori informazioni sull'inserimento di stringhe, vedere <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L'esempio seguente usa <xref:System.Object.ReferenceEquals%2A> per determinare se due oggetti sono la stessa istanza.  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una stringa che rappresenta l'oggetto corrente.</summary>
        <returns>Stringa che rappresenta l'oggetto corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> è il principale metodo di formattazione in .NET Framework. Converte un oggetto nella relativa rappresentazione di stringa in modo che sia adatto per la visualizzazione. (Per informazioni sulla formattazione di supporto in .NET Framework, vedere [formattazione dei tipi di](~/docs/standard/base-types/formatting-types.md).) Le implementazioni predefinite del <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo restituisce il nome completo del tipo dell'oggetto.  
  
> [!IMPORTANT]
>  È stato raggiunto questa pagina seguendo il collegamento dall'elenco dei membri di un altro tipo. Ciò accade perché tale tipo non esegue l'override <xref:System.Object.ToString%2A?displayProperty=nameWithType>. Eredita invece la funzionalità del <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo.  
  
 Tipi spesso eseguono l'override di <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo per fornire una rappresentazione di stringa più adatta di un determinato tipo. Tipi spesso anche eseguire l'overload di <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo per fornire il supporto per le stringhe di formato o la formattazione delle impostazioni cultura.  
  
 Contenuto della sezione:  
  
 [Il metodo ToString predefinito](#Default)   
 [Override del metodo ToString](#Overriding)   
 [L'overload del metodo ToString](#Overloading)   
 [Estendere il metodo ToString](#Extending)   
 [Note per Windows Runtime](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>Il metodo ToString predefinito  
 L'implementazione predefinita del <xref:System.Object.ToString%2A> il metodo restituisce il nome completo del tipo del <xref:System.Object>, come illustrato nell'esempio seguente.  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 Poiché <xref:System.Object> è la classe di base di tutti i tipi di riferimento in .NET Framework, questo comportamento viene ereditato dai tipi di riferimento che non eseguono l'override di <xref:System.Object.ToString%2A> metodo. Questa condizione è illustrata nell'esempio seguente. Definisce una classe denominata `Object1` che accetta l'implementazione predefinita di tutte <xref:System.Object> membri. Il relativo <xref:System.Object.ToString%2A> metodo restituisce il nome di tipo completo dell'oggetto.  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>Override del metodo ToString  
 Tipi spesso eseguono l'override di <xref:System.Object.ToString%2A?displayProperty=nameWithType> per restituire una stringa che rappresenta l'istanza dell'oggetto. Ad esempio, tipi di base come <xref:System.Char>, <xref:System.Int32>, e <xref:System.String> fornire <xref:System.Object.ToString%2A> implementazioni che restituiscono il formato di stringa del valore che rappresenta l'oggetto. L'esempio seguente definisce una classe, `Object2`, che esegue l'override di <xref:System.Object.ToString%2A> per restituire il nome del tipo insieme al relativo valore.  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 Nella tabella seguente sono elencate le categorie di tipo in .NET Framework e indica se eseguire l'override del <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo.  
  
|Categoria di tipi|Esegue l'override di ToString|Comportamento|  
|-------------------|-----------------------------------|--------------|  
|Classe|N/D|N/D|  
|Struttura|Sì (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|Identico ToString|  
|Enumerazione|Sì (<xref:System.Enum.ToString?displayProperty=nameWithType>)|Il nome del membro|  
|Interfaccia|No|N/D|  
|delegato|No|N/D|  
  
 Vedere la sezione Note per gli eredi per ulteriori informazioni sull'override <xref:System.Object.ToString%2A>.  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>L'overload del metodo ToString  
 Oltre a sostituire senza parametri <xref:System.Object.ToString?displayProperty=nameWithType> overload del metodo, molti tipi di `ToString` metodo per fornire versioni del metodo che accettano parametri. In genere, questa operazione viene eseguita per fornire il supporto per la formattazione variabile e la formattazione delle impostazioni cultura.  
  
 Gli overload di esempio seguente il `ToString` per restituire una stringa di risultato che include il valore di diversi campi di un `Automobile` classe. Definisce quattro stringhe di formato: G, che restituisce il nome del modello e l'anno; D, che restituisce il nome del modello, anno e numero di porte; C, che restituisce il nome del modello, anno e numero di cilindri; e che restituisce una stringa con tutti i valori di campo quattro.  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 Nell'esempio seguente chiama il metodo di overload <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodo di formattazione di visualizzazione delle impostazioni cultura di un valore di valuta.  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 Per ulteriori informazioni sulla stringhe di formato e la formattazione delle impostazioni cultura, vedere [formattazione dei tipi di](~/docs/standard/base-types/formatting-types.md). Per le stringhe di formato supportate da valori numerici, vedere [stringhe di formato numerico Standard](~/docs/standard/base-types/standard-numeric-format-strings.md) e [stringhe di formato numerico personalizzato](~/docs/standard/base-types/custom-numeric-format-strings.md). Per le stringhe di formato supportate dai valori data e ora, vedere [stringhe di formato di ora e data Standard](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [stringhe di formato di ora e Data personalizzata](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>Estendere il metodo ToString  
 Poiché un tipo eredita il valore predefinito <xref:System.Object.ToString%2A?displayProperty=nameWithType> (metodo), è possibile trovare il relativo comportamento indesiderato e modificarla. Questo vale in particolare delle classi di raccolta e matrici. Anche se si prevede di `ToString` metodo di una matrice o raccolta classe per visualizzare i valori dei relativi membri, ma visualizza il nome completo del tipo del tipo, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 Sono disponibili diverse opzioni per ottenere la stringa di risultato che si desidera.  
  
-   Se il tipo è una matrice, un oggetto raccolta o un oggetto che implementa il <xref:System.Collections.IEnumerable> o <xref:System.Collections.Generic.IEnumerable%601> interfacce, è possibile enumerare i relativi elementi tramite il `foreach` istruzione in c# o `For Each...Next` costruire in Visual Basic.  
  
-   Se non è la classe `sealed` (in c#) o `NotInheritable` (in Visual Basic), è possibile sviluppare una classe wrapper che eredita dalla classe di base il cui <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo che si desidera personalizzare. Come minimo, è necessario effettuare le operazioni seguenti:  
  
    1.  Implementare costruttori necessari. Le classi derivate non ereditano i costruttori di classe base.  
  
    2.  Eseguire l'override di <xref:System.Object.ToString%2A?displayProperty=nameWithType> per restituire la stringa di risultato che si desidera.  
  
     L'esempio seguente definisce una classe wrapper per la <xref:System.Collections.Generic.List%601> classe. Esegue l'override di <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo per visualizzare il valore di ogni metodo di raccolta, anziché il nome completo del tipo.  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   Sviluppare un [metodo di estensione](~/docs/standard/design-guidelines/extension-methods.md) che restituisce la stringa di risultato desiderato. Si noti che non è possibile sostituire il valore predefinito <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo in questo modo (ovvero, la classe di estensione (in c#) o il modulo (in Visual Basic) non può avere un metodo senza parametri denominato `ToString` che viene chiamato al posto del tipo originale `ToString` (metodo) . È necessario fornire un altro nome per il senza parametri `ToString` sostituzione.  
  
     L'esempio seguente definisce due metodi che estendono il <xref:System.Collections.Generic.List%601> classe: un costruttore `ToString2` (metodo) e un `ToString` metodo con un <xref:System.String> parametro che rappresenta una stringa di formato.  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Note per il [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Quando si chiama il <xref:System.Object.ToString%2A> metodo in una classe di [!INCLUDE[wrt](~/includes/wrt-md.md)], fornisce il comportamento predefinito per le classi che non esegue l'override <xref:System.Object.ToString%2A>. Questo aspetto è parte del supporto fornito da .NET Framework per la [!INCLUDE[wrt](~/includes/wrt-md.md)] (vedere [.NET Framework supportano per applicazioni Windows Store e Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Classi di [!INCLUDE[wrt](~/includes/wrt-md.md)] non ereditano <xref:System.Object>e non sempre implementare un <xref:System.Object.ToString%2A>. Tuttavia, sempre sembrano disporre <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, e <xref:System.Object.GetHashCode%2A> metodi quando utilizzarle nel codice c# o Visual Basic e .NET Framework fornisce un comportamento predefinito per questi metodi.  
  
 A partire dal [!INCLUDE[net_v451](~/includes/net-v451-md.md)], common language runtime utilizzerà [istringable. ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) su un [!INCLUDE[wrt](~/includes/wrt-md.md)] oggetto prima di eseguire il fallback per l'implementazione predefinita di <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] le classi che vengono scritti in c# o Visual Basic possono eseguire l'override di <xref:System.Object.ToString%2A> metodo.  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>Il [!INCLUDE[wrt](~/includes/wrt-md.md)] e l'interfaccia di IStringable  
 A partire da [!INCLUDE[win81](~/includes/win81-md.md)], [!INCLUDE[wrt](~/includes/wrt-md.md)] include un [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) il cui unico metodo di interfaccia [istringable. ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), fornisce il supporto di formattazione base analogo a quello fornito da <xref:System.Object.ToString%2A?displayProperty=nameWithType>. Per evitare ambiguità, è consigliabile non implementare [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in tipi gestiti.  
  
 Quando gli oggetti gestiti vengono chiamati da codice nativo o da codice scritto in linguaggi quali JavaScript o C + + CX, vengono visualizzati per implementare [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx). Common language runtime indirizzerà automaticamente le chiamate da [istringable. ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) a <xref:System.Object.ToString%2A?displayProperty=nameWithType> nell'evento [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) non è implementato nell'oggetto gestito.  
  
> [!WARNING]
>  Poiché common language runtime. auto-implementa [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) per tutti i tipi in gestiti [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] App, è consigliabile che non si fornisce la propria [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementazione. Implementazione di [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) potrebbero causare comportamenti imprevisti quando si chiama `ToString` dal [!INCLUDE[wrt](~/includes/wrt-md.md)], C + + CX o JavaScript.  
  
 Se si sceglie di implementare [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in un tipo gestito pubblico esportato in un [!INCLUDE[wrt](~/includes/wrt-md.md)] componente, le limitazioni seguenti:  
  
-   È possibile definire il [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interfaccia solo in una relazione "implementazione della classe", ad esempio  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     in C# oppure  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     in Visual Basic.  
  
-   Non è possibile implementare [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) su un'interfaccia.  
  
-   È possibile dichiarare un parametro di tipo [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).  
  
-   [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) non può essere il tipo restituito di un metodo, proprietà o campo.  
  
-   Non è possibile nascondere il [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementazione dalle classi di base usando una definizione di metodo, ad esempio le operazioni seguenti:  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     Al contrario, il [istringable. ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementazione deve sempre eseguire l'override dell'implementazione della classe base. Puoi nascondere un'implementazione di `ToString` solo richiamandola sull'istanza di una classe fortemente tipizzata.  
  
 Si noti che in diverse circostanze le chiamate dal codice nativo a un tipo gestito che implementa [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) o nasconde il [ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementazione può produrre un comportamento imprevisto.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si implementano i tipi personalizzati, è necessario eseguire l'override di <see cref="M:System.Object.ToString" /> metodo per restituire i valori che sono significativi per tali tipi. Le classi derivate che richiedono un maggiore controllo sulla formattazione rispetto <see cref="M:System.Object.ToString" /> fornisce può implementare il <see cref="T:System.IFormattable" /> interfaccia. Il relativo <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> metodo consente di definire le stringhe di formato che consentono di controllare la formattazione e di utilizzare un <see cref="T:System.IFormatProvider" /> oggetto che può fornire per la formattazione specifiche delle impostazioni cultura.  Esegue l'override del <see cref="M:System.Object.ToString" /> metodo deve attenersi alle indicazioni seguenti:-la stringa restituita deve essere leggibile dagli utenti e descrittivo.  -La stringa restituita deve identificare in modo univoco il valore dell'istanza dell'oggetto.  -La stringa restituita deve essere ridotto al minimo, in modo che sia adatto per la visualizzazione da un debugger.  -I <see cref="M:System.Object.ToString" /> override non dovrebbe restituire <see cref="F:System.String.Empty" /> o una stringa null.  -Il <see cref="M:System.Object.ToString" /> override non deve generare un'eccezione.  -Se la rappresentazione di stringa di un'istanza è dipendente dalle impostazioni cultura o può essere formattata in diversi modi, implementare il <see cref="T:System.IFormattable" /> interfaccia.  -Se la stringa restituita include informazioni riservate, si deve prima richiedere un'autorizzazione appropriata. Se la richiesta ha esito positivo, è possibile restituire le informazioni riservate; in caso contrario, si deve restituire una stringa che esclude le informazioni riservate.  -Il <see cref="M:System.Object.ToString" /> override non deve presentare alcuna effetti collaterali observable per evitare problemi di debug. Ad esempio, una chiamata al <see cref="M:System.Object.ToString" /> metodo non dovrebbe modificare il valore dei campi di istanza.  -Se il tipo implementa un metodo di analisi (o <see langword="Parse" /> oppure <see langword="TryParse" /> metodo, un costruttore o un altro metodo statico che crea un'istanza del tipo da una stringa), è consigliabile verificare che la stringa restituita dal <see cref="M:System.Object.ToString" /> metodo può essere convertito in un'istanza dell'oggetto.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>