<Type Name="Object" FullName="System.Object">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1e79dc9260fe7737b92ae37a13293d18776f2b50" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52613904" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Supporta tutte classi della gerarchia di classi .NET Framework e fornisce servizi di basso livello alle classi derivate. Questa è la principale classe base di tutte le classi di .NET Framework e rappresenta la radice della gerarchia dei tipi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lingue non richiedono in genere una classe per dichiarare l'ereditarietà da <xref:System.Object> perché l'ereditarietà è implicita.  
  
 Poiché tutte le classi in .NET Framework sono derivate da <xref:System.Object>, ogni metodo definito nel <xref:System.Object> classe è disponibile in tutti gli oggetti nel sistema. Le classi derivate possono ed eseguire l'override di alcuni di questi metodi, tra cui:  
  
-   <xref:System.Object.Equals%2A> -Supporta i confronti tra gli oggetti.  
  
-   <xref:System.Object.Finalize%2A> -Esegue operazioni di pulizia prima che un oggetto venga recuperato automaticamente.  
  
-   <xref:System.Object.GetHashCode%2A> -Genera un numero corrispondente al valore dell'oggetto per supportare l'uso di una tabella hash.  
  
-   <xref:System.Object.ToString%2A> -Produce una stringa di testo leggibile che descrive un'istanza della classe.  
  
## <a name="performance-considerations"></a>Considerazioni sulle prestazioni  
 Se si progetta una classe, ad esempio una raccolta, che debba gestire qualsiasi tipo di oggetto, è possibile creare membri della classe che le istanze di accettano il <xref:System.Object> classe. Tuttavia, il processo di conversione boxing e unboxing di un tipo comporta una riduzione delle prestazioni. Se si conosce che la nuova classe gestirà spesso determinati tipi di valore è possibile usare una delle due strategie per ridurre al minimo il costo della conversione boxing.  
  
-   Creare un metodo generico che accetta un <xref:System.Object> tipo e un set di overload di metodo specifico del tipo che accettano ogni tipo di valore si prevede che la classe per la gestione di frequente. Se esiste un metodo specifico del tipo che accetta il tipo di parametro di chiamata, nessuna conversione boxing viene eseguita e viene richiamato il metodo specifico del tipo. Se è presente alcun argomento di metodo che corrisponde al tipo di parametro di chiamata, il parametro è di tipo boxed e viene richiamato il metodo generale.  
  
-   Progettare il tipo e i relativi membri per utilizzare i generics. Common language runtime crea un tipo generico chiuso quando si crea un'istanza della classe e specificare un argomento di tipo generico. Il metodo generico è specifico del tipo e può essere richiamato senza eseguirne il boxing del parametro della chiamata.  
  
 Sebbene in alcuni casi è necessario sviluppare le classi di uso generale che accettano e restituiscono <xref:System.Object> tipi, è possibile migliorare le prestazioni, fornendo anche una classe specifica del tipo per gestire un tipo di uso frequente. Ad esempio, che fornisce una classe specifica di impostazione e recupero di valori booleani, viene eliminata la necessità di conversione boxing e unboxing valori booleani.  
  
   
  
## Examples  
 L'esempio seguente definisce un tipo di punto derivato dal <xref:System.Object> classe ed esegue l'override di molti dei metodi virtuali del <xref:System.Object> classe. Inoltre, nell'esempio viene illustrato come chiamare numerosi statica e i metodi dell'istanza di <xref:System.Object> classe.  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Statici pubblici (<see langword="Shared" /> in Visual Basic) membri di questo tipo sono thread-safe. I membri di istanza non è necessariamente essere thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Object" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore viene chiamato dai costruttori nelle classi derivate, ma può essere utilizzato anche per creare direttamente un'istanza di <xref:System.Object> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se due istanze di un oggetto sono uguali.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da confrontare con l'oggetto corrente.</param>
        <summary>Determina se l'oggetto specificato è uguale all'oggetto corrente.</summary>
        <returns>
          <see langword="true" /> se l'oggetto specificato è uguale all'oggetto corrente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo di confronto tra l'istanza corrente e il `obj` parametro dipende dal fatto che l'istanza corrente è un tipo riferimento o un tipo valore.  
  
-   Se l'istanza corrente è un tipo riferimento, il <xref:System.Object.Equals%28System.Object%29> metodo di test per l'uguaglianza dei riferimenti e una chiamata ai <xref:System.Object.Equals%28System.Object%29> è equivalente a una chiamata al metodo il <xref:System.Object.ReferenceEquals%2A> (metodo). Uguaglianza di riferimenti significa che le variabili di oggetto che devono essere confrontate facciano riferimento allo stesso oggetto. Nell'esempio seguente illustra il risultato di tale confronto. Definisce un `Person` classe, che è un tipo riferimento, e chiama il `Person` costruttore di classe per creare un'istanza di due nuovi `Person` oggetti, `person1a` e `person2`, che hanno lo stesso valore. Assegna `person1a` a un'altra variabile oggetto, `person1b`. Come illustrato nell'esempio, l'output `person1a` e `person1b` sono uguali, in quanto fanno riferimento allo stesso oggetto. Tuttavia `person1a` e `person2` non sono uguali, anche se hanno lo stesso valore.  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   Se l'istanza corrente è un tipo valore, il <xref:System.Object.Equals%28System.Object%29> metodo verifica l'uguaglianza di valore. L'uguaglianza di valori comporta quanto segue:  
  
    -   I due oggetti sono dello stesso tipo. Come illustrato nell'esempio seguente, un <xref:System.Byte> oggetto che ha un valore pari a 12 non è uguale un <xref:System.Int32> oggetto che ha un valore pari a 12, poiché i due oggetti hanno diversi tipi di fase di esecuzione.  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   I valori dei campi pubblici e privati dei due oggetti sono uguali. L'esempio seguente verifica l'uguaglianza dei valori. Definisce un `Person` struttura, ovvero un tipo di valore, e chiama il `Person` costruttore della classe per creare un'istanza di due nuovi `Person` oggetti `person1` e `person2`, che hanno lo stesso valore. Come illustrato nell'output dell'esempio, anche se le due variabili oggetto fare riferimento a oggetti diversi, `person1` e `person2` sono uguali perché hanno lo stesso valore per privato `personName` campo.  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 Poiché il <xref:System.Object> classe è la classe base per tutti i tipi in .NET Framework, il <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metodo offre il confronto di uguaglianza predefinito per tutti gli altri tipi. Tuttavia, i tipi spesso eseguire l'override di <xref:System.Object.Equals%2A> metodo per implementare l'uguaglianza di valori. Per altre informazioni, vedere le note per i chiamanti e note per le sezioni di eredi.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Note per il [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Quando si chiama il <xref:System.Object.Equals%28System.Object%29> overload del metodo in una classe il [!INCLUDE[wrt](~/includes/wrt-md.md)], fornisce il comportamento predefinito per le classi che non esegue l'override <xref:System.Object.Equals%28System.Object%29>. Ciò fa parte del supporto che .NET Framework fornisce per i [!INCLUDE[wrt](~/includes/wrt-md.md)] (vedere [app .NET Framework supportano per Windows Store e Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Le classi di [!INCLUDE[wrt](~/includes/wrt-md.md)] non ereditano <xref:System.Object>e non implementa attualmente un <xref:System.Object.Equals%28System.Object%29> (metodo). Tuttavia, sembrano disporre <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, e <xref:System.Object.GetHashCode%2A> metodi quando usarli nel codice c# o Visual Basic e .NET Framework fornisce il comportamento predefinito per questi metodi.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] le classi che vengono scritti in c# o Visual Basic possono eseguire l'override di <xref:System.Object.Equals%28System.Object%29> overload del metodo.  
  
## <a name="notes-for-callers"></a>Note per i chiamanti  
 Spesso override dalle classi derivate di <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metodo per implementare l'uguaglianza di valori. Inoltre, i tipi forniscono spesso anche un overload fortemente tipizzato aggiuntivo per il `Equals` metodo, in genere mediante l'implementazione la <xref:System.IEquatable%601> interfaccia. Quando si chiama il `Equals` metodo per verificare l'uguaglianza, è necessario conoscere se l'istanza corrente esegue l'override <xref:System.Object.Equals%2A?displayProperty=nameWithType> e comprendere come una chiamata specifica a un `Equals` metodo viene risolto. In caso contrario, è possibile eseguire un test per verificarne l'uguaglianza diverso da quelli desiderati e il metodo può restituire un valore imprevisto.  
  
 Nell'esempio seguente viene illustrato questo concetto. Crea un'istanza di tre <xref:System.Text.StringBuilder> gli oggetti con stringhe identiche e quindi esegue quattro chiamate a `Equals` metodi. Il prima chiamata al metodo restituisce `true`e la restituzione di tre rimanenti `false`.  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 Nel primo caso, l'oggetto fortemente tipizzato <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> overload del metodo che verifica l'uguaglianza dei valori, viene chiamato. Poiché le stringhe assegnato ai due <xref:System.Text.StringBuilder> gli oggetti sono uguali, il metodo restituisce `true`. Tuttavia <xref:System.Text.StringBuilder> non esegue l'override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>. Per questo motivo, quando la <xref:System.Text.StringBuilder> cast dell'oggetto a un <xref:System.Object>, quando un <xref:System.Text.StringBuilder> istanza viene assegnata a una variabile di tipo <xref:System.Object>e quando il <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> metodo vengono passati due <xref:System.Text.StringBuilder> oggetti, il valore predefinito <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>viene chiamato il metodo. Poiché <xref:System.Text.StringBuilder> è un tipo riferimento, questa operazione equivale a passare i due <xref:System.Text.StringBuilder> gli oggetti per il <xref:System.Object.ReferenceEquals%2A> (metodo). Anche se tutte e tre <xref:System.Text.StringBuilder> oggetti contengono stringhe identiche, cui fare riferimento a tre oggetti distinti. Di conseguenza, questi tre chiamate al metodo restituito `false`.  
  
 È possibile confrontare l'oggetto corrente in un altro oggetto per l'uguaglianza dei riferimenti chiamando il <xref:System.Object.ReferenceEquals%2A> (metodo). In Visual Basic, è anche possibile usare la `is` parola chiave (ad esempio, `If Me Is otherObject Then ...`).  
  
## <a name="notes-for-inheritors"></a>Note per gli eredi  
 Quando si definisce un tipo personalizzato, tale tipo eredita la funzionalità definita dal `Equals` metodo del relativo tipo di base. La tabella seguente elenca l'implementazione predefinita del `Equals` metodo per le principali categorie di tipi in .NET Framework.  
  
|Categoria di tipi|Uguaglianza definito da|Commenti|  
|-------------------|-------------------------|--------------|  
|Classe derivata direttamente da <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Uguaglianza dei riferimenti; equivalente alla chiamata <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.|  
|Struttura|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|Uguaglianza di valori; confronto byte per byte diretto o campo per campo confronto usando la reflection.|  
|Enumerazione|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|I valori devono avere lo stesso tipo di enumerazione e lo stesso valore sottostante.|  
|delegato|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|I delegati devono avere lo stesso tipo con elenchi chiamate identici.|  
|Interfaccia|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Uguaglianza dei riferimenti.|  
  
 Per un tipo di valore, è sempre consigliabile eseguire l'override <xref:System.Object.Equals%2A>, perché verifica l'uguaglianza basati sulla reflection offerta una riduzione delle prestazioni. È inoltre possibile sostituire l'implementazione predefinita di <xref:System.Object.Equals%2A> per i tipi di riferimento per verificare l'uguaglianza di valore anziché l'uguaglianza dei riferimenti e per definire il significato esatto di uguaglianza di valori. Questo tipo di implementazioni di <xref:System.Object.Equals%2A> restituire `true` se i due oggetti hanno lo stesso valore, anche se non sono la stessa istanza. Responsabile dell'implementazione del tipo decide cosa si intende per valore di un oggetto, ma è in genere alcuni o tutti i dati archiviati nelle variabili di istanza dell'oggetto. Ad esempio, il valore di un <xref:System.String> oggetto è basato sui caratteri della stringa; il <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> override dei metodi la <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> per restituire `true` per qualsiasi due istanze che contengono gli stessi caratteri nello stesso ordine di stringa.  
  
 Nell'esempio seguente viene illustrato come eseguire l'override di <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metodo per verificare l'uguaglianza di valore. Viene eseguito l'override di <xref:System.Object.Equals%2A> metodo per il `Person` classe. Se `Person` accettato l'implementazione della classe di base di uguaglianza, due `Person` oggetti sarebbe uguali solo se viene fatto un singolo oggetto. Tuttavia, in questo caso, due `Person` gli oggetti sono uguali se hanno lo stesso valore per il `Person.Id` proprietà.  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 Oltre a eseguire l'override <xref:System.Object.Equals%2A>, è possibile implementare il <xref:System.IEquatable%601> interfaccia per fornire un test fortemente tipizzato per verificarne l'uguaglianza.  
  
 Le istruzioni seguenti devono essere true per tutte le implementazioni del <xref:System.Object.Equals%28System.Object%29> (metodo). Nell'elenco `x`, `y`, e `z` rappresentano i riferimenti agli oggetti che non sono **null**.  
  
-   `x.Equals(x)` Restituisce `true`, tranne nei casi che coinvolgono tipi a virgola mobile. ISO/IEC/IEEE 60559:2011, IT - sistemi di microprocessori, aritmetica a virgola mobile, vedere.  
  
-   `y.Equals(x)` restituisce lo stesso valore di `x.Equals(y)`.  
  
-   `x.Equals(y)` Restituisce `true` se entrambi `x` e `y` sono `NaN`.  
  
-   Se `(x.Equals(y) && y.Equals(z))` restituisce `true`, quindi `x.Equals(z)` restituisce `true`.  
  
-   Le chiamate successive a `x.Equals(y)` restituiscono lo stesso valore purché gli oggetti cui fa riferimento `x` e `y` non vengono modificati.  
  
-   `x.Equals(null)` restituisce `false`.  
  
 Le implementazioni di <xref:System.Object.Equals%2A> non devono generare eccezioni; restituiscono sempre un valore. Ad esempio, se `obj` viene `null`, il <xref:System.Object.Equals%2A> metodo deve restituire `false` anziché generare un <xref:System.ArgumentNullException>.  
  
 Seguire queste linee guida quando si esegue l'override <xref:System.Object.Equals%28System.Object%29>:  
  
-   I tipi che implementano <xref:System.IComparable> deve eseguire l'override <xref:System.Object.Equals%28System.Object%29>.  
  
-   I tipi che eseguono l'override <xref:System.Object.Equals%28System.Object%29> deve eseguire l'override anche <xref:System.Object.GetHashCode%2A>; in caso contrario, le tabelle hash potrebbero non funzionare correttamente.  
  
-   È consigliabile implementare la <xref:System.IEquatable%601> interfaccia per il supporto fortemente tipizzata verifica l'uguaglianza. I <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementazione debba restituire risultati coerenti con <xref:System.Object.Equals%2A>.  
  
-   Se il linguaggio di programmazione supporta l'overload degli operatori ed l'overload dell'operatore di uguaglianza per un determinato tipo, è anche necessario eseguire l'override di <xref:System.Object.Equals%28System.Object%29> per restituire lo stesso risultato dell'operatore di uguaglianza. Ciò aiuta a garantire che il codice della libreria di classi che utilizza <xref:System.Object.Equals%2A> (ad esempio <xref:System.Collections.ArrayList> e <xref:System.Collections.Hashtable>) si comporta in modo che sia coerenza con il modo in cui l'operatore di uguaglianza viene usato dal codice dell'applicazione.  
  
### <a name="guidelines-for-reference-types"></a>Linee guida per i tipi di riferimento  
 Le linee guida seguenti si applicano a viene sottoposto a override <xref:System.Object.Equals%28System.Object%29> per un tipo di riferimento:  
  
-   Eseguire l'override <xref:System.Object.Equals%2A> se la semantica del tipo è basata sul fatto che il tipo rappresenta dei valori.  
  
-   La maggior parte dei tipi di riferimento necessario non eseguire l'overload dell'operatore di uguaglianza, anche se si esegue l'override <xref:System.Object.Equals%2A>. Tuttavia, se si implementa un tipo di riferimento che deve avere una semantica di valore, ad esempio un numero complesso di tipo, è necessario eseguire l'override dell'operatore di uguaglianza.  
  
-   È consigliabile non eseguire l'override <xref:System.Object.Equals%2A> su un tipo di riferimento modificabile. Infatti, si esegue l'override <xref:System.Object.Equals%2A> richiede anche eseguire l'override di <xref:System.Object.GetHashCode%2A> metodo, come descritto nella sezione precedente. Ciò significa che è possibile modificare il codice hash di un'istanza di un tipo di riferimento modificabile durante la sua durata, che può causare l'oggetto da andranno persi in una tabella hash.  
  
### <a name="guidelines-for-value-types"></a>Linee guida per i tipi di valore  
 Le linee guida seguenti si applicano a viene sottoposto a override <xref:System.Object.Equals%28System.Object%29> per un tipo valore:  
  
-   Se si sta definendo un tipo di valore che include uno o più campi i cui valori sono i tipi di riferimento, è necessario eseguire l'override <xref:System.Object.Equals%28System.Object%29>. Il <xref:System.Object.Equals%28System.Object%29> implementazione fornita dal <xref:System.ValueType> esegue un confronto byte per byte per i tipi di valore cui campi sono tutti i tipi di valore, ma usa la reflection per eseguire un confronto per campi di tipi di valori i cui campi includono i tipi di riferimento.  
  
-   Se esegue l'override <xref:System.Object.Equals%2A> e il linguaggio di sviluppo supporta l'overload degli operatori, è necessario eseguire l'overload dell'operatore di uguaglianza.  
  
-   È consigliabile implementare la <xref:System.IEquatable%601> interfaccia. La chiamata l'oggetto fortemente tipizzato <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> metodo evita la conversione boxing di `obj` argomento.  
  
   
  
## Examples  
 L'esempio seguente mostra un `Point` che esegue l'override di <xref:System.Object.Equals%2A> metodo per fornire l'uguaglianza di valori e un `Point3D` classe che deriva da `Point`. In quanto `Point` esegue l'override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> per verificare l'uguaglianza di valore, il <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> non viene chiamato. Tuttavia `Point3D.Equals` chiamate `Point.Equals` poiché `Point` implementa <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> in modo che fornisce l'uguaglianza di valori.  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 Il `Point.Equals` metodo di verifica per assicurarsi che il `obj` l'argomento non è **null** e che fa riferimento a un'istanza dello stesso tipo dell'oggetto corrente. Se il controllo non riesce, il metodo restituisce `false`.  
  
 Il `Point.Equals` chiamate al metodo il <xref:System.Object.GetType%2A> metodo per determinare se i tipi in fase di esecuzione dei due oggetti sono identici. Se il metodo utilizzato un controllo del form `obj is Point` in c# o `TryCast(obj, Point)` in Visual Basic, il controllo restituirà `true` nei casi in cui `obj` è un'istanza di una classe derivata di `Point`, anche se `obj` e corrente istanza non sono dello stesso tipo in fase di esecuzione. Dopo aver verificato che entrambi gli oggetti sono dello stesso tipo, il metodo esegue il cast `obj` al tipo `Point` e restituisce il risultato del confronto tra i campi di istanza dei due oggetti.  
  
 Nelle `Point3D.Equals`, ereditato `Point.Equals` metodo, che esegue l'override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, viene richiamato prima che qualsiasi altra operazione. In quanto `Point3D` è una classe sealed (`NotInheritable` in Visual Basic), un segno di spunta form `obj is Point` in c# o `TryCast(obj, Point)` in Visual Basic è sufficiente per garantire che `obj` è un `Point3D` oggetto. Se si tratta di un `Point3D` dell'oggetto, ne viene eseguito il cast a un `Point` dell'oggetto e passati all'implementazione della classe di base di <xref:System.Object.Equals%2A>. Solo quando ereditato `Point.Equals` restituzione del metodo `true` viene confronta il metodo di `z` introdotti nella classe derivata di campi di istanza.  
  
 L'esempio seguente definisce una `Rectangle` classe che implementa internamente un rettangolo come due `Point` oggetti. Il `Rectangle` classe anche le sostituzioni <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> per fornire l'uguaglianza dei valori.  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 Alcuni linguaggi quali c# e Visual Basic supportano l'overload degli operatori. Quando un tipo esegue l'overload dell'operatore di uguaglianza, è necessario anche l'override di <xref:System.Object.Equals%28System.Object%29> metodo per fornire la stessa funzionalità. Questa operazione viene in genere eseguita mediante la scrittura di <xref:System.Object.Equals%28System.Object%29> metodo in termini di operatore di uguaglianza di overload, come nell'esempio seguente.  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 Poiché `Complex` è un tipo di valore, non è possibile derivare da.  Di conseguenza, la sostituzione <xref:System.Object.Equals%28System.Object%29> metodo non è necessario chiamare <xref:System.Object.GetType%2A> per determinare il run-time preciso digitare di ogni oggetto, ma può invece utilizzare il `is` operatore nel linguaggio c# o il `TypeOf` operatore in Visual Basic per controllare il tipo del `obj` parametro.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Primo oggetto da confrontare.</param>
        <param name="objB">Secondo oggetto da confrontare.</param>
        <summary>Determina se le istanze dell'oggetto specificate sono considerate uguali.</summary>
        <returns>
          <see langword="true" /> se gli oggetti sono considerati uguali; in caso contrario, <see langword="false" />. Se entrambi i parametri <paramref name="objA" /> e <paramref name="objB" /> sono **null**, il metodo restituisce <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo statico <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> metodo indica se due oggetti, `objA` e `objB`, sono uguali. Permette anche testare gli oggetti il cui valore è **null** per verificarne l'uguaglianza. Confronta `objA` e `objB` per verificarne l'uguaglianza come indicato di seguito:  
  
-   Determina se i due oggetti rappresentano lo stesso riferimento oggetto. Se ciò si verifica, il metodo restituisce `true`. Questo test è equivalente alla chiamata di <xref:System.Object.ReferenceEquals%2A> (metodo). Inoltre, se entrambe `objA` e `objB` vengono **null**, il metodo restituisce `true`.  
  
-   Determina se sia `objA` oppure `objB` viene **null**. Se pertanto restituisce `false`.  
  
-   Se i due oggetti non rappresentano il riferimento all'oggetto stesso e nemmeno **null**, chiama `objA`.`Equals` (`objB`) e restituisce il risultato. Ciò significa che, se `objA` esegue l'override di <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> , questo override viene chiamato.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> metodo e lo confronta con il <xref:System.Object.ReferenceEquals%2A> (metodo).  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Consente a un oggetto di effettuare un tentativo di liberare risorse ed eseguire altre operazioni di pulizia prima che venga recuperato da Garbage Collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Object.Finalize%2A> metodo viene utilizzato per eseguire operazioni di pulitura su risorse non gestite bloccate dall'oggetto corrente prima dell'eliminazione permanente dell'oggetto. Il metodo è protetto e pertanto è accessibile solo tramite questa classe o una classe derivata.  
  
 Contenuto della sezione:  
  
-   [Come funziona la finalizzazione](#How)  
  
-   [Note per gli implementatori](#Notes)  
  
-   [Alternativa SafeHandle](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>Come funziona la finalizzazione  
 Il <xref:System.Object> classe non fornisce alcuna implementazione per il <xref:System.Object.Finalize%2A> metodo e il garbage collector non contrassegna i tipi derivati da <xref:System.Object> per la finalizzazione a meno che non eseguono l'override di <xref:System.Object.Finalize%2A> (metodo).  
  
 Se esegue l'override di un tipo di <xref:System.Object.Finalize%2A> metodo, il garbage collector aggiunge una voce per ogni istanza del tipo a una struttura interna denominata coda di finalizzazione. Coda di finalizzazione contiene voci per tutti gli oggetti nell'heap gestito il cui codice di finalizzazione deve essere eseguito prima che il garbage collector di recuperare la memoria. Il garbage collector chiama quindi il <xref:System.Object.Finalize%2A> metodo automaticamente nelle condizioni seguenti:  
  
-   Dopo che il garbage collector ha scoperto che un oggetto è inaccessibile, a meno che l'oggetto è stato escluso dalle finalizzazione da una chiamata al <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (metodo).  
  
-   **In .NET Framework solo**, durante l'arresto di un dominio applicazione, a meno che non è esente dalla finalizzazione dell'oggetto. Durante l'arresto, sono finalizzati anche gli oggetti che sono ancora accessibili.  
  
 <xref:System.Object.Finalize%2A> viene chiamato automaticamente una sola volta in un'istanza specifica, a meno che l'oggetto è nuovamente registrato con un meccanismo, ad esempio <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> e il <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (metodo) non è stato chiamato in seguito.  
  
 <xref:System.Object.Finalize%2A> operazioni presentano le limitazioni seguenti:  
  
-   L'ora esatta in cui viene eseguito il finalizzatore non è definito. Per garantire il rilascio deterministico delle risorse per le istanze della classe, implementare una `Close` metodo o fornire un <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementazione.  
  
-   I finalizzatori di due oggetti non è garantiti per l'esecuzione in un ordine specifico, anche se un oggetto fa riferimento a altro. Vale a dire, se un oggetto ha un riferimento all'oggetto B ed entrambi disporre di finalizzatori, oggetto B potrebbe essere già stato finalizzato quando viene avviato il finalizzatore dell'oggetto.  
  
-   Il thread in cui viene eseguito il finalizzatore non è specificato.  
  
 Il <xref:System.Object.Finalize%2A> metodo potrebbero non essere eseguiti fino al completamento o potrebbero non essere eseguiti affatto eccezionali circostanze seguenti:  
  
-   Se un altro finalizzatore si blocca per un periodo illimitato (consente di spostarsi in un ciclo infinito, prova a ottenere un blocco possa mai ottenere e così via). Poiché il runtime tenta di eseguire i finalizzatori fino al completamento, altri finalizzatori potrebbero non essere chiamate se un finalizzatore è bloccato per un periodo illimitato.  
  
-   Se il processo viene terminato senza consentirà il runtime di pulizia. In questo caso, prima notifica di completamento del processo del runtime è una notifica DLL_PROCESS_DETACH.  
  
 Il runtime continua a completare gli oggetti durante l'arresto solo quando il numero di oggetti finalizzabili continua a diminuire.  
  
 Se <xref:System.Object.Finalize%2A> o un override di <xref:System.Object.Finalize%2A> genera un'eccezione e il runtime non è ospitata da un'applicazione che sostituisce il criterio predefinito, il runtime termina il processo e non attivi `try` / `finally` blocchi o i finalizzatori vengono eseguiti. Questo comportamento assicura l'integrità del processo se il finalizzatore non è possibile liberare o eliminare le risorse.  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>Override del metodo Finalize 
 È consigliabile eseguire l'override <xref:System.Object.Finalize%2A> per una classe che usa le risorse non gestite, ad esempio gli handle di file o le connessioni di database che devono essere liberate quando viene eliminato l'oggetto gestito in cui vengono utilizzati durante l'operazione di garbage collection. È consigliabile non implementare un <xref:System.Object.Finalize%2A> metodo per gli oggetti gestiti, perché il garbage collector di liberare risorse gestite automaticamente.  
  
> [!IMPORTANT]
>  Se un <xref:System.Runtime.InteropServices.SafeHandle> sono disponibili oggetti che esegue il wrapping della risorsa non gestita, l'alternativa consigliata consiste nell'implementare il modello dispose con un handle sicuro e non eseguire l'override <xref:System.Object.Finalize%2A>. Per altre informazioni, vedere [alternativa SafeHandle The](#SafeHandle) sezione.  
  
 Il <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodo non esegue alcuna operazione per impostazione predefinita, ma è consigliabile eseguire l'override <xref:System.Object.Finalize%2A> solo se necessario e solo per rilasciare le risorse non gestite. Il recupero della memoria tende a richiedere molto più tempo se viene eseguita un'operazione di finalizzazione, perché richiede almeno due operazioni di garbage collection. Inoltre, è necessario eseguire l'override di <xref:System.Object.Finalize%2A> solo i tipi di metodo per riferimento. Common language runtime completa solo i tipi di riferimento. Ignora i finalizzatori sui tipi di valore.  

L'ambito del <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodo `protected`. Quando si esegue l'override del metodo nella classe, è necessario gestire tale limitazione dell'ambito. Mantenendo una <xref:System.Object.Finalize%2A> metodo protetto, si impedisce agli utenti dell'applicazione dalla chiamata a un oggetto <xref:System.Object.Finalize%2A> direttamente al metodo.
  
 Ogni implementazione di <xref:System.Object.Finalize%2A> in un tipo derivato deve chiamare l'implementazione del tipo di base di <xref:System.Object.Finalize%2A>. Questo è l'unico caso in quale applicazione è possibile chiamare codice <xref:System.Object.Finalize%2A>. Un oggetto <xref:System.Object.Finalize%2A> metodo non deve chiamare un metodo su tutti gli oggetti diversi da quello della relativa classe di base. Questo avviene perché altri oggetti di chiamata è stato possibile raccogliere allo stesso tempo dell'oggetto chiamante, come nel caso di arresto di un runtime di linguaggio comuni. 
  
> [!NOTE]
>  Il compilatore c# non consentono di eseguire l'override di <xref:System.Object.Finalize%2A> (metodo). Al contrario, si fornisce un finalizzatore implementando un [distruttore](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) per la classe. Un distruttore in c# chiama automaticamente il distruttore della relativa classe base.  
>   
>  Visual C++ fornisce anche una propria sintassi per l'implementazione di <xref:System.Object.Finalize%2A> (metodo). Per altre informazioni, vedere la sezione "Distruttori e finalizzatori" di [procedura: definire e usare classi e struct (C + + / CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).  
  
 Poiché l'operazione di garbage collection è non deterministico, non si conosce con precisione quando il garbage collector esegue la finalizzazione. Per rilasciare le risorse immediatamente, è possibile anche scegliere di implementare il [modello dispose](~/docs/standard/design-guidelines/dispose-pattern.md) e il <xref:System.IDisposable> interfaccia. Il <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementazione può essere chiamata dal consumer della classe per liberare le risorse non gestite ed è possibile usare il <xref:System.Object.Finalize%2A> metodo per liberare le risorse non gestite nel caso in cui il <xref:System.IDisposable.Dispose%2A> non viene chiamato.  
  
 <xref:System.Object.Finalize%2A> può eseguire quasi tutte le operazioni, tra cui ripristinare un oggetto (che, rende l'oggetto accessibile anche in questo caso) dopo che è stato pulito durante l'operazione di garbage collection. Tuttavia, l'oggetto può essere ripristinato soltanto una sola volta. <xref:System.Object.Finalize%2A> non può essere chiamato su oggetti ripristinati durante l'operazione di garbage collection. Non c'è un'azione che l'implementazione di <xref:System.Object.Finalize%2A> non dovrebbe mai aver: non deve mai generare un'eccezione. Se tutte le eccezioni generate dai metodi chiamati dal <xref:System.Object.Finalize%2A> metodo viene gestita dal <xref:System.Object.Finalize%2A> metodo, il runtime si presuppone che il <xref:System.Object.Finalize%2A> metodo restituito e continua a chiamare il <xref:System.Object.Finalize%2A> metodi di altri oggetti. 
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>Alternativa SafeHandle  
 Creazione di finalizzatori affidabile è spesso difficile, poiché è possibile fare ipotesi sullo stato dell'applicazione e sistema di eccezioni non gestite, ad esempio <xref:System.OutOfMemoryException> e <xref:System.StackOverflowException> terminare il finalizzatore. Anziché implementare un finalizzatore per la classe per rilasciare le risorse non gestite, è possibile usare un oggetto derivato dal <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> classe per eseguire il wrapping di risorse non gestite e quindi implementare il modello dispose senza un finalizzatore. .NET Framework fornisce le seguenti classi di <xref:Microsoft.Win32?displayProperty=nameWithType> dello spazio dei nomi che derivano dalla <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> è una classe wrapper per un handle di file.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> è una classe wrapper per gli handle di file mappati alla memoria.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> è una classe wrapper per un puntatore a un blocco di memoria non gestita.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, e <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> sono classi wrapper per gli handle del servizio di crittografia.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> è una classe wrapper per gli handle di pipe.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> è una classe wrapper per un handle a una chiave del Registro di sistema.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> è una classe wrapper per un handle di attesa.  
  
 L'esempio seguente usa il [modello dispose](~/docs/standard/design-guidelines/dispose-pattern.md) con gli handle sicuri invece di sostituire la <xref:System.Object.Finalize%2A> (metodo). Definisce un `FileAssociation` classe che incapsula informazioni del Registro di sistema sull'applicazione che gestisce i file con un'estensione di file specifico. Gli handle del Registro di due sistema restituiti come `out` parametri da Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) chiamate di funzione vengono passate al <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> costruttore. Il tipo del protetto `Dispose` chiama quindi il `SafeRegistryHandle.Dispose` per liberare questi due handle di metodo.  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 Nell'esempio seguente verifica che il <xref:System.Object.Finalize%2A> metodo viene chiamato quando un oggetto che esegue l'override <xref:System.Object.Finalize%2A> viene eliminato definitivamente. Si noti che, in un'applicazione di produzione di <xref:System.Object.Finalize%2A> potrebbe eseguire l'override di metodo per rilasciare le risorse non gestite contenute nell'oggetto. Si noti inoltre che l'esempio c# fornisce un distruttore invece di sostituire la <xref:System.Object.Finalize%2A> (metodo).  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 Per un altro esempio che esegue l'override di <xref:System.Object.Finalize%2A> metodo, vedere il <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Funge da funzione hash predefinita.</summary>
        <returns>Codice hash per l'oggetto corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un codice hash è un valore numerico che viene usato per inserire e identificare un oggetto in una raccolta basata su hash, ad esempio la <xref:System.Collections.Generic.Dictionary%602> (classe), il <xref:System.Collections.Hashtable> classe o un tipo derivato dal <xref:System.Collections.DictionaryBase> classe. Il <xref:System.Object.GetHashCode%2A> metodo fornisce questo codice hash per gli algoritmi che richiedono rapidi controlli di uguaglianza di oggetti.  
  
> [!NOTE]
>  Per informazioni sull'uso di codici hash nelle tabelle hash e alcuni algoritmi di codice cancelletto aggiuntivi, vedere la [funzione Hash](https://en.wikipedia.org/wiki/Hash_function) voce su Wikipedia.  
  
 Due oggetti che sono i codici hash restituito uguale che sono uguali. Tuttavia, non è vero il contrario: i codici hash uguali non implicano l'uguaglianza degli oggetti, poiché gli oggetti (diversi) diversi possono avere i codici hash identici. Inoltre, .NET Framework non garantisce l'implementazione predefinita del <xref:System.Object.GetHashCode%2A> (metodo) e il valore di questo metodo restituisce possono variare tra le versioni di .NET Framework e piattaforme, ad esempio le piattaforme a 32 e 64 bit. Per questi motivi, non utilizzare l'implementazione predefinita di questo metodo come un identificatore di oggetto univoco per scopi di hash. Due conseguenze seguono da questo oggetto:  
  
-   Non si deve presupporre che i codici hash uguali implicano l'uguaglianza degli oggetti.  
  
-   Devi mai rendere persistenti o usare un codice hash all'esterno del dominio applicazione in cui è stato creato, poiché lo stesso oggetto possono avere hash tra piattaforme, processi e domini dell'applicazione.  
  
> [!WARNING]
>  Un codice hash è destinato da inserimento efficiente e di ricerca nelle raccolte basate su una tabella hash. Un codice hash non è un valore permanente. Per questo motivo:  
>   
> -   Non serializzare i valori di codice hash o archiviarli nel database.  
> -   Non utilizzare il codice hash come chiave per recuperare un oggetto da una raccolta con chiave.  
> -   Non inviare i codici hash tra processi o domini applicazione. In alcuni casi, i codici hash possano essere calcolati in base al dominio per ogni processo o per ogni applicazione.  
> -   Non usare il codice hash anziché un valore restituito da una funzione hash di crittografia se è necessario un hash crittografico. Per gli hash di crittografia, usare una classe derivata dal <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> o <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> classe.  
> -   Eseguire test per verificarne l'uguaglianza dei codici hash per determinare se due oggetti sono uguali. (Gli oggetti diversi possono avere i codici hash identici). Per testare l'uguaglianza, chiamare il <xref:System.Object.ReferenceEquals%2A> o <xref:System.Object.Equals%2A> (metodo).  
  
 Il <xref:System.Object.GetHashCode%2A> metodo può essere sovrascritto da un tipo derivato. Se <xref:System.Object.GetHashCode%2A> è non sottoposto a override, codici hash per tipi di riferimento vengono calcolati chiamando il <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> metodo della classe di base, che calcola un codice hash in base al riferimento di un oggetto; per altre informazioni, vedere <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>. In altre parole, due oggetti per i quali la <xref:System.Object.ReferenceEquals%2A> restituzione del metodo `true` dispone di un codice hash identici. Se i tipi di valore non esegue l'override <xref:System.Object.GetHashCode%2A>, il <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> metodo della classe di base usa la reflection per calcolare il codice hash basato sui valori dei campi del tipo. In altre parole, i tipi di valori i cui campi hanno valori uguali presentano codici hash uguali. Per altre informazioni sull'override <xref:System.Object.GetHashCode%2A>, vedere la sezione "Note per gli eredi".  
  
> [!WARNING]
>  Se esegue l'override di <xref:System.Object.GetHashCode%2A> metodo, è consigliabile anche eseguire l'override <xref:System.Object.Equals%2A>e viceversa. Se sottoposto a override <xref:System.Object.Equals%2A> restituzione del metodo `true` quando due oggetti sono stati testati per verificarne l'uguaglianza, sottoposto a override <xref:System.Object.GetHashCode%2A> metodo deve restituire lo stesso valore per i due oggetti.  
  
 Se un oggetto che viene usato come chiave in una tabella hash non fornisce un'implementazione di utile <xref:System.Object.GetHashCode%2A>, è possibile specificare un provider di codice hash, fornendo un' <xref:System.Collections.IEqualityComparer> implementazione su uno degli overload del <xref:System.Collections.Hashtable> costruttore della classe.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Note per il [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Quando si chiama il <xref:System.Object.GetHashCode%2A> metodo in una classe nel [!INCLUDE[wrt](~/includes/wrt-md.md)], fornisce il comportamento predefinito per le classi che non esegue l'override <xref:System.Object.GetHashCode%2A>. Ciò fa parte del supporto che .NET Framework fornisce per i [!INCLUDE[wrt](~/includes/wrt-md.md)] (vedere [app .NET Framework supportano per Windows Store e Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Le classi di [!INCLUDE[wrt](~/includes/wrt-md.md)] non ereditano <xref:System.Object>e non implementa attualmente un <xref:System.Object.GetHashCode%2A>. Tuttavia, sembrano disporre <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, e <xref:System.Object.GetHashCode%2A> metodi quando usarli nel codice c# o Visual Basic e .NET Framework fornisce il comportamento predefinito per questi metodi.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] le classi che vengono scritti in c# o Visual Basic possono eseguire l'override di <xref:System.Object.GetHashCode%2A> (metodo).  
  
   
  
## Examples  
 Uno dei modi più semplici per calcolare un codice hash per un valore numerico con lo stesso o un intervallo più piccolo rispetto al <xref:System.Int32> tipo consiste nel restituire semplicemente quel valore. Nell'esempio seguente illustra questa implementazione per un `Number` struttura.  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 Spesso, un tipo dispone di più campi di dati che possono far parte di generazione del codice hash. Per generare un codice hash è possibile combinare questi campi usando un `XOR (eXclusive OR)` operazione, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 Nell'esempio precedente restituisce lo stesso codice hash per (n1, n2) e (n2, n1) e pertanto può generare più collisioni di informazioni cronologiche. Una serie di soluzioni è disponibile in modo che i codici hash in questi casi non sono identici. Uno consiste nel restituire il codice hash di un `Tuple` oggetto che corrisponde all'ordine di ogni campo. Nell'esempio seguente viene illustrata una possibile implementazione che usa il <xref:System.Tuple%602> classe. Tuttavia, tenere presente che l'overhead delle prestazioni di un'istanza di un `Tuple` oggetto può influire notevolmente sulle prestazioni complessive di un'applicazione che archivia un numero elevato di oggetti in tabelle hash.  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 Una seconda soluzione alternativa prevede di spostamento a sinistra i codici hash dei campi successivi da due o più bit rilevanza dei codici hash singoli. In modo ottimale, invece di essere eliminato, i bit spostati oltre a 31 bit devono eseguire il wrapping intorno invece rimossi. Poiché bit vengono ignorati per gli operatori di spostamento a sinistra in c# e Visual Basic, questo richiede la creazione di un metodo MAIUSC-e-wrap sinistro simile al seguente:  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 L'esempio seguente usa quindi questo metodo MAIUSC-e-wrap per calcolare il codice hash del `Point` struttura usata negli esempi precedenti.  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Una funzione hash viene utilizzata per generare rapidamente un numero (codice di hash) che corrisponde al valore di un oggetto. Le funzioni hash vengono in genere specifiche per ogni tipo e, per l'univocità, è necessario usare almeno uno dei campi di istanza come input. I codici hash non devono essere calcolati utilizzando i valori dei campi statici.  
  
Per le classi derivate da <see cref="T:System.Object" />, il <see langword="GetHashCode" /> metodo può delegare alla classe di base <see cref="M:System.Object.GetHashCode" /> implementazione solo se la classe derivata definisce l'uguaglianza per essere l'uguaglianza dei riferimenti. L'implementazione predefinita di <see cref="M:System.Object.GetHashCode" /> come riferimento tipi restituisce un codice hash che equivale a quello restituito dal <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> (metodo). È possibile eseguire l'override <see cref="M:System.Object.GetHashCode" /> per i tipi di riferimento non modificabile. In generale, per i tipi di riferimento modificabile, è necessario eseguire l'override <see cref="M:System.Object.GetHashCode" /> solo se: 
-È possibile calcolare il codice hash dai campi che non sono modificabili; o 
-È possibile garantire che il codice hash di un oggetto modificabile non cambia mentre l'oggetto è contenuto in una raccolta che si basa sul codice hash.  
  
In caso contrario, si potrebbe pensare che l'oggetto modificabile viene perso nella tabella hash. Se si sceglie di eseguire l'override <see cref="M:System.Object.GetHashCode" /> per un tipo di riferimento modificabile, la documentazione di inoltre deve essere chiaro che gli utenti del tipo non deve essere modificato i valori di oggetto anche se l'oggetto viene archiviato in una tabella hash.  
  
Per i tipi di valore, <see cref="M:System.ValueType.GetHashCode" /> fornisce un'implementazione di codice hash predefinito che usa la reflection. È consigliabile eseguire l'override, per ottenere prestazioni migliori.  
  
 <block subset="none" type="note"><para>  
 Per altre informazioni ed esempi che consentono di calcolare i codici hash in svariati modi, vedere la sezione esempi.  
  
</para></block>  
  
 Una funzione hash deve avere le proprietà seguenti: 
-Se due oggetti vengono considerati uguali, la <see cref="M:System.Object.GetHashCode" /> metodo per ogni oggetto deve restituire lo stesso valore. Tuttavia, se due oggetti non vengono considerati uguali, la <see cref="M:System.Object.GetHashCode" /> metodi per i due oggetti non sono necessario restituire valori diversi.  
  
-il <see cref="M:System.Object.GetHashCode" /> metodo per un oggetto deve restituire in modo coerente lo stesso codice hash fino a quando non viene modificato per lo stato dell'oggetto che determina il valore dell'oggetto di ritorno [System.Object.Equals](xref:System.Object.Equals*) (metodo). Si noti che questo vale solo per l'esecuzione corrente di un'applicazione e che può essere restituito un codice hash diverso se si esegue nuovamente l'applicazione.  
  
-Per ottenere prestazioni ottimali, una funzione hash deve generare una distribuzione uniforme per tutti gli input, tra cui input molto in cluster. Un'implicazione è che piccole modifiche per lo stato dell'oggetto deve essere restituito apportare modifiche estese per il codice hash risultante per ottimizzare le prestazioni di tabella hash.  
  
-Le funzioni hash devono essere conveniente per il calcolo.  
  
-La <see cref="M:System.Object.GetHashCode" /> (metodo) non deve generare eccezioni.  
  
Ad esempio, l'implementazione del <see cref="M:System.String.GetHashCode" /> metodo fornito dal <see cref="T:System.String" /> classe restituisce i codici hash identici per i valori di stringa identica. Pertanto, due <see cref="T:System.String" /> oggetti restituisce lo stesso codice hash se rappresentino lo stesso valore di stringa. Inoltre, il metodo Usa tutti i caratteri nella stringa per generare l'output in modo relativamente casuale distribuita, anche quando l'input viene inserito nel cluster in determinati intervalli (ad esempio, molti utenti potrebbero avere le stringhe che contengono solo gli inferiore 128 caratteri ASCII, anche se un stringa può contenere i caratteri Unicode 65.535).  
  
Fornendo una funzione hash valida in una classe può influire in modo significativo le prestazioni dell'aggiunta di tali oggetti in una tabella hash. In una tabella hash con chiavi che forniscono l'implementazione di una funzione hash, la ricerca di un elemento richiede un tempo costante (ad esempio, un'operazione o (1)). In una tabella hash con un'implementazione di una riduzione di una funzione hash, le prestazioni di una ricerca dipendono dal numero di elementi nella tabella hash (ad esempio, un'operazione O (`n`) operazione, in cui `n` è il numero di elementi nella tabella hash). Un utente malintenzionato è possibile immettere i dati che aumenta il numero di conflitti, che può ridurre significativamente le prestazioni delle applicazioni che dipendono da tabelle hash, le condizioni seguenti: 
-Quando le funzioni hash producono frequenti conflitti.  
  
-Quando una gran parte degli oggetti in una tabella hash producono i codici hash che sono uguali o approssimativamente uguale a tra loro.  
  
-Quando gli utenti di input i dati da cui viene calcolato il codice hash.  
  
Le classi derivate che esegue l'override <see cref="M:System.Object.GetHashCode" /> inoltre è necessario eseguire l'override <see cref="M:System.Object.Equals(System.Object)" /> per garantire che due oggetti uguali hanno lo stesso codice hash; in caso contrario, il <see cref="T:System.Collections.Hashtable" /> tipo potrebbe non funzionare correttamente.</para>
        </block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Type" /> dell'istanza corrente.</summary>
        <returns>Tipo esatto di runtime dell'istanza corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In quanto <xref:System.Object?displayProperty=nameWithType> è la classe base per tutti i tipi nel sistema di tipi .NET Framework, il <xref:System.Object.GetType%2A> metodo può essere utilizzato per restituire <xref:System.Type> gli oggetti che rappresentano tutti i tipi di .NET Framework. .NET Framework riconosce le cinque categorie dei tipi seguenti:  
  
-   Le classi che derivano da <xref:System.Object?displayProperty=nameWithType>,  
  
-   Valore di tipi che derivano da <xref:System.ValueType?displayProperty=nameWithType>.  
  
-   Interfacce che derivano da <xref:System.Object?displayProperty=nameWithType> a partire da .NET Framework 2.0.  
  
-   Enumerazioni, che derivano da <xref:System.Enum?displayProperty=nameWithType>.  
  
-   I delegati, che derivano da <xref:System.MulticastDelegate?displayProperty=nameWithType>.  
  
 Per due oggetti `x` e `y` che hanno tipi di runtime identici `Object.ReferenceEquals(x.GetType(),y.GetType())` restituisce `true`. L'esempio seguente usa il <xref:System.Object.GetType%2A> metodo con il <xref:System.Object.ReferenceEquals%2A> metodo per determinare se un valore numerico è lo stesso tipo due altri valori numerici.  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  Per determinare se un oggetto è un tipo specifico, è possibile usare la parola chiave confronto type del linguaggio o costruire. Ad esempio, è possibile usare la `TypeOf…Is` costruire in Visual Basic o `is` parola chiave nel linguaggio c#.  
  
 Il <xref:System.Object.GetType%2A> metodo viene ereditato da tutti i tipi che derivano da <xref:System.Object>. Ciò significa che, oltre a usare parole chiave di confronto del proprio linguaggio, è possibile usare il <xref:System.Object.GetType%2A> metodo per determinare il tipo di un oggetto specifico, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 Il <xref:System.Type> oggetto espone i metadati associati alla classe dell'oggetto corrente <xref:System.Object>.  
  
   
  
## Examples  
 Esempio di codice seguente viene dimostrato che <xref:System.Object.GetType%2A> restituisce il tipo di runtime dell'istanza corrente.  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una copia superficiale dell'oggetto <see cref="T:System.Object" /> corrente.</summary>
        <returns>Copia superficiale dell'oggetto <see cref="T:System.Object" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Object.MemberwiseClone%2A> metodo crea una copia superficiale, creando un nuovo oggetto e quindi copiare i campi non statici dell'oggetto corrente per il nuovo oggetto. Se un campo è un tipo di valore, viene eseguita una copia bit per bit del campo. Se un campo è un tipo riferimento, il riferimento è copiato ma l'oggetto di cui viene fatto riferimento non; Pertanto, l'oggetto originale e il suo clone fare riferimento allo stesso oggetto.  
  
 Si consideri ad esempio un oggetto denominato X che fa riferimento a oggetti A e B, a sua volta, oggetto references C. Una copia superficiale di X Crea nuovo oggetto X2 che fa riferimento anche a oggetti A e B. Al contrario, una copia completa di X crea un nuovo oggetto X2 che fa riferimento a nuovi oggetti A2 e B2, che sono copie di un e B2 B., a sua volta, fa riferimento il nuovo oggetto C2, ovvero una copia di C. Nell'esempio viene illustrata la differenza tra un shallow e un'operazione di copia completa.  
  
 Esistono diversi modi per implementare un'operazione di copia completa, se l'operazione di copia superficiale eseguita dal <xref:System.Object.MemberwiseClone%2A> metodo non soddisfa le proprie esigenze. tra cui:  
  
-   Chiamare un costruttore della classe dell'oggetto da copiare per creare un secondo oggetto con valori di proprietà forniti dal primo oggetto. Ciò presuppone che i valori di un oggetto vengono definiti interamente dal costruttore di classe.  
  
-   Chiamare il <xref:System.Object.MemberwiseClone%2A> metodo per creare una copia superficiale di un oggetto e quindi assegnare nuovi oggetti i cui valori sono lo stesso dell'oggetto originale a qualsiasi proprietà o campi i cui valori sono i tipi di riferimento. Il `DeepCopy` metodo nell'esempio viene illustrato questo approccio.  
  
-   Serializzare l'oggetto verrà approfondita copiato e quindi ripristinare i dati serializzati in una variabile di un oggetto diverso.  
  
-   Usare la reflection con la ricorsione per eseguire l'operazione di copia completa.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Object.MemberwiseClone%2A> (metodo). Definisce un `ShallowCopy` metodo che chiama il <xref:System.Object.MemberwiseClone%2A> metodo per eseguire un'operazione di copia dei riferimenti in un `Person` oggetto. Definisce anche un `DeepCopy` metodo che esegue un'operazione di copia completa su un `Person` oggetto.  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 In questo esempio, il `Person.IdInfo` proprietà restituisce un `IdInfo` oggetto. Come output illustrato nell'esempio, quando un `Person` oggetto viene clonato chiamando il <xref:System.Object.MemberwiseClone%2A> metodo, clonata `Person` oggetto è una copia indipendente dell'oggetto originale, ad eccezione del fatto che essi condividono lo stesso `Person.IdInfo` il riferimento all'oggetto. Di conseguenza, la modifica del clone `Person.IdInfo` proprietà dell'oggetto originale viene modificata `Person.IdInfo` proprietà. D'altra parte, quando viene eseguita un'operazione di copia completa, clonata `Person` dell'oggetto, tra cui relativo `Person.IdInfo` proprietà, può essere modificata senza influire sull'oggetto originale.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Primo oggetto da confrontare.</param>
        <param name="objB">Secondo oggetto da confrontare.</param>
        <summary>Determina se le istanze di <see cref="T:System.Object" /> specificate rappresentano la stessa istanza.</summary>
        <returns>
          <see langword="true" /> se <paramref name="objA" /> è la stessa istanza di <paramref name="objB" /> oppure se entrambe sono **null**; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza di <xref:System.Object.Equals%2A> metodo e l'operatore di uguaglianza, il <xref:System.Object.ReferenceEquals%2A> non è possibile eseguire l'override di metodo. Per questo motivo, se si vuole testare due riferimenti per verificarne l'uguaglianza di oggetti e non si conosce l'implementazione del `Equals` metodo, è possibile chiamare il <xref:System.Object.ReferenceEquals%2A> (metodo).  
  
 Tuttavia, il valore restituito del <xref:System.Object.ReferenceEquals%2A> metodo può sembrare anomale in questi due scenari:  
  
-   Quando si confrontano i tipi di valore. Se `objA` e `objB` sono tipi valore, essi vengono sottoposti a boxing prima che vengano passati per il <xref:System.Object.ReferenceEquals%2A> (metodo). Ciò significa che se entrambe `objA` e `objB` rappresentino la stessa istanza di un tipo di valore, il <xref:System.Object.ReferenceEquals%2A> metodo restituisce comunque `false`, come illustrato nell'esempio seguente.  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     Per informazioni sui tipi di valore di conversione boxing, vedere [conversioni Boxing e Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).  
  
-   Quando si confrontano le stringhe. Se `objA` e `objB` sono stringhe, il <xref:System.Object.ReferenceEquals%2A> restituzione del metodo `true` se la stringa è inserita. Non esegue un test di uguaglianza di valori.  Nell'esempio riportato di seguito `s1` e `s2` sono uguali perché sono due istanze di una singola stringa centralizzata. Tuttavia `s3` e `s4` non sono uguali, perché anche se hanno valori di stringa identica, tale stringa non è stata inserita.  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     Per altre informazioni sull'inserimento di stringhe, vedere <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L'esempio seguente usa <xref:System.Object.ReferenceEquals%2A> per determinare se due oggetti rappresentano la stessa istanza.  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una stringa che rappresenta l'oggetto corrente.</summary>
        <returns>Stringa che rappresenta l'oggetto corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> è la versione principale metodo di formattazione in .NET Framework. Converte un oggetto alla relativa rappresentazione di stringa, in modo che sia adatto per la visualizzazione. (Per informazioni sulla formattazione di supporto in .NET Framework, vedere [formattazione di tipi](~/docs/standard/base-types/formatting-types.md).) Le implementazioni predefinite del <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo restituisce il nome completo del tipo dell'oggetto.  
  
> [!IMPORTANT]
>  È stato raggiunto questa pagina, seguendo il collegamento dall'elenco dei membri di un altro tipo. Infatti, non l'override di tale tipo <xref:System.Object.ToString%2A?displayProperty=nameWithType>. Al contrario, eredita la funzionalità del <xref:System.Object.ToString%2A?displayProperty=nameWithType> (metodo).  
  
 Tipi di eseguire l'override di frequente il <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo per fornire una rappresentazione di stringa più adatta di un determinato tipo. Tipi spesso anche eseguire l'overload di <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo per fornire supporto per le stringhe di formato o formattazione dipendente dalle impostazioni cultura.  
  
 Contenuto della sezione:  
  
 [Il metodo ToString () predefinita](#Default)   
 [Override del metodo ToString)](#Overriding)   
 [L'overload del metodo ToString](#Overloading)   
 [Estendere il metodo ToString](#Extending)   
 [Note per il Runtime di Windows](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>Il metodo ToString () predefinita  
 L'implementazione predefinita del <xref:System.Object.ToString%2A> metodo viene restituito il nome completo del tipo del <xref:System.Object>, come illustrato nell'esempio seguente.  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 In quanto <xref:System.Object> è la classe di base di tutti i tipi di riferimento in .NET Framework, questo comportamento viene ereditato da tipi di riferimento che non eseguono l'override di <xref:System.Object.ToString%2A> (metodo). Questa condizione è illustrata nell'esempio seguente. Definisce una classe denominata `Object1` che accetta l'implementazione predefinita di tutte le <xref:System.Object> membri. Relativo <xref:System.Object.ToString%2A> metodo restituisce il nome di tipo completo dell'oggetto.  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>Override del metodo ToString)  
 Tipi comunemente eseguire l'override di <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo per restituire una stringa che rappresenta l'istanza dell'oggetto. Ad esempio, i tipi di base, ad esempio <xref:System.Char>, <xref:System.Int32>, e <xref:System.String> fornire <xref:System.Object.ToString%2A> implementazioni che restituiscono il formato di stringa del valore che rappresenta l'oggetto. L'esempio seguente definisce una classe `Object2`, che esegue l'override di <xref:System.Object.ToString%2A> per restituire il nome del tipo insieme al relativo valore.  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 Nella tabella seguente sono elencate le categorie dei tipi in .NET Framework e indica se eseguire l'override di <xref:System.Object.ToString%2A?displayProperty=nameWithType> (metodo).  
  
|Categoria di tipi|Esegue l'override di ToString)|Comportamento|  
|-------------------|-----------------------------------|--------------|  
|Classe|N/D|N/D|  
|Struttura|Sì (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|Uguale a ToString)|  
|Enumerazione|Sì (<xref:System.Enum.ToString?displayProperty=nameWithType>)|Il nome del membro|  
|Interfaccia|No|N/D|  
|delegato|No|N/D|  
  
 Vedere la sezione Note per gli eredi per altre informazioni sull'override <xref:System.Object.ToString%2A>.  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>L'overload del metodo ToString  
 Oltre a sostituire senza parametri <xref:System.Object.ToString?displayProperty=nameWithType> overload del metodo, molti tipi di `ToString` metodo per fornire versioni che accettano parametri del metodo. In genere, questa operazione viene eseguita per fornire il supporto per la formattazione variabile e formattazione dipendente dalle impostazioni cultura.  
  
 Gli overload di esempio seguente il `ToString` per restituire una stringa di risultato che include il valore di diversi campi di un `Automobile` classe. Definisce quattro stringhe di formato: G, che restituisce il nome del modello e l'anno; 1!d, che restituisce il nome del modello, anno e numero di portiere; C, che restituisce il nome del modello, anno e numero di cilindri; e A, che restituisce una stringa con tutti i valori dei campi di quattro.  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 L'esempio seguente chiama l'overload <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodo da visualizzare formattazione dipendente dalle impostazioni cultura di un valore di valuta.  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 Per altre informazioni su stringhe di formato e formattazione dipendente dalle impostazioni cultura, vedere [formattazione di tipi](~/docs/standard/base-types/formatting-types.md). Per le stringhe di formato supportate da valori numerici, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Per le stringhe di formato supportate dai valori data e ora, vedere [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>Estendere il metodo ToString  
 Poiché un tipo eredita il valore predefinito <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo, è possibile trovare il proprio comportamento indesiderato e per modificarlo. Questo vale in particolare delle classi di raccolta e matrici. Mentre si sarebbe potuto prevedere il `ToString` metodo di una matrice o raccolta di classe per visualizzare i valori dei relativi membri, viene invece visualizzato il nome tipo completo del tipo, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 Sono disponibili diverse opzioni per ottenere la stringa di risultato desiderato.  
  
-   Se il tipo è una matrice, un oggetto raccolta o un oggetto che implementa il <xref:System.Collections.IEnumerable> o <xref:System.Collections.Generic.IEnumerable%601> interfacce, è possibile enumerare i relativi elementi tramite il `foreach` istruzione in c# o `For Each...Next` costruire in Visual Basic.  
  
-   Se non è la classe `sealed` (in c#) o `NotInheritable` (in Visual Basic), è possibile sviluppare una classe wrapper che eredita dalla classe di base cui <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo che si desidera personalizzare. Come minimo, questa operazione richiede che procedere nel modo seguente:  
  
    1.  Implementare eventuali costruttori necessari. Le classi derivate non ereditano i relativi costruttori di classe di base.  
  
    2.  Eseguire l'override di <xref:System.Object.ToString%2A?displayProperty=nameWithType> per restituire la stringa di risultato desiderato.  
  
     L'esempio seguente definisce una classe wrapper per il <xref:System.Collections.Generic.List%601> classe. Viene eseguito l'override di <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo per visualizzare il valore di ogni metodo di raccolta piuttosto che il nome completo del tipo.  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   Sviluppare un' [metodo di estensione](~/docs/standard/design-guidelines/extension-methods.md) che restituisce la stringa di risultato desiderato. Si noti che non è possibile sostituire il valore predefinito <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo in questo modo (vale a dire, la classe di estensione (in c#) o il modulo (in Visual Basic) non può avere un metodo senza parametri denominato `ToString` che viene chiamato al posto del tipo originale `ToString` (metodo) . È possibile fornire un altro nome per il senza parametri `ToString` sostituzione.  
  
     L'esempio seguente definisce due metodi che estendono il <xref:System.Collections.Generic.List%601> classe: un costruttore `ToString2` metodo e una `ToString` metodo con un <xref:System.String> parametro che rappresenta una stringa di formato.  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Note per il [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Quando si chiama il <xref:System.Object.ToString%2A> metodo in una classe nel [!INCLUDE[wrt](~/includes/wrt-md.md)], fornisce il comportamento predefinito per le classi che non esegue l'override <xref:System.Object.ToString%2A>. Ciò fa parte del supporto che .NET Framework fornisce per i [!INCLUDE[wrt](~/includes/wrt-md.md)] (vedere [app .NET Framework supportano per Windows Store e Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Le classi di [!INCLUDE[wrt](~/includes/wrt-md.md)] non ereditano <xref:System.Object>e non sempre implementare un <xref:System.Object.ToString%2A>. Tuttavia, sempre sembrano disporre <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, e <xref:System.Object.GetHashCode%2A> metodi quando usarli nel codice c# o Visual Basic e .NET Framework fornisce un comportamento predefinito per questi metodi.  
  
 Inizia con la [!INCLUDE[net_v451](~/includes/net-v451-md.md)], common language runtime utilizzerà [istringable. ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) su un [!INCLUDE[wrt](~/includes/wrt-md.md)] oggetto prima di eseguire il fallback per l'implementazione predefinita di <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] le classi che vengono scritti in c# o Visual Basic possono eseguire l'override di <xref:System.Object.ToString%2A> (metodo).  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>Il [!INCLUDE[wrt](~/includes/wrt-md.md)] e l'interfaccia di IStringable  
 A partire [!INCLUDE[win81](~/includes/win81-md.md)], il [!INCLUDE[wrt](~/includes/wrt-md.md)] include un [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) il cui metodo singolo, di interfaccia [istringable. ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), fornisce un supporto di formattazione base analogo a quello fornito da <xref:System.Object.ToString%2A?displayProperty=nameWithType>. Per evitare ambiguità, è consigliabile non implementare [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) nei tipi gestiti.  
  
 Quando gli oggetti gestiti vengono chiamati da codice nativo o dal codice scritto in linguaggi quali JavaScript o C + + c++ /CX, vengono visualizzati per implementare [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx). Common language runtime indirizzerà automaticamente le chiamate da [istringable. ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) al <xref:System.Object.ToString%2A?displayProperty=nameWithType> event [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) non è implementato nell'oggetto gestito.  
  
> [!WARNING]
>  Poiché common language runtime. automatico-implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) per tutti i tipi in gestiti [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] le app, è consigliabile che non viene fornito il proprio [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementazione. Implementazione [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) può comportare un comportamento imprevisto quando si chiama `ToString` dal [!INCLUDE[wrt](~/includes/wrt-md.md)], C + c++ /CX o JavaScript.  
  
 Se si sceglie di implementare [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in un tipo gestito pubblico esportato in un [!INCLUDE[wrt](~/includes/wrt-md.md)] componente, rispettare i requisiti seguenti:  
  
-   È possibile definire le [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interfaccia solo in una relazione "classe", ad esempio  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     in C# oppure  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     in Visual Basic.  
  
-   Non è possibile implementare [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) su un'interfaccia.  
  
-   Non è possibile dichiarare un parametro di tipo [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).  
  
-   [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) non può essere il tipo restituito di un metodo, proprietà o campo.  
  
-   Non è possibile nascondere il [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementazione dalle classi di base usando una definizione di metodo analoga alla seguente:  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     Al contrario, il [istringable. ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementazione deve sempre eseguire l'override dell'implementazione della classe base. Puoi nascondere un'implementazione di `ToString` solo richiamandola sull'istanza di una classe fortemente tipizzata.  
  
 Si noti che in diverse circostanze le chiamate dal codice nativo a un tipo gestito che implementa [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) o nasconde la relativa [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementazione può produrre un comportamento imprevisto.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando si implementano i tipi personalizzati, è necessario eseguire l'override di <see cref="M:System.Object.ToString" /> metodo per restituire i valori più appropriati per tali tipi. Le classi derivate che richiedono un maggiore controllo sulla formattazione rispetto <see cref="M:System.Object.ToString" /> fornisce può implementare il <see cref="T:System.IFormattable" /> interfaccia. Relativi <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> metodo consente di definire le stringhe di formato che controllano la formattazione e usare un <see cref="T:System.IFormatProvider" /> oggetto che può fornire per la formattazione delle impostazioni cultura specifiche.  
  
Esegue l'override del <see cref="M:System.Object.ToString" /> metodo dovrebbe seguire queste linee guida: 
-La stringa restituita deve essere descrittivi e leggibile dagli utenti.  
  
-La stringa restituita deve identificare in modo univoco il valore dell'istanza dell'oggetto.  
  
-La stringa restituita deve essere più corte possibili, in modo che sia adatto per la visualizzazione da un debugger.  
  
-il <see cref="M:System.Object.ToString" /> override non deve restituire <see cref="F:System.String.Empty" /> o una stringa null.  
  
-il <see cref="M:System.Object.ToString" /> override non deve generare un'eccezione.  
  
-Se la rappresentazione di stringa di un'istanza di distinzione delle impostazioni cultura o può essere formattata in diversi modi, implementare il <see cref="T:System.IFormattable" /> interfaccia.  
  
-Se la stringa restituita include le informazioni riservate, è innanzitutto necessario richiedere un'autorizzazione appropriata. Se la richiesta ha esito positivo, è possibile restituire le informazioni sensibili. in caso contrario, è necessario restituire una stringa che esclude le informazioni riservate.  
  
-il <see cref="M:System.Object.ToString" /> sostituzione non deve avere nessun effetto collaterale observable per evitare complicazioni durante il debug. Ad esempio, una chiamata al <see cref="M:System.Object.ToString" /> metodo non deve modificare il valore dei campi di istanza.  
  
-Se il tipo implementa un metodo di analisi (o <see langword="Parse" /> oppure <see langword="TryParse" /> metodo, un costruttore o un altro metodo statico che crea un'istanza del tipo da una stringa), è necessario assicurarsi che la stringa restituita dal <see cref="M:System.Object.ToString" /> metodo può essere convertito in un'istanza dell'oggetto.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formattazione di tipi in .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>