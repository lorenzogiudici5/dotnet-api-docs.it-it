<Type Name="Object" FullName="System.Object">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="795aa213f55320afb69e8ac92a851b4700704644" />
    <Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="12/01/2018" />
    <Meta Name="ms.locfileid" Value="52734504" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="de8fa-101">Supporta tutte classi della gerarchia di classi .NET Framework e fornisce servizi di basso livello alle classi derivate.</span>
      <span class="sxs-lookup">
        <span data-stu-id="de8fa-101">Supports all classes in the .NET Framework class hierarchy and provides low-level services to derived classes.</span>
      </span>
      <span data-ttu-id="de8fa-102">Questa è la principale classe base di tutte le classi di .NET Framework e rappresenta la radice della gerarchia dei tipi.</span>
      <span class="sxs-lookup">
        <span data-stu-id="de8fa-102">This is the ultimate base class of all classes in the .NET Framework; it is the root of the type hierarchy.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de8fa-103">Lingue non richiedono in genere una classe per dichiarare l'ereditarietà da <xref:System.Object> perché l'ereditarietà è implicita.</span><span class="sxs-lookup"><span data-stu-id="de8fa-103">Languages typically do not require a class to declare inheritance from <xref:System.Object> because the inheritance is implicit.</span></span>  
  
 <span data-ttu-id="de8fa-104">Poiché tutte le classi in .NET Framework sono derivate da <xref:System.Object>, ogni metodo definito nel <xref:System.Object> classe è disponibile in tutti gli oggetti nel sistema.</span><span class="sxs-lookup"><span data-stu-id="de8fa-104">Because all classes in the .NET Framework are derived from <xref:System.Object>, every method defined in the <xref:System.Object> class is available in all objects in the system.</span></span> <span data-ttu-id="de8fa-105">Le classi derivate possono ed eseguire l'override di alcuni di questi metodi, tra cui:</span><span class="sxs-lookup"><span data-stu-id="de8fa-105">Derived classes can and do override some of these methods, including:</span></span>  
  
-   <span data-ttu-id="de8fa-106"><xref:System.Object.Equals%2A> -Supporta i confronti tra gli oggetti.</span><span class="sxs-lookup"><span data-stu-id="de8fa-106"><xref:System.Object.Equals%2A> - Supports comparisons between objects.</span></span>  
  
-   <span data-ttu-id="de8fa-107"><xref:System.Object.Finalize%2A> -Esegue operazioni di pulizia prima che un oggetto venga recuperato automaticamente.</span><span class="sxs-lookup"><span data-stu-id="de8fa-107"><xref:System.Object.Finalize%2A> - Performs cleanup operations before an object is automatically reclaimed.</span></span>  
  
-   <span data-ttu-id="de8fa-108"><xref:System.Object.GetHashCode%2A> -Genera un numero corrispondente al valore dell'oggetto per supportare l'uso di una tabella hash.</span><span class="sxs-lookup"><span data-stu-id="de8fa-108"><xref:System.Object.GetHashCode%2A> - Generates a number corresponding to the value of the object to support the use of a hash table.</span></span>  
  
-   <span data-ttu-id="de8fa-109"><xref:System.Object.ToString%2A> -Produce una stringa di testo leggibile che descrive un'istanza della classe.</span><span class="sxs-lookup"><span data-stu-id="de8fa-109"><xref:System.Object.ToString%2A> - Manufactures a human-readable text string that describes an instance of the class.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="de8fa-110">Considerazioni sulle prestazioni</span><span class="sxs-lookup"><span data-stu-id="de8fa-110">Performance Considerations</span></span>  
 <span data-ttu-id="de8fa-111">Se si progetta una classe, ad esempio una raccolta, che debba gestire qualsiasi tipo di oggetto, è possibile creare membri della classe che le istanze di accettano il <xref:System.Object> classe.</span><span class="sxs-lookup"><span data-stu-id="de8fa-111">If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <xref:System.Object> class.</span></span> <span data-ttu-id="de8fa-112">Tuttavia, il processo di conversione boxing e unboxing di un tipo comporta una riduzione delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="de8fa-112">However, the process of boxing and unboxing a type carries a performance cost.</span></span> <span data-ttu-id="de8fa-113">Se si conosce che la nuova classe gestirà spesso determinati tipi di valore è possibile usare una delle due strategie per ridurre al minimo il costo della conversione boxing.</span><span class="sxs-lookup"><span data-stu-id="de8fa-113">If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.</span></span>  
  
-   <span data-ttu-id="de8fa-114">Creare un metodo generico che accetta un <xref:System.Object> tipo e un set di overload di metodo specifico del tipo che accettano ogni tipo di valore si prevede che la classe per la gestione di frequente.</span><span class="sxs-lookup"><span data-stu-id="de8fa-114">Create a general method that accepts an <xref:System.Object> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle.</span></span> <span data-ttu-id="de8fa-115">Se esiste un metodo specifico del tipo che accetta il tipo di parametro di chiamata, nessuna conversione boxing viene eseguita e viene richiamato il metodo specifico del tipo.</span><span class="sxs-lookup"><span data-stu-id="de8fa-115">If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked.</span></span> <span data-ttu-id="de8fa-116">Se è presente alcun argomento di metodo che corrisponde al tipo di parametro di chiamata, il parametro è di tipo boxed e viene richiamato il metodo generale.</span><span class="sxs-lookup"><span data-stu-id="de8fa-116">If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.</span></span>  
  
-   <span data-ttu-id="de8fa-117">Progettare il tipo e i relativi membri per utilizzare i generics.</span><span class="sxs-lookup"><span data-stu-id="de8fa-117">Design your type and its members to use generics.</span></span> <span data-ttu-id="de8fa-118">Common language runtime crea un tipo generico chiuso quando si crea un'istanza della classe e specificare un argomento di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="de8fa-118">The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument.</span></span> <span data-ttu-id="de8fa-119">Il metodo generico è specifico del tipo e può essere richiamato senza eseguirne il boxing del parametro della chiamata.</span><span class="sxs-lookup"><span data-stu-id="de8fa-119">The generic method is type-specific and can be invoked without boxing the calling parameter.</span></span>  
  
 <span data-ttu-id="de8fa-120">Sebbene in alcuni casi è necessario sviluppare le classi di uso generale che accettano e restituiscono <xref:System.Object> tipi, è possibile migliorare le prestazioni, fornendo anche una classe specifica del tipo per gestire un tipo di uso frequente.</span><span class="sxs-lookup"><span data-stu-id="de8fa-120">Although it is sometimes necessary to develop general purpose classes that accept and return <xref:System.Object> types, you can improve performance by also providing a type-specific class to handle a frequently used type.</span></span> <span data-ttu-id="de8fa-121">Ad esempio, che fornisce una classe specifica di impostazione e recupero di valori booleani, viene eliminata la necessità di conversione boxing e unboxing valori booleani.</span><span class="sxs-lookup"><span data-stu-id="de8fa-121">For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="de8fa-122">L'esempio seguente definisce un tipo di punto derivato dal <xref:System.Object> classe ed esegue l'override di molti dei metodi virtuali del <xref:System.Object> classe.</span><span class="sxs-lookup"><span data-stu-id="de8fa-122">The following example defines a Point type derived from the <xref:System.Object> class and overrides many of the virtual methods of the <xref:System.Object> class.</span></span> <span data-ttu-id="de8fa-123">Inoltre, nell'esempio viene illustrato come chiamare numerosi statica e i metodi dell'istanza di <xref:System.Object> classe.</span><span class="sxs-lookup"><span data-stu-id="de8fa-123">In addition, the example shows how to call many of the static and instance methods of the <xref:System.Object> class.</span></span>  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="de8fa-124">Statici pubblici (<see langword="Shared" /> in Visual Basic) membri di questo tipo sono thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="de8fa-124">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span>
      </span>
      <span data-ttu-id="de8fa-125">I membri di istanza non è necessariamente essere thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="de8fa-125">Instance members are not guaranteed to be thread-safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="de8fa-126">Inizializza una nuova istanza della classe <see cref="T:System.Object" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-126">Initializes a new instance of the <see cref="T:System.Object" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de8fa-127">Questo costruttore viene chiamato dai costruttori nelle classi derivate, ma può essere utilizzato anche per creare direttamente un'istanza di <xref:System.Object> classe.</span><span class="sxs-lookup"><span data-stu-id="de8fa-127">This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <xref:System.Object> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="de8fa-128">Determina se due istanze di un oggetto sono uguali.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-128">Determines whether two object instances are equal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="de8fa-129">Oggetto da confrontare con l'oggetto corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-129">The object to compare with the current object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="de8fa-130">Determina se l'oggetto specificato è uguale all'oggetto corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-130">Determines whether the specified object is equal to the current object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="de8fa-131">
            <see langword="true" /> se l'oggetto specificato è uguale all'oggetto corrente; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-131">
              <see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de8fa-132">Il tipo di confronto tra l'istanza corrente e il `obj` parametro dipende dal fatto che l'istanza corrente è un tipo riferimento o un tipo valore.</span><span class="sxs-lookup"><span data-stu-id="de8fa-132">The type of comparison between the current instance and the `obj` parameter depends on whether the current instance is a reference type or a value type.</span></span>  
  
-   <span data-ttu-id="de8fa-133">Se l'istanza corrente è un tipo riferimento, il <xref:System.Object.Equals%28System.Object%29> metodo di test per l'uguaglianza dei riferimenti e una chiamata ai <xref:System.Object.Equals%28System.Object%29> è equivalente a una chiamata al metodo il <xref:System.Object.ReferenceEquals%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-133">If the current instance is a reference type, the <xref:System.Object.Equals%28System.Object%29> method tests for reference equality, and a call to the <xref:System.Object.Equals%28System.Object%29> method is equivalent to a call to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="de8fa-134">Uguaglianza di riferimenti significa che le variabili di oggetto che devono essere confrontate facciano riferimento allo stesso oggetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-134">Reference equality means that the object variables that are compared refer to the same object.</span></span> <span data-ttu-id="de8fa-135">Nell'esempio seguente illustra il risultato di tale confronto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-135">The following example illustrates the result of such a comparison.</span></span> <span data-ttu-id="de8fa-136">Definisce un `Person` classe, che è un tipo riferimento, e chiama il `Person` costruttore di classe per creare un'istanza di due nuovi `Person` oggetti, `person1a` e `person2`, che hanno lo stesso valore.</span><span class="sxs-lookup"><span data-stu-id="de8fa-136">It defines a `Person` class, which is a reference type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1a` and `person2`, which have the same value.</span></span> <span data-ttu-id="de8fa-137">Assegna `person1a` a un'altra variabile oggetto, `person1b`.</span><span class="sxs-lookup"><span data-stu-id="de8fa-137">It also assigns `person1a` to another object variable, `person1b`.</span></span> <span data-ttu-id="de8fa-138">Come illustrato nell'esempio, l'output `person1a` e `person1b` sono uguali, in quanto fanno riferimento allo stesso oggetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-138">As the output from the example shows, `person1a` and `person1b` are equal because they reference the same object.</span></span> <span data-ttu-id="de8fa-139">Tuttavia `person1a` e `person2` non sono uguali, anche se hanno lo stesso valore.</span><span class="sxs-lookup"><span data-stu-id="de8fa-139">However, `person1a` and `person2` are not equal, although they have the same value.</span></span>  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   <span data-ttu-id="de8fa-140">Se l'istanza corrente è un tipo valore, il <xref:System.Object.Equals%28System.Object%29> metodo verifica l'uguaglianza di valore.</span><span class="sxs-lookup"><span data-stu-id="de8fa-140">If the current instance is a value type, the <xref:System.Object.Equals%28System.Object%29> method tests for value equality.</span></span> <span data-ttu-id="de8fa-141">L'uguaglianza di valori comporta quanto segue:</span><span class="sxs-lookup"><span data-stu-id="de8fa-141">Value equality means the following:</span></span>  
  
    -   <span data-ttu-id="de8fa-142">I due oggetti sono dello stesso tipo.</span><span class="sxs-lookup"><span data-stu-id="de8fa-142">The two objects are of the same type.</span></span> <span data-ttu-id="de8fa-143">Come illustrato nell'esempio seguente, un <xref:System.Byte> oggetto che ha un valore pari a 12 non è uguale un <xref:System.Int32> oggetto che ha un valore pari a 12, poiché i due oggetti hanno diversi tipi di fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="de8fa-143">As the following example shows, a <xref:System.Byte> object that has a value of 12 does not equal an <xref:System.Int32> object that has a value of 12, because the two objects have different run-time types.</span></span>  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   <span data-ttu-id="de8fa-144">I valori dei campi pubblici e privati dei due oggetti sono uguali.</span><span class="sxs-lookup"><span data-stu-id="de8fa-144">The values of the public and private fields of the two objects are equal.</span></span> <span data-ttu-id="de8fa-145">L'esempio seguente verifica l'uguaglianza dei valori.</span><span class="sxs-lookup"><span data-stu-id="de8fa-145">The following example tests for value equality.</span></span> <span data-ttu-id="de8fa-146">Definisce un `Person` struttura, ovvero un tipo di valore, e chiama il `Person` costruttore della classe per creare un'istanza di due nuovi `Person` oggetti `person1` e `person2`, che hanno lo stesso valore.</span><span class="sxs-lookup"><span data-stu-id="de8fa-146">It defines a `Person` structure, which is a value type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1` and `person2`, which have the same value.</span></span> <span data-ttu-id="de8fa-147">Come illustrato nell'output dell'esempio, anche se le due variabili oggetto fare riferimento a oggetti diversi, `person1` e `person2` sono uguali perché hanno lo stesso valore per privato `personName` campo.</span><span class="sxs-lookup"><span data-stu-id="de8fa-147">As the output from the example shows, although the two object variables refer to different objects, `person1` and `person2` are equal because they have the same value for the private `personName` field.</span></span>  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 <span data-ttu-id="de8fa-148">Poiché il <xref:System.Object> classe è la classe base per tutti i tipi in .NET Framework, il <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metodo offre il confronto di uguaglianza predefinito per tutti gli altri tipi.</span><span class="sxs-lookup"><span data-stu-id="de8fa-148">Because the <xref:System.Object> class is the base class for all types in the .NET Framework, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method provides the default equality comparison for all other types.</span></span> <span data-ttu-id="de8fa-149">Tuttavia, i tipi spesso eseguire l'override di <xref:System.Object.Equals%2A> metodo per implementare l'uguaglianza di valori.</span><span class="sxs-lookup"><span data-stu-id="de8fa-149">However, types often override the <xref:System.Object.Equals%2A> method to implement value equality.</span></span> <span data-ttu-id="de8fa-150">Per altre informazioni, vedere le note per i chiamanti e note per le sezioni di eredi.</span><span class="sxs-lookup"><span data-stu-id="de8fa-150">For more information, see the Notes for Callers and Notes for Inheritors sections.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="de8fa-151">Note per il [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="de8fa-151">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="de8fa-152">Quando si chiama il <xref:System.Object.Equals%28System.Object%29> overload del metodo in una classe il [!INCLUDE[wrt](~/includes/wrt-md.md)], fornisce il comportamento predefinito per le classi che non esegue l'override <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-152">When you call the <xref:System.Object.Equals%28System.Object%29> method overload on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="de8fa-153">Ciò fa parte del supporto che .NET Framework fornisce per i [!INCLUDE[wrt](~/includes/wrt-md.md)] (vedere [app .NET Framework supportano per Windows Store e Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="de8fa-153">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="de8fa-154">Le classi di [!INCLUDE[wrt](~/includes/wrt-md.md)] non ereditano <xref:System.Object>e non implementa attualmente un <xref:System.Object.Equals%28System.Object%29> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-154">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and currently don't implement an <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="de8fa-155">Tuttavia, sembrano disporre <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, e <xref:System.Object.GetHashCode%2A> metodi quando usarli nel codice c# o Visual Basic e .NET Framework fornisce il comportamento predefinito per questi metodi.</span><span class="sxs-lookup"><span data-stu-id="de8fa-155">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="de8fa-156">le classi che vengono scritti in c# o Visual Basic possono eseguire l'override di <xref:System.Object.Equals%28System.Object%29> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="de8fa-156">classes that are written in C# or Visual Basic can override the <xref:System.Object.Equals%28System.Object%29> method overload.</span></span>  
  
## <a name="notes-for-callers"></a><span data-ttu-id="de8fa-157">Note per i chiamanti</span><span class="sxs-lookup"><span data-stu-id="de8fa-157">Notes for Callers</span></span>  
 <span data-ttu-id="de8fa-158">Spesso override dalle classi derivate di <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metodo per implementare l'uguaglianza di valori.</span><span class="sxs-lookup"><span data-stu-id="de8fa-158">Derived classes frequently override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to implement value equality.</span></span> <span data-ttu-id="de8fa-159">Inoltre, i tipi forniscono spesso anche un overload fortemente tipizzato aggiuntivo per il `Equals` metodo, in genere mediante l'implementazione la <xref:System.IEquatable%601> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="de8fa-159">In addition, types also frequently provide an additional strongly typed overload to the `Equals` method, typically by implementing the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="de8fa-160">Quando si chiama il `Equals` metodo per verificare l'uguaglianza, è necessario conoscere se l'istanza corrente esegue l'override <xref:System.Object.Equals%2A?displayProperty=nameWithType> e comprendere come una chiamata specifica a un `Equals` metodo viene risolto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-160">When you call the `Equals` method to test for equality, you should know whether the current instance overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType> and understand how a particular call to an `Equals` method is resolved.</span></span> <span data-ttu-id="de8fa-161">In caso contrario, è possibile eseguire un test per verificarne l'uguaglianza diverso da quelli desiderati e il metodo può restituire un valore imprevisto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-161">Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.</span></span>  
  
 <span data-ttu-id="de8fa-162">Nell'esempio seguente viene illustrato questo concetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-162">The following example provides an illustration.</span></span> <span data-ttu-id="de8fa-163">Crea un'istanza di tre <xref:System.Text.StringBuilder> gli oggetti con stringhe identiche e quindi esegue quattro chiamate a `Equals` metodi.</span><span class="sxs-lookup"><span data-stu-id="de8fa-163">It instantiates three <xref:System.Text.StringBuilder> objects with identical strings, and then makes four calls to `Equals` methods.</span></span> <span data-ttu-id="de8fa-164">Il prima chiamata al metodo restituisce `true`e la restituzione di tre rimanenti `false`.</span><span class="sxs-lookup"><span data-stu-id="de8fa-164">The first method call returns `true`, and the remaining three return `false`.</span></span>  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 <span data-ttu-id="de8fa-165">Nel primo caso, l'oggetto fortemente tipizzato <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> overload del metodo che verifica l'uguaglianza dei valori, viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="de8fa-165">In the first case, the strongly typed <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> method overload, which tests for value equality, is called.</span></span> <span data-ttu-id="de8fa-166">Poiché le stringhe assegnato ai due <xref:System.Text.StringBuilder> gli oggetti sono uguali, il metodo restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="de8fa-166">Because the strings assigned to the two <xref:System.Text.StringBuilder> objects are equal, the method returns `true`.</span></span> <span data-ttu-id="de8fa-167">Tuttavia <xref:System.Text.StringBuilder> non esegue l'override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-167">However, <xref:System.Text.StringBuilder> does not override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="de8fa-168">Per questo motivo, quando la <xref:System.Text.StringBuilder> cast dell'oggetto a un <xref:System.Object>, quando un <xref:System.Text.StringBuilder> istanza viene assegnata a una variabile di tipo <xref:System.Object>e quando il <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> metodo vengono passati due <xref:System.Text.StringBuilder> oggetti, il valore predefinito <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>viene chiamato il metodo.</span><span class="sxs-lookup"><span data-stu-id="de8fa-168">Because of this, when the <xref:System.Text.StringBuilder> object is cast to an <xref:System.Object>, when a <xref:System.Text.StringBuilder> instance is assigned to a variable of type <xref:System.Object>, and when the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> method is passed two <xref:System.Text.StringBuilder> objects, the default <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="de8fa-169">Poiché <xref:System.Text.StringBuilder> è un tipo riferimento, questa operazione equivale a passare i due <xref:System.Text.StringBuilder> gli oggetti per il <xref:System.Object.ReferenceEquals%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-169">Because <xref:System.Text.StringBuilder> is a reference type, this is equivalent to passing the two <xref:System.Text.StringBuilder> objects to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="de8fa-170">Anche se tutte e tre <xref:System.Text.StringBuilder> oggetti contengono stringhe identiche, cui fare riferimento a tre oggetti distinti.</span><span class="sxs-lookup"><span data-stu-id="de8fa-170">Although all three <xref:System.Text.StringBuilder> objects contain identical strings, they refer to three distinct objects.</span></span> <span data-ttu-id="de8fa-171">Di conseguenza, questi tre chiamate al metodo restituito `false`.</span><span class="sxs-lookup"><span data-stu-id="de8fa-171">As a result, these three method calls return `false`.</span></span>  
  
 <span data-ttu-id="de8fa-172">È possibile confrontare l'oggetto corrente in un altro oggetto per l'uguaglianza dei riferimenti chiamando il <xref:System.Object.ReferenceEquals%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-172">You can compare the current object to another object for reference equality by calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="de8fa-173">In Visual Basic, è anche possibile usare la `is` parola chiave (ad esempio, `If Me Is otherObject Then ...`).</span><span class="sxs-lookup"><span data-stu-id="de8fa-173">In Visual Basic, you can also use the `is` keyword (for example, `If Me Is otherObject Then ...`).</span></span>  
  
## <a name="notes-for-inheritors"></a><span data-ttu-id="de8fa-174">Note per gli eredi</span><span class="sxs-lookup"><span data-stu-id="de8fa-174">Notes for Inheritors</span></span>  
 <span data-ttu-id="de8fa-175">Quando si definisce un tipo personalizzato, tale tipo eredita la funzionalità definita dal `Equals` metodo del relativo tipo di base.</span><span class="sxs-lookup"><span data-stu-id="de8fa-175">When you define your own type, that type inherits the functionality defined by the `Equals` method of its base type.</span></span> <span data-ttu-id="de8fa-176">La tabella seguente elenca l'implementazione predefinita del `Equals` metodo per le principali categorie di tipi in .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="de8fa-176">The following table lists the default implementation of the `Equals` method for the major categories of types in the .NET Framework.</span></span>  
  
|<span data-ttu-id="de8fa-177">Categoria di tipi</span><span class="sxs-lookup"><span data-stu-id="de8fa-177">Type category</span></span>|<span data-ttu-id="de8fa-178">Uguaglianza definito da</span><span class="sxs-lookup"><span data-stu-id="de8fa-178">Equality defined by</span></span>|<span data-ttu-id="de8fa-179">Commenti</span><span class="sxs-lookup"><span data-stu-id="de8fa-179">Comments</span></span>|  
|-------------------|-------------------------|--------------|  
|<span data-ttu-id="de8fa-180">Classe derivata direttamente da <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="de8fa-180">Class derived directly from <xref:System.Object></span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="de8fa-181">Uguaglianza dei riferimenti; equivalente alla chiamata <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-181">Reference equality; equivalent to calling <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span></span>|  
|<span data-ttu-id="de8fa-182">Struttura</span><span class="sxs-lookup"><span data-stu-id="de8fa-182">Structure</span></span>|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="de8fa-183">Uguaglianza di valori; confronto byte per byte diretto o campo per campo confronto usando la reflection.</span><span class="sxs-lookup"><span data-stu-id="de8fa-183">Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.</span></span>|  
|<span data-ttu-id="de8fa-184">Enumerazione</span><span class="sxs-lookup"><span data-stu-id="de8fa-184">Enumeration</span></span>|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="de8fa-185">I valori devono avere lo stesso tipo di enumerazione e lo stesso valore sottostante.</span><span class="sxs-lookup"><span data-stu-id="de8fa-185">Values must have the same enumeration type and the same underlying value.</span></span>|  
|<span data-ttu-id="de8fa-186">delegato</span><span class="sxs-lookup"><span data-stu-id="de8fa-186">Delegate</span></span>|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="de8fa-187">I delegati devono avere lo stesso tipo con elenchi chiamate identici.</span><span class="sxs-lookup"><span data-stu-id="de8fa-187">Delegates must have the same type with identical invocation lists.</span></span>|  
|<span data-ttu-id="de8fa-188">Interfaccia</span><span class="sxs-lookup"><span data-stu-id="de8fa-188">Interface</span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="de8fa-189">Uguaglianza dei riferimenti.</span><span class="sxs-lookup"><span data-stu-id="de8fa-189">Reference equality.</span></span>|  
  
 <span data-ttu-id="de8fa-190">Per un tipo di valore, è sempre consigliabile eseguire l'override <xref:System.Object.Equals%2A>, perché verifica l'uguaglianza basati sulla reflection offerta una riduzione delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="de8fa-190">For a value type, you should always override <xref:System.Object.Equals%2A>, because tests for equality that rely on reflection offer poor performance.</span></span> <span data-ttu-id="de8fa-191">È inoltre possibile sostituire l'implementazione predefinita di <xref:System.Object.Equals%2A> per i tipi di riferimento per verificare l'uguaglianza di valore anziché l'uguaglianza dei riferimenti e per definire il significato esatto di uguaglianza di valori.</span><span class="sxs-lookup"><span data-stu-id="de8fa-191">You can also override the default implementation of <xref:System.Object.Equals%2A> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality.</span></span> <span data-ttu-id="de8fa-192">Questo tipo di implementazioni di <xref:System.Object.Equals%2A> restituire `true` se i due oggetti hanno lo stesso valore, anche se non sono la stessa istanza.</span><span class="sxs-lookup"><span data-stu-id="de8fa-192">Such implementations of <xref:System.Object.Equals%2A> return `true` if the two objects have the same value, even if they are not the same instance.</span></span> <span data-ttu-id="de8fa-193">Responsabile dell'implementazione del tipo decide cosa si intende per valore di un oggetto, ma è in genere alcuni o tutti i dati archiviati nelle variabili di istanza dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-193">The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object.</span></span> <span data-ttu-id="de8fa-194">Ad esempio, il valore di un <xref:System.String> oggetto è basato sui caratteri della stringa; il <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> override dei metodi la <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> per restituire `true` per qualsiasi due istanze che contengono gli stessi caratteri nello stesso ordine di stringa.</span><span class="sxs-lookup"><span data-stu-id="de8fa-194">For example, the value of a <xref:System.String> object is based on the characters of the string; the <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> method overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to return `true` for any two string instances that contain the same characters in the same order.</span></span>  
  
 <span data-ttu-id="de8fa-195">Nell'esempio seguente viene illustrato come eseguire l'override di <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metodo per verificare l'uguaglianza di valore.</span><span class="sxs-lookup"><span data-stu-id="de8fa-195">The following example shows how to override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to test for value equality.</span></span> <span data-ttu-id="de8fa-196">Viene eseguito l'override di <xref:System.Object.Equals%2A> metodo per il `Person` classe.</span><span class="sxs-lookup"><span data-stu-id="de8fa-196">It overrides the <xref:System.Object.Equals%2A> method for the `Person` class.</span></span> <span data-ttu-id="de8fa-197">Se `Person` accettato l'implementazione della classe di base di uguaglianza, due `Person` oggetti sarebbe uguali solo se viene fatto un singolo oggetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-197">If `Person` accepted its base class implementation of equality, two `Person` objects would be equal only if they referenced a single object.</span></span> <span data-ttu-id="de8fa-198">Tuttavia, in questo caso, due `Person` gli oggetti sono uguali se hanno lo stesso valore per il `Person.Id` proprietà.</span><span class="sxs-lookup"><span data-stu-id="de8fa-198">However, in this case, two `Person` objects are equal if they have the same value for the `Person.Id` property.</span></span>  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 <span data-ttu-id="de8fa-199">Oltre a eseguire l'override <xref:System.Object.Equals%2A>, è possibile implementare il <xref:System.IEquatable%601> interfaccia per fornire un test fortemente tipizzato per verificarne l'uguaglianza.</span><span class="sxs-lookup"><span data-stu-id="de8fa-199">In addition to overriding <xref:System.Object.Equals%2A>, you can implement the <xref:System.IEquatable%601> interface to provide a strongly typed test for equality.</span></span>  
  
 <span data-ttu-id="de8fa-200">Le istruzioni seguenti devono essere true per tutte le implementazioni del <xref:System.Object.Equals%28System.Object%29> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-200">The following statements must be true for all implementations of the <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="de8fa-201">Nell'elenco `x`, `y`, e `z` rappresentano i riferimenti agli oggetti che non sono **null**.</span><span class="sxs-lookup"><span data-stu-id="de8fa-201">In the list, `x`, `y`, and `z` represent object references that are not **null**.</span></span>  
  
-   <span data-ttu-id="de8fa-202">`x.Equals(x)` Restituisce `true`, tranne nei casi che coinvolgono tipi a virgola mobile.</span><span class="sxs-lookup"><span data-stu-id="de8fa-202">`x.Equals(x)` returns `true`, except in cases that involve floating-point types.</span></span> <span data-ttu-id="de8fa-203">ISO/IEC/IEEE 60559:2011, IT - sistemi di microprocessori, aritmetica a virgola mobile, vedere.</span><span class="sxs-lookup"><span data-stu-id="de8fa-203">See ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic.</span></span>  
  
-   <span data-ttu-id="de8fa-204">`y.Equals(x)` restituisce lo stesso valore di `x.Equals(y)`.</span><span class="sxs-lookup"><span data-stu-id="de8fa-204">`x.Equals(y)` returns the same value as `y.Equals(x)`.</span></span>  
  
-   <span data-ttu-id="de8fa-205">`x.Equals(y)` Restituisce `true` se entrambi `x` e `y` sono `NaN`.</span><span class="sxs-lookup"><span data-stu-id="de8fa-205">`x.Equals(y)` returns `true` if both `x` and `y` are `NaN`.</span></span>  
  
-   <span data-ttu-id="de8fa-206">Se `(x.Equals(y) && y.Equals(z))` restituisce `true`, quindi `x.Equals(z)` restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="de8fa-206">If `(x.Equals(y) && y.Equals(z))` returns `true`, then `x.Equals(z)` returns `true`.</span></span>  
  
-   <span data-ttu-id="de8fa-207">Le chiamate successive a `x.Equals(y)` restituiscono lo stesso valore purché gli oggetti cui fa riferimento `x` e `y` non vengono modificati.</span><span class="sxs-lookup"><span data-stu-id="de8fa-207">Successive calls to `x.Equals(y)` return the same value as long as the objects referenced by `x` and `y` are not modified.</span></span>  
  
-   <span data-ttu-id="de8fa-208">`x.Equals(null)` restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="de8fa-208">`x.Equals(null)` returns `false`.</span></span>  
  
 <span data-ttu-id="de8fa-209">Le implementazioni di <xref:System.Object.Equals%2A> non devono generare eccezioni; restituiscono sempre un valore.</span><span class="sxs-lookup"><span data-stu-id="de8fa-209">Implementations of <xref:System.Object.Equals%2A> must not throw exceptions; they should always return a value.</span></span> <span data-ttu-id="de8fa-210">Ad esempio, se `obj` viene `null`, il <xref:System.Object.Equals%2A> metodo deve restituire `false` anziché generare un <xref:System.ArgumentNullException>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-210">For example, if `obj` is `null`, the <xref:System.Object.Equals%2A> method should return `false` instead of throwing an <xref:System.ArgumentNullException>.</span></span>  
  
 <span data-ttu-id="de8fa-211">Seguire queste linee guida quando si esegue l'override <xref:System.Object.Equals%28System.Object%29>:</span><span class="sxs-lookup"><span data-stu-id="de8fa-211">Follow these guidelines when overriding <xref:System.Object.Equals%28System.Object%29>:</span></span>  
  
-   <span data-ttu-id="de8fa-212">I tipi che implementano <xref:System.IComparable> deve eseguire l'override <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-212">Types that implement <xref:System.IComparable> must override <xref:System.Object.Equals%28System.Object%29>.</span></span>  
  
-   <span data-ttu-id="de8fa-213">I tipi che eseguono l'override <xref:System.Object.Equals%28System.Object%29> deve eseguire l'override anche <xref:System.Object.GetHashCode%2A>; in caso contrario, le tabelle hash potrebbero non funzionare correttamente.</span><span class="sxs-lookup"><span data-stu-id="de8fa-213">Types that override <xref:System.Object.Equals%28System.Object%29> must also override <xref:System.Object.GetHashCode%2A>; otherwise, hash tables  might not work correctly.</span></span>  
  
-   <span data-ttu-id="de8fa-214">È consigliabile implementare la <xref:System.IEquatable%601> interfaccia per il supporto fortemente tipizzata verifica l'uguaglianza.</span><span class="sxs-lookup"><span data-stu-id="de8fa-214">You should consider implementing the <xref:System.IEquatable%601> interface to support strongly typed tests for equality.</span></span> <span data-ttu-id="de8fa-215">I <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementazione debba restituire risultati coerenti con <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-215">Your <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementation should return results that are consistent with <xref:System.Object.Equals%2A>.</span></span>  
  
-   <span data-ttu-id="de8fa-216">Se il linguaggio di programmazione supporta l'overload degli operatori ed l'overload dell'operatore di uguaglianza per un determinato tipo, è anche necessario eseguire l'override di <xref:System.Object.Equals%28System.Object%29> per restituire lo stesso risultato dell'operatore di uguaglianza.</span><span class="sxs-lookup"><span data-stu-id="de8fa-216">If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <xref:System.Object.Equals%28System.Object%29> method to return the same result as the equality operator.</span></span> <span data-ttu-id="de8fa-217">Ciò aiuta a garantire che il codice della libreria di classi che utilizza <xref:System.Object.Equals%2A> (ad esempio <xref:System.Collections.ArrayList> e <xref:System.Collections.Hashtable>) si comporta in modo che sia coerenza con il modo in cui l'operatore di uguaglianza viene usato dal codice dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="de8fa-217">This  helps ensure that class library code that uses <xref:System.Object.Equals%2A> (such as <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>) behaves in a manner that is consistent with the way the equality operator is used by application code.</span></span>  
  
### <a name="guidelines-for-reference-types"></a><span data-ttu-id="de8fa-218">Linee guida per i tipi di riferimento</span><span class="sxs-lookup"><span data-stu-id="de8fa-218">Guidelines for Reference Types</span></span>  
 <span data-ttu-id="de8fa-219">Le linee guida seguenti si applicano a viene sottoposto a override <xref:System.Object.Equals%28System.Object%29> per un tipo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="de8fa-219">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a reference type:</span></span>  
  
-   <span data-ttu-id="de8fa-220">Eseguire l'override <xref:System.Object.Equals%2A> se la semantica del tipo è basata sul fatto che il tipo rappresenta dei valori.</span><span class="sxs-lookup"><span data-stu-id="de8fa-220">Consider overriding <xref:System.Object.Equals%2A> if the semantics of the type are based on the fact that the type represents some value(s).</span></span>  
  
-   <span data-ttu-id="de8fa-221">La maggior parte dei tipi di riferimento necessario non eseguire l'overload dell'operatore di uguaglianza, anche se si esegue l'override <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-221">Most reference types must not overload the equality operator, even if they override <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="de8fa-222">Tuttavia, se si implementa un tipo di riferimento che deve avere una semantica di valore, ad esempio un numero complesso di tipo, è necessario eseguire l'override dell'operatore di uguaglianza.</span><span class="sxs-lookup"><span data-stu-id="de8fa-222">However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.</span></span>  
  
-   <span data-ttu-id="de8fa-223">È consigliabile non eseguire l'override <xref:System.Object.Equals%2A> su un tipo di riferimento modificabile.</span><span class="sxs-lookup"><span data-stu-id="de8fa-223">You should not override <xref:System.Object.Equals%2A> on a mutable reference type.</span></span> <span data-ttu-id="de8fa-224">Infatti, si esegue l'override <xref:System.Object.Equals%2A> richiede anche eseguire l'override di <xref:System.Object.GetHashCode%2A> metodo, come descritto nella sezione precedente.</span><span class="sxs-lookup"><span data-stu-id="de8fa-224">This is because overriding <xref:System.Object.Equals%2A> requires that you also override the <xref:System.Object.GetHashCode%2A> method, as discussed in the previous section.</span></span> <span data-ttu-id="de8fa-225">Ciò significa che è possibile modificare il codice hash di un'istanza di un tipo di riferimento modificabile durante la sua durata, che può causare l'oggetto da andranno persi in una tabella hash.</span><span class="sxs-lookup"><span data-stu-id="de8fa-225">This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.</span></span>  
  
### <a name="guidelines-for-value-types"></a><span data-ttu-id="de8fa-226">Linee guida per i tipi di valore</span><span class="sxs-lookup"><span data-stu-id="de8fa-226">Guidelines for Value Types</span></span>  
 <span data-ttu-id="de8fa-227">Le linee guida seguenti si applicano a viene sottoposto a override <xref:System.Object.Equals%28System.Object%29> per un tipo valore:</span><span class="sxs-lookup"><span data-stu-id="de8fa-227">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a value type:</span></span>  
  
-   <span data-ttu-id="de8fa-228">Se si sta definendo un tipo di valore che include uno o più campi i cui valori sono i tipi di riferimento, è necessario eseguire l'override <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-228">If you are defining a value type that includes one or more fields whose values are reference types, you should override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="de8fa-229">Il <xref:System.Object.Equals%28System.Object%29> implementazione fornita dal <xref:System.ValueType> esegue un confronto byte per byte per i tipi di valore cui campi sono tutti i tipi di valore, ma usa la reflection per eseguire un confronto per campi di tipi di valori i cui campi includono i tipi di riferimento.</span><span class="sxs-lookup"><span data-stu-id="de8fa-229">The <xref:System.Object.Equals%28System.Object%29> implementation provided by <xref:System.ValueType> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.</span></span>  
  
-   <span data-ttu-id="de8fa-230">Se esegue l'override <xref:System.Object.Equals%2A> e il linguaggio di sviluppo supporta l'overload degli operatori, è necessario eseguire l'overload dell'operatore di uguaglianza.</span><span class="sxs-lookup"><span data-stu-id="de8fa-230">If you override <xref:System.Object.Equals%2A> and your development language supports operator overloading, you must overload the equality operator.</span></span>  
  
-   <span data-ttu-id="de8fa-231">È consigliabile implementare la <xref:System.IEquatable%601> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="de8fa-231">You should implement the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="de8fa-232">La chiamata l'oggetto fortemente tipizzato <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> metodo evita la conversione boxing di `obj` argomento.</span><span class="sxs-lookup"><span data-stu-id="de8fa-232">Calling the strongly typed <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> method avoids boxing the `obj` argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="de8fa-233">L'esempio seguente mostra un `Point` che esegue l'override di <xref:System.Object.Equals%2A> metodo per fornire l'uguaglianza di valori e un `Point3D` classe che deriva da `Point`.</span><span class="sxs-lookup"><span data-stu-id="de8fa-233">The following example shows a `Point` class that overrides the <xref:System.Object.Equals%2A> method to provide value equality, and a `Point3D` class that is derived from `Point`.</span></span> <span data-ttu-id="de8fa-234">In quanto `Point` esegue l'override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> per verificare l'uguaglianza di valore, il <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> non viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="de8fa-234">Because `Point` overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to test for value equality, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is not called.</span></span> <span data-ttu-id="de8fa-235">Tuttavia `Point3D.Equals` chiamate `Point.Equals` poiché `Point` implementa <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> in modo che fornisce l'uguaglianza di valori.</span><span class="sxs-lookup"><span data-stu-id="de8fa-235">However, `Point3D.Equals` calls `Point.Equals` because `Point` implements <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> in a manner that provides value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 <span data-ttu-id="de8fa-236">Il `Point.Equals` metodo di verifica per assicurarsi che il `obj` l'argomento non è **null** e che fa riferimento a un'istanza dello stesso tipo dell'oggetto corrente.</span><span class="sxs-lookup"><span data-stu-id="de8fa-236">The `Point.Equals` method checks to make sure that the `obj` argument is not **null** and that it references an instance of the same type as this object.</span></span> <span data-ttu-id="de8fa-237">Se il controllo non riesce, il metodo restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="de8fa-237">If either check fails, the method returns `false`.</span></span>  
  
 <span data-ttu-id="de8fa-238">Il `Point.Equals` chiamate al metodo il <xref:System.Object.GetType%2A> metodo per determinare se i tipi in fase di esecuzione dei due oggetti sono identici.</span><span class="sxs-lookup"><span data-stu-id="de8fa-238">The `Point.Equals` method calls the <xref:System.Object.GetType%2A> method to determine whether the run-time types of the two objects are identical.</span></span> <span data-ttu-id="de8fa-239">Se il metodo utilizzato un controllo del form `obj is Point` in c# o `TryCast(obj, Point)` in Visual Basic, il controllo restituirà `true` nei casi in cui `obj` è un'istanza di una classe derivata di `Point`, anche se `obj` e corrente istanza non sono dello stesso tipo in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="de8fa-239">If the method used a check of the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic, the check would return `true` in cases where `obj` is an instance of a derived class of `Point`, even though `obj` and the current instance are not of the same run-time type.</span></span> <span data-ttu-id="de8fa-240">Dopo aver verificato che entrambi gli oggetti sono dello stesso tipo, il metodo esegue il cast `obj` al tipo `Point` e restituisce il risultato del confronto tra i campi di istanza dei due oggetti.</span><span class="sxs-lookup"><span data-stu-id="de8fa-240">Having verified that both objects are of the same type, the method casts `obj` to type `Point` and returns the result of comparing the instance fields of the two objects.</span></span>  
  
 <span data-ttu-id="de8fa-241">Nelle `Point3D.Equals`, ereditato `Point.Equals` metodo, che esegue l'override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, viene richiamato prima che qualsiasi altra operazione.</span><span class="sxs-lookup"><span data-stu-id="de8fa-241">In `Point3D.Equals`, the inherited `Point.Equals` method, which overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, is invoked before anything else is done.</span></span> <span data-ttu-id="de8fa-242">In quanto `Point3D` è una classe sealed (`NotInheritable` in Visual Basic), un segno di spunta form `obj is Point` in c# o `TryCast(obj, Point)` in Visual Basic è sufficiente per garantire che `obj` è un `Point3D` oggetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-242">Because `Point3D` is a sealed class (`NotInheritable` in Visual Basic), a check in the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic is adequate to ensure that `obj` is a `Point3D` object.</span></span> <span data-ttu-id="de8fa-243">Se si tratta di un `Point3D` dell'oggetto, ne viene eseguito il cast a un `Point` dell'oggetto e passati all'implementazione della classe di base di <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-243">If it is a `Point3D` object, it is cast to a `Point` object and passed to the base class implementation of <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="de8fa-244">Solo quando ereditato `Point.Equals` restituzione del metodo `true` viene confronta il metodo di `z` introdotti nella classe derivata di campi di istanza.</span><span class="sxs-lookup"><span data-stu-id="de8fa-244">Only when the inherited `Point.Equals` method returns `true` does the method compare the `z` instance fields introduced in the derived class.</span></span>  
  
 <span data-ttu-id="de8fa-245">L'esempio seguente definisce una `Rectangle` classe che implementa internamente un rettangolo come due `Point` oggetti.</span><span class="sxs-lookup"><span data-stu-id="de8fa-245">The following example defines a `Rectangle` class that internally implements a rectangle as two `Point` objects.</span></span> <span data-ttu-id="de8fa-246">Il `Rectangle` classe anche le sostituzioni <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> per fornire l'uguaglianza dei valori.</span><span class="sxs-lookup"><span data-stu-id="de8fa-246">The `Rectangle` class also overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to provide for value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 <span data-ttu-id="de8fa-247">Alcuni linguaggi quali c# e Visual Basic supportano l'overload degli operatori.</span><span class="sxs-lookup"><span data-stu-id="de8fa-247">Some languages such as C# and Visual Basic support operator overloading.</span></span> <span data-ttu-id="de8fa-248">Quando un tipo esegue l'overload dell'operatore di uguaglianza, è necessario anche l'override di <xref:System.Object.Equals%28System.Object%29> metodo per fornire la stessa funzionalità.</span><span class="sxs-lookup"><span data-stu-id="de8fa-248">When a type overloads the equality operator, it must also override the <xref:System.Object.Equals%28System.Object%29> method to provide the same functionality.</span></span> <span data-ttu-id="de8fa-249">Questa operazione viene in genere eseguita mediante la scrittura di <xref:System.Object.Equals%28System.Object%29> metodo in termini di operatore di uguaglianza di overload, come nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="de8fa-249">This is typically accomplished by writing the <xref:System.Object.Equals%28System.Object%29> method in terms of the overloaded equality operator, as in the following example.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 <span data-ttu-id="de8fa-250">Poiché `Complex` è un tipo di valore, non è possibile derivare da.</span><span class="sxs-lookup"><span data-stu-id="de8fa-250">Because `Complex` is a value type, it cannot be derived from.</span></span>  <span data-ttu-id="de8fa-251">Di conseguenza, la sostituzione <xref:System.Object.Equals%28System.Object%29> metodo non è necessario chiamare <xref:System.Object.GetType%2A> per determinare il run-time preciso digitare di ogni oggetto, ma può invece utilizzare il `is` operatore nel linguaggio c# o il `TypeOf` operatore in Visual Basic per controllare il tipo del `obj` parametro.</span><span class="sxs-lookup"><span data-stu-id="de8fa-251">Therefore, the override to <xref:System.Object.Equals%28System.Object%29> method need not call <xref:System.Object.GetType%2A> to determine the precise run-time type of each object, but can instead use the `is` operator in C# or the `TypeOf` operator in Visual Basic to check the type of the `obj` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">
          <span data-ttu-id="de8fa-252">Primo oggetto da confrontare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-252">The first object to compare.</span>
          </span>
        </param>
        <param name="objB">
          <span data-ttu-id="de8fa-253">Secondo oggetto da confrontare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-253">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="de8fa-254">Determina se le istanze dell'oggetto specificate sono considerate uguali.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-254">Determines whether the specified object instances are considered equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="de8fa-255">
            <see langword="true" /> se gli oggetti sono considerati uguali; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-255">
              <see langword="true" /> if the objects are considered equal; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="de8fa-256">Se entrambi i parametri <paramref name="objA" /> e <paramref name="objB" /> sono **null**, il metodo restituisce <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-256">If both <paramref name="objA" /> and <paramref name="objB" /> are **null**, the method returns <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de8fa-257">Il metodo statico <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> metodo indica se due oggetti, `objA` e `objB`, sono uguali.</span><span class="sxs-lookup"><span data-stu-id="de8fa-257">The static <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method indicates whether two objects, `objA` and  `objB`, are equal.</span></span> <span data-ttu-id="de8fa-258">Permette anche testare gli oggetti il cui valore è **null** per verificarne l'uguaglianza.</span><span class="sxs-lookup"><span data-stu-id="de8fa-258">It also enables you to test objects whose value is **null** for equality.</span></span> <span data-ttu-id="de8fa-259">Confronta `objA` e `objB` per verificarne l'uguaglianza come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="de8fa-259">It compares `objA` and `objB` for equality as follows:</span></span>  
  
-   <span data-ttu-id="de8fa-260">Determina se i due oggetti rappresentano lo stesso riferimento oggetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-260">It determines whether the two objects represent the same object reference.</span></span> <span data-ttu-id="de8fa-261">Se ciò si verifica, il metodo restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="de8fa-261">If they do, the method returns `true`.</span></span> <span data-ttu-id="de8fa-262">Questo test è equivalente alla chiamata di <xref:System.Object.ReferenceEquals%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-262">This test is equivalent to calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="de8fa-263">Inoltre, se entrambe `objA` e `objB` vengono **null**, il metodo restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="de8fa-263">In addition, if both `objA` and `objB` are **null**, the method returns `true`.</span></span>  
  
-   <span data-ttu-id="de8fa-264">Determina se sia `objA` oppure `objB` viene **null**.</span><span class="sxs-lookup"><span data-stu-id="de8fa-264">It determines whether either `objA` or `objB` is **null**.</span></span> <span data-ttu-id="de8fa-265">Se pertanto restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="de8fa-265">If so, it returns `false`.</span></span>  
  
-   <span data-ttu-id="de8fa-266">Se i due oggetti non rappresentano il riferimento all'oggetto stesso e nemmeno **null**, chiama `objA`.`Equals` (`objB`) e restituisce il risultato.</span><span class="sxs-lookup"><span data-stu-id="de8fa-266">If the two objects do not represent the same object reference and neither is **null**, it calls `objA`.`Equals`(`objB`) and returns the result.</span></span> <span data-ttu-id="de8fa-267">Ciò significa che, se `objA` esegue l'override di <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> , questo override viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="de8fa-267">This means that if `objA` overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, this override is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="de8fa-268">Nell'esempio seguente viene illustrato il <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> metodo e lo confronta con il <xref:System.Object.ReferenceEquals%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-268">The following example illustrates the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method and compares it with the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="de8fa-269">Consente a un oggetto di effettuare un tentativo di liberare risorse ed eseguire altre operazioni di pulizia prima che venga recuperato da Garbage Collection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-269">Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de8fa-270">Il <xref:System.Object.Finalize%2A> metodo viene utilizzato per eseguire operazioni di pulitura su risorse non gestite bloccate dall'oggetto corrente prima dell'eliminazione permanente dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-270">The <xref:System.Object.Finalize%2A> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.</span></span> <span data-ttu-id="de8fa-271">Il metodo è protetto e pertanto è accessibile solo tramite questa classe o una classe derivata.</span><span class="sxs-lookup"><span data-stu-id="de8fa-271">The method is protected and therefore is accessible only through this class or through a derived class.</span></span>  
  
 <span data-ttu-id="de8fa-272">Contenuto della sezione:</span><span class="sxs-lookup"><span data-stu-id="de8fa-272">In this section:</span></span>  
  
-   [<span data-ttu-id="de8fa-273">Come funziona la finalizzazione</span><span class="sxs-lookup"><span data-stu-id="de8fa-273">How finalization works</span></span>](#How)  
  
-   [<span data-ttu-id="de8fa-274">Note per gli implementatori</span><span class="sxs-lookup"><span data-stu-id="de8fa-274">Notes for implementers</span></span>](#Notes)  
  
-   [<span data-ttu-id="de8fa-275">Alternativa SafeHandle</span><span class="sxs-lookup"><span data-stu-id="de8fa-275">The SafeHandle alternative</span></span>](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a><span data-ttu-id="de8fa-276">Come funziona la finalizzazione</span><span class="sxs-lookup"><span data-stu-id="de8fa-276">How finalization works</span></span>  
 <span data-ttu-id="de8fa-277">Il <xref:System.Object> classe non fornisce alcuna implementazione per il <xref:System.Object.Finalize%2A> metodo e il garbage collector non contrassegna i tipi derivati da <xref:System.Object> per la finalizzazione a meno che non eseguono l'override di <xref:System.Object.Finalize%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-277">The <xref:System.Object> class provides no implementation for the <xref:System.Object.Finalize%2A> method, and the garbage collector does not mark types derived from <xref:System.Object> for finalization unless they override the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 <span data-ttu-id="de8fa-278">Se esegue l'override di un tipo di <xref:System.Object.Finalize%2A> metodo, il garbage collector aggiunge una voce per ogni istanza del tipo a una struttura interna denominata coda di finalizzazione.</span><span class="sxs-lookup"><span data-stu-id="de8fa-278">If a type does override the <xref:System.Object.Finalize%2A> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue.</span></span> <span data-ttu-id="de8fa-279">Coda di finalizzazione contiene voci per tutti gli oggetti nell'heap gestito il cui codice di finalizzazione deve essere eseguito prima che il garbage collector di recuperare la memoria.</span><span class="sxs-lookup"><span data-stu-id="de8fa-279">The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory.</span></span> <span data-ttu-id="de8fa-280">Il garbage collector chiama quindi il <xref:System.Object.Finalize%2A> metodo automaticamente nelle condizioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="de8fa-280">The garbage collector then calls the <xref:System.Object.Finalize%2A> method automatically under the following conditions:</span></span>  
  
-   <span data-ttu-id="de8fa-281">Dopo che il garbage collector ha scoperto che un oggetto è inaccessibile, a meno che l'oggetto è stato escluso dalle finalizzazione da una chiamata al <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-281">After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="de8fa-282">**In .NET Framework solo**, durante l'arresto di un dominio applicazione, a meno che non è esente dalla finalizzazione dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-282">**On .NET Framework only**, during shutdown of an application domain, unless the object is exempt from finalization.</span></span> <span data-ttu-id="de8fa-283">Durante l'arresto, sono finalizzati anche gli oggetti che sono ancora accessibili.</span><span class="sxs-lookup"><span data-stu-id="de8fa-283">During shutdown, even objects that are still accessible are finalized.</span></span>  
  
 <span data-ttu-id="de8fa-284"><xref:System.Object.Finalize%2A> viene chiamato automaticamente una sola volta in un'istanza specifica, a meno che l'oggetto è nuovamente registrato con un meccanismo, ad esempio <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> e il <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (metodo) non è stato chiamato in seguito.</span><span class="sxs-lookup"><span data-stu-id="de8fa-284"><xref:System.Object.Finalize%2A> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> and the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method has not been subsequently called.</span></span>  
  
 <span data-ttu-id="de8fa-285"><xref:System.Object.Finalize%2A> operazioni presentano le limitazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="de8fa-285"><xref:System.Object.Finalize%2A> operations have the following limitations:</span></span>  
  
-   <span data-ttu-id="de8fa-286">L'ora esatta in cui viene eseguito il finalizzatore non è definito.</span><span class="sxs-lookup"><span data-stu-id="de8fa-286">The exact time when the finalizer executes is undefined.</span></span> <span data-ttu-id="de8fa-287">Per garantire il rilascio deterministico delle risorse per le istanze della classe, implementare una `Close` metodo o fornire un <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementazione.</span><span class="sxs-lookup"><span data-stu-id="de8fa-287">To ensure deterministic release of resources for instances of your class, implement a `Close` method or provide a <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
-   <span data-ttu-id="de8fa-288">I finalizzatori di due oggetti non è garantiti per l'esecuzione in un ordine specifico, anche se un oggetto fa riferimento a altro.</span><span class="sxs-lookup"><span data-stu-id="de8fa-288">The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other.</span></span> <span data-ttu-id="de8fa-289">Vale a dire, se un oggetto ha un riferimento all'oggetto B ed entrambi disporre di finalizzatori, oggetto B potrebbe essere già stato finalizzato quando viene avviato il finalizzatore dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-289">That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.</span></span>  
  
-   <span data-ttu-id="de8fa-290">Il thread in cui viene eseguito il finalizzatore non è specificato.</span><span class="sxs-lookup"><span data-stu-id="de8fa-290">The thread on which the finalizer runs is unspecified.</span></span>  
  
 <span data-ttu-id="de8fa-291">Il <xref:System.Object.Finalize%2A> metodo potrebbero non essere eseguiti fino al completamento o potrebbero non essere eseguiti affatto eccezionali circostanze seguenti:</span><span class="sxs-lookup"><span data-stu-id="de8fa-291">The <xref:System.Object.Finalize%2A> method might not run to completion or might not run at all under the following exceptional circumstances:</span></span>  
  
-   <span data-ttu-id="de8fa-292">Se un altro finalizzatore si blocca per un periodo illimitato (consente di spostarsi in un ciclo infinito, prova a ottenere un blocco possa mai ottenere e così via).</span><span class="sxs-lookup"><span data-stu-id="de8fa-292">If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on).</span></span> <span data-ttu-id="de8fa-293">Poiché il runtime tenta di eseguire i finalizzatori fino al completamento, altri finalizzatori potrebbero non essere chiamate se un finalizzatore è bloccato per un periodo illimitato.</span><span class="sxs-lookup"><span data-stu-id="de8fa-293">Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</span></span>  
  
-   <span data-ttu-id="de8fa-294">Se il processo viene terminato senza consentirà il runtime di pulizia.</span><span class="sxs-lookup"><span data-stu-id="de8fa-294">If the process terminates without giving the runtime a chance to clean up.</span></span> <span data-ttu-id="de8fa-295">In questo caso, prima notifica di completamento del processo del runtime è una notifica DLL_PROCESS_DETACH.</span><span class="sxs-lookup"><span data-stu-id="de8fa-295">In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</span></span>  
  
 <span data-ttu-id="de8fa-296">Il runtime continua a completare gli oggetti durante l'arresto solo quando il numero di oggetti finalizzabili continua a diminuire.</span><span class="sxs-lookup"><span data-stu-id="de8fa-296">The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.</span></span>  
  
 <span data-ttu-id="de8fa-297">Se <xref:System.Object.Finalize%2A> o un override di <xref:System.Object.Finalize%2A> genera un'eccezione e il runtime non è ospitata da un'applicazione che sostituisce il criterio predefinito, il runtime termina il processo e non attivi `try` / `finally` blocchi o i finalizzatori vengono eseguiti.</span><span class="sxs-lookup"><span data-stu-id="de8fa-297">If <xref:System.Object.Finalize%2A> or an override of <xref:System.Object.Finalize%2A> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active `try`/`finally` blocks or finalizers are executed.</span></span> <span data-ttu-id="de8fa-298">Questo comportamento assicura l'integrità del processo se il finalizzatore non è possibile liberare o eliminare le risorse.</span><span class="sxs-lookup"><span data-stu-id="de8fa-298">This behavior ensures process integrity if the finalizer cannot free or destroy resources.</span></span>  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a><span data-ttu-id="de8fa-299">Override del metodo Finalize</span><span class="sxs-lookup"><span data-stu-id="de8fa-299">Overriding the Finalize method</span></span> 
 <span data-ttu-id="de8fa-300">È consigliabile eseguire l'override <xref:System.Object.Finalize%2A> per una classe che usa le risorse non gestite, ad esempio gli handle di file o le connessioni di database che devono essere liberate quando viene eliminato l'oggetto gestito in cui vengono utilizzati durante l'operazione di garbage collection.</span><span class="sxs-lookup"><span data-stu-id="de8fa-300">You should override <xref:System.Object.Finalize%2A> for a class that uses unmanaged resources, such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.</span></span> <span data-ttu-id="de8fa-301">È consigliabile non implementare un <xref:System.Object.Finalize%2A> metodo per gli oggetti gestiti, perché il garbage collector di liberare risorse gestite automaticamente.</span><span class="sxs-lookup"><span data-stu-id="de8fa-301">You shouldn't implement a <xref:System.Object.Finalize%2A> method for managed objects because the garbage collector releases managed resources automatically.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="de8fa-302">Se un <xref:System.Runtime.InteropServices.SafeHandle> sono disponibili oggetti che esegue il wrapping della risorsa non gestita, l'alternativa consigliata consiste nell'implementare il modello dispose con un handle sicuro e non eseguire l'override <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-302">If a <xref:System.Runtime.InteropServices.SafeHandle> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="de8fa-303">Per altre informazioni, vedere [alternativa SafeHandle The](#SafeHandle) sezione.</span><span class="sxs-lookup"><span data-stu-id="de8fa-303">For more information, see [The SafeHandle alternative](#SafeHandle) section.</span></span>  
  
 <span data-ttu-id="de8fa-304">Il <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodo non esegue alcuna operazione per impostazione predefinita, ma è consigliabile eseguire l'override <xref:System.Object.Finalize%2A> solo se necessario e solo per rilasciare le risorse non gestite.</span><span class="sxs-lookup"><span data-stu-id="de8fa-304">The <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method does nothing by default, but you should override <xref:System.Object.Finalize%2A> only if necessary, and only to release unmanaged resources.</span></span> <span data-ttu-id="de8fa-305">Il recupero della memoria tende a richiedere molto più tempo se viene eseguita un'operazione di finalizzazione, perché richiede almeno due operazioni di garbage collection.</span><span class="sxs-lookup"><span data-stu-id="de8fa-305">Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections.</span></span> <span data-ttu-id="de8fa-306">Inoltre, è necessario eseguire l'override di <xref:System.Object.Finalize%2A> solo i tipi di metodo per riferimento.</span><span class="sxs-lookup"><span data-stu-id="de8fa-306">In addition, you should override the <xref:System.Object.Finalize%2A> method for reference types only.</span></span> <span data-ttu-id="de8fa-307">Common language runtime completa solo i tipi di riferimento.</span><span class="sxs-lookup"><span data-stu-id="de8fa-307">The common language runtime only finalizes reference types.</span></span> <span data-ttu-id="de8fa-308">Ignora i finalizzatori sui tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="de8fa-308">It ignores finalizers on value types.</span></span>  

<span data-ttu-id="de8fa-309">L'ambito del <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodo `protected`.</span><span class="sxs-lookup"><span data-stu-id="de8fa-309">The scope of the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method is `protected`.</span></span> <span data-ttu-id="de8fa-310">Quando si esegue l'override del metodo nella classe, è necessario gestire tale limitazione dell'ambito.</span><span class="sxs-lookup"><span data-stu-id="de8fa-310">You should maintain this limited scope when you override the method in your class.</span></span> <span data-ttu-id="de8fa-311">Mantenendo una <xref:System.Object.Finalize%2A> metodo protetto, si impedisce agli utenti dell'applicazione dalla chiamata a un oggetto <xref:System.Object.Finalize%2A> direttamente al metodo.</span><span class="sxs-lookup"><span data-stu-id="de8fa-311">By keeping a <xref:System.Object.Finalize%2A> method protected, you prevent users of your application from calling an object's <xref:System.Object.Finalize%2A> method directly.</span></span>
  
 <span data-ttu-id="de8fa-312">Ogni implementazione di <xref:System.Object.Finalize%2A> in un tipo derivato deve chiamare l'implementazione del tipo di base di <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-312">Every implementation of <xref:System.Object.Finalize%2A> in a derived type must call its base type's implementation of <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="de8fa-313">Questo è l'unico caso in quale applicazione è possibile chiamare codice <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-313">This is the only case in which application code is allowed to call <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="de8fa-314">Un oggetto <xref:System.Object.Finalize%2A> metodo non deve chiamare un metodo su tutti gli oggetti diversi da quello della relativa classe di base.</span><span class="sxs-lookup"><span data-stu-id="de8fa-314">An object's <xref:System.Object.Finalize%2A> method shouldn't call a method on any objects other than that of its base class.</span></span> <span data-ttu-id="de8fa-315">Questo avviene perché altri oggetti di chiamata è stato possibile raccogliere allo stesso tempo dell'oggetto chiamante, come nel caso di arresto di un runtime di linguaggio comuni.</span><span class="sxs-lookup"><span data-stu-id="de8fa-315">This is because the other objects being called could be collected at the same time as the calling object, such as in the case of a common language runtime shutdown.</span></span> 
  
> [!NOTE]
>  <span data-ttu-id="de8fa-316">Il compilatore c# non consentono di eseguire l'override di <xref:System.Object.Finalize%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-316">The C# compiler does not allow you to override the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="de8fa-317">Al contrario, si fornisce un finalizzatore implementando un [distruttore](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) per la classe.</span><span class="sxs-lookup"><span data-stu-id="de8fa-317">Instead, you provide a finalizer by implementing a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) for your class.</span></span> <span data-ttu-id="de8fa-318">Un distruttore in c# chiama automaticamente il distruttore della relativa classe base.</span><span class="sxs-lookup"><span data-stu-id="de8fa-318">A C# destructor automatically calls the destructor of its base class.</span></span>  
>   
>  <span data-ttu-id="de8fa-319">Visual C++ fornisce anche una propria sintassi per l'implementazione di <xref:System.Object.Finalize%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-319">Visual C++ also provides its own syntax for implementing the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="de8fa-320">Per altre informazioni, vedere la sezione "Distruttori e finalizzatori" di [procedura: definire e usare classi e struct (C + + / CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span><span class="sxs-lookup"><span data-stu-id="de8fa-320">For more information, see the "Destructors and finalizers" section of [How to: Define and Consume Classes and Structs (C++/CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span></span>  
  
 <span data-ttu-id="de8fa-321">Poiché l'operazione di garbage collection è non deterministico, non si conosce con precisione quando il garbage collector esegue la finalizzazione.</span><span class="sxs-lookup"><span data-stu-id="de8fa-321">Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization.</span></span> <span data-ttu-id="de8fa-322">Per rilasciare le risorse immediatamente, è possibile anche scegliere di implementare il [modello dispose](~/docs/standard/design-guidelines/dispose-pattern.md) e il <xref:System.IDisposable> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="de8fa-322">To release resources immediately, you can also choose to implement the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) and the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="de8fa-323">Il <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementazione può essere chiamata dal consumer della classe per liberare le risorse non gestite ed è possibile usare il <xref:System.Object.Finalize%2A> metodo per liberare le risorse non gestite nel caso in cui il <xref:System.IDisposable.Dispose%2A> non viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="de8fa-323">The <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <xref:System.Object.Finalize%2A> method to free unmanaged resources in the event that the <xref:System.IDisposable.Dispose%2A> method is not called.</span></span>  
  
 <span data-ttu-id="de8fa-324"><xref:System.Object.Finalize%2A> può eseguire quasi tutte le operazioni, tra cui ripristinare un oggetto (che, rende l'oggetto accessibile anche in questo caso) dopo che è stato pulito durante l'operazione di garbage collection.</span><span class="sxs-lookup"><span data-stu-id="de8fa-324"><xref:System.Object.Finalize%2A> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection.</span></span> <span data-ttu-id="de8fa-325">Tuttavia, l'oggetto può essere ripristinato soltanto una sola volta. <xref:System.Object.Finalize%2A> non può essere chiamato su oggetti ripristinati durante l'operazione di garbage collection.</span><span class="sxs-lookup"><span data-stu-id="de8fa-325">However, the object can only be resurrected once; <xref:System.Object.Finalize%2A> cannot be called on resurrected objects during garbage collection.</span></span> <span data-ttu-id="de8fa-326">Non c'è un'azione che l'implementazione di <xref:System.Object.Finalize%2A> non dovrebbe mai aver: non deve mai generare un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="de8fa-326">There is one action that your implementation of <xref:System.Object.Finalize%2A> should never take: it should never throw an exception.</span></span> <span data-ttu-id="de8fa-327">Se tutte le eccezioni generate dai metodi chiamati dal <xref:System.Object.Finalize%2A> metodo viene gestita dal <xref:System.Object.Finalize%2A> metodo, il runtime si presuppone che il <xref:System.Object.Finalize%2A> metodo restituito e continua a chiamare il <xref:System.Object.Finalize%2A> metodi di altri oggetti.</span><span class="sxs-lookup"><span data-stu-id="de8fa-327">If any exceptions thrown by methods called from the <xref:System.Object.Finalize%2A> method are unhandled by the <xref:System.Object.Finalize%2A> method, the runtime assumes that the <xref:System.Object.Finalize%2A> method returned and continues to call the <xref:System.Object.Finalize%2A> methods of other objects.</span></span> 
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a><span data-ttu-id="de8fa-328">Alternativa SafeHandle</span><span class="sxs-lookup"><span data-stu-id="de8fa-328">The SafeHandle alternative</span></span>  
 <span data-ttu-id="de8fa-329">Creazione di finalizzatori affidabile è spesso difficile, poiché è possibile fare ipotesi sullo stato dell'applicazione e sistema di eccezioni non gestite, ad esempio <xref:System.OutOfMemoryException> e <xref:System.StackOverflowException> terminare il finalizzatore.</span><span class="sxs-lookup"><span data-stu-id="de8fa-329">Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <xref:System.OutOfMemoryException> and <xref:System.StackOverflowException> terminate the finalizer.</span></span> <span data-ttu-id="de8fa-330">Anziché implementare un finalizzatore per la classe per rilasciare le risorse non gestite, è possibile usare un oggetto derivato dal <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> classe per eseguire il wrapping di risorse non gestite e quindi implementare il modello dispose senza un finalizzatore.</span><span class="sxs-lookup"><span data-stu-id="de8fa-330">Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer.</span></span> <span data-ttu-id="de8fa-331">.NET Framework fornisce le seguenti classi di <xref:Microsoft.Win32?displayProperty=nameWithType> dello spazio dei nomi che derivano dalla <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="de8fa-331">The .NET Framework provides the following classes in the <xref:Microsoft.Win32?displayProperty=nameWithType> namespace that are derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span></span>  
  
-   <span data-ttu-id="de8fa-332"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> è una classe wrapper per un handle di file.</span><span class="sxs-lookup"><span data-stu-id="de8fa-332"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> is a wrapper class for a file handle.</span></span>  
  
-   <span data-ttu-id="de8fa-333"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> è una classe wrapper per gli handle di file mappati alla memoria.</span><span class="sxs-lookup"><span data-stu-id="de8fa-333"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> is a wrapper class for memory-mapped file handles.</span></span>  
  
-   <span data-ttu-id="de8fa-334"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> è una classe wrapper per un puntatore a un blocco di memoria non gestita.</span><span class="sxs-lookup"><span data-stu-id="de8fa-334"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> is a wrapper class for a pointer to a block of unmanaged memory.</span></span>  
  
-   <span data-ttu-id="de8fa-335"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, e <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> sono classi wrapper per gli handle del servizio di crittografia.</span><span class="sxs-lookup"><span data-stu-id="de8fa-335"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> are wrapper classes for cryptographic handles.</span></span>  
  
-   <span data-ttu-id="de8fa-336"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> è una classe wrapper per gli handle di pipe.</span><span class="sxs-lookup"><span data-stu-id="de8fa-336"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> is a wrapper class for pipe handles.</span></span>  
  
-   <span data-ttu-id="de8fa-337"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> è una classe wrapper per un handle a una chiave del Registro di sistema.</span><span class="sxs-lookup"><span data-stu-id="de8fa-337"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> is a wrapper class for a handle to a registry key.</span></span>  
  
-   <span data-ttu-id="de8fa-338"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> è una classe wrapper per un handle di attesa.</span><span class="sxs-lookup"><span data-stu-id="de8fa-338"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> is a wrapper class for a wait handle.</span></span>  
  
 <span data-ttu-id="de8fa-339">L'esempio seguente usa il [modello dispose](~/docs/standard/design-guidelines/dispose-pattern.md) con gli handle sicuri invece di sostituire la <xref:System.Object.Finalize%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-339">The following example uses the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) with safe handles instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="de8fa-340">Definisce un `FileAssociation` classe che incapsula informazioni del Registro di sistema sull'applicazione che gestisce i file con un'estensione di file specifico.</span><span class="sxs-lookup"><span data-stu-id="de8fa-340">It defines a `FileAssociation` class that wraps registry information about the application that handles files with a particular file extension.</span></span> <span data-ttu-id="de8fa-341">Gli handle del Registro di due sistema restituiti come `out` parametri da Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) chiamate di funzione vengono passate al <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> costruttore.</span><span class="sxs-lookup"><span data-stu-id="de8fa-341">The two registry handles returned as `out` parameters by Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) function calls are passed to the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructor.</span></span> <span data-ttu-id="de8fa-342">Il tipo del protetto `Dispose` chiama quindi il `SafeRegistryHandle.Dispose` per liberare questi due handle di metodo.</span><span class="sxs-lookup"><span data-stu-id="de8fa-342">The type's protected `Dispose` method then calls the `SafeRegistryHandle.Dispose` method  to free these two handles.</span></span>  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="de8fa-343">Nell'esempio seguente verifica che il <xref:System.Object.Finalize%2A> metodo viene chiamato quando un oggetto che esegue l'override <xref:System.Object.Finalize%2A> viene eliminato definitivamente.</span><span class="sxs-lookup"><span data-stu-id="de8fa-343">The following example verifies that the <xref:System.Object.Finalize%2A> method is called when an object that overrides <xref:System.Object.Finalize%2A> is destroyed.</span></span> <span data-ttu-id="de8fa-344">Si noti che, in un'applicazione di produzione di <xref:System.Object.Finalize%2A> potrebbe eseguire l'override di metodo per rilasciare le risorse non gestite contenute nell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-344">Note that, in a production application, the <xref:System.Object.Finalize%2A> method would be overridden to release unmanaged resources held by the object.</span></span> <span data-ttu-id="de8fa-345">Si noti inoltre che l'esempio c# fornisce un distruttore invece di sostituire la <xref:System.Object.Finalize%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-345">Also note that the C# example provides a destructor instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 <span data-ttu-id="de8fa-346">Per un altro esempio che esegue l'override di <xref:System.Object.Finalize%2A> metodo, vedere il <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-346">For an additional example that overrides the <xref:System.Object.Finalize%2A> method, see the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="de8fa-347">Funge da funzione hash predefinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-347">Serves as the default hash function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="de8fa-348">Codice hash per l'oggetto corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-348">A hash code for the current object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de8fa-349">Un codice hash è un valore numerico che viene usato per inserire e identificare un oggetto in una raccolta basata su hash, ad esempio la <xref:System.Collections.Generic.Dictionary%602> (classe), il <xref:System.Collections.Hashtable> classe o un tipo derivato dal <xref:System.Collections.DictionaryBase> classe.</span><span class="sxs-lookup"><span data-stu-id="de8fa-349">A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <xref:System.Collections.Generic.Dictionary%602> class, the <xref:System.Collections.Hashtable> class, or a type derived from the <xref:System.Collections.DictionaryBase> class.</span></span> <span data-ttu-id="de8fa-350">Il <xref:System.Object.GetHashCode%2A> metodo fornisce questo codice hash per gli algoritmi che richiedono rapidi controlli di uguaglianza di oggetti.</span><span class="sxs-lookup"><span data-stu-id="de8fa-350">The <xref:System.Object.GetHashCode%2A> method provides this hash code for algorithms that need quick checks of object equality.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="de8fa-351">Per informazioni sull'uso di codici hash nelle tabelle hash e alcuni algoritmi di codice cancelletto aggiuntivi, vedere la [funzione Hash](https://en.wikipedia.org/wiki/Hash_function) voce su Wikipedia.</span><span class="sxs-lookup"><span data-stu-id="de8fa-351">For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the [Hash Function](https://en.wikipedia.org/wiki/Hash_function) entry in Wikipedia.</span></span>  
  
 <span data-ttu-id="de8fa-352">Due oggetti che sono i codici hash restituito uguale che sono uguali.</span><span class="sxs-lookup"><span data-stu-id="de8fa-352">Two objects that are equal return hash codes that are equal.</span></span> <span data-ttu-id="de8fa-353">Tuttavia, non è vero il contrario: i codici hash uguali non implicano l'uguaglianza degli oggetti, poiché gli oggetti (diversi) diversi possono avere i codici hash identici.</span><span class="sxs-lookup"><span data-stu-id="de8fa-353">However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes.</span></span> <span data-ttu-id="de8fa-354">Inoltre, .NET Framework non garantisce l'implementazione predefinita del <xref:System.Object.GetHashCode%2A> (metodo) e il valore di questo metodo restituisce possono variare tra le versioni di .NET Framework e piattaforme, ad esempio le piattaforme a 32 e 64 bit.</span><span class="sxs-lookup"><span data-stu-id="de8fa-354">Furthermore, the .NET Framework does not guarantee the default implementation of the <xref:System.Object.GetHashCode%2A> method, and the value this method returns may differ between .NET Framework versions and platforms, such as 32-bit and 64-bit platforms.</span></span> <span data-ttu-id="de8fa-355">Per questi motivi, non utilizzare l'implementazione predefinita di questo metodo come un identificatore di oggetto univoco per scopi di hash.</span><span class="sxs-lookup"><span data-stu-id="de8fa-355">For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes.</span></span> <span data-ttu-id="de8fa-356">Due conseguenze seguono da questo oggetto:</span><span class="sxs-lookup"><span data-stu-id="de8fa-356">Two consequences follow from this:</span></span>  
  
-   <span data-ttu-id="de8fa-357">Non si deve presupporre che i codici hash uguali implicano l'uguaglianza degli oggetti.</span><span class="sxs-lookup"><span data-stu-id="de8fa-357">You should not assume that equal hash codes imply object equality.</span></span>  
  
-   <span data-ttu-id="de8fa-358">Devi mai rendere persistenti o usare un codice hash all'esterno del dominio applicazione in cui è stato creato, poiché lo stesso oggetto possono avere hash tra piattaforme, processi e domini dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="de8fa-358">You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="de8fa-359">Un codice hash è destinato da inserimento efficiente e di ricerca nelle raccolte basate su una tabella hash.</span><span class="sxs-lookup"><span data-stu-id="de8fa-359">A hash code is intended for efficient insertion and lookup in collections that are based on a hash table.</span></span> <span data-ttu-id="de8fa-360">Un codice hash non è un valore permanente.</span><span class="sxs-lookup"><span data-stu-id="de8fa-360">A hash code is not a permanent value.</span></span> <span data-ttu-id="de8fa-361">Per questo motivo:</span><span class="sxs-lookup"><span data-stu-id="de8fa-361">For this reason:</span></span>  
>   
> -   <span data-ttu-id="de8fa-362">Non serializzare i valori di codice hash o archiviarli nel database.</span><span class="sxs-lookup"><span data-stu-id="de8fa-362">Do not serialize hash code values or store them in databases.</span></span>  
> -   <span data-ttu-id="de8fa-363">Non utilizzare il codice hash come chiave per recuperare un oggetto da una raccolta con chiave.</span><span class="sxs-lookup"><span data-stu-id="de8fa-363">Do not use the hash code as the key to retrieve an object from a keyed collection.</span></span>  
> -   <span data-ttu-id="de8fa-364">Non inviare i codici hash tra processi o domini applicazione.</span><span class="sxs-lookup"><span data-stu-id="de8fa-364">Do not send hash codes across application domains or processes.</span></span> <span data-ttu-id="de8fa-365">In alcuni casi, i codici hash possano essere calcolati in base al dominio per ogni processo o per ogni applicazione.</span><span class="sxs-lookup"><span data-stu-id="de8fa-365">In some cases, hash codes may be computed on a per-process or per-application domain basis.</span></span>  
> -   <span data-ttu-id="de8fa-366">Non usare il codice hash anziché un valore restituito da una funzione hash di crittografia se è necessario un hash crittografico.</span><span class="sxs-lookup"><span data-stu-id="de8fa-366">Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</span></span> <span data-ttu-id="de8fa-367">Per gli hash di crittografia, usare una classe derivata dal <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> o <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> classe.</span><span class="sxs-lookup"><span data-stu-id="de8fa-367">For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> class.</span></span>  
> -   <span data-ttu-id="de8fa-368">Eseguire test per verificarne l'uguaglianza dei codici hash per determinare se due oggetti sono uguali.</span><span class="sxs-lookup"><span data-stu-id="de8fa-368">Do not test for equality of hash codes to determine whether two objects are equal.</span></span> <span data-ttu-id="de8fa-369">(Gli oggetti diversi possono avere i codici hash identici). Per testare l'uguaglianza, chiamare il <xref:System.Object.ReferenceEquals%2A> o <xref:System.Object.Equals%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-369">(Unequal objects can have identical hash codes.) To test for equality, call the <xref:System.Object.ReferenceEquals%2A> or <xref:System.Object.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="de8fa-370">Il <xref:System.Object.GetHashCode%2A> metodo può essere sovrascritto da un tipo derivato.</span><span class="sxs-lookup"><span data-stu-id="de8fa-370">The <xref:System.Object.GetHashCode%2A> method can be overridden by a derived type.</span></span> <span data-ttu-id="de8fa-371">Se <xref:System.Object.GetHashCode%2A> è non sottoposto a override, codici hash per tipi di riferimento vengono calcolati chiamando il <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> metodo della classe di base, che calcola un codice hash in base al riferimento di un oggetto; per altre informazioni, vedere <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-371">If <xref:System.Object.GetHashCode%2A> is not overridden, hash codes for reference types are computed by calling the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method of the base class, which computes a hash code based on an object's reference; for more information, see <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="de8fa-372">In altre parole, due oggetti per i quali la <xref:System.Object.ReferenceEquals%2A> restituzione del metodo `true` dispone di un codice hash identici.</span><span class="sxs-lookup"><span data-stu-id="de8fa-372">In other words, two objects for which the <xref:System.Object.ReferenceEquals%2A> method returns `true` have identical hash codes.</span></span> <span data-ttu-id="de8fa-373">Se i tipi di valore non esegue l'override <xref:System.Object.GetHashCode%2A>, il <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> metodo della classe di base usa la reflection per calcolare il codice hash basato sui valori dei campi del tipo.</span><span class="sxs-lookup"><span data-stu-id="de8fa-373">If value types do not override <xref:System.Object.GetHashCode%2A>, the <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> method of the base class uses reflection to compute the hash code based on the values of the type's fields.</span></span> <span data-ttu-id="de8fa-374">In altre parole, i tipi di valori i cui campi hanno valori uguali presentano codici hash uguali.</span><span class="sxs-lookup"><span data-stu-id="de8fa-374">In other words, value types whose fields have equal values have equal hash codes.</span></span> <span data-ttu-id="de8fa-375">Per altre informazioni sull'override <xref:System.Object.GetHashCode%2A>, vedere la sezione "Note per gli eredi".</span><span class="sxs-lookup"><span data-stu-id="de8fa-375">For more information about overriding <xref:System.Object.GetHashCode%2A>, see the "Notes to Inheritors" section.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="de8fa-376">Se esegue l'override di <xref:System.Object.GetHashCode%2A> metodo, è consigliabile anche eseguire l'override <xref:System.Object.Equals%2A>e viceversa.</span><span class="sxs-lookup"><span data-stu-id="de8fa-376">If you override the <xref:System.Object.GetHashCode%2A> method, you should also override <xref:System.Object.Equals%2A>, and vice versa.</span></span> <span data-ttu-id="de8fa-377">Se sottoposto a override <xref:System.Object.Equals%2A> restituzione del metodo `true` quando due oggetti sono stati testati per verificarne l'uguaglianza, sottoposto a override <xref:System.Object.GetHashCode%2A> metodo deve restituire lo stesso valore per i due oggetti.</span><span class="sxs-lookup"><span data-stu-id="de8fa-377">If your overridden <xref:System.Object.Equals%2A> method returns `true` when two objects are tested for equality, your overridden <xref:System.Object.GetHashCode%2A> method must return the same value for the two objects.</span></span>  
  
 <span data-ttu-id="de8fa-378">Se un oggetto che viene usato come chiave in una tabella hash non fornisce un'implementazione di utile <xref:System.Object.GetHashCode%2A>, è possibile specificare un provider di codice hash, fornendo un' <xref:System.Collections.IEqualityComparer> implementazione su uno degli overload del <xref:System.Collections.Hashtable> costruttore della classe.</span><span class="sxs-lookup"><span data-stu-id="de8fa-378">If an object that is used as a key in a hash table does not provide a useful implementation of <xref:System.Object.GetHashCode%2A>, you can specify a hash code provider by supplying an <xref:System.Collections.IEqualityComparer> implementation to one of the overloads of the <xref:System.Collections.Hashtable> class constructor.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="de8fa-379">Note per il [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="de8fa-379">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="de8fa-380">Quando si chiama il <xref:System.Object.GetHashCode%2A> metodo in una classe nel [!INCLUDE[wrt](~/includes/wrt-md.md)], fornisce il comportamento predefinito per le classi che non esegue l'override <xref:System.Object.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-380">When you call the <xref:System.Object.GetHashCode%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="de8fa-381">Ciò fa parte del supporto che .NET Framework fornisce per i [!INCLUDE[wrt](~/includes/wrt-md.md)] (vedere [app .NET Framework supportano per Windows Store e Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="de8fa-381">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="de8fa-382">Le classi di [!INCLUDE[wrt](~/includes/wrt-md.md)] non ereditano <xref:System.Object>e non implementa attualmente un <xref:System.Object.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-382">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and currently don't implement a <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="de8fa-383">Tuttavia, sembrano disporre <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, e <xref:System.Object.GetHashCode%2A> metodi quando usarli nel codice c# o Visual Basic e .NET Framework fornisce il comportamento predefinito per questi metodi.</span><span class="sxs-lookup"><span data-stu-id="de8fa-383">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="de8fa-384">le classi che vengono scritti in c# o Visual Basic possono eseguire l'override di <xref:System.Object.GetHashCode%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-384">classes that are written in C# or Visual Basic can override the <xref:System.Object.GetHashCode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="de8fa-385">Uno dei modi più semplici per calcolare un codice hash per un valore numerico con lo stesso o un intervallo più piccolo rispetto al <xref:System.Int32> tipo consiste nel restituire semplicemente quel valore.</span><span class="sxs-lookup"><span data-stu-id="de8fa-385">One of the simplest ways to compute a hash code for a numeric value that has the same or a smaller range than the <xref:System.Int32> type is to simply return that value.</span></span> <span data-ttu-id="de8fa-386">Nell'esempio seguente illustra questa implementazione per un `Number` struttura.</span><span class="sxs-lookup"><span data-stu-id="de8fa-386">The following example shows such an implementation for a `Number` structure.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 <span data-ttu-id="de8fa-387">Spesso, un tipo dispone di più campi di dati che possono far parte di generazione del codice hash.</span><span class="sxs-lookup"><span data-stu-id="de8fa-387">Frequently, a type has multiple data fields that can participate in generating the hash code.</span></span> <span data-ttu-id="de8fa-388">Per generare un codice hash è possibile combinare questi campi usando un `XOR (eXclusive OR)` operazione, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="de8fa-388">One way to generate a hash code is to combine these fields using an `XOR (eXclusive OR)` operation, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 <span data-ttu-id="de8fa-389">Nell'esempio precedente restituisce lo stesso codice hash per (n1, n2) e (n2, n1) e pertanto può generare più collisioni di informazioni cronologiche.</span><span class="sxs-lookup"><span data-stu-id="de8fa-389">The previous example returns the same hash code for (n1, n2) and (n2, n1), and so may generate more collisions than are desirable.</span></span> <span data-ttu-id="de8fa-390">Una serie di soluzioni è disponibile in modo che i codici hash in questi casi non sono identici.</span><span class="sxs-lookup"><span data-stu-id="de8fa-390">A number of solutions are available so that hash codes in these cases are not identical.</span></span> <span data-ttu-id="de8fa-391">Uno consiste nel restituire il codice hash di un `Tuple` oggetto che corrisponde all'ordine di ogni campo.</span><span class="sxs-lookup"><span data-stu-id="de8fa-391">One is to return the hash code of a `Tuple` object that reflects the order of each field.</span></span> <span data-ttu-id="de8fa-392">Nell'esempio seguente viene illustrata una possibile implementazione che usa il <xref:System.Tuple%602> classe.</span><span class="sxs-lookup"><span data-stu-id="de8fa-392">The following example shows a possible implementation that uses the <xref:System.Tuple%602> class.</span></span> <span data-ttu-id="de8fa-393">Tuttavia, tenere presente che l'overhead delle prestazioni di un'istanza di un `Tuple` oggetto può influire notevolmente sulle prestazioni complessive di un'applicazione che archivia un numero elevato di oggetti in tabelle hash.</span><span class="sxs-lookup"><span data-stu-id="de8fa-393">Note, though, that the performance overhead of instantiating a `Tuple` object may significantly impact the overall performance of an application that stores large numbers of objects in hash tables.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 <span data-ttu-id="de8fa-394">Una seconda soluzione alternativa prevede di spostamento a sinistra i codici hash dei campi successivi da due o più bit rilevanza dei codici hash singoli.</span><span class="sxs-lookup"><span data-stu-id="de8fa-394">A second alternative solution involves weighting the individual hash codes by left-shifting the hash codes of successive fields by two or more bits.</span></span> <span data-ttu-id="de8fa-395">In modo ottimale, invece di essere eliminato, i bit spostati oltre a 31 bit devono eseguire il wrapping intorno invece rimossi.</span><span class="sxs-lookup"><span data-stu-id="de8fa-395">Optimally, instead of being discarded, bits shifted beyond bit 31 should wrap around rather than be discarded.</span></span> <span data-ttu-id="de8fa-396">Poiché bit vengono ignorati per gli operatori di spostamento a sinistra in c# e Visual Basic, questo richiede la creazione di un metodo MAIUSC-e-wrap sinistro simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="de8fa-396">Since bits are discarded by the left-shift operators in both C# and Visual Basic, this requires creating a left shift-and-wrap method like the following:</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 <span data-ttu-id="de8fa-397">L'esempio seguente usa quindi questo metodo MAIUSC-e-wrap per calcolare il codice hash del `Point` struttura usata negli esempi precedenti.</span><span class="sxs-lookup"><span data-stu-id="de8fa-397">The following example then uses this shift-and-wrap method to compute the hash code of the `Point` structure used in the previous examples.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="de8fa-398">Una funzione hash viene utilizzata per generare rapidamente un numero (codice di hash) che corrisponde al valore di un oggetto.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-398">A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object.</span>
            </span>
            <span data-ttu-id="de8fa-399">Le funzioni hash vengono in genere specifiche per ogni tipo e, per l'univocità, è necessario usare almeno uno dei campi di istanza come input.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-399">Hash functions are usually specific to each type and, for uniqueness, must use at least one of the instance fields as input.</span>
            </span>
            <span data-ttu-id="de8fa-400">I codici hash non devono essere calcolati utilizzando i valori dei campi statici.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-400">Hash codes should not be computed by using the values of static fields.</span>
            </span>
            <span data-ttu-id="de8fa-401">Per le classi derivate da <see cref="T:System.Object" />, il <see langword="GetHashCode" /> metodo può delegare alla classe di base <see cref="M:System.Object.GetHashCode" /> implementazione solo se la classe derivata definisce l'uguaglianza per essere l'uguaglianza dei riferimenti.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-401">For classes derived from <see cref="T:System.Object" />, the <see langword="GetHashCode" /> method can delegate to the base class <see cref="M:System.Object.GetHashCode" /> implementation only if the derived class defines equality to be reference equality.</span>
            </span>
            <span data-ttu-id="de8fa-402">L'implementazione predefinita di <see cref="M:System.Object.GetHashCode" /> come riferimento tipi restituisce un codice hash che equivale a quello restituito dal <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> (metodo).</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-402">The default implementation of <see cref="M:System.Object.GetHashCode" /> for reference types returns a hash code that is equivalent to the one returned by the <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> method.</span>
            </span>
            <span data-ttu-id="de8fa-403">È possibile eseguire l'override <see cref="M:System.Object.GetHashCode" /> per i tipi di riferimento non modificabile.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-403">You can override <see cref="M:System.Object.GetHashCode" /> for immutable reference types.</span>
            </span>
            <span data-ttu-id="de8fa-404">In generale, per i tipi di riferimento modificabile, è necessario eseguire l'override <see cref="M:System.Object.GetHashCode" /> solo se:</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-404">In general, for mutable reference types, you should override <see cref="M:System.Object.GetHashCode" /> only if:</span>
            </span>
            <span data-ttu-id="de8fa-405">-È possibile calcolare il codice hash dai campi che non sono modificabili; o</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-405">-   You can compute the hash code from fields that are not mutable; or</span>
            </span>
            <span data-ttu-id="de8fa-406">-È possibile garantire che il codice hash di un oggetto modificabile non cambia mentre l'oggetto è contenuto in una raccolta che si basa sul codice hash.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-406">-   You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.</span>
            </span>
            <span data-ttu-id="de8fa-407">In caso contrario, si potrebbe pensare che l'oggetto modificabile viene perso nella tabella hash.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-407">Otherwise, you might think that the mutable object is lost in the hash table.</span>
            </span>
            <span data-ttu-id="de8fa-408">Se si sceglie di eseguire l'override <see cref="M:System.Object.GetHashCode" /> per un tipo di riferimento modificabile, la documentazione di inoltre deve essere chiaro che gli utenti del tipo non deve essere modificato i valori di oggetto anche se l'oggetto viene archiviato in una tabella hash.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-408">If you do choose to override <see cref="M:System.Object.GetHashCode" /> for a mutable reference type, your documentation should make it clear that users of your type should not modify object values while the object is stored in a hash table.</span>
            </span>
            <span data-ttu-id="de8fa-409">Per i tipi di valore, <see cref="M:System.ValueType.GetHashCode" /> fornisce un'implementazione di codice hash predefinito che usa la reflection.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-409">For value types, <see cref="M:System.ValueType.GetHashCode" /> provides a default hash code implementation that uses reflection.</span>
            </span>
            <span data-ttu-id="de8fa-410">È consigliabile eseguire l'override, per ottenere prestazioni migliori.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-410">You should consider overriding it for better performance.</span>
            </span>
            <block subset="none" type="note">
              <para>
                <span data-ttu-id="de8fa-411">Per altre informazioni ed esempi che consentono di calcolare i codici hash in svariati modi, vedere la sezione esempi.</span>
                <span class="sxs-lookup">
                  <span data-stu-id="de8fa-411">For more information and examples that compute hash codes in a variety of ways, see the Examples section.</span>
                </span>
              </para>
            </block>
            <span data-ttu-id="de8fa-412">Una funzione hash deve avere le proprietà seguenti:</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-412">A hash function must have the following properties:</span>
            </span>
            <span data-ttu-id="de8fa-413">-Se due oggetti vengono considerati uguali, la <see cref="M:System.Object.GetHashCode" /> metodo per ogni oggetto deve restituire lo stesso valore.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-413">-   If two objects compare as equal, the <see cref="M:System.Object.GetHashCode" /> method for each object must return the same value.</span>
            </span>
            <span data-ttu-id="de8fa-414">Tuttavia, se due oggetti non vengono considerati uguali, la <see cref="M:System.Object.GetHashCode" /> metodi per i due oggetti non sono necessario restituire valori diversi.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-414">However, if two objects do not compare as equal, the <see cref="M:System.Object.GetHashCode" /> methods for the two objects do not have to return different values.</span>
            </span>
            <span data-ttu-id="de8fa-415">-il <see cref="M:System.Object.GetHashCode" /> metodo per un oggetto deve restituire in modo coerente lo stesso codice hash fino a quando non viene modificato per lo stato dell'oggetto che determina il valore dell'oggetto di ritorno [System.Object.Equals](xref:System.Object.Equals*) (metodo).</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-415">-   The <see cref="M:System.Object.GetHashCode" /> method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's [System.Object.Equals](xref:System.Object.Equals*) method.</span>
            </span>
            <span data-ttu-id="de8fa-416">Si noti che questo vale solo per l'esecuzione corrente di un'applicazione e che può essere restituito un codice hash diverso se si esegue nuovamente l'applicazione.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-416">Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.</span>
            </span>
            <span data-ttu-id="de8fa-417">-Per ottenere prestazioni ottimali, una funzione hash deve generare una distribuzione uniforme per tutti gli input, tra cui input molto in cluster.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-417">-   For the best performance, a hash function should generate an even distribution for all input, including input that is heavily clustered.</span>
            </span>
            <span data-ttu-id="de8fa-418">Un'implicazione è che piccole modifiche per lo stato dell'oggetto deve essere restituito apportare modifiche estese per il codice hash risultante per ottimizzare le prestazioni di tabella hash.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-418">An implication is that small modifications to object state should result in large modifications to the resulting hash code for best hash table performance.</span>
            </span>
            <span data-ttu-id="de8fa-419">-Le funzioni hash devono essere conveniente per il calcolo.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-419">-   Hash functions should be inexpensive to compute.</span>
            </span>
            <span data-ttu-id="de8fa-420">-La <see cref="M:System.Object.GetHashCode" /> (metodo) non deve generare eccezioni.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-420">-   The <see cref="M:System.Object.GetHashCode" /> method should not throw exceptions.</span>
            </span>
            <span data-ttu-id="de8fa-421">Ad esempio, l'implementazione del <see cref="M:System.String.GetHashCode" /> metodo fornito dal <see cref="T:System.String" /> classe restituisce i codici hash identici per i valori di stringa identica.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-421">For example, the implementation of the <see cref="M:System.String.GetHashCode" /> method provided by the <see cref="T:System.String" /> class returns identical hash codes for identical string values.</span>
            </span>
            <span data-ttu-id="de8fa-422">Pertanto, due <see cref="T:System.String" /> oggetti restituisce lo stesso codice hash se rappresentino lo stesso valore di stringa.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-422">Therefore, two <see cref="T:System.String" /> objects return the same hash code if they represent the same string value.</span>
            </span>
            <span data-ttu-id="de8fa-423">Inoltre, il metodo Usa tutti i caratteri nella stringa per generare l'output in modo relativamente casuale distribuita, anche quando l'input viene inserito nel cluster in determinati intervalli (ad esempio, molti utenti potrebbero avere le stringhe che contengono solo gli inferiore 128 caratteri ASCII, anche se un stringa può contenere i caratteri Unicode 65.535).</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-423">Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).</span>
            </span>
            <span data-ttu-id="de8fa-424">Fornendo una funzione hash valida in una classe può influire in modo significativo le prestazioni dell'aggiunta di tali oggetti in una tabella hash.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-424">Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table.</span>
            </span>
            <span data-ttu-id="de8fa-425">In una tabella hash con chiavi che forniscono l'implementazione di una funzione hash, la ricerca di un elemento richiede un tempo costante (ad esempio, un'operazione o (1)).</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-425">In a hash table with keys that provide a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation).</span>
            </span>
            <span data-ttu-id="de8fa-426">In una tabella hash con un'implementazione di una riduzione di una funzione hash, le prestazioni di una ricerca dipendono dal numero di elementi nella tabella hash (ad esempio, un'operazione O (`n`) operazione, in cui `n` è il numero di elementi nella tabella hash).</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-426">In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(`n`) operation, where `n` is the number of items in the hash table).</span>
            </span>
            <span data-ttu-id="de8fa-427">Un utente malintenzionato è possibile immettere i dati che aumenta il numero di conflitti, che può ridurre significativamente le prestazioni delle applicazioni che dipendono da tabelle hash, le condizioni seguenti:</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-427">A malicious user can input data that increases the number of collisions, which can significantly degrade the performance of applications that depend on hash tables, under the following conditions:</span>
            </span>
            <span data-ttu-id="de8fa-428">-Quando le funzioni hash producono frequenti conflitti.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-428">-   When hash functions produce frequent collisions.</span>
            </span>
            <span data-ttu-id="de8fa-429">-Quando una gran parte degli oggetti in una tabella hash producono i codici hash che sono uguali o approssimativamente uguale a tra loro.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-429">-   When a large proportion of objects in a hash table produce hash codes that are equal or approximately equal to one another.</span>
            </span>
            <span data-ttu-id="de8fa-430">-Quando gli utenti di input i dati da cui viene calcolato il codice hash.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-430">-   When users input the data from which the hash code is computed.</span>
            </span>
            <span data-ttu-id="de8fa-431">Le classi derivate che esegue l'override <see cref="M:System.Object.GetHashCode" /> inoltre è necessario eseguire l'override <see cref="M:System.Object.Equals(System.Object)" /> per garantire che due oggetti uguali hanno lo stesso codice hash; in caso contrario, il <see cref="T:System.Collections.Hashtable" /> tipo potrebbe non funzionare correttamente.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-431">Derived classes that override <see cref="M:System.Object.GetHashCode" /> must also override <see cref="M:System.Object.Equals(System.Object)" /> to guarantee that two objects considered equal have the same hash code; otherwise, the <see cref="T:System.Collections.Hashtable" /> type might not work correctly.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="de8fa-432">Ottiene l'oggetto <see cref="T:System.Type" /> dell'istanza corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-432">Gets the <see cref="T:System.Type" /> of the current instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="de8fa-433">Tipo esatto di runtime dell'istanza corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-433">The exact runtime type of the current instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de8fa-434">In quanto <xref:System.Object?displayProperty=nameWithType> è la classe base per tutti i tipi nel sistema di tipi .NET Framework, il <xref:System.Object.GetType%2A> metodo può essere utilizzato per restituire <xref:System.Type> gli oggetti che rappresentano tutti i tipi di .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="de8fa-434">Because <xref:System.Object?displayProperty=nameWithType> is the base class for all types in the .NET Framework type system, the <xref:System.Object.GetType%2A> method can be used to return <xref:System.Type> objects that represent all .NET Framework types.</span></span> <span data-ttu-id="de8fa-435">.NET Framework riconosce le cinque categorie dei tipi seguenti:</span><span class="sxs-lookup"><span data-stu-id="de8fa-435">The .NET Framework recognizes the following five categories of types:</span></span>  
  
-   <span data-ttu-id="de8fa-436">Le classi che derivano da <xref:System.Object?displayProperty=nameWithType>,</span><span class="sxs-lookup"><span data-stu-id="de8fa-436">Classes, which are derived from <xref:System.Object?displayProperty=nameWithType>,</span></span>  
  
-   <span data-ttu-id="de8fa-437">Valore di tipi che derivano da <xref:System.ValueType?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-437">Value types, which are derived from <xref:System.ValueType?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="de8fa-438">Interfacce che derivano da <xref:System.Object?displayProperty=nameWithType> a partire da .NET Framework 2.0.</span><span class="sxs-lookup"><span data-stu-id="de8fa-438">Interfaces, which are derived from <xref:System.Object?displayProperty=nameWithType> starting with the .NET Framework 2.0.</span></span>  
  
-   <span data-ttu-id="de8fa-439">Enumerazioni, che derivano da <xref:System.Enum?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-439">Enumerations, which are derived from <xref:System.Enum?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="de8fa-440">I delegati, che derivano da <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-440">Delegates, which are derived from <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="de8fa-441">Per due oggetti `x` e `y` che hanno tipi di runtime identici `Object.ReferenceEquals(x.GetType(),y.GetType())` restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="de8fa-441">For two objects `x` and `y` that have identical runtime types, `Object.ReferenceEquals(x.GetType(),y.GetType())` returns `true`.</span></span> <span data-ttu-id="de8fa-442">L'esempio seguente usa il <xref:System.Object.GetType%2A> metodo con il <xref:System.Object.ReferenceEquals%2A> metodo per determinare se un valore numerico è lo stesso tipo due altri valori numerici.</span><span class="sxs-lookup"><span data-stu-id="de8fa-442">The following example uses the <xref:System.Object.GetType%2A> method with the <xref:System.Object.ReferenceEquals%2A> method to determine whether one numeric value is the same type as two other numeric values.</span></span>  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  <span data-ttu-id="de8fa-443">Per determinare se un oggetto è un tipo specifico, è possibile usare la parola chiave confronto type del linguaggio o costruire.</span><span class="sxs-lookup"><span data-stu-id="de8fa-443">To determine whether an object is a specific type, you can use your language's type comparison keyword or construct.</span></span> <span data-ttu-id="de8fa-444">Ad esempio, è possibile usare la `TypeOf…Is` costruire in Visual Basic o `is` parola chiave nel linguaggio c#.</span><span class="sxs-lookup"><span data-stu-id="de8fa-444">For example, you can use the `TypeOf…Is` construct in Visual Basic or the `is` keyword in C#.</span></span>  
  
 <span data-ttu-id="de8fa-445">Il <xref:System.Object.GetType%2A> metodo viene ereditato da tutti i tipi che derivano da <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-445">The <xref:System.Object.GetType%2A> method is inherited by all types that derive from <xref:System.Object>.</span></span> <span data-ttu-id="de8fa-446">Ciò significa che, oltre a usare parole chiave di confronto del proprio linguaggio, è possibile usare il <xref:System.Object.GetType%2A> metodo per determinare il tipo di un oggetto specifico, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="de8fa-446">This means that, in addition to using your own language's comparison keyword, you can use the <xref:System.Object.GetType%2A> method to determine the type of a particular object, as the following example shows.</span></span>  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <span data-ttu-id="de8fa-447">Il <xref:System.Type> oggetto espone i metadati associati alla classe dell'oggetto corrente <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-447">The <xref:System.Type> object exposes the metadata associated with the class of the current <xref:System.Object>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="de8fa-448">Esempio di codice seguente viene dimostrato che <xref:System.Object.GetType%2A> restituisce il tipo di runtime dell'istanza corrente.</span><span class="sxs-lookup"><span data-stu-id="de8fa-448">The following code example demonstrates that <xref:System.Object.GetType%2A> returns the runtime type of the current instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="de8fa-449">Crea una copia superficiale dell'oggetto <see cref="T:System.Object" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-449">Creates a shallow copy of the current <see cref="T:System.Object" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="de8fa-450">Copia superficiale dell'oggetto <see cref="T:System.Object" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-450">A shallow copy of the current <see cref="T:System.Object" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de8fa-451">Il <xref:System.Object.MemberwiseClone%2A> metodo crea una copia superficiale, creando un nuovo oggetto e quindi copiare i campi non statici dell'oggetto corrente per il nuovo oggetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-451">The <xref:System.Object.MemberwiseClone%2A> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object.</span></span> <span data-ttu-id="de8fa-452">Se un campo è un tipo di valore, viene eseguita una copia bit per bit del campo.</span><span class="sxs-lookup"><span data-stu-id="de8fa-452">If a field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="de8fa-453">Se un campo è un tipo riferimento, il riferimento è copiato ma l'oggetto di cui viene fatto riferimento non; Pertanto, l'oggetto originale e il suo clone fare riferimento allo stesso oggetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-453">If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</span></span>  
  
 <span data-ttu-id="de8fa-454">Si consideri ad esempio un oggetto denominato X che fa riferimento a oggetti A e B, a sua volta, oggetto references C. Una copia superficiale di X Crea nuovo oggetto X2 che fa riferimento anche a oggetti A e B. Al contrario, una copia completa di X crea un nuovo oggetto X2 che fa riferimento a nuovi oggetti A2 e B2, che sono copie di un e B2 B., a sua volta, fa riferimento il nuovo oggetto C2, ovvero una copia di C. Nell'esempio viene illustrata la differenza tra un shallow e un'operazione di copia completa.</span><span class="sxs-lookup"><span data-stu-id="de8fa-454">For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.</span></span>  
  
 <span data-ttu-id="de8fa-455">Esistono diversi modi per implementare un'operazione di copia completa, se l'operazione di copia superficiale eseguita dal <xref:System.Object.MemberwiseClone%2A> metodo non soddisfa le proprie esigenze.</span><span class="sxs-lookup"><span data-stu-id="de8fa-455">There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <xref:System.Object.MemberwiseClone%2A> method does not meet your needs.</span></span> <span data-ttu-id="de8fa-456">tra cui:</span><span class="sxs-lookup"><span data-stu-id="de8fa-456">These include the following:</span></span>  
  
-   <span data-ttu-id="de8fa-457">Chiamare un costruttore della classe dell'oggetto da copiare per creare un secondo oggetto con valori di proprietà forniti dal primo oggetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-457">Call a class constructor of the object to be copied to create a second object with property values taken from the first object.</span></span> <span data-ttu-id="de8fa-458">Ciò presuppone che i valori di un oggetto vengono definiti interamente dal costruttore di classe.</span><span class="sxs-lookup"><span data-stu-id="de8fa-458">This assumes that the values of an object are entirely defined by its class constructor.</span></span>  
  
-   <span data-ttu-id="de8fa-459">Chiamare il <xref:System.Object.MemberwiseClone%2A> metodo per creare una copia superficiale di un oggetto e quindi assegnare nuovi oggetti i cui valori sono lo stesso dell'oggetto originale a qualsiasi proprietà o campi i cui valori sono i tipi di riferimento.</span><span class="sxs-lookup"><span data-stu-id="de8fa-459">Call the <xref:System.Object.MemberwiseClone%2A> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types.</span></span> <span data-ttu-id="de8fa-460">Il `DeepCopy` metodo nell'esempio viene illustrato questo approccio.</span><span class="sxs-lookup"><span data-stu-id="de8fa-460">The `DeepCopy` method in the example illustrates this approach.</span></span>  
  
-   <span data-ttu-id="de8fa-461">Serializzare l'oggetto verrà approfondita copiato e quindi ripristinare i dati serializzati in una variabile di un oggetto diverso.</span><span class="sxs-lookup"><span data-stu-id="de8fa-461">Serialize the object to be deep copied, and then restore the serialized data to a different object variable.</span></span>  
  
-   <span data-ttu-id="de8fa-462">Usare la reflection con la ricorsione per eseguire l'operazione di copia completa.</span><span class="sxs-lookup"><span data-stu-id="de8fa-462">Use reflection with recursion to perform the deep copy operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="de8fa-463">Nell'esempio seguente viene illustrato il <xref:System.Object.MemberwiseClone%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-463">The following example illustrates the <xref:System.Object.MemberwiseClone%2A> method.</span></span> <span data-ttu-id="de8fa-464">Definisce un `ShallowCopy` metodo che chiama il <xref:System.Object.MemberwiseClone%2A> metodo per eseguire un'operazione di copia dei riferimenti in un `Person` oggetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-464">It defines a `ShallowCopy` method that calls the <xref:System.Object.MemberwiseClone%2A> method to perform a shallow copy operation on a `Person` object.</span></span> <span data-ttu-id="de8fa-465">Definisce anche un `DeepCopy` metodo che esegue un'operazione di copia completa su un `Person` oggetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-465">It also defines a `DeepCopy` method that performs a deep copy operation on a `Person` object.</span></span>  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 <span data-ttu-id="de8fa-466">In questo esempio, il `Person.IdInfo` proprietà restituisce un `IdInfo` oggetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-466">In this example, the `Person.IdInfo` property returns an `IdInfo` object.</span></span> <span data-ttu-id="de8fa-467">Come output illustrato nell'esempio, quando un `Person` oggetto viene clonato chiamando il <xref:System.Object.MemberwiseClone%2A> metodo, clonata `Person` oggetto è una copia indipendente dell'oggetto originale, ad eccezione del fatto che essi condividono lo stesso `Person.IdInfo` il riferimento all'oggetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-467">As the output from the example shows, when a `Person` object is cloned by calling the <xref:System.Object.MemberwiseClone%2A> method, the cloned `Person` object is an independent copy of the original object, except that they share the same `Person.IdInfo` object reference.</span></span> <span data-ttu-id="de8fa-468">Di conseguenza, la modifica del clone `Person.IdInfo` proprietà dell'oggetto originale viene modificata `Person.IdInfo` proprietà.</span><span class="sxs-lookup"><span data-stu-id="de8fa-468">As a result, modifying the clone's `Person.IdInfo` property changes the original object's `Person.IdInfo` property.</span></span> <span data-ttu-id="de8fa-469">D'altra parte, quando viene eseguita un'operazione di copia completa, clonata `Person` dell'oggetto, tra cui relativo `Person.IdInfo` proprietà, può essere modificata senza influire sull'oggetto originale.</span><span class="sxs-lookup"><span data-stu-id="de8fa-469">On the other hand, when a deep copy operation is performed, the cloned `Person` object, including its `Person.IdInfo` property, can be modified without affecting the original object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">
          <span data-ttu-id="de8fa-470">Primo oggetto da confrontare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-470">The first object to compare.</span>
          </span>
        </param>
        <param name="objB">
          <span data-ttu-id="de8fa-471">Secondo oggetto da confrontare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-471">The second object  to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="de8fa-472">Determina se le istanze di <see cref="T:System.Object" /> specificate rappresentano la stessa istanza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-472">Determines whether the specified <see cref="T:System.Object" /> instances are the same instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="de8fa-473">
            <see langword="true" /> se <paramref name="objA" /> è la stessa istanza di <paramref name="objB" /> oppure se entrambe sono **null**; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-473">
              <see langword="true" /> if <paramref name="objA" /> is the same instance as <paramref name="objB" /> or if both are **null**; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de8fa-474">A differenza di <xref:System.Object.Equals%2A> metodo e l'operatore di uguaglianza, il <xref:System.Object.ReferenceEquals%2A> non è possibile eseguire l'override di metodo.</span><span class="sxs-lookup"><span data-stu-id="de8fa-474">Unlike the <xref:System.Object.Equals%2A> method and the equality operator, the <xref:System.Object.ReferenceEquals%2A> method cannot be overridden.</span></span> <span data-ttu-id="de8fa-475">Per questo motivo, se si vuole testare due riferimenti per verificarne l'uguaglianza di oggetti e non si conosce l'implementazione del `Equals` metodo, è possibile chiamare il <xref:System.Object.ReferenceEquals%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-475">Because of this, if you want to test two object references for equality and you are unsure about the implementation of the `Equals` method, you can call the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 <span data-ttu-id="de8fa-476">Tuttavia, il valore restituito del <xref:System.Object.ReferenceEquals%2A> metodo può sembrare anomale in questi due scenari:</span><span class="sxs-lookup"><span data-stu-id="de8fa-476">However, the return value of the <xref:System.Object.ReferenceEquals%2A> method may appear to be anomalous in these two scenarios:</span></span>  
  
-   <span data-ttu-id="de8fa-477">Quando si confrontano i tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="de8fa-477">When comparing value types.</span></span> <span data-ttu-id="de8fa-478">Se `objA` e `objB` sono tipi valore, essi vengono sottoposti a boxing prima che vengano passati per il <xref:System.Object.ReferenceEquals%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-478">If `objA` and `objB` are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="de8fa-479">Ciò significa che se entrambe `objA` e `objB` rappresentino la stessa istanza di un tipo di valore, il <xref:System.Object.ReferenceEquals%2A> metodo restituisce comunque `false`, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="de8fa-479">This means that if both `objA` and `objB` represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns `false`, as the following example shows.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     <span data-ttu-id="de8fa-480">Per informazioni sui tipi di valore di conversione boxing, vedere [conversioni Boxing e Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span><span class="sxs-lookup"><span data-stu-id="de8fa-480">For information on boxing value types, see [Boxing and Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span></span>  
  
-   <span data-ttu-id="de8fa-481">Quando si confrontano le stringhe.</span><span class="sxs-lookup"><span data-stu-id="de8fa-481">When comparing strings.</span></span> <span data-ttu-id="de8fa-482">Se `objA` e `objB` sono stringhe, il <xref:System.Object.ReferenceEquals%2A> restituzione del metodo `true` se la stringa è inserita.</span><span class="sxs-lookup"><span data-stu-id="de8fa-482">If `objA` and `objB` are strings, the <xref:System.Object.ReferenceEquals%2A> method returns `true` if the string is interned.</span></span> <span data-ttu-id="de8fa-483">Non esegue un test di uguaglianza di valori.</span><span class="sxs-lookup"><span data-stu-id="de8fa-483">It does not perform a test for value equality.</span></span>  <span data-ttu-id="de8fa-484">Nell'esempio riportato di seguito `s1` e `s2` sono uguali perché sono due istanze di una singola stringa centralizzata.</span><span class="sxs-lookup"><span data-stu-id="de8fa-484">In the following example, `s1` and `s2` are equal because they are two instances of a single interned string.</span></span> <span data-ttu-id="de8fa-485">Tuttavia `s3` e `s4` non sono uguali, perché anche se hanno valori di stringa identica, tale stringa non è stata inserita.</span><span class="sxs-lookup"><span data-stu-id="de8fa-485">However, `s3` and `s4` are not equal, because although they are have identical string values, that string is not interned.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     <span data-ttu-id="de8fa-486">Per altre informazioni sull'inserimento di stringhe, vedere <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-486">For more information about string interning, see <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="de8fa-487">L'esempio seguente usa <xref:System.Object.ReferenceEquals%2A> per determinare se due oggetti rappresentano la stessa istanza.</span><span class="sxs-lookup"><span data-stu-id="de8fa-487">The following example uses <xref:System.Object.ReferenceEquals%2A> to determine if two objects are the same instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="de8fa-488">Restituisce una stringa che rappresenta l'oggetto corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-488">Returns a string that represents the current object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="de8fa-489">Stringa che rappresenta l'oggetto corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-489">A string that represents the current object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="de8fa-490"><xref:System.Object.ToString%2A?displayProperty=nameWithType> è la versione principale metodo di formattazione in .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="de8fa-490"><xref:System.Object.ToString%2A?displayProperty=nameWithType> is the major formatting method in the .NET Framework.</span></span> <span data-ttu-id="de8fa-491">Converte un oggetto alla relativa rappresentazione di stringa, in modo che sia adatto per la visualizzazione.</span><span class="sxs-lookup"><span data-stu-id="de8fa-491">It converts an object to its string representation so that it is suitable for display.</span></span> <span data-ttu-id="de8fa-492">(Per informazioni sulla formattazione di supporto in .NET Framework, vedere [formattazione di tipi](~/docs/standard/base-types/formatting-types.md).) Le implementazioni predefinite del <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo restituisce il nome completo del tipo dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-492">(For information about formatting support in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).) Default implementations of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method return the fully qualified name of the object's type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="de8fa-493">È stato raggiunto questa pagina, seguendo il collegamento dall'elenco dei membri di un altro tipo.</span><span class="sxs-lookup"><span data-stu-id="de8fa-493">You may have reached this page by following the link from the member list of another type.</span></span> <span data-ttu-id="de8fa-494">Infatti, non l'override di tale tipo <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-494">That is because that type does not override <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="de8fa-495">Al contrario, eredita la funzionalità del <xref:System.Object.ToString%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-495">Instead, it inherits the functionality of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="de8fa-496">Tipi di eseguire l'override di frequente il <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo per fornire una rappresentazione di stringa più adatta di un determinato tipo.</span><span class="sxs-lookup"><span data-stu-id="de8fa-496">Types frequently override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide a more suitable string representation of a particular type.</span></span> <span data-ttu-id="de8fa-497">Tipi spesso anche eseguire l'overload di <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo per fornire supporto per le stringhe di formato o formattazione dipendente dalle impostazioni cultura.</span><span class="sxs-lookup"><span data-stu-id="de8fa-497">Types also frequently overload the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide support for format strings or culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="de8fa-498">Contenuto della sezione:</span><span class="sxs-lookup"><span data-stu-id="de8fa-498">In this section:</span></span>  
  
 <span data-ttu-id="de8fa-499">[Il metodo ToString () predefinita](#Default) </span><span class="sxs-lookup"><span data-stu-id="de8fa-499">[The default Object.ToString() method](#Default) </span></span>  
 <span data-ttu-id="de8fa-500">[Override del metodo ToString)](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="de8fa-500">[Overriding the Object.ToString() method](#Overriding) </span></span>  
 <span data-ttu-id="de8fa-501">[L'overload del metodo ToString](#Overloading) </span><span class="sxs-lookup"><span data-stu-id="de8fa-501">[Overloading the ToString method](#Overloading) </span></span>  
 <span data-ttu-id="de8fa-502">[Estendere il metodo ToString](#Extending) </span><span class="sxs-lookup"><span data-stu-id="de8fa-502">[Extending the Object.ToString method](#Extending) </span></span>  
 [<span data-ttu-id="de8fa-503">Note per il Runtime di Windows</span><span class="sxs-lookup"><span data-stu-id="de8fa-503">Notes for the Windows Runtime</span></span>](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a><span data-ttu-id="de8fa-504">Il metodo ToString () predefinita</span><span class="sxs-lookup"><span data-stu-id="de8fa-504">The default Object.ToString() method</span></span>  
 <span data-ttu-id="de8fa-505">L'implementazione predefinita del <xref:System.Object.ToString%2A> metodo viene restituito il nome completo del tipo del <xref:System.Object>, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="de8fa-505">The default implementation of the <xref:System.Object.ToString%2A> method returns the fully qualified name of the type of the <xref:System.Object>, as the following example shows.</span></span>  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 <span data-ttu-id="de8fa-506">In quanto <xref:System.Object> è la classe di base di tutti i tipi di riferimento in .NET Framework, questo comportamento viene ereditato da tipi di riferimento che non eseguono l'override di <xref:System.Object.ToString%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-506">Because <xref:System.Object> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <xref:System.Object.ToString%2A> method.</span></span> <span data-ttu-id="de8fa-507">Questa condizione è illustrata nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="de8fa-507">The following example illustrates this.</span></span> <span data-ttu-id="de8fa-508">Definisce una classe denominata `Object1` che accetta l'implementazione predefinita di tutte le <xref:System.Object> membri.</span><span class="sxs-lookup"><span data-stu-id="de8fa-508">It defines a class named `Object1` that accepts the default implementation of all <xref:System.Object> members.</span></span> <span data-ttu-id="de8fa-509">Relativo <xref:System.Object.ToString%2A> metodo restituisce il nome di tipo completo dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-509">Its <xref:System.Object.ToString%2A> method returns the object's fully qualified type name.</span></span>  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a><span data-ttu-id="de8fa-510">Override del metodo ToString)</span><span class="sxs-lookup"><span data-stu-id="de8fa-510">Overriding the Object.ToString() method</span></span>  
 <span data-ttu-id="de8fa-511">Tipi comunemente eseguire l'override di <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo per restituire una stringa che rappresenta l'istanza dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-511">Types commonly override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return a string that represents the object instance.</span></span> <span data-ttu-id="de8fa-512">Ad esempio, i tipi di base, ad esempio <xref:System.Char>, <xref:System.Int32>, e <xref:System.String> fornire <xref:System.Object.ToString%2A> implementazioni che restituiscono il formato di stringa del valore che rappresenta l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-512">For example, the base types such as <xref:System.Char>, <xref:System.Int32>, and <xref:System.String> provide <xref:System.Object.ToString%2A> implementations that return the string form of the value that the object represents.</span></span> <span data-ttu-id="de8fa-513">L'esempio seguente definisce una classe `Object2`, che esegue l'override di <xref:System.Object.ToString%2A> per restituire il nome del tipo insieme al relativo valore.</span><span class="sxs-lookup"><span data-stu-id="de8fa-513">The following example defines a class, `Object2`, that overrides the <xref:System.Object.ToString%2A> method to return the type name along with its value.</span></span>  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 <span data-ttu-id="de8fa-514">Nella tabella seguente sono elencate le categorie dei tipi in .NET Framework e indica se eseguire l'override di <xref:System.Object.ToString%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-514">The following table lists the type categories in the .NET Framework and indicates whether or not they override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
|<span data-ttu-id="de8fa-515">Categoria di tipi</span><span class="sxs-lookup"><span data-stu-id="de8fa-515">Type category</span></span>|<span data-ttu-id="de8fa-516">Esegue l'override di ToString)</span><span class="sxs-lookup"><span data-stu-id="de8fa-516">Overrides Object.ToString()</span></span>|<span data-ttu-id="de8fa-517">Comportamento</span><span class="sxs-lookup"><span data-stu-id="de8fa-517">Behavior</span></span>|  
|-------------------|-----------------------------------|--------------|  
|<span data-ttu-id="de8fa-518">Classe</span><span class="sxs-lookup"><span data-stu-id="de8fa-518">Class</span></span>|<span data-ttu-id="de8fa-519">N/D</span><span class="sxs-lookup"><span data-stu-id="de8fa-519">n/a</span></span>|<span data-ttu-id="de8fa-520">N/D</span><span class="sxs-lookup"><span data-stu-id="de8fa-520">n/a</span></span>|  
|<span data-ttu-id="de8fa-521">Struttura</span><span class="sxs-lookup"><span data-stu-id="de8fa-521">Structure</span></span>|<span data-ttu-id="de8fa-522">Sì (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="de8fa-522">Yes (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="de8fa-523">Uguale a ToString)</span><span class="sxs-lookup"><span data-stu-id="de8fa-523">Same as Object.ToString()</span></span>|  
|<span data-ttu-id="de8fa-524">Enumerazione</span><span class="sxs-lookup"><span data-stu-id="de8fa-524">Enumeration</span></span>|<span data-ttu-id="de8fa-525">Sì (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="de8fa-525">Yes (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="de8fa-526">Il nome del membro</span><span class="sxs-lookup"><span data-stu-id="de8fa-526">The member name</span></span>|  
|<span data-ttu-id="de8fa-527">Interfaccia</span><span class="sxs-lookup"><span data-stu-id="de8fa-527">Interface</span></span>|<span data-ttu-id="de8fa-528">No</span><span class="sxs-lookup"><span data-stu-id="de8fa-528">No</span></span>|<span data-ttu-id="de8fa-529">N/D</span><span class="sxs-lookup"><span data-stu-id="de8fa-529">n/a</span></span>|  
|<span data-ttu-id="de8fa-530">delegato</span><span class="sxs-lookup"><span data-stu-id="de8fa-530">Delegate</span></span>|<span data-ttu-id="de8fa-531">No</span><span class="sxs-lookup"><span data-stu-id="de8fa-531">No</span></span>|<span data-ttu-id="de8fa-532">N/D</span><span class="sxs-lookup"><span data-stu-id="de8fa-532">n/a</span></span>|  
  
 <span data-ttu-id="de8fa-533">Vedere la sezione Note per gli eredi per altre informazioni sull'override <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-533">See the Notes to Inheritors section for additional information on overriding <xref:System.Object.ToString%2A>.</span></span>  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a><span data-ttu-id="de8fa-534">L'overload del metodo ToString</span><span class="sxs-lookup"><span data-stu-id="de8fa-534">Overloading the ToString method</span></span>  
 <span data-ttu-id="de8fa-535">Oltre a sostituire senza parametri <xref:System.Object.ToString?displayProperty=nameWithType> overload del metodo, molti tipi di `ToString` metodo per fornire versioni che accettano parametri del metodo.</span><span class="sxs-lookup"><span data-stu-id="de8fa-535">In addition to overriding the parameterless <xref:System.Object.ToString?displayProperty=nameWithType> method, many types overload the `ToString` method to provide versions of the method that accept parameters.</span></span> <span data-ttu-id="de8fa-536">In genere, questa operazione viene eseguita per fornire il supporto per la formattazione variabile e formattazione dipendente dalle impostazioni cultura.</span><span class="sxs-lookup"><span data-stu-id="de8fa-536">Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="de8fa-537">Gli overload di esempio seguente il `ToString` per restituire una stringa di risultato che include il valore di diversi campi di un `Automobile` classe.</span><span class="sxs-lookup"><span data-stu-id="de8fa-537">The following example overloads the `ToString` method to return a result string that includes the value of various fields of an `Automobile` class.</span></span> <span data-ttu-id="de8fa-538">Definisce quattro stringhe di formato: G, che restituisce il nome del modello e l'anno; 1!d, che restituisce il nome del modello, anno e numero di portiere; C, che restituisce il nome del modello, anno e numero di cilindri; e A, che restituisce una stringa con tutti i valori dei campi di quattro.</span><span class="sxs-lookup"><span data-stu-id="de8fa-538">It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.</span></span>  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 <span data-ttu-id="de8fa-539">L'esempio seguente chiama l'overload <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodo da visualizzare formattazione dipendente dalle impostazioni cultura di un valore di valuta.</span><span class="sxs-lookup"><span data-stu-id="de8fa-539">The following example calls the overloaded <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method to display culture-sensitive formatting of a currency value.</span></span>  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 <span data-ttu-id="de8fa-540">Per altre informazioni su stringhe di formato e formattazione dipendente dalle impostazioni cultura, vedere [formattazione di tipi](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="de8fa-540">For more information on format strings and culture-sensitive formatting, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span> <span data-ttu-id="de8fa-541">Per le stringhe di formato supportate da valori numerici, vedere [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) e [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="de8fa-541">For the format strings supported by numeric values, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span> <span data-ttu-id="de8fa-542">Per le stringhe di formato supportate dai valori data e ora, vedere [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="de8fa-542">For the format strings supported by date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span></span>  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a><span data-ttu-id="de8fa-543">Estendere il metodo ToString</span><span class="sxs-lookup"><span data-stu-id="de8fa-543">Extending the Object.ToString method</span></span>  
 <span data-ttu-id="de8fa-544">Poiché un tipo eredita il valore predefinito <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo, è possibile trovare il proprio comportamento indesiderato e per modificarlo.</span><span class="sxs-lookup"><span data-stu-id="de8fa-544">Because a type inherits the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, you may find its behavior undesirable and want to change it.</span></span> <span data-ttu-id="de8fa-545">Questo vale in particolare delle classi di raccolta e matrici.</span><span class="sxs-lookup"><span data-stu-id="de8fa-545">This is particularly true of arrays and collection classes.</span></span> <span data-ttu-id="de8fa-546">Mentre si sarebbe potuto prevedere il `ToString` metodo di una matrice o raccolta di classe per visualizzare i valori dei relativi membri, viene invece visualizzato il nome tipo completo del tipo, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="de8fa-546">While you may expect the `ToString` method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.</span></span>  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 <span data-ttu-id="de8fa-547">Sono disponibili diverse opzioni per ottenere la stringa di risultato desiderato.</span><span class="sxs-lookup"><span data-stu-id="de8fa-547">You have several options to produce the result string that you'd like.</span></span>  
  
-   <span data-ttu-id="de8fa-548">Se il tipo è una matrice, un oggetto raccolta o un oggetto che implementa il <xref:System.Collections.IEnumerable> o <xref:System.Collections.Generic.IEnumerable%601> interfacce, è possibile enumerare i relativi elementi tramite il `foreach` istruzione in c# o `For Each...Next` costruire in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="de8fa-548">If the type is an array, a collection object, or an object that implements the <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> interfaces, you can enumerate its elements by using the `foreach` statement in C# or the `For Each...Next` construct in Visual Basic.</span></span>  
  
-   <span data-ttu-id="de8fa-549">Se non è la classe `sealed` (in c#) o `NotInheritable` (in Visual Basic), è possibile sviluppare una classe wrapper che eredita dalla classe di base cui <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo che si desidera personalizzare.</span><span class="sxs-lookup"><span data-stu-id="de8fa-549">If the class is not `sealed` (in C#) or `NotInheritable` (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <xref:System.Object.ToString%2A?displayProperty=nameWithType> method you want to customize.</span></span> <span data-ttu-id="de8fa-550">Come minimo, questa operazione richiede che procedere nel modo seguente:</span><span class="sxs-lookup"><span data-stu-id="de8fa-550">At a minimum, this requires that you do the following:</span></span>  
  
    1.  <span data-ttu-id="de8fa-551">Implementare eventuali costruttori necessari.</span><span class="sxs-lookup"><span data-stu-id="de8fa-551">Implement any necessary constructors.</span></span> <span data-ttu-id="de8fa-552">Le classi derivate non ereditano i relativi costruttori di classe di base.</span><span class="sxs-lookup"><span data-stu-id="de8fa-552">Derived classes do not inherit their base class constructors.</span></span>  
  
    2.  <span data-ttu-id="de8fa-553">Eseguire l'override di <xref:System.Object.ToString%2A?displayProperty=nameWithType> per restituire la stringa di risultato desiderato.</span><span class="sxs-lookup"><span data-stu-id="de8fa-553">Override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the result string that you'd like.</span></span>  
  
     <span data-ttu-id="de8fa-554">L'esempio seguente definisce una classe wrapper per il <xref:System.Collections.Generic.List%601> classe.</span><span class="sxs-lookup"><span data-stu-id="de8fa-554">The following example defines a wrapper class for the <xref:System.Collections.Generic.List%601> class.</span></span> <span data-ttu-id="de8fa-555">Viene eseguito l'override di <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo per visualizzare il valore di ogni metodo di raccolta piuttosto che il nome completo del tipo.</span><span class="sxs-lookup"><span data-stu-id="de8fa-555">It overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to display the value of each method of the collection rather than the fully qualified type name.</span></span>  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   <span data-ttu-id="de8fa-556">Sviluppare un' [metodo di estensione](~/docs/standard/design-guidelines/extension-methods.md) che restituisce la stringa di risultato desiderato.</span><span class="sxs-lookup"><span data-stu-id="de8fa-556">Develop an [extension method](~/docs/standard/design-guidelines/extension-methods.md) that returns the result string that you want.</span></span> <span data-ttu-id="de8fa-557">Si noti che non è possibile sostituire il valore predefinito <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodo in questo modo (vale a dire, la classe di estensione (in c#) o il modulo (in Visual Basic) non può avere un metodo senza parametri denominato `ToString` che viene chiamato al posto del tipo originale `ToString` (metodo) .</span><span class="sxs-lookup"><span data-stu-id="de8fa-557">Note that you can't override the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named `ToString` that is called in place of the original type's `ToString` method.</span></span> <span data-ttu-id="de8fa-558">È possibile fornire un altro nome per il senza parametri `ToString` sostituzione.</span><span class="sxs-lookup"><span data-stu-id="de8fa-558">You'll have to provide some other name for your parameterless `ToString` replacement.</span></span>  
  
     <span data-ttu-id="de8fa-559">L'esempio seguente definisce due metodi che estendono il <xref:System.Collections.Generic.List%601> classe: un costruttore `ToString2` metodo e una `ToString` metodo con un <xref:System.String> parametro che rappresenta una stringa di formato.</span><span class="sxs-lookup"><span data-stu-id="de8fa-559">The following example defines two methods that extend the <xref:System.Collections.Generic.List%601> class: a parameterless `ToString2` method, and a `ToString` method with a <xref:System.String> parameter that represents a format string.</span></span>  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="de8fa-560">Note per il [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="de8fa-560">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="de8fa-561">Quando si chiama il <xref:System.Object.ToString%2A> metodo in una classe nel [!INCLUDE[wrt](~/includes/wrt-md.md)], fornisce il comportamento predefinito per le classi che non esegue l'override <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-561">When you call the <xref:System.Object.ToString%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="de8fa-562">Ciò fa parte del supporto che .NET Framework fornisce per i [!INCLUDE[wrt](~/includes/wrt-md.md)] (vedere [app .NET Framework supportano per Windows Store e Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="de8fa-562">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="de8fa-563">Le classi di [!INCLUDE[wrt](~/includes/wrt-md.md)] non ereditano <xref:System.Object>e non sempre implementare un <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-563">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and don't always implement a <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="de8fa-564">Tuttavia, sempre sembrano disporre <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, e <xref:System.Object.GetHashCode%2A> metodi quando usarli nel codice c# o Visual Basic e .NET Framework fornisce un comportamento predefinito per questi metodi.</span><span class="sxs-lookup"><span data-stu-id="de8fa-564">However, they always appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.</span></span>  
  
 <span data-ttu-id="de8fa-565">Inizia con la [!INCLUDE[net_v451](~/includes/net-v451-md.md)], common language runtime utilizzerà [istringable. ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) su un [!INCLUDE[wrt](~/includes/wrt-md.md)] oggetto prima di eseguire il fallback per l'implementazione predefinita di <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-565">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], the common language runtime will use [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) on a [!INCLUDE[wrt](~/includes/wrt-md.md)] object before falling back to the default implementation of <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="de8fa-566">le classi che vengono scritti in c# o Visual Basic possono eseguire l'override di <xref:System.Object.ToString%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="de8fa-566">classes that are written in C# or Visual Basic can override the <xref:System.Object.ToString%2A> method.</span></span>  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a><span data-ttu-id="de8fa-567">Il [!INCLUDE[wrt](~/includes/wrt-md.md)] e l'interfaccia di IStringable</span><span class="sxs-lookup"><span data-stu-id="de8fa-567">The [!INCLUDE[wrt](~/includes/wrt-md.md)] and the IStringable Interface</span></span>  
 <span data-ttu-id="de8fa-568">A partire [!INCLUDE[win81](~/includes/win81-md.md)], il [!INCLUDE[wrt](~/includes/wrt-md.md)] include un [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) il cui metodo singolo, di interfaccia [istringable. ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), fornisce un supporto di formattazione base analogo a quello fornito da <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="de8fa-568">Starting with [!INCLUDE[win81](~/includes/win81-md.md)], the [!INCLUDE[wrt](~/includes/wrt-md.md)] includes an [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface whose single method, [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), provides basic formatting support comparable to that provided by <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="de8fa-569">Per evitare ambiguità, è consigliabile non implementare [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) nei tipi gestiti.</span><span class="sxs-lookup"><span data-stu-id="de8fa-569">To prevent ambiguity, you should not implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on managed types.</span></span>  
  
 <span data-ttu-id="de8fa-570">Quando gli oggetti gestiti vengono chiamati da codice nativo o dal codice scritto in linguaggi quali JavaScript o C + + c++ /CX, vengono visualizzati per implementare [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span><span class="sxs-lookup"><span data-stu-id="de8fa-570">When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span> <span data-ttu-id="de8fa-571">Common language runtime indirizzerà automaticamente le chiamate da [istringable. ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) al <xref:System.Object.ToString%2A?displayProperty=nameWithType> event [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) non è implementato nell'oggetto gestito.</span><span class="sxs-lookup"><span data-stu-id="de8fa-571">The common language runtime will automatically route calls from [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) to <xref:System.Object.ToString%2A?displayProperty=nameWithType> in the event [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) is not implemented on the managed object.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="de8fa-572">Poiché common language runtime. automatico-implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) per tutti i tipi in gestiti [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] le app, è consigliabile che non viene fornito il proprio [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementazione.</span><span class="sxs-lookup"><span data-stu-id="de8fa-572">Because the common language runtime auto-implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) for all managed types in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps, we recommend that you do not provide your own [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation.</span></span> <span data-ttu-id="de8fa-573">Implementazione [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) può comportare un comportamento imprevisto quando si chiama `ToString` dal [!INCLUDE[wrt](~/includes/wrt-md.md)], C + c++ /CX o JavaScript.</span><span class="sxs-lookup"><span data-stu-id="de8fa-573">Implementing [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) may result in unintended behavior when calling `ToString` from the [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX, or JavaScript.</span></span>  
  
 <span data-ttu-id="de8fa-574">Se si sceglie di implementare [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in un tipo gestito pubblico esportato in un [!INCLUDE[wrt](~/includes/wrt-md.md)] componente, rispettare i requisiti seguenti:</span><span class="sxs-lookup"><span data-stu-id="de8fa-574">If you do choose to implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in a public managed type that is exported in a [!INCLUDE[wrt](~/includes/wrt-md.md)] component, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="de8fa-575">È possibile definire le [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interfaccia solo in una relazione "classe", ad esempio</span><span class="sxs-lookup"><span data-stu-id="de8fa-575">You can define the [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface only in a "class implements" relationship, such as</span></span>  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     <span data-ttu-id="de8fa-576">in C# oppure</span><span class="sxs-lookup"><span data-stu-id="de8fa-576">in C#, or</span></span>  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     <span data-ttu-id="de8fa-577">in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="de8fa-577">in Visual Basic.</span></span>  
  
-   <span data-ttu-id="de8fa-578">Non è possibile implementare [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) su un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="de8fa-578">You cannot implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on an interface.</span></span>  
  
-   <span data-ttu-id="de8fa-579">Non è possibile dichiarare un parametro di tipo [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span><span class="sxs-lookup"><span data-stu-id="de8fa-579">You cannot declare a parameter to be of type [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span>  
  
-   <span data-ttu-id="de8fa-580">[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) non può essere il tipo restituito di un metodo, proprietà o campo.</span><span class="sxs-lookup"><span data-stu-id="de8fa-580">[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) cannot be the return type of a method, property, or field.</span></span>  
  
-   <span data-ttu-id="de8fa-581">Non è possibile nascondere il [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementazione dalle classi di base usando una definizione di metodo analoga alla seguente:</span><span class="sxs-lookup"><span data-stu-id="de8fa-581">You cannot hide your [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation from base classes by using a method definition such as the following:</span></span>  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     <span data-ttu-id="de8fa-582">Al contrario, il [istringable. ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementazione deve sempre eseguire l'override dell'implementazione della classe base.</span><span class="sxs-lookup"><span data-stu-id="de8fa-582">Instead, the [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation must always override the base class implementation.</span></span> <span data-ttu-id="de8fa-583">Puoi nascondere un'implementazione di `ToString` solo richiamandola sull'istanza di una classe fortemente tipizzata.</span><span class="sxs-lookup"><span data-stu-id="de8fa-583">You can hide a `ToString` implementation only by invoking it on a strongly typed class instance.</span></span>  
  
 <span data-ttu-id="de8fa-584">Si noti che in diverse circostanze le chiamate dal codice nativo a un tipo gestito che implementa [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) o nasconde la relativa [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementazione può produrre un comportamento imprevisto.</span><span class="sxs-lookup"><span data-stu-id="de8fa-584">Note that under a variety of conditions, calls from native code to a managed type that implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) or hides its [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation can produce unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="de8fa-585">Quando si implementano i tipi personalizzati, è necessario eseguire l'override di <see cref="M:System.Object.ToString" /> metodo per restituire i valori più appropriati per tali tipi.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-585">When you implement your own types, you should override the <see cref="M:System.Object.ToString" /> method to return values that are meaningful for those types.</span>
            </span>
            <span data-ttu-id="de8fa-586">Le classi derivate che richiedono un maggiore controllo sulla formattazione rispetto <see cref="M:System.Object.ToString" /> fornisce può implementare il <see cref="T:System.IFormattable" /> interfaccia.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-586">Derived classes that require more control over formatting than <see cref="M:System.Object.ToString" /> provides can implement the <see cref="T:System.IFormattable" /> interface.</span>
            </span>
            <span data-ttu-id="de8fa-587">Relativi <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> metodo consente di definire le stringhe di formato che controllano la formattazione e usare un <see cref="T:System.IFormatProvider" /> oggetto che può fornire per la formattazione delle impostazioni cultura specifiche.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-587">Its <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> method enables you to define format strings that control formatting and to use an <see cref="T:System.IFormatProvider" /> object that can provide for culture-specific formatting.</span>
            </span>
            <span data-ttu-id="de8fa-588">Esegue l'override del <see cref="M:System.Object.ToString" /> metodo dovrebbe seguire queste linee guida:</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-588">Overrides of the <see cref="M:System.Object.ToString" /> method should follow these guidelines:</span>
            </span>
            <span data-ttu-id="de8fa-589">-La stringa restituita deve essere descrittivi e leggibile dagli utenti.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-589">-   The returned string should be friendly and readable by humans.</span>
            </span>
            <span data-ttu-id="de8fa-590">-La stringa restituita deve identificare in modo univoco il valore dell'istanza dell'oggetto.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-590">-   The returned string should uniquely identify the value of the object instance.</span>
            </span>
            <span data-ttu-id="de8fa-591">-La stringa restituita deve essere più corte possibili, in modo che sia adatto per la visualizzazione da un debugger.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-591">-   The returned string should be as short as possible so that it is suitable for display by a debugger.</span>
            </span>
            <span data-ttu-id="de8fa-592">-il <see cref="M:System.Object.ToString" /> override non deve restituire <see cref="F:System.String.Empty" /> o una stringa null.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-592">-   Your <see cref="M:System.Object.ToString" /> override should not return <see cref="F:System.String.Empty" /> or a null string.</span>
            </span>
            <span data-ttu-id="de8fa-593">-il <see cref="M:System.Object.ToString" /> override non deve generare un'eccezione.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-593">-   Your <see cref="M:System.Object.ToString" /> override should not throw an exception.</span>
            </span>
            <span data-ttu-id="de8fa-594">-Se la rappresentazione di stringa di un'istanza di distinzione delle impostazioni cultura o può essere formattata in diversi modi, implementare il <see cref="T:System.IFormattable" /> interfaccia.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-594">-   If the string representation of an instance is culture-sensitive or can be formatted in multiple ways, implement the <see cref="T:System.IFormattable" /> interface.</span>
            </span>
            <span data-ttu-id="de8fa-595">-Se la stringa restituita include le informazioni riservate, è innanzitutto necessario richiedere un'autorizzazione appropriata.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-595">-   If the returned string includes sensitive information, you should first demand an appropriate permission.</span>
            </span>
            <span data-ttu-id="de8fa-596">Se la richiesta ha esito positivo, è possibile restituire le informazioni sensibili. in caso contrario, è necessario restituire una stringa che esclude le informazioni riservate.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-596">If the demand succeeds, you can return the sensitive information; otherwise, you should return a string that excludes the sensitive information.</span>
            </span>
            <span data-ttu-id="de8fa-597">-il <see cref="M:System.Object.ToString" /> sostituzione non deve avere nessun effetto collaterale observable per evitare complicazioni durante il debug.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-597">-   Your <see cref="M:System.Object.ToString" /> override should have no observable side effects to avoid complications in debugging.</span>
            </span>
            <span data-ttu-id="de8fa-598">Ad esempio, una chiamata al <see cref="M:System.Object.ToString" /> metodo non deve modificare il valore dei campi di istanza.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-598">For example, a call to the <see cref="M:System.Object.ToString" /> method should not change the value of instance fields.</span>
            </span>
            <span data-ttu-id="de8fa-599">-Se il tipo implementa un metodo di analisi (o <see langword="Parse" /> oppure <see langword="TryParse" /> metodo, un costruttore o un altro metodo statico che crea un'istanza del tipo da una stringa), è necessario assicurarsi che la stringa restituita dal <see cref="M:System.Object.ToString" /> metodo può essere convertito in un'istanza dell'oggetto.</span>
            <span class="sxs-lookup">
              <span data-stu-id="de8fa-599">-   If your type implements a parsing method (or <see langword="Parse" /> or <see langword="TryParse" /> method, a constructor, or some other static method that instantiates an instance of the type from a string), you should ensure that the string returned by the <see cref="M:System.Object.ToString" /> method can be converted to an object instance.</span>
            </span>
          </para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">
          <span data-ttu-id="de8fa-600">Formattazione di tipi in .NET</span>
          <span class="sxs-lookup">
            <span data-stu-id="de8fa-600">Formatting Types in .NET</span>
          </span>
        </related>
      </Docs>
    </Member>
  </Members>
</Type>