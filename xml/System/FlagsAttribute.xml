<Type Name="FlagsAttribute" FullName="System.FlagsAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4b2417901d3ec970c72a2c6cc0524b2108855ce0" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36431664" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FlagsAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit FlagsAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.FlagsAttribute" />
  <TypeSignature Language="VB.NET" Value="Public Class FlagsAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class FlagsAttribute : Attribute" />
  <TypeSignature Language="F#" Value="type FlagsAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Enum, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Indica che un'enumerazione può essere gestita come un campo di bit, ovvero un set di flag.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I campi di bit vengono in genere utilizzati per gli elenchi di elementi che possono ricorrere in combinazioni, mentre le costanti di enumerazione sono in genere utilizzate per elenchi di elementi si escludono a vicenda. Pertanto, i campi di bit sono progettati per essere combinati con un'operazione OR bit per bit per generare i valori senza nome, mentre non sono costanti enumerate. Lingue variano l'uso dei campi di bit rispetto alle costanti di enumerazione.  
  
## <a name="attributes-of-the-flagsattribute"></a>Attributi di FlagsAttribute  
 <xref:System.AttributeUsageAttribute> viene applicata a questa classe e il relativo <xref:System.AttributeUsageAttribute.Inherited%2A> proprietà specifica `false`. Questo attributo può essere applicato solo alle enumerazioni.  
  
## <a name="guidelines-for-flagsattribute-and-enum"></a>Linee guida per FlagsAttribute ed Enum  
  
-   Utilizzare il <xref:System.FlagsAttribute> attributo personalizzato per un'enumerazione solo se è un'operazione bit per bit (AND, OR esclusivo o) deve essere eseguita su un valore numerico.  
  
-   Definire le costanti di enumerazione in potenze di due, ovvero 1, 2, 4, 8 e così via. Ciò significa che i singoli flag nelle costanti di enumerazione combinate non si sovrappongano.  
  
-   È consigliabile creare una costante enumerata per le combinazioni di flag di uso comune. Ad esempio, se si dispone di un'enumerazione utilizzata per le operazioni dei / o file che contiene le costanti enumerate `Read = 1` e `Write = 2`, è consigliabile creare costante enumerata `ReadWrite = Read OR Write`, che combina il `Read` e `Write` flag. Inoltre, l'operazione OR bit per bit usato per combinare i flag può essere considerato un concetto avanzato in alcuni casi che non devono essere necessaria per semplici attività.  
  
-   Prestare attenzione se si definisce un numero negativo come costante enumerata di flag poiché molte posizioni di flag potrebbero essere impostate su 1, che potrebbe rendere il codice poco chiaro e incoraggiare gli errori di codifica.  
  
-   Un modo pratico per verificare se è impostato un flag in un valore numerico è per eseguire un'operazione con AND bit per bit tra il valore numerico e costante enumerata di flag, che imposta tutti i bit nel valore numerico da zero, che non corrispondono al flag , quindi verificare se il risultato di tale operazione è uguale alla costante enumerata di flag.  
  
-   Utilizzare `None` come il nome del flag costante enumerata il cui valore è zero. Non è possibile utilizzare il `None` costante enumerata in un'operazione con AND bit per bit per verificare un flag perché il risultato è sempre zero. Tuttavia, è possibile eseguire una logica, non un confronto bit per bit tra il valore numerico e `None` costante enumerata per determinare se si assegnano bit del valore numerico.  
  
     Se si crea un'enumerazione dei valori anziché un'enumerazione flags, risulta comunque utile creare un `None` costante enumerata. Il motivo è che per impostazione predefinita la memoria utilizzata per l'enumerazione è inizializzata su zero da common language runtime. Di conseguenza, se non si definisce una costante il cui valore è uguale a zero, l'enumerazione conterrà un valore non valido al momento della creazione.  
  
     Se è un caso predefinito ovvio che deve rappresentare l'applicazione, è consigliabile utilizzare una costante enumerata il cui valore è uguale a zero per rappresentare il valore predefinito. Se non esiste alcun caso predefinito, valutare l'uso di una costante enumerata il cui valore è zero che significa che non è rappresentato da una delle altre costanti enumerate.  
  
-   Non definire un valore di enumerazione esclusivamente per rispecchiare lo stato dell'enumerazione stessa. Ad esempio, si definisce una costante enumerata che semplicemente contrassegna la fine dell'enumerazione. Se è necessario determinare l'ultimo valore dell'enumerazione, controllare in modo esplicito per quel valore. Inoltre, è possibile eseguire un controllo di intervallo per la prima e ultima costante enumerata se tutti i valori all'interno dell'intervallo sono validi.  
  
-   Non si specifica costanti enumerate che sono riservate per utilizzi futuri.  
  
-   Quando si definisce un metodo o proprietà che accetta una costante enumerata come valore, prendere in considerazione la convalida del valore. Il motivo è che, anche se tale valore numerico non è definito nell'enumerazione, è possibile impostare un valore numerico per il tipo di enumerazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del `FlagsAttribute` dell'attributo e Mostra l'effetto sul <xref:System.Enum.ToString%2A> metodo di utilizzo `FlagsAttribute` su un <xref:System.Enum> dichiarazione.  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 L'esempio seguente definisce due enumerazioni correlate al colore `SingleHue` e `MultiHue`. Quest'ultimo ha il `FlagsAttribute` attributo; il primo non lo è. L'esempio mostra la differenza nel comportamento quando viene eseguito il cast di un intervallo di numeri interi, inclusi valori integer che rappresenta i valori sottostanti del tipo di enumerazione, per il tipo di enumerazione e le relative rappresentazioni di stringa visualizzate.   Ad esempio, si noti che 3 non può essere rappresentato come un `SingleHue` valore perché 3 non è il valore sottostante di qualsiasi `SingleHue` membro, mentre il `FlagsAttribute` attributo consente di rappresentare 3 come una `MultiHue` valore `Black, Red`.  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FlagsAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FlagsAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FlagsAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.FlagsAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente definisce un `PhoneService` enumerazione che rappresenta i form di comunicazione fornito da una società di telefono. Inizializza le tre variabili che rappresentano il servizio fornito ai tre famiglie diverse e indicherà quali famiglie non dispone di alcun servizio, quali famiglie solo servizio di telefoni cellulari e quali famiglie servizio riga sia telefoni cellulari e terreni. Infine, chiama in modo implicito il <xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType> metodo per visualizzare i tipi di servizio fornito per ogni famiglia.  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 Nell'esempio seguente viene illustrato l'utilizzo del `FlagsAttribute` dell'attributo e Mostra l'effetto sul <xref:System.Enum.ToString%2A> metodo di utilizzo `FlagsAttribute` su un <xref:System.Enum> dichiarazione.  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>