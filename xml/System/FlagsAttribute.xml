<Type Name="FlagsAttribute" FullName="System.FlagsAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b4a43daf94141e166fdacae6f0ba6f4be584c7b5" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30727655" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FlagsAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit FlagsAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.FlagsAttribute" />
  <TypeSignature Language="VB.NET" Value="Public Class FlagsAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class FlagsAttribute : Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Enum, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Indica che un'enumerazione può essere gestita come un campo di bit, ovvero un set di flag.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I campi di bit vengono in genere utilizzati per elenchi di elementi che possono ricorrere in combinazioni, mentre le costanti di enumerazione sono in genere utilizzate per elenchi di elementi si escludono a vicenda. Di conseguenza, i campi di bit sono progettati per essere combinati con un'operazione OR bit per bit per generare valori senza nome, mentre non sono costanti enumerate. Lingue variano l'uso dei campi di bit rispetto alle costanti di enumerazione.  
  
## <a name="attributes-of-the-flagsattribute"></a>Attributi di FlagsAttribute  
 <xref:System.AttributeUsageAttribute> viene applicata a questa classe e il relativo <xref:System.AttributeUsageAttribute.Inherited%2A> specifica proprietà `false`. Questo attributo può essere applicato solo alle enumerazioni.  
  
## <a name="guidelines-for-flagsattribute-and-enum"></a>Linee guida per FlagsAttribute ed Enum  
  
-   Utilizzare il <xref:System.FlagsAttribute> attributo personalizzato per un'enumerazione solo se un'operazione bit per bit (AND, OR esclusivo o) deve essere eseguita su un valore numerico.  
  
-   Definire le costanti di enumerazione in potenze di due, ovvero 1, 2, 4, 8 e così via. Ciò significa che i singoli flag nelle costanti di enumerazione combinate non si sovrappongano.  
  
-   È consigliabile creare una costante enumerata per le combinazioni di flag di uso comune. Ad esempio, se si dispone di un'enumerazione utilizzata per le operazioni dei / o file che contiene le costanti enumerate `Read = 1` e `Write = 2`, prendere in considerazione la creazione della costante enumerata `ReadWrite = Read OR Write`, che combina il `Read` e `Write` flag. Inoltre, l'operazione OR bit per bit usato per combinare i flag può essere considerato un concetto avanzato in alcuni casi che non devono essere necessari per eseguire semplici operazioni.  
  
-   Prestare attenzione se si definisce un numero negativo come costante enumerata di flag poiché molte posizioni di flag potrebbero essere impostate su 1, che potrebbe rendere il codice poco chiaro e incoraggiare gli errori di codice.  
  
-   È un modo pratico per verificare se un flag è impostato in un valore numerico per eseguire un'operazione con AND bit per bit tra il valore numerico e costante enumerata di flag, che imposta il valore numerico da zero che corrisponde al flag di tutti i bit , quindi verificare se il risultato di tale operazione è uguale alla costante enumerata di flag.  
  
-   Utilizzare `None` come il nome del flag costante enumerata il cui valore è zero. Non è possibile utilizzare il `None` costante enumerata in un'operazione con AND bit per bit per verificare un flag perché il risultato è sempre zero. Tuttavia, è possibile eseguire una logica, non un confronto bit per bit tra il valore numerico e `None` costante enumerata per determinare se alcuni bit del valore numerico sono impostati.  
  
     Se si crea un'enumerazione dei valori anziché un'enumerazione di flag, è comunque utile creare un `None` costante enumerata. Il motivo è che per impostazione predefinita la memoria utilizzata per l'enumerazione è inizializzata su zero da common language runtime. Di conseguenza, se non si definisce una costante il cui valore è zero, l'enumerazione conterrà un valore non valido al momento della creazione.  
  
     Se è presente un caso predefinito ovvio che deve rappresentare l'applicazione, utilizzare una costante enumerata il cui valore è uguale a zero per rappresentare il valore predefinito. Se nessun caso predefinito, è consigliabile utilizzare una costante enumerata il cui valore è zero, che significa che non è rappresentato da una delle altre costanti enumerate.  
  
-   Non definire un valore di enumerazione esclusivamente per rispecchiare lo stato dell'enumerazione stessa. Ad esempio, si definisce una costante enumerata che semplicemente contrassegna la fine dell'enumerazione. Se è necessario determinare l'ultimo valore dell'enumerazione, verificare la presenza di tale valore in modo esplicito. Inoltre, è possibile eseguire un controllo di intervallo per la prima e ultima costante enumerata se tutti i valori all'interno dell'intervallo sono validi.  
  
-   Non si specifica costanti enumerate che sono riservate per utilizzi futuri.  
  
-   Quando si definisce un metodo o proprietà che accetta una costante enumerata come valore, è consigliabile convalidare il valore. Infatti, è possibile eseguire il cast di un valore numerico per il tipo di enumerazione anche se tale valore numerico non è definito nell'enumerazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del `FlagsAttribute` degli attributi e Mostra l'effetto sul <xref:System.Enum.ToString%2A> metodo di utilizzo `FlagsAttribute` su un <xref:System.Enum> dichiarazione.  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 L'esempio seguente definisce due enumerazioni correlate al colore, `SingleHue` e `MultiHue`. Quest'ultimo ha il `FlagsAttribute` attributo; il primo non. L'esempio mostra la differenza nel comportamento quando viene eseguito il cast di un intervallo di numeri interi, inclusi i numeri interi che rappresentano valori sottostanti del tipo di enumerazione, per il tipo di enumerazione e le relative rappresentazioni di stringa visualizzate.   Ad esempio, si noti che 3 non può essere rappresentato come un `SingleHue` valore perché 3 non è il valore sottostante di qualsiasi `SingleHue` membro, mentre il `FlagsAttribute` attributo rende possibile rappresentare 3 come un `MultiHue` valore `Black, Red`.  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FlagsAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FlagsAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FlagsAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.FlagsAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente definisce un `PhoneService` enumerazione che rappresenta i form di comunicazione forniti da una società di telefono. Inizializza le tre variabili che rappresenta il servizio fornito ai tre famiglie diverse e indicherà quali famiglie non dispone di alcun servizio, quali famiglie solo servizio di telefoni cellulari e quali famiglie cellulare sia terreni servizio riga. Infine, chiama in modo implicito il <xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType> metodo per visualizzare i tipi di servizio fornito per ogni famiglia.  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 Nell'esempio seguente viene illustrato l'utilizzo del `FlagsAttribute` degli attributi e Mostra l'effetto sul <xref:System.Enum.ToString%2A> metodo di utilizzo `FlagsAttribute` su un <xref:System.Enum> dichiarazione.  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>