<Type Name="IDisposable" FullName="System.IDisposable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1e6b408b88af2e3e5027106be9c33751cc9e19c3" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34452200" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IDisposable" />
  <TypeSignature Language="VB.NET" Value="Public Interface IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Offre un meccanismo per il rilascio delle risorse non gestite.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'utilizzo principale di questa interfaccia è per rilasciare le risorse non gestite. Il garbage collector rilascia automaticamente la memoria allocata a un oggetto gestito quando tale oggetto non viene più utilizzato. Non è tuttavia possibile prevedere in cui verrà effettuata l'operazione di garbage collection. Inoltre, il garbage collector non ha alcuna conoscenza delle risorse non gestite, ad esempio gli handle di finestra o aprire file e flussi.  
  
 Utilizzare il <xref:System.IDisposable.Dispose%2A> metodo di questa interfaccia per rilasciare in modo esplicito le risorse non gestite in combinazione con il garbage collector. Il consumer di un oggetto può chiamare questo metodo quando l'oggetto non è più necessario.  
  
> [!WARNING]
>  Tratta di una modifica per aggiungere il <xref:System.IDisposable> interfaccia a una classe esistente. Poiché non è possibile chiamare preesistente consumer del tipo <xref:System.IDisposable.Dispose%2A>, è possibile essere certi che le risorse non gestite utilizzate dal tipo verranno rilasciate.  
  
 Poiché il <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementazione viene chiamata dal consumer di un tipo quando le risorse di proprietà da un'istanza non sono più necessari, è necessario includere sia l'oggetto gestito in un <xref:System.Runtime.InteropServices.SafeHandle> (l'alternativa consigliata) o eseguire l'override <xref:System.Object.Finalize%2A?displayProperty=nameWithType>per liberare risorse non gestite nel caso in cui il consumer ometta di chiamare <xref:System.IDisposable.Dispose%2A>.  
  
> [!IMPORTANT]
>  In .NET Framework, il compilatore C++ supporta l'eliminazione deterministica delle risorse e non consente l'implementazione diretta del <xref:System.IDisposable.Dispose%2A> metodo.  
  
 Per informazioni dettagliate su come questa interfaccia e <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodo, vedere il [Garbage Collection](~/docs/standard/garbage-collection/index.md) e [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md) argomenti.  
  
## <a name="using-an-object-that-implements-idisposable"></a>Uso di un oggetto che implementa IDisposable  
 Se l'app Usa semplicemente un oggetto che implementa il <xref:System.IDisposable> interfaccia, è necessario chiamare l'oggetto <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementazione dopo aver terminato di usarlo. A seconda del linguaggio di programmazione, è possibile farlo in uno dei due modi:  
  
-   Tramite un linguaggio costruire, ad esempio il `using` istruzione in c# e Visual Basic.  
  
-   Eseguendo il wrapping della chiamata al <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementazione in una `try` / `finally` blocco.  
  
> [!NOTE]
>  Documentazione per i tipi che implementano <xref:System.IDisposable> si noti che i fatti e includere un promemoria per chiamare il relativo <xref:System.IDisposable.Dispose%2A> implementazione.  
  
<a name="Using"></a>   
### <a name="the-c-and-visual-basic-using-statement"></a>L'istruzione c# e Visual Basic usano  
 Se il linguaggio supporta un costrutto, ad esempio il [utilizzando](~/docs/csharp/language-reference/keywords/using.md) istruzione in c# e [Using](~/docs/visual-basic/language-reference/statements/using-statement.md) istruzione in Visual Basic, è possibile utilizzarlo invece di chiamare in modo esplicito <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> manualmente. Nell'esempio seguente viene utilizzato questo approccio nella definizione di un `WordCount` classe che mantiene le informazioni su un file e il numero di parole in esso.  
  
 [!code-csharp[System.IDisposable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling1.cs#1)]
 [!code-vb[System.IDisposable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling1.vb#1)]  
  
 Il `using` istruzione è effettivamente sintattica. In fase di compilazione, il compilatore implementa il linguaggio intermedio (IL) per un `try` / `finally` blocco.  
  
 Per ulteriori informazioni sul `using` istruzione, vedere il [istruzione Using](~/docs/visual-basic/language-reference/statements/using-statement.md) o [utilizzando l'istruzione](~/docs/csharp/language-reference/keywords/using-statement.md) argomenti.  
  
### <a name="the-tryfinally-block"></a>Il blocco Try/Finally  
 Se il linguaggio di programmazione non supporta un costrutto come il `using` istruzione in c# o Visual Basic, oppure se si preferisce non utilizzarla, è possibile chiamare il <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementazione di `finally` blocco di un `try` / `finally` istruzione. Nell'esempio seguente sostituisce il `using` bloccare nella sezione precedente, con un `try` / `finally` blocco.  
  
 [!code-csharp[System.IDisposable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling2.cs#2)]
 [!code-vb[System.IDisposable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling2.vb#2)]  
  
 Per ulteriori informazioni sul `try` / `finally` di schema, vedere [provare... Catch... Istruzione finally](~/docs/visual-basic/language-reference/statements/try-catch-finally-statement.md), [try-finally](~/docs/csharp/language-reference/keywords/try-finally.md), o [istruzione try-finally](http://msdn.microsoft.com/library/514400c1-c322-4bf3-9e48-3047240b8a82).  
  
## <a name="implementing-idisposable"></a>Implementazione di IDisposable  
 È necessario implementare <xref:System.IDisposable> solo se il tipo di risorse non gestite viene utilizzato direttamente. I consumer del tipo è possono chiamare il <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementazione di liberare risorse quando l'istanza non è più necessario. Gestire i casi in cui sono in grado di chiamare <xref:System.IDisposable.Dispose%2A>, è necessario utilizzare una classe derivata da <xref:System.Runtime.InteropServices.SafeHandle> per andare a capo le risorse non gestite, è necessario eseguire l'override di <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodo per un tipo di riferimento. In entrambi i casi, utilizzare il <xref:System.IDisposable.Dispose%2A> metodo per eseguire qualsiasi tipo di pulizia è necessario dopo l'utilizzo di risorse non gestite, ad esempio liberare, rilasciare o reimpostare risorse non gestite.  
  
> [!IMPORTANT]
>  Se si sta definendo una classe di base che utilizza le risorse non gestite e che ha o potrebbe avere, sottoclassi che devono essere eliminate, è necessario implementare la <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metodo e fornire un overload del secondo `Dispose`, come descritto nella prossima sezione.  
  
<a name="BaseClasses"></a>   
## <a name="idisposable-and-the-inheritance-hierarchy"></a>IDisposable e la gerarchia di ereditarietà  
 Deve implementare una classe base con sottoclassi che devono essere disposable <xref:System.IDisposable> come indicato di seguito. È consigliabile utilizzare questo modello ogni volta che implementa <xref:System.IDisposable> su qualsiasi tipo che non è `sealed` (`NotInheritable` in Visual Basic).  
  
-   È necessario fornire una pubblica, non virtuale <xref:System.IDisposable.Dispose> metodo e protected virtuale `Dispose(Boolean disposing)` metodo.  
  
-   Il <xref:System.IDisposable.Dispose> metodo deve chiamare `Dispose(true)` e deve eliminare la finalizzazione per le prestazioni.  
  
-   Il tipo di base non deve includere alcun finalizzatori.  
  
 Nel seguente frammento di codice riflette il modello dispose per le classi di base. Si presuppone che il tipo non esegue l'override di <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodo.  
  
 [!code-csharp[System.IDisposable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
 [!code-vb[System.IDisposable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]  
  
 Se si esegue l'override di <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodo, la classe deve implementare il modello seguente.  
  
 [!code-csharp[System.IDisposable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
 [!code-vb[System.IDisposable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]  
  
 Le sottoclassi devono implementare il modello Disposable nel modo seguente:  
  
-   Devono eseguire l'override di `Dispose(Boolean)` e chiamare l'implementazione `Dispose(Boolean)` della classe di base.  
  
-   Se necessario, possono fornire un finalizzatore. Il finalizzatore deve chiamare `Dispose(false)`.  
  
 Si noti che le classi derivate non possono implementare la <xref:System.IDisposable> l'interfaccia e non includere un costruttore <xref:System.IDisposable.Dispose%2A> metodo. Sostituiscono solo la classe di base `Dispose(Boolean)` metodo.  
  
 Nel seguente frammento di codice riflette il modello dispose per le classi derivate. Si presuppone che il tipo non esegue l'override di <xref:System.Object.Finalize%2A?displayProperty=nameWithType> metodo.  
  
 [!code-csharp[System.IDisposable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
 [!code-vb[System.IDisposable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare una classe di risorse che implementa il <xref:System.IDisposable> interfaccia.  
  
 [!code-cpp[System.IDisposable.Dispose Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CPP/idisposabledispose.cpp#1)]
 [!code-csharp[System.IDisposable.Dispose Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CS/idisposabledispose.cs#1)]
 [!code-vb[System.IDisposable.Dispose Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/VB/idisposabledispose.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" />
  </Docs>
  <Members>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IDisposable.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Dispose();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Esegue attività definite dall'applicazione, come rilasciare o reimpostare risorse non gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo metodo per chiudere o rilasciare le risorse non gestite, ad esempio file, flussi e handle, occupate da un'istanza della classe che implementa questa interfaccia. Per convenzione, questo metodo viene utilizzato per tutte le attività relative al rilascio di risorse occupate da un oggetto, o la preparazione di un oggetto per il riutilizzo.  
  
> [!WARNING]
>  Se si utilizza una classe che implementa il <xref:System.IDisposable> interfaccia, è necessario chiamare il relativo <xref:System.IDisposable.Dispose%2A> quando si è terminato di utilizzare la classe di implementazione. Per ulteriori informazioni, vedere la sezione "Utilizzo di un oggetto che implementa IDisposable" nel <xref:System.IDisposable> argomento.  
  
 Quando si implementa questo metodo, verificare che tutte occupate le risorse vengano liberate, propagando la chiamata tramite la gerarchia di contenimento. Ad esempio, se un oggetto a alloca un oggetto B e oggetto B alloca un oggetto C, quindi A <xref:System.IDisposable.Dispose%2A> deve chiamare l'implementazione <xref:System.IDisposable.Dispose%2A> su B, che a sua volta deve chiamare <xref:System.IDisposable.Dispose%2A> in C.  
  
> [!IMPORTANT]
>  Il compilatore C++ supporta l'eliminazione deterministica delle risorse e non consente l'implementazione diretta del <xref:System.IDisposable.Dispose%2A> metodo.  
  
 Un oggetto è necessario chiamare anche il <xref:System.IDisposable.Dispose%2A> metodo della classe base se la classe base implementa <xref:System.IDisposable>. Per ulteriori informazioni sull'implementazione <xref:System.IDisposable> in una classe di base e delle relative sottoclassi, vedere la sezione "Gerarchia di ereditarietà e IDisposable" nel <xref:System.IDisposable> argomento.  
  
 Se un oggetto <xref:System.IDisposable.Dispose%2A> metodo viene chiamato più volte, l'oggetto deve ignorare tutte le chiamate successive alla prima. L'oggetto non deve generare un'eccezione se il relativo <xref:System.IDisposable.Dispose%2A> metodo viene chiamato più volte. Metodi di istanza diverso da <xref:System.IDisposable.Dispose%2A> può generare un <xref:System.ObjectDisposedException> quando le risorse sono già state eliminate.  
  
 Gli utenti potrebbero prevedere un tipo di risorsa per usare una convenzione particolare per indicare uno stato allocato o uno stato liberato. Un esempio di questo oggetto è classi di flusso, che vengono in genere considerate aperte o chiuse. Il responsabile dell'implementazione di una classe che ha una convenzione è possibile scegliere di implementare un metodo pubblico con un nome personalizzato, ad esempio `Close`, che chiama il <xref:System.IDisposable.Dispose%2A> metodo.  
  
 Poiché il <xref:System.IDisposable.Dispose%2A> metodo deve essere chiamato in modo esplicito, è sempre il rischio che le risorse non gestite non sarà rilasciato, perché il consumer di un oggetto non riesce a chiamare il relativo <xref:System.IDisposable.Dispose%2A> (metodo). Esistono due modi per evitare questo problema:  
  
-   Eseguire il wrapping della risorsa gestita in un oggetto derivato da <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>. Il <xref:System.IDisposable.Dispose%2A> quindi chiama il <xref:System.IDisposable.Dispose%2A> metodo il <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> istanze. Per ulteriori informazioni, vedere la sezione "Alternativa SafeHandle" il <xref:System.Object.Finalize%2A?displayProperty=nameWithType> argomento.  
  
-   Implementare un finalizzatore per liberare risorse quando <xref:System.IDisposable.Dispose%2A> non viene chiamato. Per impostazione predefinita, il garbage collector chiama automaticamente un finalizzatore dell'oggetto prima di recuperarne la memoria. Tuttavia, se il <xref:System.IDisposable.Dispose%2A> metodo è stato chiamato, non è in genere necessaria per il garbage collector di chiamare il finalizzatore dell'oggetto eliminato. Per impedire il completamento automatico, <xref:System.IDisposable.Dispose%2A> possono chiamare le implementazioni di <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> metodo.  
  
 Quando si utilizza un oggetto che accede a risorse non gestite, ad esempio un <xref:System.IO.StreamWriter>, una procedura consigliata consiste nel creare l'istanza con un `using` istruzione. Il `using` istruzione chiude automaticamente il flusso e chiama <xref:System.IDisposable.Dispose%2A> per l'oggetto quando il codice in uso è stato completato. Per un esempio, vedere la <xref:System.IO.StreamWriter> classe.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come è possibile implementare il <xref:System.IDisposable.Dispose%2A> metodo.  
  
 [!code-cpp[System.IDisposable.Dispose Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CPP/idisposabledispose.cpp#1)]
 [!code-csharp[System.IDisposable.Dispose Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CS/idisposabledispose.cs#1)]
 [!code-vb[System.IDisposable.Dispose Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/VB/idisposabledispose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>