<Type Name="Func&lt;TResult&gt;" FullName="System.Func&lt;TResult&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="32bfd87c717460eeca143861ae42f3f64042f133" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30729725" />
  </Metadata>
  <TypeSignature Language="C#" Value="public delegate TResult Func&lt;out TResult&gt;();" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed Func`1&lt;+ TResult&gt; extends System.MulticastDelegate" />
  <TypeSignature Language="DocId" Value="T:System.Func`1" />
  <TypeSignature Language="VB.NET" Value="Public Delegate Function Func(Of Out TResult)() As TResult " />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TResult&gt;&#xA;public delegate TResult Func();" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TResult">
      <Constraints>
        <ParameterAttribute>Covariant</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")</AttributeName>
    </Attribute>
  </Attributes>
  <Parameters />
  <ReturnValue>
    <ReturnType>TResult</ReturnType>
  </ReturnValue>
  <Docs>
    <typeparam name="TResult">Tipo del valore restituito del metodo incapsulato da questo delegato.</typeparam>
    <summary>Incapsula un metodo che non dispone di parametri e restituisce un valore del tipo specificato dal parametro <typeparamref name="TResult" />.</summary>
    <returns>Valore restituito del metodo incapsulato da questo delegato.</returns>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare questo delegato per rappresentare un metodo che può essere passato come parametro senza dichiarare in modo esplicito un delegato personalizzato. Il metodo incapsulato deve corrispondere alla firma del metodo che è definita da questo delegato. Ciò significa che il metodo incapsulato non deve avere parametri e deve restituire un valore.  
  
> [!NOTE]
>  Per fare riferimento a un metodo che non presenta parametri e restituisce `void` (o in Visual Basic, che è dichiarato come un `Sub` piuttosto che come un `Function`), utilizzare il <xref:System.Action> delegato.  
  
 Quando si utilizza il <xref:System.Func%601> delegato, non è necessario definire in modo esplicito un delegato che incapsula un metodo senza parametri. Ad esempio, il codice seguente dichiara in modo esplicito un delegato denominato `WriteMethod` e assegna un riferimento di `OutputTarget.SendToFile` metodo all'istanza di delegato di istanza.  
  
 [!code-csharp[System.Func~1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Func~1/cs/Delegate.cs#1)]
 [!code-vb[System.Func~1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Func~1/vb/Delegate.vb#1)]  
  
 Nell'esempio seguente viene semplificato questo codice creando il <xref:System.Func%601> delegato anziché la definizione di un nuovo delegato e assegnarle un metodo denominato in modo esplicito.  
  
 [!code-csharp[System.Func~1#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Func~1/cs/Func1.cs#2)]
 [!code-vb[System.Func~1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Func~1/vb/Func1.vb#2)]  
  
 È possibile utilizzare il <xref:System.Func%601> delegato con i metodi anonimi in c#, come illustrato nell'esempio seguente. (Per un'introduzione ai metodi anonimi, vedere [metodi anonimi](~/docs/csharp/programming-guide/statements-expressions-operators/anonymous-methods.md).)  
  
 [!code-csharp[System.Func~1#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Func~1/cs/Anon.cs#3)]  
  
 È inoltre possibile assegnare un'espressione lambda a un <xref:System.Func%602> delegare, come illustrato nell'esempio seguente. (Per un'introduzione alle espressioni lambda, vedere [espressioni Lambda](~/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md) e [espressioni Lambda](~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).)  
  
 [!code-csharp[System.Func~1#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Func~1/cs/Lambda.cs#4)]
 [!code-vb[System.Func~1#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Func~1/vb/Lambda.vb#4)]  
  
 Il tipo sottostante di un'espressione lambda è uno del tipo generico `Func` delegati. Questo rende possibile passare un'espressione lambda come un parametro senza l'assegnazione in modo esplicito a un delegato. In particolare, poiché molti metodi di tipi nel <xref:System.Linq> dispone di spazio dei nomi `Func` parametri, è possibile passare questi metodi di un'espressione lambda senza creare l'istanza in modo esplicito un `Func` delegato.  
  
 Se si dispone di un'attività onerose di calcolo che si desidera eseguire solo se il risultato è effettivamente necessario, è possibile assegnare la funzione dispendiosa a un <xref:System.Func%601> delegato. L'esecuzione della funzione può quindi essere posticipato fino a quando non viene utilizzata una proprietà che accede al valore in un'espressione. L'esempio nella sezione successiva illustra come eseguire questa operazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare un delegato che non accetta parametri. Questo codice crea una classe generica denominata `LazyValue` che dispone di un campo di tipo <xref:System.Func%601>. Questo campo delegato può archiviare un riferimento a qualsiasi funzione che restituisce un valore di tipo che corrisponde al parametro di tipo di `LazyValue` oggetto. Il `LazyValue` tipo dispone anche di un `Value` proprietà che esegue la funzione (se non è già stata eseguita) e restituisce il valore risultante.  
  
 Nell'esempio vengono creati due metodi e un'istanza di due `LazyValue` oggetti con le espressioni lambda che chiamano questi metodi. Le espressioni lambda non accettano parametri, poiché devono chiamare un metodo. Come illustrato nell'output, i due metodi vengono eseguiti solo quando il valore di ogni `LazyValue` viene recuperato l'oggetto.  
  
 [!code-csharp[System.Func~1#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Func~1/cs/Example.cs#5)]
 [!code-vb[System.Func~1#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Func~1/vb/Example.vb#5)]  
  
 ]]></format>
    </remarks>
  </Docs>
</Type>