<Type Name="Uri" FullName="System.Uri">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f31f66dc7ef61083f857685fcdb50a85d836898f" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34174379" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Uri : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Uri extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Uri" />
  <TypeSignature Language="VB.NET" Value="Public Class Uri&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Uri : System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.UriTypeConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce una rappresentazione in forma di oggetto di un identificatore URI (uniform resource identifier) e un pratico accesso alle parti dell'URI.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un URI è una rappresentazione compatta di una risorsa disponibile per l'applicazione nella rete intranet o in Internet. La <xref:System.Uri> classe definisce le proprietà e metodi per la gestione di URI, tra cui l'analisi, confronto e la combinazione. Il <xref:System.Uri> le proprietà di classe sono di sola lettura; per creare un oggetto modificabile, usare la <xref:System.UriBuilder> classe.  
  
 URI relativo (ad esempio, "/ /New/index.htm") deve essere espanso rispetto a un URI di base in modo che siano assoluti. Il <xref:System.Uri.MakeRelative%2A> metodo è fornito per convertire gli URI assoluti in URI relativi quando necessario.  
  
 Il <xref:System.Uri> costruttori senza caratteri di escape stringhe URI se la stringa è un URI ben formato, incluso un identificatore di schema.  
  
 Il <xref:System.Uri> restituiscono una rappresentazione canonica dei dati nella codifica caratteri di escape con tutti i caratteri con valori Unicode maggiori di 127 vengono sostituiti con i relativi equivalenti esadecimali. Per inserire l'URI in forma canonica di <xref:System.Uri> costruttore esegue i passaggi seguenti:  
  
-   Converte lo schema URI in caratteri minuscoli.  
  
-   Converte il nome host in minuscolo.  
  
-   Se il nome host è un indirizzo IPv6, viene utilizzato l'indirizzo IPv6 canonico. ScopeId e altri dati IPv6 facoltativi vengono rimossi.  
  
-   Rimuove predefiniti e i numeri di porta vuoto.

-   I caratteri di escape (noto anche come ottetti codificati in percentuale) che non hanno uno scopo riservato vengono decodificati (noto anche come da non sottoposta a escape). Questi caratteri non riservati non includano lettere maiuscole e lettere minuscole (% % 41 - 5A e % 61-% 7), cifre decimali (30-% 39), trattino (% 2D), punto (% 2E) carattere di sottolineatura (% 5F) e tilde (% 7E).

-   Conversione in formato canonico il percorso per gli URI gerarchici compattando sequenze, ad esempio /. /, /... /, e / / (o meno la sequenza di escape). Si noti che esistono alcuni schemi per cui queste sequenze non vengono compattate.
  
-   Per gli URI gerarchici, se l'host non è stato terminato con una barra (/), viene aggiunto uno.  
  
-   Per impostazione predefinita, i caratteri riservati nell'URI vengono sottoposti a escape in conformità con RFC 2396. Questo comportamento cambia se International Resource Identifier o nome di dominio internazionali durante l'analisi è abilitato in quali casi caratteri riservati nell'URI viene sottoposti a escape in conformità con RFC 3986 e RFC 3987.

 Come parte di canonizzazione nel costruttore per alcuni schemi, punto segmenti e segmenti vuoti (o. /, /... /, e / o) vengono compattati (in altre parole, vengono rimossi). Gli schemi per cui l'URI compatterà queste sequenze includono http, https, tcp, NET. pipe e NET. TCP. Per altri schemi, le sequenze non vengono compattate. Di seguito è illustrato l'aspetto di questo processo di compattazione in pratica.
  
```  
var uri = new Uri("http://myUrl/../.."); // http scheme, unescaped
OR
var uri = new Uri("http://myUrl/%2E%2E/%2E%2E"); // http scheme, escaped
OR
var uri = new Uri("ftp://myUrl/../.."); // ftp scheme, unescaped
OR
var uri = new Uri("ftp://myUrl/%2E%2E/%2E%2E"); // ftp scheme, escaped

Console.WriteLine(uri.AbsoluteUri);  
Console.WriteLine(uri.PathAndQuery);  
```  
  
 Quando viene eseguito questo codice, viene restituito il seguente output con sequenze di escape senza caratteri di escape se necessario e quindi compattato.

```  
http://myUrl/  
/  
```  
  
 È possibile trasformare il contenuto del <xref:System.Uri> classe da un riferimento URI con escape con codificata a un riferimento URI leggibile utilizzando il <xref:System.Uri.ToString%2A> metodo. Si noti che alcuni caratteri riservati potrebbero comunque essere sottoposto a escape nell'output del <xref:System.Uri.ToString%2A> metodo. Si tratta di supportare la ricostruzione non ambigua di un URI dal valore restituito da <xref:System.Uri.ToString%2A>.  
  
 Alcuni URI includono un identificatore di frammento o una query o entrambi. Un identificatore di frammento è qualsiasi testo che segue un simbolo di cancelletto (#), senza includere il simbolo di cancelletto; il testo del frammento viene archiviato nel <xref:System.Uri.Fragment%2A> proprietà. Informazioni sulle query è qualsiasi testo che segue un punto interrogativo (?) nell'URI; il testo della query viene archiviato nel <xref:System.Uri.Query%2A> proprietà.  
  
 In .NET Framework versione 1.1, se la stringa specificata di un costruttore contiene uno schema sconosciuto e "c:\\", gli inserimenti di classe Uri "/ /" dopo i due punti. Ad esempio, l'URI `xyz:c:\abc` viene convertito in `xyz://c:/abc`. In .NET Framework versione 2.0, questo comportamento è stato rimosso e la stringa di esempio viene convertita in `xyz:c:/abc`.  
  
> [!NOTE]
>  La classe URI supporta l'utilizzo di indirizzi IP in entrambi notazione per il protocollo IPv4 ed esadecimale con due punti per il protocollo IPv6. È necessario racchiudere l'indirizzo IPv6 tra parentesi quadre, come http://[::1].  
  
## <a name="international-resource-identifier-support"></a>Supporto dell'identificatore di risorse internazionali  
 Gli indirizzi Web sono in genere espressi tramite uniform resource identifier costituiti da un set molto limitato di caratteri:  
  
-   Lettere ASCII maiuscole e minuscole dell'alfabeto inglese.  
  
-   Cifre comprese tra 0 e 9.  
  
-   Numero ridotto di altri simboli ASCII.  
  
 Le specifiche per gli URI sono documentate nella RFC 2396, RFC 2732, RFC 3986 e RFC 3987 pubblicata da Internet Engineering Task Force (IETF).  
  
 Con la crescita di Internet, è sempre più necessario identificare le risorse che usano lingue diverse dall'inglese. Gli identificatori semplificano le operazioni a questo scopo e fanno sì che caratteri non ASCII (caratteri inclusi nel set di caratteri Unicode/ISO 10646) vengano riconosciuti come International Resource Identifier (IRI). Le specifiche per gli IRI sono documentate nella nota RFC 3987, pubblicata da IETF. L'uso di IRI permette a un URL di includere caratteri Unicode.  
  
 Esistente <xref:System.Uri> classe è stata estesa in .NET Framework v 3.5, 3.0 SP1 e 2.0 SP1 per fornire il supporto per IRI basati su RFC 3987. A meno che non consentono in modo specifico IRI agli utenti di versioni di .NET Framework precedenti alla versione 4.5 non visualizzeranno qualsiasi modifica rispetto al comportamento di .NET Framework 2.0. Questo garantisce la compatibilità delle applicazioni con le versioni precedenti di .NET Framework.  
  
 Per abilitare il supporto per IRI, è necessaria la modifica seguente:  
  
-   Specificare se l'analisi IDN (Internationalized Domain Name) applicata al nome di dominio e se devono essere applicate le regole di analisi IRI. Questa operazione può essere eseguita *Machine. config* oppure il *app. config* file. Ad esempio, aggiungere quanto segue:  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 Gli utenti di .NET Framework 4.5 e versioni più recenti dispongono sempre IRI abilitato. Analisi IRI non può essere modificato utilizzando un *config* file.  
  
 L'abilitazione degli IDN comporta la conversione di tutte le etichette Unicode in un nome di dominio nei rispettivi equivalenti Punycode. I nomi Punycode contengono solo caratteri ASCII e iniziano sempre con il prefisso "xn--". Questo avviene per supportare i server DNS esistenti in Internet, in quanto la maggior parte dei server DNS supporta solo caratteri ASCII. Vedere il documento RFC 3940.  
  
 L'abilitazione di IRI e IDN influisce sul valore della proprietà <xref:System.Uri.DnsSafeHost%2A?displayProperty=nameWithType>. L'abilitazione di IRI e IDN può anche modificare il comportamento dei metodi <xref:System.Uri.Equals%2A>, <xref:System.Uri.OriginalString%2A>, <xref:System.Uri.GetComponents%2A> e <xref:System.Uri.IsWellFormedOriginalString%2A>.  
  
 Esistono tre possibili valori per IDN a seconda di server DNS che vengono utilizzati:  
  
-   IDN abilitata = All  
  
     Questo valore convertirà qualsiasi nome di dominio Unicode negli equivalenti Punycode (nomi IDN).  
  
-   IDN abilitata = AllExceptIntranet  
  
     Questo valore verrà convertito tutti i nomi di dominio Unicode non sulla rete Intranet locale per l'utilizzo degli equivalenti Punycode (nomi IDN). In questo caso, per gestire nomi internazionali sulla rete Intranet locale, i server DNS utilizzati per la rete Intranet devono supportare la risoluzione dei nomi di Unicode.  
  
-   IDN abilitata = nessuno  
  
     Questo valore non convertirà alcun nome di dominio Unicode per l'utilizzo di Punycode Questo è il valore predefinito è coerenza con il comportamento di .NET Framework 2.0.  
  
 Quando è abilitata l'analisi IRI (iriParsing abilitato = `true`) la normalizzazione e il controllo dei caratteri vengono eseguite in base alle ultime regole IRI in RFC 3986 e RFC 3987. Quando l'analisi IRI è disabilitata, la normalizzazione e il controllo dei caratteri vengono eseguiti in base allo standard RFC 2396 e RFC 2732 (per i valori letterali IPv6).  Nelle versioni di .NET Framework precedenti alla versione 4.5, il valore predefinito è `false`. In .NET Framework versione 4.5 e successive, il valore predefinito è `true`, lo stato di abilitazione di analisi IRI non può essere modificata dalle impostazioni in un *config* file.  
  
 IRI e IDN elaborazione il <xref:System.Uri> classe può essere controllata anche utilizzando la <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType>, <xref:System.Configuration.IdnElement?displayProperty=nameWithType>, e <xref:System.Configuration.UriSection?displayProperty=nameWithType> classi di impostazioni di configurazione. L'impostazione <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> abilita o disabilita l'elaborazione degli IRI nella classe <xref:System.Uri>. L'impostazione <xref:System.Configuration.IdnElement?displayProperty=nameWithType> abilita o disabilita l'elaborazione degli IDN nella classe <xref:System.Uri>. L'impostazione <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> controlla anche indirettamente gli IDN. L'elaborazione degli IRI deve essere abilitata perché sia possibile elaborare gli IDN. Se l'elaborazione degli IRI è disabilitata, l'elaborazione degli IDN usa l'impostazione predefinita, basata sul comportamento di .NET Framework 2.0 per motivi di compatibilità e i nomi IDN non vengono usati.  
  
 L'impostazione di configurazione per il <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> e <xref:System.Configuration.IdnElement?displayProperty=nameWithType> verranno letti una volta quando il primo <xref:System.Uri?displayProperty=nameWithType> classe viene costruita. Le modifiche apportate alle impostazioni di configurazione da questo momento in poi verranno ignorate.  
  
 La classe <xref:System.GenericUriParser?displayProperty=nameWithType> è stata estesa anche per consentire la creazione di un parser personalizzabile che supporta gli IRI e gli IDN. Il comportamento di un oggetto <xref:System.GenericUriParser?displayProperty=nameWithType> è specificato passando una combinazione bit per bit dei valori disponibili nell'enumerazione <xref:System.GenericUriParserOptions?displayProperty=nameWithType> al costruttore <xref:System.GenericUriParser?displayProperty=nameWithType>. Il tipo <xref:System.GenericUriParserOptions.IriParsing?displayProperty=nameWithType> indica che il parser supporta le regole specificate nel documento RFC 3987 per gli IRI (International Resource Identifier). Se viene utilizzato IRI dipende dai valori di configurazione illustrati in precedenza.  
  
 Il tipo <xref:System.GenericUriParserOptions.Idn?displayProperty=nameWithType> indica che il parser supporta l'analisi degli IDN (Internationalized Domain Name) dei nomi host. Se l'utilizzo di IDN dipende dai valori di configurazione illustrati in precedenza.  
  
## <a name="performance-considerations"></a>Considerazioni sulle prestazioni  
 Se si utilizza un *Web.config * file che contiene l'URI per inizializzare il tempo applicazione, altro è necessarie per elaborare gli URI se gli identificatori di schema siano non standard. In tal caso, inizializzare le parti interessate dell'applicazione quando sono necessari gli URI, non in fase di avvio.  
  
   
  
## Examples  
 Nell'esempio seguente crea un'istanza di <xref:System.Uri> classe e viene utilizzato per creare un <xref:System.Net.WebRequest> istanza.  
  
 [!code-cpp[Classic Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>A causa di problemi di sicurezza, l'applicazione deve prestare attenzione quando si accettano <see cref="T:System.Uri" /> istanze da origini non attendibili e con <paramref name="dontEscape" /> impostato su <see langword="true" />. È possibile controllare la validità di una stringa URI chiamando il <see cref="M:System.Uri.IsWellFormedOriginalString" /> metodo.</para>
    </block>
    <altmember cref="T:System.Configuration.IdnElement" />
    <altmember cref="T:System.Configuration.IriParsingElement" />
    <altmember cref="T:System.Configuration.UriSection" />
    <altmember cref="P:System.Uri.DnsSafeHost" />
    <altmember cref="M:System.Uri.MakeRelative(System.Uri)" />
    <altmember cref="M:System.Uri.IsWellFormedOriginalString" />
    <altmember cref="T:System.UriBuilder" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Uri" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriString">Stringa che identifica la risorsa che deve essere rappresentata dall'istanza di <see cref="T:System.Uri" />. Si noti che un indirizzo IPv6 in formato di stringa deve essere racchiuso tra parentesi quadre. Ad esempio, "http://[2607:f8b0:400d:c06::69]".</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Uri" /> con l'URI specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un <xref:System.Uri> istanza da una stringa URI. Analizza l'URI, lo inserisce in formato canonico e rende escape richiesto.  
  
 Questo costruttore non garantisce che il <xref:System.Uri> fa riferimento a una risorsa accessibile.  
  
 Questo costruttore si presuppone che il `string` parametro fa riferimento a un URI assoluto ed è equivalente alla chiamata di <xref:System.Uri.%23ctor%2A> costruttore con <xref:System.UriKind> impostato su <xref:System.UriKind.Absolute>. Se il `string` parametro passato al costruttore non è un URI relativo, il costruttore genererà un <xref:System.UriFormatException>.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Uri> istanza con l'URI "http://www.contoso.com/".  
  
 [!code-cpp[Classic Uri.Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> è <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>In [.NET per le app Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), individuare in alternativa l'eccezione della classe base <see cref="T:System.FormatException" />.</para>
          </block>
          <paramref name="uriString" /> è vuoto.  - oppure - Lo schema specificato in <paramref name="uriString" /> non ha un formato corretto. Vedere <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  - oppure - <paramref name="uriString" /> contiene troppe barre.  - oppure - La password specificata in <paramref name="uriString" /> non è valida.  - oppure - Il nome host specificato in <paramref name="uriString" /> non è valido.  - oppure - Il nome file specificato in <paramref name="uriString" /> non è valido.  - oppure - Il nome utente specificato in <paramref name="uriString" /> non è valido.  - oppure - Il nome host o dell'autorità specificato in <paramref name="uriString" /> non può terminare con barre rovesciate.  - oppure - Il numero di porta specificato in <paramref name="uriString" /> non è valido e non può essere analizzato.  - oppure - La lunghezza di <paramref name="uriString" /> supera i 65519 caratteri.  - oppure - La lunghezza dello schema specificato in <paramref name="uriString" /> supera 1023 caratteri.  - oppure - <paramref name="uriString" /> contiene una sequenza di caratteri non valida.  - oppure - Il percorso MS-DOS specificato in <paramref name="uriString" /> deve iniziare con c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Uri (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Uri(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Istanza della classe <see cref="T:System.Runtime.Serialization.SerializationInfo" /> contenente le informazioni necessarie per serializzare la nuova istanza di <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Istanza della classe <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenente l'origine del flusso serializzato associato alla nuova istanza di <see cref="T:System.Uri" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Uri" /> dalle istanze specificate delle classi <see cref="T:System.Runtime.Serialization.SerializationInfo" /> e <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore implementa il <xref:System.Runtime.Serialization.ISerializable> interfaccia per la <xref:System.Uri> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="serializationInfo" /> contiene l'URI <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">Il parametro <paramref name="serializationInfo" /> contiene un URI che è vuoto.  - oppure - Lo schema specificato non ha un formato corretto. Vedere <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  - oppure - L'URI contiene troppe barre.  - oppure - La password specificata nell'URI non è valida.  - oppure - Il nome host specificato nell'URI non è valido.  - oppure - Il nome file specificato nell'URI non è valido.  - oppure - Il nome utente specificato nell'URI non è valido.  - oppure - Il nome host o dell'autorità specificato nell'URI non può terminare con barre rovesciate.  - oppure - Il numero di porta specificato nell'URI non è valido e non può essere analizzato.  - oppure - La lunghezza dell'URI supera i 65519 caratteri.  - oppure - La lunghezza dello schema specificato nell'URI supera i 1023 caratteri.  - oppure - L'URI contiene una sequenza di caratteri non valida.  - oppure - Il percorso MS-DOS specificato nell'URI deve iniziare con c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, bool dontEscape);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="uriString">Stringa che identifica la risorsa che deve essere rappresentata dall'istanza di <see cref="T:System.Uri" />. Si noti che un indirizzo IPv6 in formato di stringa deve essere racchiuso tra parentesi quadre. Ad esempio, "http://[2607:f8b0:400d:c06::69]".</param>
        <param name="dontEscape">
          <see langword="true" /> se <c>uriString</c> è sottoposto a escape in modo completo, in caso contrario <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Uri" /> con l'URI specificato e con il controllo esplicito dell'escape dei caratteri.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un <xref:System.Uri> istanza da una stringa URI. Analizza l'URI e lo inserisce in formato canonico.  
  
 Il `dontEscape` parametro determina se i caratteri riservati vengono convertiti in sequenze di escape. Questo parametro deve essere impostato su `true` solo se si è certi che tutti i caratteri riservati nell'URI siano stati sottoposti a escape. Impostazione del valore su `true` per un URI che non sottoposto a escape completo può causare comportamenti imprevisti. È consigliabile impostare sempre questo parametro `false`.  
  
 Se `dontEscape` è impostato su `false`, il costruttore di sequenze di escape qualsiasi carattere riservato controllando che tutte le occorrenze di percentuale (%)) sono seguite da una sequenza di escape valida. Se la sequenza di caratteri seguente percentuale non è valida, la percentuale viene sostituita da % 25.  
  
 Questo costruttore non garantisce che il <xref:System.Uri> fa riferimento a una risorsa accessibile.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una <xref:System.Uri> istanza per l'URI http://www.contoso.com/Hello%20World.htm. Poiché l'URI contenuto è preceduto da caratteri di escape e presenta il formato canonico, il `dontEscape` parametro può essere impostato su `true`.  
  
 [!code-cpp[Classic Uri.Uri1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> è <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="uriString" /> è vuoto o contiene solo spazi.  - oppure - Lo schema specificato in <paramref name="uriString" /> non è valido.  - oppure - <paramref name="uriString" /> contiene troppe barre.  - oppure - La password specificata in <paramref name="uriString" /> non è valida.  - oppure - Il nome host specificato in <paramref name="uriString" /> non è valido.  - oppure - Il nome file specificato in <paramref name="uriString" /> non è valido.  - oppure - Il nome utente specificato in <paramref name="uriString" /> non è valido.  - oppure - Il nome host o dell'autorità specificato in <paramref name="uriString" /> non può terminare con barre rovesciate.  - oppure - Il numero di porta specificato in <paramref name="uriString" /> non è valido e non può essere analizzato.  - oppure - La lunghezza di <paramref name="uriString" /> supera i 65519 caratteri.  - oppure - La lunghezza dello schema specificato in <paramref name="uriString" /> supera 1023 caratteri.  - oppure - <paramref name="uriString" /> contiene una sequenza di caratteri non valida.  - oppure - Il percorso MS-DOS specificato in <paramref name="uriString" /> deve iniziare con c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, UriKind uriKind);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">Stringa che identifica la risorsa che deve essere rappresentata dall'istanza di <see cref="T:System.Uri" />. Si noti che un indirizzo IPv6 in formato di stringa deve essere racchiuso tra parentesi quadre. Ad esempio, "http://[2607:f8b0:400d:c06::69]".</param>
        <param name="uriKind">Specifica se la stringa URI è un URI relativo, un URI assoluto o se è indeterminata.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Uri" /> con l'URI specificato. Questo costruttore consente di specificare se la stringa URI è un URI relativo, un URI assoluto o se è indeterminata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URI relativi e assoluti presentano diverse restrizioni sui loro formato. Ad esempio, un URI relativo non richiede uno schema o un'autorità. Il valore specificato in `uriKind` deve corrispondere al tipo di URI passato in `uriString`. Tuttavia, se <xref:System.UriKind.RelativeOrAbsolute> viene specificato, la stringa URI può essere relativo o assoluto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="uriKind" /> non è valido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> è <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>In [.NET per le app Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), individuare in alternativa l'eccezione della classe base <see cref="T:System.FormatException" />.</para>
          </block>
          <paramref name="uriString" /> contiene un URI relativo e <paramref name="uriKind" /> è <see cref="F:System.UriKind.Absolute" />.  oppure <paramref name="uriString" /> contiene un URI assoluto e <paramref name="uriKind" /> è <see cref="F:System.UriKind.Relative" />.  oppure <paramref name="uriString" /> è vuoto.  - oppure - Lo schema specificato in <paramref name="uriString" /> non ha un formato corretto. Vedere <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  - oppure - <paramref name="uriString" /> contiene troppe barre.  - oppure - La password specificata in <paramref name="uriString" /> non è valida.  - oppure - Il nome host specificato in <paramref name="uriString" /> non è valido.  - oppure - Il nome file specificato in <paramref name="uriString" /> non è valido.  - oppure - Il nome utente specificato in <paramref name="uriString" /> non è valido.  - oppure - Il nome host o dell'autorità specificato in <paramref name="uriString" /> non può terminare con barre rovesciate.  - oppure - Il numero di porta specificato in <paramref name="uriString" /> non è valido e non può essere analizzato.  - oppure - La lunghezza di <paramref name="uriString" /> supera i 65519 caratteri.  - oppure - La lunghezza dello schema specificato in <paramref name="uriString" /> supera 1023 caratteri.  - oppure - <paramref name="uriString" /> contiene una sequenza di caratteri non valida.  - oppure - Il percorso MS-DOS specificato in <paramref name="uriString" /> deve iniziare con c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseUri">URI di base.</param>
        <param name="relativeUri">URI relativo da aggiungere all'URI di base.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Uri" /> basata sull'URI di base specificato e sulla stringa URI relativa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un <xref:System.Uri> istanza combinando il `baseUri` e `relativeUri`. Se `relativeUri` è un URI assoluto (contenente una combinazione di nome host e, facoltativamente, un numero di porta), il <xref:System.Uri> istanza viene creata utilizzando solo `relativeUri`.  
 
 Se il `baseUri` è costituito da parti relativo (come `/api`), quindi la parte relativa deve terminare con una barra (come `/api/`), se la parte relativa `baseUri` deve essere mantenuto in costruito <xref:System.Uri>. 

 Inoltre, se il `relativeUri` inizia con una barra, quindi qualsiasi parte del relativo sostituirà il `baseUri`

 Questo costruttore non garantisce che il <xref:System.Uri> fa riferimento a una risorsa accessibile.  
  
   
  
## Examples  
 Nell'esempio seguente crea una nuova istanza di <xref:System.Uri> classe combinando gli URI relativi http://www.contoso.com /catalog/shownew.htm per formare l'URI assoluto e http://www.contoso.com/catalog/shownew.htm.  
  
 [!code-cpp[Classic Uri.Uri3 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri3 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" /> non è un'istanza di <see cref="T:System.Uri" /> assoluta.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para> In [.NET per le app Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), individuare in alternativa l'eccezione della classe base <see cref="T:System.FormatException" />.</para>
          </block> L'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> è vuoto o contiene solo spazi.  - oppure - Lo schema specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  - oppure - L'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> contiene troppe barre.  - oppure - La password specificata nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valida.  - oppure - Il nome host specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  - oppure - Il nome file specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  - oppure - Il nome utente specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  - oppure - Il nome host o dell'autorità specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non può terminare con barre rovesciate.  - oppure - Il numero di porta specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido o non può essere analizzato.  - oppure - La lunghezza dell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> supera i 65519 caratteri.  - oppure - La lunghezza dello schema specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> supera i 1023 caratteri.  - oppure - È presente una sequenza di caratteri non valida nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" />.  - oppure - Il percorso MS-DOS specificato in <paramref name="uriString" /> deve iniziare con c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, Uri relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, class System.Uri relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, Uri ^ relativeUri);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="baseUri">Oggetto <see cref="T:System.Uri" /> assoluto che costituisce la base per la nuova istanza di <see cref="T:System.Uri" />.</param>
        <param name="relativeUri">Istanza di <see cref="T:System.Uri" /> relativa combinata con <c>baseUri</c>.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Uri" /> sulla combinazione di un'istanza di <see cref="T:System.Uri" /> di base specificata e un'istanza di <see cref="T:System.Uri" /> relativa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un nuovo <xref:System.Uri> istanza combinando assoluto <xref:System.Uri> istanza, `baseUri`, con un valore relativo <xref:System.Uri> istanza `relativeUri`. Se `relativeUri` è assoluto <xref:System.Uri> istanza (contenente una combinazione di nome host e, facoltativamente, un numero di porta), il <xref:System.Uri> istanza viene creata utilizzando solo `relativeUri`.  
 
 Se il `baseUri` è costituito da parti relativo (come `/api`), quindi la parte relativa deve terminare con una barra (come `/api/`), se la parte relativa `baseUri` deve essere mantenuto in costruito <xref:System.Uri>. 

 Inoltre, se il `relativeUri` inizia con una barra, quindi qualsiasi parte del relativo sostituirà il `baseUri`
 
 Questo costruttore non garantisce che il <xref:System.Uri> fa riferimento a una risorsa accessibile.  
  
   
  
## Examples  
 Questo esempio viene creato un assoluto <xref:System.Uri> istanza, `absoluteUri`, relativo <xref:System.Uri> istanza `relativeUri`. Un nuovo <xref:System.Uri> istanza, `combinedUri`, quindi viene creato da queste due istanze.  
  
 [!code-cpp[NCLUriEnhancements#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#2)]
 [!code-csharp[NCLUriEnhancements#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#2)]
 [!code-vb[NCLUriEnhancements#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="baseUri" /> non è un'istanza di <see cref="T:System.Uri" /> assoluta.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" /> non è un'istanza di <see cref="T:System.Uri" /> assoluta.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para> In [.NET per le app Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), individuare in alternativa l'eccezione della classe base <see cref="T:System.FormatException" />.</para>
          </block> L'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> è vuoto o contiene solo spazi.  - oppure - Lo schema specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  - oppure - L'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> contiene troppe barre.  - oppure - La password specificata nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valida.  - oppure - Il nome host specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  - oppure - Il nome file specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  - oppure - Il nome utente specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  - oppure - Il nome host o dell'autorità specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non può terminare con barre rovesciate.  - oppure - Il numero di porta specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido o non può essere analizzato.  - oppure - La lunghezza dell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> supera i 65519 caratteri.  - oppure - La lunghezza dello schema specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> supera i 1023 caratteri.  - oppure - È presente una sequenza di caratteri non valida nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" />.  - oppure - Il percorso MS-DOS specificato in <paramref name="uriString" /> deve iniziare con c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri, bool dontEscape);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="baseUri">URI di base.</param>
        <param name="relativeUri">URI relativo da aggiungere all'URI di base.</param>
        <param name="dontEscape">
          <see langword="true" /> se <c>uriString</c> è sottoposto a escape in modo completo, in caso contrario <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Uri" /> basata sugli URI di base e relativi specificati, con controllo esplicito dell'escape dei caratteri.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un <xref:System.Uri> istanza combinando `baseUri` e `relativeUri`. Se l'URI passato in `relativeUri` è un URI assoluto (contenente una combinazione di nome host e, facoltativamente, un numero di porta), il <xref:System.Uri> istanza viene creata utilizzando solo `relativeUri`.  
  
 Il `dontEscape` parametro determina se i caratteri riservati vengono convertiti in sequenze di escape. Questo parametro deve essere impostato su `true` solo se si è certi che tutti i caratteri riservati nell'URI siano stati sottoposti a escape. Impostazione del valore su `true` per un URI che non sottoposto a escape completo può causare comportamenti imprevisti. È consigliabile impostare sempre questo parametro `false`. Se `dontEscape` è impostato su `false`, il costruttore di sequenze di escape qualsiasi carattere riservato controllando che tutte le occorrenze di percentuale (%)) sono seguite da una sequenza di escape valida. Se la sequenza di caratteri seguente percentuale non è valida, la percentuale viene sostituita da % 25.  
  
 Questo costruttore non garantisce che il <xref:System.Uri> fa riferimento a una risorsa accessibile.  
  
   
  
## Examples  
 Nell'esempio seguente crea una nuova istanza di <xref:System.Uri> classe combinando gli URI relativi http://www.contoso.com e Hello%20World.htm in modo da formare un URI assoluto.  
  
 [!code-cpp[Classic Uri.Uri4 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri4 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" /> non è un'istanza di <see cref="T:System.Uri" /> assoluta.</exception>
        <exception cref="T:System.UriFormatException">L'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> è vuoto o contiene solo spazi.  - oppure - Lo schema specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  - oppure - L'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> contiene troppe barre.  - oppure - La password specificata nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valida.  - oppure - Il nome host specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  - oppure - Il nome file specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  - oppure - Il nome utente specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  - oppure - Il nome host o dell'autorità specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non può terminare con barre rovesciate.  - oppure - Il numero di porta specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido o non può essere analizzato.  - oppure - La lunghezza dell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> supera i 65519 caratteri.  - oppure - La lunghezza dello schema specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> supera i 1023 caratteri.  - oppure - È presente una sequenza di caratteri non valida nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" />.  - oppure - Il percorso MS-DOS specificato in <paramref name="uriString" /> deve iniziare con c:\\\\.</exception>
        <block subset="none" type="usage">
          <para>A causa di problemi di sicurezza, l'applicazione non chiami il costruttore con stringhe URI da origini non attendibili e con <paramref name="dontEscape" /> impostato su <see langword="true" />. In alternativa, è possibile verificare la validità di una stringa URI chiamando il <see cref="M:System.Uri.IsWellFormedOriginalString" /> metodo prima di chiamare questo costruttore.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AbsolutePath">
      <MemberSignature Language="C#" Value="public string AbsolutePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsolutePath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsolutePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsolutePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsolutePath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il percorso assoluto dell'URI.</summary>
        <value>Oggetto <see cref="T:System.String" /> contenente il percorso assoluto della risorsa.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.AbsolutePath%2A> proprietà contiene le informazioni sul percorso utilizzato dal server per risolvere le richieste di informazioni. In genere, questo è il percorso per le informazioni desiderate nel file system del server, anche se è possibile indicare anche l'applicazione o il server deve eseguire per fornire le informazioni di script.  
  
 Le informazioni sul percorso non include lo schema, nome host o parte di query dell'URI.  
  
   
  
## Examples  
 Nell'esempio seguente scrive /catalog/shownew.htm il percorso nella console.  
  
 [!code-cpp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsolutePath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="AbsoluteUri">
      <MemberSignature Language="C#" Value="public string AbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsoluteUri As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsoluteUri { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'URI assoluto.</summary>
        <value>Oggetto <see cref="T:System.String" /> contenente l'URI intero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.AbsoluteUri%2A> proprietà include l'URI intero memorizzato nel <xref:System.Uri> istanza, inclusi tutti i frammenti e le stringhe di query.  
  
   
  
## Examples  
 Nell'esempio seguente scrive il contenuto completo del <xref:System.Uri> istanza nella console. Nell'esempio illustrato, http://www.contoso.com/catalog/shownew.htm?date=today viene scritto nella console.  
  
 [!code-cpp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="Authority">
      <MemberSignature Language="C#" Value="public string Authority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Authority" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Authority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authority As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Authority { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome host DNS (Domain Name System) o l'indirizzo IP e il numero di porta per un server.</summary>
        <value>Oggetto <see cref="T:System.String" /> contenente il componente autorità dell'URI rappresentato da questa istanza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.Authority%2A> proprietà è in genere un nome host DNS del server o indirizzo IP. Se è diversa dalla porta predefinita per l'URI, questa proprietà includono il numero di porta del servizio. Se il <xref:System.Uri.Authority%2A> componente contiene caratteri riservati, questi vengono sottoposti a escape nel valore della stringa restituito da questa proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente scrive il nome host (www.contoso.com) e il numero di porta (8080) del server nella console.  
  
 [!code-cpp[Classic Uri.Authority Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Authority Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Authority Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Authority Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Authority Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Authority Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="Canonicalize">
      <MemberSignature Language="C#" Value="protected virtual void Canonicalize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Canonicalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Canonicalize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Canonicalize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Canonicalize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte in formato canonico l'URI archiviato internamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Archivia internamente la versione canonica dell'URI.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questo metodo è valido solo per URI assoluti.</exception>
        <exception cref="T:System.UriFormatException">L'URI non è formato correttamente.</exception>
      </Docs>
    </Member>
    <Member MemberName="CheckHostName">
      <MemberSignature Language="C#" Value="public static UriHostNameType CheckHostName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UriHostNameType CheckHostName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckHostName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckHostName (name As String) As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UriHostNameType CheckHostName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome host da convalidare. Può essere un indirizzo IPv4 o IPv6 oppure un nome host Internet.</param>
        <summary>Determina se il nome host specificato è un nome DNS valido.</summary>
        <returns>Oggetto <see cref="T:System.UriHostNameType" /> che indica il tipo del nome host. Se non è possibile determinare il tipo del nome host o se il nome host è <see langword="null" /> oppure è una stringa di lunghezza zero, questo metodo restituisce <see cref="F:System.UriHostNameType.Unknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.CheckHostName%2A> metodo controlla che il nome host specificato soddisfi i requisiti per un nome host Internet valido. Non tuttavia eseguire una ricerca del nome host per verificare l'esistenza dell'host.  
  
   
  
## Examples  
 Nell'esempio seguente controlla se il nome host è valido.  
  
 [!code-cpp[Classic Uri.CheckHostName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.CheckHostName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.CheckHostName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSchemeName">
      <MemberSignature Language="C#" Value="public static bool CheckSchemeName (string schemeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CheckSchemeName(string schemeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSchemeName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckSchemeName (schemeName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CheckSchemeName(System::String ^ schemeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="schemeName">Nome dello schema da convalidare.</param>
        <summary>Determina se il nome dello schema specificato è valido.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se il nome dello schema è valido; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo controlla il nome dello schema per la validità in base allo standard RFC 2396 per impostazione predefinita. Se è abilitata l'International Resource Identifier (IRIs) o l'analisi IDN (Internationalized Domain Name), questo metodo controlla il nome dello schema per la validità in base allo standard RFC 3986. Il nome dello schema deve iniziare con una lettera e deve contenere solo lettere, cifre e i caratteri ".", "+" o "-".  
  
 Per ulteriori informazioni sul supporto IRI, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza e controlla se il nome dello schema è valido.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSecurity">
      <MemberSignature Language="C#" Value="protected virtual void CheckSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CheckSecurity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSecurity" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CheckSecurity ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CheckSecurity();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>La chiamata a questo metodo non ha effetto.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(class System.Uri uri1, class System.Uri uri2, valuetype System.UriComponents partsToCompare, valuetype System.UriFormat compareFormat, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Compare(System.Uri,System.Uri,System.UriComponents,System.UriFormat,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (uri1 As Uri, uri2 As Uri, partsToCompare As UriComponents, compareFormat As UriFormat, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(Uri ^ uri1, Uri ^ uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
        <Parameter Name="partsToCompare" Type="System.UriComponents" />
        <Parameter Name="compareFormat" Type="System.UriFormat" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="uri1">Primo oggetto <see cref="T:System.Uri" />.</param>
        <param name="uri2">Secondo oggetto <see cref="T:System.Uri" />.</param>
        <param name="partsToCompare">Combinazione bit per bit dei valori di <see cref="T:System.UriComponents" /> che specifica le parti di <c>uri1</c> e <c>uri2</c> da confrontare.</param>
        <param name="compareFormat">Uno dei valori di <see cref="T:System.UriFormat" /> che specifica l'escape dei caratteri usato durante il confronto dei componenti dell'URI.</param>
        <param name="comparisonType">Uno dei valori di <see cref="T:System.StringComparison" />.</param>
        <summary>Confronta le parti specificate dei due URI usando le regole di confronto specificate.</summary>
        <returns>Valore <see cref="T:System.Int32" /> che indica la relazione lessicale tra i componenti <see cref="T:System.Uri" /> confrontati.  
  
 <list type="table"><listheader><term> Valore  </term><description> Significato  </description></listheader><item><term> Minore di zero  </term><description><paramref name="uri1" /> è minore di <paramref name="uri2" />.  </description></item><item><term> Zero  </term><description><paramref name="uri1" /> è uguale a <paramref name="uri2" />.  </description></item><item><term> Maggiore di zero  </term><description><paramref name="uri1" /> è maggiore di <paramref name="uri2" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se entrambi `uri1` e `uri2` sono `null`, questo metodo restituisce 0. Quando si confrontano i valori URI, un URI relativo è sempre minore di un URI assoluto e un URI non null è sempre maggiore di un URI null. Per i casi in cui entrambi `uri1` e `uri2` non `null` e sono entrambi URI relativi o entrambi URI assoluti, il <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> metodo esegue il confronto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore valido di <see cref="T:System.StringComparison" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DnsSafeHost">
      <MemberSignature Language="C#" Value="public string DnsSafeHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DnsSafeHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.DnsSafeHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DnsSafeHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DnsSafeHost { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un nome host che, dopo la rimozione dei caratteri di escape, se necessario, può essere usato in sicurezza per la risoluzione DNS.</summary>
        <value>Oggetto <see cref="T:System.String" /> che contiene la parte host dell'URI in un formato appropriato per la risoluzione DNS oppure stringa host originale, se già adatta per la risoluzione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per gli indirizzi IPv6, le parentesi quadre ([]) vengono rimossi e <xref:System.Net.IPAddress.ScopeId%2A> è impostata, se ne è stata specificata una costruzione di questa istanza.

Se è stata utilizzata una stringa di escape per costruire l'istanza (ad esempio, "http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), quindi DnsSafeHost restituisce una stringa di escape. Unescape restituito da qualsiasi stringa di escape `DnsSafeHost` prima di usare tale stringa per la risoluzione DNS (vedere l'esempio). Se è stata utilizzata una stringa senza caratteri escape non valida per costruire l'istanza (ad esempio, "http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm"), quindi DnsSafeHost restituisce una stringa senza caratteri escape.
  
 Il <xref:System.Uri.DnsSafeHost%2A> proprietà è dipendente da impostazioni di configurazione, come descritto più avanti in questo argomento. Le impostazioni di configurazione non possono essere modificate dalle applicazioni Windows Store, che possono causare risultati incoerenti quando si utilizza <xref:System.Uri.DnsSafeHost%2A>. Il <xref:System.Uri.IdnHost%2A> proprietà viene fornita l'alternativa preferita all'utilizzo <xref:System.Uri.DnsSafeHost%2A>perché <xref:System.Uri.IdnHost%2A> è garantito che siano sempre DNS-safe, indipendentemente da quali corrente *app* impostazioni potrebbero essere.  
  
 Il <xref:System.Uri.DnsSafeHost%2A> proprietà è stata estesa in .NET Framework v 3.5, 3.0 SP1 e 2.0 SP1 per fornire l'identificatore IRI (International Resource) supporta in base a RFC 3987. Gli utenti non noteranno alcun cambiamento dal comportamento di .NET Framework 2.0, a meno che non abilitino in modo specifico gli URI. Questo garantisce la compatibilità delle applicazioni con le versioni precedenti di .NET Framework.  
  
 Per abilitare il supporto per IRI, sono necessarie le seguenti due modifiche:  
  
1.  Aggiungere la seguente riga per il *Machine. config* file nella directory di .NET Framework 2.0  
  
     \<section name="uri" type="System.Configuration.UriSection, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />  
  
2.  Specificare se l'analisi IDN (Internationalized Domain Name) applicata al nome di dominio e se devono essere applicate le regole di analisi IRI. Questa operazione può essere eseguita *Machine. config* oppure il *app. config* file. Ad esempio, aggiungere quanto segue:  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 L'abilitazione degli IDN comporta la conversione di tutte le etichette Unicode in un nome di dominio nei rispettivi equivalenti Punycode. I nomi Punycode contengono solo caratteri ASCII e iniziano sempre con il prefisso "xn--". Questo avviene per supportare i server DNS esistenti in Internet, in quanto la maggior parte dei server DNS supporta solo caratteri ASCII. Vedere il documento RFC 3940.  
  
 L'attivazione di IDN interessa solo il valore della <xref:System.Uri.DnsSafeHost%2A> proprietà.  
  
 Esistono tre possibili valori per IDN a seconda di server DNS che vengono utilizzati:  
  
-   IDN abilitata = All  
  
     Questo valore convertirà qualsiasi nome di dominio Unicode negli equivalenti Punycode (nomi IDN).  
  
-   IDN abilitata = AllExceptIntranet  
  
     Questo valore convertirà tutti i nomi di dominio Unicode esterni per l'utilizzo degli equivalenti Punycode (nomi IDN). In questo caso, per gestire nomi internazionali sulla rete Intranet locale, è necessario che i server DNS utilizzati per la rete Intranet supportino i nomi Unicode.  
  
-   IDN abilitata = nessuno  
  
     Questo valore non convertirà alcun nome di dominio Unicode per l'utilizzo di Punycode Questo è il valore predefinito è coerenza con il comportamento di .NET Framework 2.0.  
  
 Abilitazione dell'analisi IRI (iriParsing abilitato = `true`) consentirà la normalizzazione e regole di controllo in base alle IRI più recente dei caratteri nella RFC 3987. Il valore predefinito è `false` e la normalizzazione e i caratteri di controllo in base a RFC 2396 e RFC 2732 (per i valori letterali IPv6).  
  
 Per ulteriori informazioni sul supporto IRI, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza da una stringa. Viene illustrata la differenza tra il valore restituito da <xref:System.Uri.Host%2A>, che restituisce il nome host o l'indirizzo specificato nell'URI e il valore restituito da <xref:System.Uri.DnsSafeHost%2A>, che restituisce un indirizzo che è possibile utilizzare nella risoluzione DNS.  
  
 [!code-cpp[NCLUriEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#4)]
 [!code-csharp[NCLUriEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#4)]
 [!code-vb[NCLUriEnhancements#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#4)]  

 Come illustrato nella sezione Osservazioni, unescape il nome host prima di risolverli. È possibile utilizzare il <xref:System.Uri.UnescapeDataString%2A> metodo unescape il nome host e si può risolvere il problema chiamando il <xref:System.Net.Dns.GetHostEntry%2A> metodo.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand">Istanza di <see cref="T:System.Uri" /> o identificatore URI da confrontare con l'istanza corrente.</param>
        <summary>Verifica l'uguaglianza tra due istanze di <see cref="T:System.Uri" />.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se le due istanze rappresentano lo stesso URI; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.Equals%2A> metodo confronta le due istanze senza tenere in considerazione le informazioni utente (<xref:System.Uri.UserInfo%2A>) e frammento (<xref:System.Uri.Fragment%2A>) parti che possono contenere. Si consideri ad esempio gli URI http://www.contoso.com/index.htm#search e http://user:password@www.contoso.com/index.htm, la <xref:System.Uri.Equals%2A> metodo restituirebbe `true`.  
  
 Se uno <xref:System.Uri> istanza è costituita da un nome host Unicode e `comparand` parametro contiene un <xref:System.Uri> istanza o un identificatore che è costituita da un nome host con il nome dell'host Punycode equivalente, quindi <xref:System.Uri.Equals%2A> restituisce `true` sono abilitate solo se supporta identificatore IRI (International Resource) e IDN (Internationalized Domain Name). I nomi Punycode contengono solo caratteri ASCII e iniziano sempre con il prefisso "xn--".  
  
 Per ulteriori informazioni sul supporto IRI, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
> [!NOTE]
>  In .NET Framework versioni 1.0 e 1.1, il <xref:System.Uri.Query%2A> viene inoltre ignorato.  
  
> [!NOTE]
>  Il <xref:System.Uri.Equals%2A> metodo può essere sottoposto a override in una classe derivata, prestare attenzione a come un'entità dannoso è stato possibile modificare il metodo. Utilizzare questo metodo non per eseguire controlli di sicurezza, a meno che non si conosce che questa istanza proviene da una fonte attendibile.  
  
   
  
## Examples  
 In questo esempio vengono create due <xref:System.Uri> istanze da stringhe che vengono confrontate per determinare se rappresentano lo stesso valore. `address1` e `address2` sono uguali, in quanto il <xref:System.Uri.Fragment%2A> parte viene ignorata per questo confronto. Il risultato viene scritto nella console.  
  
 [!code-cpp[NCLUriExamples#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#8)]
 [!code-csharp[NCLUriExamples#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#8)]
 [!code-vb[NCLUriExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#8)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per impedire che deriva da codice parzialmente attendibile <see cref="T:System.Uri" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="protected virtual void Escape ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Escape() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Escape" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Escape ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Escape();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte qualsiasi carattere unsafe o riservato presente nel componente percorso della relativa rappresentazione in caratteri esadecimali.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">L'URI passato dal costruttore non è valido. Questa eccezione può essere generata se un URI presenta troppi caratteri o se è relativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeDataString">
      <MemberSignature Language="C#" Value="public static string EscapeDataString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeDataString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeDataString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeDataString(System::String ^ stringToEscape);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">Stringa di cui effettuare l'escape.</param>
        <summary>Converte una stringa nella relativa rappresentazione escape.</summary>
        <returns>Oggetto <see cref="T:System.String" /> che contiene la rappresentazione escape di <paramref name="stringToEscape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, il <xref:System.Uri.EscapeDataString%2A> metodo converte tutti i caratteri, ad eccezione dei caratteri RFC 2396 nella relativa rappresentazione esadecimale. Se è abilitata l'International Resource Identifier (IRIs) o l'analisi IDN (Internationalized Domain Name), il <xref:System.Uri.EscapeDataString%2A> metodo converte tutti i caratteri, ad eccezione di RFC 3986 non riservato, nella relativa rappresentazione esadecimale. Tutti i caratteri Unicode vengono convertiti in formato UTF-8 prima sequenza di escape.  
  
 Questo metodo presuppone che `stringToEscape` non ha sequenze di escape in essa contenuti.  
  
 Per impostazione predefinita, la stringa di escape in base allo standard RFC 2396. Se è abilitata l'International Resource Identifier (IRIs) o l'analisi IDN (Internationalized Domain Name), la stringa di escape in base allo standard RFC 3986 e RFC 3987. Vedere le RFC per una definizione dei caratteri riservati e.  
  
 Per ulteriori informazioni sul supporto IRI, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToEscape" /> è <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para> In [.NET per le app Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), individuare in alternativa l'eccezione della classe base <see cref="T:System.FormatException" />.</para>
          </block>  La lunghezza di <paramref name="stringToEscape" /> supera i 32766 caratteri.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeString">
      <MemberSignature Language="C#" Value="protected static string EscapeString (string str);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig string EscapeString(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function EscapeString (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::String ^ EscapeString(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Stringa da trasformare nella rispettiva rappresentazione escape.</param>
        <summary>Converte una stringa nella relativa rappresentazione escape.</summary>
        <returns>Rappresentazione escape della stringa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.EscapeString%2A> metodo converte caratteri riservati RFC 2396 e tutti i caratteri con un valore di carattere maggiore di 127 in rappresentazione esadecimale. Tutti i caratteri Unicode vengono convertiti in formato UTF-8 prima sequenza di escape.  
  
 Per impostazione predefinita, la stringa di escape in base allo standard RFC 2396. Se è abilitata l'International Resource Identifier (IRIs) o l'analisi IDN (Internationalized Domain Name), la stringa di escape in base allo standard RFC 3986 e RFC 3987.  
  
 Per ulteriori informazioni sul supporto IRI, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapeUriString">
      <MemberSignature Language="C#" Value="public static string EscapeUriString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeUriString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeUriString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeUriString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeUriString(System::String ^ stringToEscape);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">Stringa di cui effettuare l'escape.</param>
        <summary>Converte una stringa URI nella relativa rappresentazione escape.</summary>
        <returns>Oggetto <see cref="T:System.String" /> che contiene la rappresentazione escape di <paramref name="stringToEscape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Uri.EscapeUriString%2A> per preparare una stringa URI senza caratteri escape come parametro per il <xref:System.Uri.%23ctor%2A> costruttore.  
  
 Per impostazione predefinita, il <xref:System.Uri.EscapeUriString%2A> metodo converte tutti i caratteri, ad eccezione dei caratteri non riservati RFC 2396, nella relativa rappresentazione esadecimale. Se è abilitata l'International Resource Identifier (IRIs) o l'analisi IDN (Internationalized Domain Name), il <xref:System.Uri.EscapeUriString%2A> metodo converte tutti i caratteri, ad eccezione di RFC 3986 non riservato, nella relativa rappresentazione esadecimale. Tutti i caratteri Unicode vengono convertiti in formato UTF-8 prima sequenza di escape.  
  
 Questo metodo presuppone che `stringToEscape` non ha sequenze di escape in essa contenuti.  
  
 Per impostazione predefinita, la stringa di escape in base allo standard RFC 2396. Se è abilitata l'International Resource Identifier (IRIs) o l'analisi IDN (Internationalized Domain Name), la stringa di escape in base allo standard RFC 3986 e RFC 3987. Vedere le RFC per una definizione dei caratteri riservati e.  
  
 Per ulteriori informazioni sul supporto IRI, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToEscape" /> è <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para> In [.NET per le app Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), individuare in alternativa l'eccezione della classe base <see cref="T:System.FormatException" />.</para>
          </block>  La lunghezza di <paramref name="stringToEscape" /> supera i 32766 caratteri.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fragment">
      <MemberSignature Language="C#" Value="public string Fragment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Fragment" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Fragment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Fragment As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Fragment { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il frammento URI in sequenza escape.</summary>
        <value>Oggetto <see cref="T:System.String" /> che contiene informazioni sui frammenti URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.Fragment%2A> proprietà ottiene qualsiasi testo che segue un marcatore di frammento (#) nell'URI, compreso il marcatore di frammento stesso. Dato l'URI http://www.contoso.com/index.htm#main, il <xref:System.Uri.Fragment%2A> proprietà restituirebbe #main.  
  
 Il <xref:System.Uri.Fragment%2A> proprietà non viene considerata in qualsiasi <xref:System.Uri.Equals%2A> confronto.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza e scrive le informazioni sui frammenti nella console.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromHex">
      <MemberSignature Language="C#" Value="public static int FromHex (char digit);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FromHex(char digit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.FromHex(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHex (digit As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FromHex(char digit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="digit" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="digit">Cifra esadecimale (0-9, a-f, A-F) da convertire.</param>
        <summary>Ottiene il valore decimale di una cifra esadecimale.</summary>
        <returns>Valore <see cref="T:System.Int32" /> che contiene un numero compreso tra 0 e 15 corrispondente alla cifra esadecimale specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.FromHex%2A> metodo converte un carattere che rappresenta una cifra esadecimale (0-9, a-f, A-F) al valore decimale (da 0 a 15). Se `digit` non è una cifra esadecimale valida, un <xref:System.ArgumentException> viene generata un'eccezione.  
  
   
  
## Examples  
 Nell'esempio seguente determina se un carattere è un carattere esadecimale e, in questo caso, scrive il valore decimale corrispondente nella console.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="digit" /> non è una cifra esadecimale valida (0-9, a-f, A-F).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetComponents">
      <MemberSignature Language="C#" Value="public string GetComponents (UriComponents components, UriFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetComponents(valuetype System.UriComponents components, valuetype System.UriFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetComponents(System.UriComponents,System.UriFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetComponents (components As UriComponents, format As UriFormat) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetComponents(UriComponents components, UriFormat format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="components" Type="System.UriComponents" />
        <Parameter Name="format" Type="System.UriFormat" />
      </Parameters>
      <Docs>
        <param name="components">Combinazione bit per bit dei valori di <see cref="T:System.UriComponents" /> che specifica quali parti dell'istanza corrente restituire al chiamante.</param>
        <param name="format">Uno dei valori di <see cref="T:System.UriFormat" /> che controlla come viene eseguito l'escape dei caratteri speciali.</param>
        <summary>Ottiene i componenti specificati dell'istanza corrente usando l'escape specificato per caratteri speciali.</summary>
        <returns>Oggetto <see cref="T:System.String" /> che contiene i componenti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.UriComponents.Query>, <xref:System.UriComponents.Fragment>, <xref:System.UriComponents.Scheme>, <xref:System.UriComponents.UserInfo>, <xref:System.UriComponents.Host>, <xref:System.UriComponents.Port>, e <xref:System.UriComponents.Path> componenti non includono il delimitatore. È possibile combinare la <xref:System.UriComponents.KeepDelimiter> flag (utilizzando l'operatore OR bit per bit) con uno di essi per ottenere il valore con il delimitatore. Per tutti gli altri <xref:System.UriComponents> valori e combinazioni di valori, i delimitatori sono inclusi nel valore restituito.  
  
 I componenti vengono restituiti nell'ordine in cui appaiono nell'URI. Ad esempio, se <xref:System.UriComponents.Scheme> viene specificato, verrà visualizzato per primo.  
  
 Quando sono attivati identificatore IRI (International Resource) e IDN (Internationalized Domain Name), il numero di caratteri restituiti nel <xref:System.String> aumenta. Nomi Punycode utilizzati per il supporto di IRI contengono solo caratteri ASCII e iniziano sempre con il prefisso xn-. Quando IRI e IDN sono abilitati, i caratteri surrogati Unicode vengono gestiti correttamente dal <xref:System.Uri.GetComponents%2A> metodo.  
  
 Per ulteriori informazioni sul supporto IRI, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
> [!NOTE]
>  Se il <xref:System.Uri.GetComponents%2A> metodo viene chiamato con `format` impostato su <xref:System.UriFormat.Unescaped> , è possibile utilizzare il valore restituito come argomento a un <xref:System.Uri.%23ctor%2A> costruttore per creare un equivalente <xref:System.Uri>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="components" /> non è una combinazione di valori di <see cref="T:System.UriComponents" /> validi.</exception>
        <exception cref="T:System.InvalidOperationException">L'oggetto <see cref="T:System.Uri" /> corrente non è un URI assoluto. Non è possibile utilizzare URI relativi con questo metodo.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene il codice hash per l'URI.</summary>
        <returns>Oggetto <see cref="T:System.Int32" /> contenente il valore hash generato per questo URI.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza e scrive il codice hash per la console.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLeftPart">
      <MemberSignature Language="C#" Value="public string GetLeftPart (UriPartial part);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetLeftPart(valuetype System.UriPartial part) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetLeftPart(System.UriPartial)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLeftPart (part As UriPartial) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetLeftPart(UriPartial part);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="part" Type="System.UriPartial" />
      </Parameters>
      <Docs>
        <param name="part">Uno dei valori di <see cref="T:System.UriPartial" /> che specifica la fine della parte di URI da restituire.</param>
        <summary>Ottiene la parte specificata di un'istanza di <see cref="T:System.Uri" />.</summary>
        <returns>Oggetto <see cref="T:System.String" /> contenente la parte specificata dell'istanza di <see cref="T:System.Uri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.GetLeftPart%2A> metodo restituisce una stringa contenente la parte più a sinistra della stringa URI, che termina con la parte specificata da `part`.  
  
 <xref:System.Uri.GetLeftPart%2A> sono inclusi i delimitatori nei casi seguenti:  
  
-   <xref:System.UriPartial.Scheme> include il delimitatore di schema.  
  
-   <xref:System.UriPartial.Authority> non include il delimitatore di percorso.  
  
-   <xref:System.UriPartial.Path> sono inclusi i delimitatori nell'URI originale fino al delimitatore di query o frammento.  
  
-   <xref:System.UriPartial.Query> include il <xref:System.UriPartial.Path>, oltre alla query e relativo delimitatore.  
  
 Gli esempi seguenti mostrano un URI e i risultati della chiamata al metodo <xref:System.Uri.GetLeftPart%2A> con <xref:System.UriPartial.Scheme>, <xref:System.UriPartial.Authority>, <xref:System.UriPartial.Path>, o <xref:System.UriPartial.Query>.  
  
|URI|Scheme|Autorità|Path|Query|  
|---------|------------|---------------|----------|-----------|  
|http://www.contoso.com/index.htm?date=today|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm?date=today|  
|http://www.contoso.com/index.htm#main|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm|  
|mailto:user@contoso.com? subject = uri|mailto:|mailto:user@contoso.com|mailto:user@contoso.com? subject = uri|\<Nessuno >|  
|nntp://news.contoso.com/123456@contoso.com|nntp://|nntp://news.contoso.com|nntp://news.contoso.com/123456@contoso.com|nntp://news.contoso.com/123456@contoso.com|  
|news:123456@contoso.com|news:|news:123456@contoso.com|news:123456@contoso.com|\<Nessuno >|  
|file://server/filename.ext|file://|file://server|file://server/filename.ext|file://server/filename.ext|  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza e il percorso viene scritto nella console.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'istanza di <see cref="T:System.Uri" /> corrente non è un'istanza assoluta.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="part" /> specificato non è valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> contenente le informazioni necessarie per serializzare l'oggetto <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenente l'origine e la destinazione del flusso serializzato associato a <see cref="T:System.Uri" />.</param>
        <summary>Restituisce i dati necessari per serializzare l'istanza corrente.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per utilizzare i metodi di serializzazione. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="HexEscape">
      <MemberSignature Language="C#" Value="public static string HexEscape (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string HexEscape(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexEscape(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexEscape (character As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ HexEscape(char character);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Carattere da convertire nella rappresentazione esadecimale.</param>
        <summary>Converte un carattere specificato nel relativo equivalente esadecimale.</summary>
        <returns>Rappresentazione esadecimale del carattere specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente converte un carattere nel relativo equivalente esadecimale e lo scrive nella console.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="character" /> è maggiore di 255.</exception>
      </Docs>
    </Member>
    <Member MemberName="HexUnescape">
      <MemberSignature Language="C#" Value="public static char HexUnescape (string pattern, ref int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char HexUnescape(string pattern, int32&amp; index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexUnescape(System.String,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexUnescape (pattern As String, ByRef index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char HexUnescape(System::String ^ pattern, int % index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="pattern">Rappresentazione esadecimale di un carattere.</param>
        <param name="index">Posizione in <c>pattern</c> in cui ha inizio la rappresentazione esadecimale di un carattere.</param>
        <summary>Converte una rappresentazione esadecimale specificata di un carattere nel carattere corrispondente.</summary>
        <returns>Carattere rappresentato dalla codifica esadecimale alla posizione <paramref name="index" />. Se il carattere alla posizione <paramref name="index" /> non è in formato esadecimale, viene restituito il carattere alla posizione <paramref name="index" />. Il valore di <paramref name="index" /> viene incrementato per indicare il carattere che segue quello restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esempio di codice seguente determina se un carattere è esadecimale codificato e, in tal caso, il carattere equivalente viene scritto nella console.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0 oppure maggiore o uguale al numero di caratteri di <paramref name="pattern" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Host" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il componente host di questa istanza.</summary>
        <value>Oggetto <see cref="T:System.String" /> che contiene il nome host. Si tratta in genere del nome host DNS o dell'indirizzo IP del server.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza di <xref:System.Uri.Authority%2A> proprietà, il valore della proprietà non include il numero di porta.  
  
   
  
## Examples  
 Nell'esempio seguente scrive il nome host (www.contoso.com) del server nella console.  
  
 [!code-cpp[Classic Uri.Host Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Host Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Host Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Host Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Host Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Host Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="HostNameType">
      <MemberSignature Language="C#" Value="public UriHostNameType HostNameType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.UriHostNameType HostNameType" />
      <MemberSignature Language="DocId" Value="P:System.Uri.HostNameType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HostNameType As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property UriHostNameType HostNameType { UriHostNameType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo del nome host specificato nell'URI.</summary>
        <value>Membro dell'enumerazione <see cref="T:System.UriHostNameType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza e scrive il <xref:System.Uri.HostNameType%2A> nella console.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="IdnHost">
      <MemberSignature Language="C#" Value="public string IdnHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string IdnHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IdnHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IdnHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ IdnHost { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Nome IDN (Internationalized Domain Name) conforme con RFC 3490 dell'host, che usa Punycode come appropriato. Questa stringa, dopo la rimozione dei caratteri di escape, se necessario, può essere usata in sicurezza per la risoluzione DNS.</summary>
        <value>Restituisce il nome dell'host, formattato con Punycode in base allo standard IDN<see cref="T:System.String" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà viene fornita per l'utilizzo di protocolli di rete di livello inferiore che richiedono il nome di dominio nel formato Punycode. Se il codice non richiede tale formato specifico, utilizzare <xref:System.Uri.Host%2A> per il nome host.  
  
 Deprecate <xref:System.Uri.DnsSafeHost%2A> proprietà è dipendente dal *app* impostazioni, che non possono essere modificate da applicazioni Windows Store. IdnHost viene fornito come l'alternativa preferita all'utilizzo <xref:System.Uri.DnsSafeHost%2A>perché <xref:System.Uri.IdnHost%2A> è garantito che siano sempre DNS-safe, indipendentemente da quali corrente *app* impostazioni potrebbero essere.  

 Se è stata utilizzata una stringa di escape per costruire l'istanza (ad esempio, "http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), quindi IdnHost restituisce una stringa di escape. È consigliabile unescape qualsiasi stringa di escape restituito da IdnHost prima di usare tale stringa per la risoluzione DNS. Tenere presente che se è utilizzata una stringa senza caratteri escape non valida per costruire l'istanza (ad esempio, "http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm"), quindi IdnHost restituisce una stringa senza caratteri escape.


 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAbsoluteUri">
      <MemberSignature Language="C#" Value="public bool IsAbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsAbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbsoluteUri As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbsoluteUri { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'istanza di <see cref="T:System.Uri" /> è assoluta.</summary>
        <value>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se l'istanza di <see cref="T:System.Uri" /> è assoluta; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà è `true` se la stringa o <xref:System.Uri> istanza che è stato passato al costruttore può essere analizzato come assoluto <xref:System.Uri> istanza, che contiene uno schema, un'autorità e un percorso. In caso contrario, il <xref:System.Uri> istanza viene considerata come relativa e omettere lo schema o gli altri componenti URI.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBadFileSystemCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsBadFileSystemCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsBadFileSystemCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBadFileSystemCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsBadFileSystemCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsBadFileSystemCharacter(char character);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Oggetto <see cref="T:System.Char" /> da verificare.</param>
        <summary>Ottiene un valore che indica se un carattere non è valido in un nome del file system.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se il carattere specificato non è valido; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il carattere viene analizzato in base alle regole per il file system NTFS.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBaseOf">
      <MemberSignature Language="C#" Value="public bool IsBaseOf (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsBaseOf(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBaseOf(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsBaseOf(Uri ^ uri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">Istanza di <see cref="T:System.Uri" /> specificata da testare.</param>
        <summary>Determina se l'istanza di <see cref="T:System.Uri" /> corrente è una base dell'istanza di <see cref="T:System.Uri" /> specificata.</summary>
        <returns>
          <see langword="true" /> se l'istanza di <see cref="T:System.Uri" /> corrente è una base di <paramref name="uri" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsBaseOf%2A> viene utilizzato per confrontare corrente <xref:System.Uri> istanza a un oggetto specificato <xref:System.Uri> per determinare se questo URI è una base per l'oggetto specificato <xref:System.Uri>. Quando si confrontano due <xref:System.Uri> oggetti per stabilire una relazione di base, le informazioni utente (<xref:System.Uri.UserInfo%2A>) non viene valutato. Quando si confrontano due URI (uri1 e uri2), uri1 costituisce la base di uri2 se, quando lo si ignora tutti gli elementi di uri2 dopo l'ultima barra (/), i due URI sono identici. Utilizzando http://host/path/path/file?query come URI di base, la tabella riportata di seguito se si tratta di una base per gli altri URI.  
  
|URI|http://host/path/path/file?query è la base di|  
|---------|------------------------------------------------------|  
|http://host/path/path/file/|sì|  
|http://host/path/path/#fragment|sì|  
|http://host/path/path/MoreDir/"|sì|  
|http://host/path/path/OtherFile?Query|sì|  
|http://host/path/path/|sì|  
|http://host/path/path/file|sì|  
|http://host/path/path|No|  
|http://host/path/path?query|No|  
|http://host/path/path#Fragment|No|  
|http://host/path/path2/|No|  
://host/path/path2/MoreDir|No|  
|http://host/path/File|No|  
  
   
  
## Examples  
 Questo esempio viene creato un <xref:System.Uri> istanza che rappresenta una base <xref:System.Uri> istanza. Crea quindi un secondo <xref:System.Uri> istanza da una stringa. Chiama <xref:System.Uri.IsBaseOf%2A> per determinare se l'istanza di base è la base della seconda istanza. Il risultato viene scritto nella console.  
  
 [!code-cpp[NCLUriEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#6)]
 [!code-csharp[NCLUriEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#6)]
 [!code-vb[NCLUriEnhancements#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uri" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefaultPort">
      <MemberSignature Language="C#" Value="public bool IsDefaultPort { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefaultPort" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsDefaultPort" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDefaultPort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDefaultPort { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il valore relativo alla porta dell'URI è quello predefinito per questo schema.</summary>
        <value>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se il valore della proprietà <see cref="P:System.Uri.Port" /> corrisponde alla porta predefinita per questo schema; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza e viene verificato se utilizza la porta predefinita.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsExcludedCharacter">
      <MemberSignature Language="C#" Value="protected static bool IsExcludedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool IsExcludedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsExcludedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function IsExcludedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static bool IsExcludedCharacter(char character);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Oggetto <see cref="T:System.Char" /> da verificare.</param>
        <summary>Ottiene un valore che indica se il carattere specificato deve essere disposto in sequenza escape.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se il carattere specificato deve essere disposto in sequenza escape; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFile">
      <MemberSignature Language="C#" Value="public bool IsFile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFile" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsFile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFile As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFile { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la classe <see cref="T:System.Uri" /> specificata è un URI di file.</summary>
        <value>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se <see cref="T:System.Uri" /> è l'URI di un file; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.IsFile%2A> proprietà `true` quando il <xref:System.Uri.Scheme%2A> uguale a proprietà <xref:System.Uri.UriSchemeFile>.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza e determina se è un URI di file.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsHexDigit">
      <MemberSignature Language="C#" Value="public static bool IsHexDigit (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexDigit(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexDigit (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexDigit(char character);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Carattere da convalidare.</param>
        <summary>Determina se un carattere specificato è una cifra esadecimale valida.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se il carattere è una cifra esadecimale valida; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cifre esadecimali sono le cifre da 0 a 9 e le lettere A-F o a-f.  
  
   
  
## Examples  
 Nell'esempio seguente determina se un carattere è un carattere esadecimale e, in questo caso, scrive il valore decimale corrispondente nella console.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHexEncoding">
      <MemberSignature Language="C#" Value="public static bool IsHexEncoding (string pattern, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexEncoding(string pattern, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexEncoding(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexEncoding (pattern As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexEncoding(System::String ^ pattern, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pattern">Stringa da verificare.</param>
        <param name="index">Posizione in <c>pattern</c> di cui verificare la codifica esadecimale.</param>
        <summary>Determina se un carattere in una stringa è codificato in formato esadecimale.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se <paramref name="pattern" /> è un esadecimale codificato nella posizione specificata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.IsHexEncoding%2A> metodo verifica la codifica esadecimale che segue il modello "% hexhex" in una stringa, dove "hex" è una cifra da 0 a 9 o una lettera da A-F (tra maiuscole e minuscole).  
  
   
  
## Examples  
 Esempio di codice seguente determina se un carattere è esadecimale codificato e, in tal caso, il carattere equivalente viene scritto nella console.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public bool IsLoopback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsLoopback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoopback { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Uri" /> specificato fa riferimento all'host locale.</summary>
        <value>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se l'oggetto <see cref="T:System.Uri" /> corrente fa riferimento all'host locale; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsLoopback%2A> Restituisce `true` se l'URI specificato quando è stata creata questa istanza è stata loopback, 127.0.0.1 o localhost, o se l'URI non specificava informazioni sull'host (ad esempio file:///c:Dir/file.txt). Tutti gli altri URI restituiscono `false`.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza e determina se fa riferimento a un host locale.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReservedCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsReservedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsReservedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsReservedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsReservedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsReservedCharacter(char character);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Oggetto <see cref="T:System.Char" /> da verificare.</param>
        <summary>Ottiene un valore che indica se il carattere specificato è un carattere riservato.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se il carattere specificato è un carattere riservato; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnc">
      <MemberSignature Language="C#" Value="public bool IsUnc { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnc" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsUnc" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnc As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnc { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Uri" /> specificato è un percorso UNC (Universal Naming Convention).</summary>
        <value>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se <see cref="T:System.Uri" /> è un percorso UNC; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.IsUnc%2A> proprietà `true` se l'oggetto specificato <xref:System.Uri> istanza è un percorso UNC (ad esempio \\\server\folder o file://server/folder). Questa proprietà restituisce sempre `true` se l'URI è conforme allo schema file:// e specifica un componente dell'host.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza e determina se è un percorso UNC.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedOriginalString">
      <MemberSignature Language="C#" Value="public bool IsWellFormedOriginalString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsWellFormedOriginalString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedOriginalString" />
      <MemberSignature Language="VB.NET" Value="Public Function IsWellFormedOriginalString () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsWellFormedOriginalString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica se la stringa usata per costruire questo oggetto <see cref="T:System.Uri" /> è ben formata e se non è necessario sottoporla ulteriormente a escape.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che è <see langword="true" /> se la stringa è ben formata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La stringa viene considerata in formato corretto in conformità con RFC 2396 e RFC 2732 per impostazione predefinita. Se è abilitata l'International Resource Identifier (IRIs) o l'analisi IDN (Internationalized Domain Name), la stringa viene considerata in formato corretto in base allo standard RFC 3986 e RFC 3987  
  
 La stringa viene considerata ben formata, pertanto il metodo a restituire false se si verifica una delle condizioni seguenti.  
  
|Error|Esempio|  
|-----------|-------------|  
|La stringa non correttamente sottoposto a escape.|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) Nome|  
|La stringa è assoluto <xref:System.Uri> che rappresenta un file implicito <xref:System.Uri>.|c:\\\directory\filename|  
|La stringa è un URI assoluto che non contiene una barra prima del percorso.|file://c:/directory/filename|  
|La stringa contiene barre rovesciate non di escape anche se vengono considerate come barre.|http:\\\host/path/file|  
|La stringa rappresenta un oggetto assoluto gerarchico <xref:System.Uri> e non contiene "://".|www.contoso.com/path/file|  
|Il parser per il <xref:System.Uri.Scheme%2A?displayProperty=nameWithType> indica che la stringa originale non è corretta.|Nell'esempio dipende dallo schema dell'URI.|  
  
 Per impostazione predefinita, la stringa utilizzata per costruire questo <xref:System.Uri> è considerata ben formata in conformità con RFC 2396 e RFC 2732.  
  
 Quando sono abilitate identificatore IRI (International Resource) e il supporto IDN (Internationalized Domain Name), la stringa utilizzata per costruire questo <xref:System.Uri> è considerata ben formata in conformità con RFC 3986 e RFC 3987. Nomi Punycode utilizzati per il supporto di IRI contengono solo caratteri ASCII e iniziano sempre con il prefisso xn-.  
  
 Per ulteriori informazioni sul supporto IRI, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedUriString">
      <MemberSignature Language="C#" Value="public static bool IsWellFormedUriString (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWellFormedUriString(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedUriString(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWellFormedUriString(System::String ^ uriString, UriKind uriKind);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">Stringa usata per tentare di costruire un oggetto <see cref="T:System.Uri" />.</param>
        <param name="uriKind">Tipo di <see cref="T:System.Uri" /> in <c>uriString</c>.</param>
        <summary>Indica se la stringa è ben formata mediante un tentativo di costruire un URI con tale stringa e assicura che la stringa non deve essere ulteriormente sottoposta ad escape.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che è <see langword="true" /> se la stringa è ben formata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nelle versioni precedenti alla versione 4.5 di .NET, per impostazione predefinita la stringa viene considerata corretta in conformità con RFC 2396 e RFC 2732. Se sono abilitato International Resource Identifier (IRIs) o l'analisi IDN (Internationalized Domain Name), la stringa viene considerata ben formata in conformità con RFC 3986 e RFC 3987.  
  
 A partire da .NET 4.5, le stringhe vengono considerate sempre ben formata in conformità con RFC 3986 e RFC 3987, o meno IRI o IDN sono abilitati. Si noti tuttavia che questo è solo true per le app destinate a .NET 4.5 o versioni successive. Le app destinate a .NET 4.0 richiamano il codice di compatibilità e il comportamento precedente (pre-4.5).  
  
 La stringa viene considerata ben formata, pertanto il metodo a restituire false se si verifica una delle condizioni seguenti  
  
|Error|Esempio|  
|-----------|-------------|  
|La stringa non correttamente sottoposto a escape.|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) Nome|  
|La stringa è assoluto <xref:System.Uri> che rappresenta un file implicito <xref:System.Uri>.|c:\\\directory\filename|  
|La stringa è un URI assoluto che non contiene una barra prima del percorso.|file://c:/directory/filename|  
|La stringa contiene barre rovesciate non di escape anche se essi verranno gestiti come barre|http:\\\host/path/file|  
|La stringa rappresenta un oggetto assoluto gerarchico <xref:System.Uri> e non contiene "://"|www.contoso.com/path/file|  
|Il parser per il <xref:System.Uri.Scheme%2A> indica che la stringa originale non è corretta.|Nell'esempio dipende dallo schema dell'URI.|  
|A partire da .NET 4.5, relativi URI con un virgola (': ') nella loro primo segmento non sono considerati ben formato.|2013.05.29_14:33:41|  
  
 Per ulteriori informazioni sul supporto IRI, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalPath">
      <MemberSignature Language="C#" Value="public string LocalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalPath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.LocalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LocalPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una rappresentazione di un nome file nel formato del sistema operativo locale.</summary>
        <value>Oggetto <see cref="T:System.String" /> che contiene la rappresentazione del sistema operativo locale di un nome file.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà è non di escape. Se il percorso viene riconosciuto come un percorso di file di Windows, tutte le barre (/) sono sostituite dalle barre rovesciate (\\).  
  
 Per l'URI `file://computer/file.ext`, il percorso assoluto è `/file.ext` e il percorso locale è `\\computer\file.ext`.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza e scrive il percorso locale alla console.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelative">
      <MemberSignature Language="C#" Value="public string MakeRelative (Uri toUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MakeRelative(class System.Uri toUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelative(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function MakeRelative (toUri As Uri) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MakeRelative(Uri ^ toUri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. Please use MakeRelativeUri(Uri uri). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="toUri">URI da confrontare con l'URI corrente.</param>
        <summary>Determina la differenza tra due istanze di <see cref="T:System.Uri" />.</summary>
        <returns>Se il nome host e lo schema di questa istanza di URI e <paramref name="toUri" /> sono identici, questo metodo restituisce un oggetto <see cref="T:System.String" /> che rappresenta un URI relativo che, quando aggiunto all'istanza URI corrente, restituisce il parametro <paramref name="toUri" />.  Se il nome host o lo schema è differente, questo metodo restituisce un oggetto <see cref="T:System.String" /> che rappresenta il parametro <paramref name="toUri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente viene illustrata l'istanza URI, `toUri`e i risultati della chiamata al metodo <xref:System.Uri.MakeRelative%2A>.  
  
|Istanza URI corrente|`toUri`|Valore restituito|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|test/test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|../|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|test1/test1.txt|  
  
 Informazioni sull'utente, se presente nell'URI, viene ignorati.  
  
   
  
## Examples  
 L'esempio seguente crea 2 <xref:System.Uri> istanze. La differenza nelle informazioni sul percorso viene scritto nella console.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toUri" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questo metodo è valido solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelativeUri">
      <MemberSignature Language="C#" Value="public Uri MakeRelativeUri (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Uri MakeRelativeUri(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelativeUri(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri ^ MakeRelativeUri(Uri ^ uri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">URI da confrontare con l'URI corrente.</param>
        <summary>Determina la differenza tra due istanze di <see cref="T:System.Uri" />.</summary>
        <returns>Se il nome host e lo schema di questa istanza di URI e <paramref name="uri" /> sono identici, questo metodo restituisce un oggetto <see cref="T:System.Uri" /> relativo che, se aggiunto all'istanza di URI corrente, restituisce <paramref name="uri" />.  Se il nome host o lo schema è differente, questo metodo restituisce un oggetto <see cref="T:System.Uri" /> che rappresenta il parametro <paramref name="uri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente viene illustrata l'istanza URI, `toUri`e i risultati della chiamata al metodo <xref:System.Uri.MakeRelativeUri%2A>.  
  
|Istanza URI corrente|`toUri`|Valore restituito|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|test/test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|../|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|test1/test1.txt|  
  
 Informazioni sull'utente, se presente nell'URI, viene ignorati.  
  
   
  
## Examples  
 L'esempio seguente crea 2 <xref:System.Uri> istanze. La differenza nelle informazioni sul percorso viene scritto nella console.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uri" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Equality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Uri ^ uri1, Uri ^ uri2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">Istanza di <see cref="T:System.Uri" /> da confrontare con <c>uri2</c>.</param>
        <param name="uri2">Istanza di <see cref="T:System.Uri" /> da confrontare con <c>uri1</c>.</param>
        <summary>Determina se due istanze di <see cref="T:System.Uri" /> hanno lo stesso valore.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se le istanze di <see cref="T:System.Uri" /> sono equivalenti; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload viene utilizzato il <xref:System.Uri.Equals%2A> metodo per determinare se i due <xref:System.Uri> istanze sono equivalenti. <xref:System.Uri.UserInfo%2A> e <xref:System.Uri.Fragment%2A> il contenuto viene ignorato quando si effettua il confronto.  
  
   
  
## Examples  
 In questo esempio crea tre <xref:System.Uri> istanze da stringhe che vengono confrontate per determinare se rappresentano lo stesso valore. `Address1` e `Address2` sono uguali, in quanto il <xref:System.Uri.Fragment%2A> parte viene ignorata per questo confronto. Il risultato viene scritto nella console.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Inequality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Uri ^ uri1, Uri ^ uri2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">Istanza di <see cref="T:System.Uri" /> da confrontare con <c>uri2</c>.</param>
        <param name="uri2">Istanza di <see cref="T:System.Uri" /> da confrontare con <c>uri1</c>.</param>
        <summary>Determina se due istanze di <see cref="T:System.Uri" /> non hanno lo stesso valore.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se le due istanze di <see cref="T:System.Uri" /> non sono uguali; in caso contrario, <see langword="false" />. Se uno dei parametri è <see langword="null" />, questo metodo restituisce <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload viene utilizzato il <xref:System.Uri.Equals%2A> metodo per determinare se i due <xref:System.Uri> istanze non sono equivalenti. <xref:System.Uri.UserInfo%2A> e <xref:System.Uri.Fragment%2A> il contenuto viene ignorato quando si effettua il confronto.  
  
   
  
## Examples  
 In questo esempio crea tre <xref:System.Uri> istanze da stringhe che vengono confrontate per determinare se rappresentano lo stesso valore. `Address2` e `Address3` non sono uguali perché `Address3` contiene un <xref:System.Uri.Query%2A> che non è presente `Address2`. Il risultato viene scritto nella console.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalString">
      <MemberSignature Language="C#" Value="public string OriginalString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OriginalString" />
      <MemberSignature Language="DocId" Value="P:System.Uri.OriginalString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OriginalString { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la stringa URI originale passata al costruttore <see cref="T:System.Uri" />.</summary>
        <value>Oggetto <see cref="T:System.String" /> contenente l'URI esatto specificato alla costruzione di questa istanza; in caso contrario, <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'URI specificato per il costruttore contiene spazi iniziali o finali, questi spazi vengono mantenuti.  
  
 Il valore restituito da questa proprietà è diverso da <xref:System.Uri.ToString%2A> e <xref:System.Uri.AbsoluteUri%2A>. <xref:System.Uri.ToString%2A> Restituisce il formato canonico senza caratteri escape dell'URI. <xref:System.Uri.AbsoluteUri%2A> Restituisce il formato canonico in sequenza escape dell'URI.  
  
 Quando sono attivati identificatore IRI (International Resource) e IDN (Internationalized Domain Name), <xref:System.Uri.OriginalString%2A> restituisce la stringa originale non normalizzata con il nome host Punycode se ne è stato utilizzato per inizializzare il <xref:System.Uri> istanza. I nomi Punycode contengono solo caratteri ASCII e iniziano sempre con il prefisso "xn--".  
  
 Per ulteriori informazioni sul supporto IRI, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
 Quando un <xref:System.Uri> oggetto viene serializzato, il <xref:System.Uri.OriginalString%2A> non viene mantenuto. Il processo di serializzazione utilizza completamente con caratteri di escape e in forma canonica <xref:System.Uri.AbsoluteUri%2A> proprietà durante la serializzazione. Per un <xref:System.Uri> che contiene un indirizzo IPv6, l'indirizzo IPv6 e l'ID ambito sono inclusi in serializzato <xref:System.Uri> oggetto.  
  
   
  
## Examples  
 L'esempio seguente crea un nuovo <xref:System.Uri> istanza da una stringa. Viene illustrata la differenza tra il valore restituito da <xref:System.Uri.OriginalString%2A>, che restituisce la stringa passata al costruttore e da una chiamata a <xref:System.Uri.ToString%2A>, che restituisce il formato canonico della stringa.  
  
 [!code-cpp[NCLUriEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#3)]
 [!code-csharp[NCLUriEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#3)]
 [!code-vb[NCLUriEnhancements#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="protected virtual void Parse ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Parse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Parse" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Parse ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Parse();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Analizza l'URI dell'istanza corrente per assicurare che contenga tutte le parti richieste per un URI valido.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">L'URI passato dal costruttore non è valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="PathAndQuery">
      <MemberSignature Language="C#" Value="public string PathAndQuery { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathAndQuery" />
      <MemberSignature Language="DocId" Value="P:System.Uri.PathAndQuery" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathAndQuery As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathAndQuery { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene le proprietà <see cref="P:System.Uri.AbsolutePath" /> e <see cref="P:System.Uri.Query" /> separate da un punto interrogativo (?).</summary>
        <value>Oggetto <see cref="T:System.String" /> che contiene le proprietà <see cref="P:System.Uri.AbsolutePath" /> e <see cref="P:System.Uri.Query" /> separate da un punto interrogativo (?).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.PathAndQuery%2A> proprietà contiene il percorso assoluto nel server e le informazioni di query inviata con la richiesta. È identico alla concatenazione di <xref:System.Uri.AbsolutePath%2A> e <xref:System.Uri.Query%2A> proprietà.  
  
 Il <xref:System.Uri.PathAndQuery%2A> proprietà viene sottoposta a escape in base allo standard RFC 2396 per impostazione predefinita. Se è abilitata l'International Resource Identifier (IRIs) o l'analisi IDN (Internationalized Domain Name), il <xref:System.Uri.PathAndQuery%2A> proprietà sottoposta a escape in base allo standard RFC 3986 e RFC 3987.  
  
 Per ulteriori informazioni sul supporto IRI, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
   
  
## Examples  
 Nell'esempio seguente scrive il percorso dell'URI (/ /catalog/shownew.htm) e query (Data = today) informazioni nella console.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.PathAndQuery Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="Port">
      <MemberSignature Language="C#" Value="public int Port { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Port" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Port" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Port As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Port { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di porta di questo URI.</summary>
        <value>Valore <see cref="T:System.Int32" /> contenente il numero di porta per questo URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il numero di porta definisce la porta del protocollo utilizzata per la connessione al server a cui fa riferimento nell'URI. Se una porta non è specificata come parte dell'URI, la <xref:System.Uri.Port%2A> proprietà restituisce il valore predefinito per il protocollo. Se è presente alcun numero di porta predefinito, questa proprietà restituisce -1.  
  
   
  
## Examples  
 Nell'esempio seguente scrive il numero di porta URI nella console. In questo caso, il valore è il numero di porta predefinito per il protocollo HTTP, la porta 80.  
  
 [!code-cpp[Classic Uri.Port Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Port Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Port Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Port Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Port Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Port Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="Query">
      <MemberSignature Language="C#" Value="public string Query { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Query" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Query" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Query As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Query { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene le informazioni sulle query incluse nell'URI specificato.</summary>
        <value>Oggetto <see cref="T:System.String" /> contenente le informazioni sulle query incluse nell'URI specificato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.Query%2A> proprietà contiene le informazioni sulle query incluse nell'URI. Informazioni sulle query separate dalle informazioni sul percorso da un punto interrogativo (?) e continua fino alla fine dell'URI. Le informazioni di query restituite includono il punto interrogativo iniziale.  
  
 Le informazioni di query viene sottoposta a escape in base allo standard RFC 2396 per impostazione predefinita. Se è abilitata l'International Resource Identifier (IRIs) o l'analisi IDN (Internationalized Domain Name), le informazioni di query viene sottoposta a escape in base allo standard RFC 3986 e RFC 3987.  
  
 Per ulteriori informazioni sul supporto IRI, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
   
  
## Examples  
 Nell'esempio seguente scrive la query? data = oggi nella console.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#2)]
 [!code-vb[Classic Uri.PathAndQuery Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome di schema per questo URI.</summary>
        <value>Oggetto <see cref="T:System.String" /> contenente lo schema per questo URI, convertito in caratteri minuscoli.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.Scheme%2A> proprietà restituisce lo schema utilizzato per inizializzare il <xref:System.Uri> istanza. Questa proprietà indica che lo schema utilizzato per inizializzare il <xref:System.Uri> istanza è stata riconosciuta.  
  
 Nella tabella seguente vengono illustrati esempi di alcuni valori possibili restituiti dal <xref:System.Uri.Scheme%2A> proprietà.  
  
|Scheme|Descrizione|  
|------------|-----------------|  
|file|La risorsa è un file nel computer locale.|  
|ftp|La risorsa è accessibile tramite FTP.|  
|gopher|La risorsa è accessibile tramite il protocollo Gopher.|  
|http|Accesso alla risorsa tramite HTTP.|  
|https|Accesso alla risorsa tramite HTTP crittografata con SSL.|  
|LDAP|La risorsa è accessibile tramite il protocollo LDAP.|  
|mailto|La risorsa è un indirizzo di posta elettronica e si accede tramite il protocollo SMTP.|  
|net.pipe|Accesso alla risorsa tramite una named pipe.|  
|net.tcp|La risorsa è accessibile dalla endpoint TCP.|  
|news|Accesso alla risorsa tramite il protocollo NNTP.|  
|nntp|Accesso alla risorsa tramite il protocollo NNTP.|  
|telnet|La risorsa è accessibile tramite il protocollo TELNET.|  
|uuid|Tramite un nome di endpoint UUID univoco per la comunicazione con un servizio di accesso alla risorsa.|  
  
   
  
## Examples  
 Nell'esempio seguente scrive il nome dello schema (http) nella console per la http://www.contoso.com/ URI.  
  
 [!code-cpp[Classic Uri.Scheme Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Scheme Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Scheme Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Scheme Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemeDelimiter">
      <MemberSignature Language="C#" Value="public static readonly string SchemeDelimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string SchemeDelimiter" />
      <MemberSignature Language="DocId" Value="F:System.Uri.SchemeDelimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SchemeDelimiter As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ SchemeDelimiter;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica i caratteri che separano lo schema del protocollo di comunicazione dalla parte di indirizzo dell'URI. Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene creata una stringa da <xref:System.Uri.UriSchemeHttp>, <xref:System.Uri.SchemeDelimiter>e un indirizzo. Oggetto <xref:System.Uri> istanza viene quindi creata dalla stringa.  
  
 [!code-cpp[NCLUriExamples#17](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#17)]
 [!code-csharp[NCLUriExamples#17](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#17)]
 [!code-vb[NCLUriExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Segments">
      <MemberSignature Language="C#" Value="public string[] Segments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Segments" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Segments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Segments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Segments { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una matrice contenente i segmenti di percorso che compongono l'URI specificato.</summary>
        <value>Matrice <see cref="T:System.String" /> contenente i segmenti di percorso che compongono l'URI specificato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.Segments%2A> proprietà restituisce una matrice di stringhe che contiene i "segmenti (sottostringhe) che formano il percorso dell'URI assoluto. Il primo segmento viene ottenuto da un'analisi del percorso assoluto dal primo carattere fino a raggiungere una barra (/) o alla fine del percorso. Ogni segmento aggiuntivo inizia in corrispondenza del primo carattere dopo il segmento precedente e termina con la successiva barra o la fine del percorso. (Percorso assoluto dell'URI contiene tutti gli elementi dopo l'host e la porta che prima della query e un frammento).  
  
 Nell'esempio seguente viene illustrato il percorso assoluto e i segmenti per due URI. Nel secondo esempio viene illustrato che il frammento e la query non fanno parte del percorso assoluto e pertanto non sono segmenti.  
  
 URI assoluto  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm  
  
 Percorso assoluto  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Segmenti  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 URI assoluto  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm#page1?answer=NO  
  
 Percorso assoluto  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Segmenti  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Si noti che, poiché il percorso assoluto inizia con '/', il primo segmento contiene e nient'altro.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza con 3 segmenti e visualizzati sullo schermo.  
  
 [!code-cpp[NCLUriExamples#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#5)]
 [!code-csharp[NCLUriExamples#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#5)]
 [!code-vb[NCLUriExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> contenente le informazioni necessarie per serializzare l'oggetto <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenente l'origine e la destinazione del flusso serializzato associato a <see cref="T:System.Uri" />.</param>
        <summary>Restituisce i dati necessari per serializzare l'istanza corrente.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per utilizzare i metodi di serializzazione. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene una rappresentazione in forma di stringa canonica per l'istanza di <see cref="T:System.Uri" /> specificata.</summary>
        <returns>Istanza di <see cref="T:System.String" /> che contiene la rappresentazione canonica senza caratteri escape dell'istanza di <see cref="T:System.Uri" />. Non viene effettuato l'escape di alcun carattere, ad eccezione di #, ? e %.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La stringa restituita da questo metodo non contiene informazioni sulla porta quando la porta è la porta predefinita per lo schema.  
  
> [!NOTE]
>  La stringa restituita dal <xref:System.Uri.ToString%2A> metodo può contenere caratteri di controllo che possono danneggiare lo stato di un'applicazione console. È possibile utilizzare il <xref:System.Uri.GetComponents%2A> metodo con il <xref:System.UriFormat.SafeUnescaped?displayProperty=nameWithType> formato per rimuovere i caratteri di controllo dalla stringa restituita.  
  
   
  
## Examples  
 L'esempio seguente crea un nuovo <xref:System.Uri> istanza da una stringa. Viene illustrata la differenza tra il valore restituito da <xref:System.Uri.OriginalString%2A>, che restituisce la stringa passata al costruttore e da una chiamata a <xref:System.Uri.ToString%2A>, che restituisce il formato canonico della stringa.  
  
 [!code-cpp[NCLUriExamples#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#7)]
 [!code-csharp[NCLUriExamples#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#7)]
 [!code-vb[NCLUriExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#7)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per impedire che deriva da codice parzialmente attendibile <see cref="T:System.Uri" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryCreate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Uri" />. Se non è possibile creare l'oggetto <see cref="T:System.Uri" />, non viene generata alcuna eccezione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (string uriString, UriKind uriKind, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(string uriString, valuetype System.UriKind uriKind, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.String,System.UriKind,System.Uri@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(System::String ^ uriString, UriKind uriKind, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
        <Parameter Name="result" Type="System.Uri&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="uriString">Oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Uri" />.</param>
        <param name="uriKind">Tipo dell'URI.</param>
        <param name="result">Quando questo metodo viene restituito, contiene l'oggetto <see cref="T:System.Uri" /> costruito.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Uri" /> usando l'istanza di <see cref="T:System.String" /> specificata e un oggetto <see cref="T:System.UriKind" />.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se l'oggetto <see cref="T:System.Uri" /> è stato creato correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questo metodo restituisce `true`, il nuovo <xref:System.Uri> in `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, string relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, string relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.String,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As String, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, System::String ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="result" Type="System.Uri&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">Oggetto <see cref="T:System.Uri" /> di base.</param>
        <param name="relativeUri">Oggetto <see cref="T:System.Uri" /> relativo, rappresentato come oggetto <see cref="T:System.String" />, da aggiungere all'oggetto <see cref="T:System.Uri" /> di base.</param>
        <param name="result">Quando termina, questo metodo contiene un oggetto <see cref="T:System.Uri" /> costruito da <c>baseUri</c> e <c>relativeUri</c>. Questo parametro viene passato non inizializzato.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Uri" /> usando le istanze di <see cref="T:System.String" /> relativa e di base.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se l'oggetto <see cref="T:System.Uri" /> è stato creato correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questo metodo restituisce `true`, il nuovo <xref:System.Uri> in `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, Uri relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, class System.Uri relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.Uri,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As Uri, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, Uri ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
        <Parameter Name="result" Type="System.Uri&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">Oggetto <see cref="T:System.Uri" /> di base.</param>
        <param name="relativeUri">Oggetto <see cref="T:System.Uri" /> relativo da aggiungere all'oggetto <see cref="T:System.Uri" /> di base.</param>
        <param name="result">Quando termina, questo metodo contiene un oggetto <see cref="T:System.Uri" /> costruito da <c>baseUri</c> e <c>relativeUri</c>. Questo parametro viene passato non inizializzato.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Uri" /> usando le istanze di <see cref="T:System.Uri" /> relativa e di base.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se l'oggetto <see cref="T:System.Uri" /> è stato creato correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questo metodo restituisce `true`, il nuovo <xref:System.Uri> in `result`.  
  
 Questo metodo crea l'URI, lo inserisce in forma canonica e la convalida. Se si verifica un'eccezione non gestita, questo metodo rileva. Se si desidera creare un <xref:System.Uri> e get eccezioni, utilizzare uno del <xref:System.Uri.%23ctor%2A> costruttori.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="protected virtual string Unescape (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string Unescape(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Unescape (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ Unescape(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Oggetto <see cref="T:System.String" /> da convertire.</param>
        <summary>Converte la stringa specificata sostituendo qualsiasi sequenza di escape con la relativa rappresentazione senza caratteri escape.</summary>
        <returns>Oggetto <see cref="T:System.String" /> contenente il valore senza caratteri escape del parametro <paramref name="path" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnescapeDataString">
      <MemberSignature Language="C#" Value="public static string UnescapeDataString (string stringToUnescape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UnescapeDataString(string stringToUnescape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.UnescapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnescapeDataString (stringToUnescape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UnescapeDataString(System::String ^ stringToUnescape);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToUnescape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToUnescape">Stringa da convertire in stringa senza caratteri escape.</param>
        <summary>Converte una stringa nella relativa rappresentazione senza caratteri escape.</summary>
        <returns>Oggetto <see cref="T:System.String" /> che contiene la rappresentazione senza caratteri escape di <paramref name="stringToUnescape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È consigliabile utilizzarlo con cautela. Una stringa che è stato in precedenza senza caratteri escape unescaping può causare ambiguità e gli errori.  
  
 Molti browser Web escape spazi all'interno di URI in più caratteri ("+"); Tuttavia, il metodo UnescapeDataString non converte più caratteri in spazi perché questo comportamento non standard tutti gli schemi URI.  
  
   
  
## Examples  
 Esempio di codice seguente converte un URI e quindi converte uno più caratteri ("+") in spazi.  
  
 [!code-csharp[NCLUriExamples#19](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToUnescape" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Uri.EscapeDataString(System.String)" />
        <altmember cref="M:System.Uri.EscapeUriString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFile">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFile" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFile As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFile;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che l'URI è un puntatore a un file. Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework versione 1.1, un "`file:///path`"Viene convertito in"`file:/path`". Questo problema è stato corretto per la versione 2.0.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza e determina se lo schema è <xref:System.Uri.UriSchemeFile>.  
  
 [!code-cpp[NCLUriExamples#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#10)]
 [!code-csharp[NCLUriExamples#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#10)]
 [!code-vb[NCLUriExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFtp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFtp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFtp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFtp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFtp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFtp;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che l'accesso all'URI viene eseguito tramite FTP (File Transfer Protocol). Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza e determina se lo schema è <xref:System.Uri.UriSchemeFtp>.  
  
 [!code-cpp[NCLUriExamples#15](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#15)]
 [!code-csharp[NCLUriExamples#15](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#15)]
 [!code-vb[NCLUriExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeGopher">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeGopher;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeGopher" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeGopher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeGopher As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeGopher;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che l'accesso all'URI viene eseguito tramite il protocollo Gopher. Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza e determina se lo schema è <xref:System.Uri.UriSchemeGopher>.  
  
 [!code-cpp[NCLUriExamples#14](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#14)]
 [!code-csharp[NCLUriExamples#14](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#14)]
 [!code-vb[NCLUriExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttp;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che l'accesso all'URI viene eseguito tramite HTTP (Hypertext Transfer Protocol). Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza e determina se lo schema è <xref:System.Uri.UriSchemeHttp>.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttps">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttps;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttps" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttps" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttps As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttps;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che l'accesso all'URI viene eseguito tramite HTTPS (Secure Hypertext Transfer Protocol). Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza e determina se lo schema è <xref:System.Uri.UriSchemeHttps>.  
  
 [!code-cpp[NCLUriExamples#16](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#16)]
 [!code-csharp[NCLUriExamples#16](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#16)]
 [!code-vb[NCLUriExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeMailto">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeMailto;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeMailto" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeMailto" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeMailto As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeMailto;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che l'URI è un indirizzo di posta elettronica a cui si accede tramite SMTP (Simple Mail Transport Protocol). Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza e determina se lo schema è <xref:System.Uri.UriSchemeMailto>.  
  
 [!code-cpp[NCLUriExamples#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#11)]
 [!code-csharp[NCLUriExamples#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#11)]
 [!code-vb[NCLUriExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetPipe">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetPipe;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetPipe" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetPipe" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetPipe As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetPipe;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che all'URI si accede tramite lo schema NetPipe usato da Windows Communication Foundation (WCF). Questo campo è di sola lettura.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetTcp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetTcp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetTcp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetTcp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetTcp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetTcp;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che all'URI si accede tramite lo schema NetTcp usato da Windows Communication Foundation (WCF). Questo campo è di sola lettura.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNews">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNews;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNews" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNews" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNews As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNews;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che l'URI è un newsgroup Internet a cui si accede tramite NNTP (Network News Transport Protocol). Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza e determina se lo schema è <xref:System.Uri.UriSchemeNews>.  
  
 [!code-cpp[NCLUriExamples#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#12)]
 [!code-csharp[NCLUriExamples#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#12)]
 [!code-vb[NCLUriExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNntp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNntp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNntp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNntp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNntp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNntp;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che l'URI è un newsgroup Internet a cui si accede tramite NNTP (Network News Transport Protocol). Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il protocollo NNTP <xref:System.Uri> l'analisi degli errori in .NET Framework versione 1.1 sono stati corretti.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza e determina se lo schema è <xref:System.Uri.UriSchemeNntp>.  
  
 [!code-cpp[NCLUriExamples#13](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#13)]
 [!code-csharp[NCLUriExamples#13](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#13)]
 [!code-vb[NCLUriExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserEscaped">
      <MemberSignature Language="C#" Value="public bool UserEscaped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UserEscaped" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserEscaped" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserEscaped As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UserEscaped { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica che la stringa URI è stata sottoposta a escape completo prima della creazione dell'istanza di <see cref="T:System.Uri" />.</summary>
        <value>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se il parametro <paramref name="dontEscape" /> è stato impostato su <see langword="true" /> al momento della creazione dell'istanza di <see cref="T:System.Uri" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.UserEscaped%2A> è impostata su `true` per indicare che la stringa utilizzata per creare il <xref:System.Uri> istanza è stata sottoposta a escape completo prima di cui è stato passato al costruttore, vale a dire, il `dontEscape` parametro della chiamata al costruttore è stato impostato su `true`.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza e determina se è stata sottoposta a escape completo quando è stata creata.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInfo">
      <MemberSignature Language="C#" Value="public string UserInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserInfo" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserInfo { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome utente, la password o altre informazioni specifiche dell'utente associate all'URI specificato.</summary>
        <value>Oggetto <see cref="T:System.String" /> contenente le informazioni utente associate all'URI. Il valore restituito non include il carattere "@" riservato per la delimitazione della parte di informazioni utente dell'URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà è in genere in formato "nomeutente: password".  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Uri> istanza e scrive le informazioni utente nella console.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
  </Members>
</Type>