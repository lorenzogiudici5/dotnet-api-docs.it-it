<Type Name="Uri" FullName="System.Uri">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c4797e00d91b925c8d372942e758cbd9ca8e0804" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48689799" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Uri : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Uri extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Uri" />
  <TypeSignature Language="VB.NET" Value="Public Class Uri&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Uri : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Uri = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.UriTypeConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce una rappresentazione in forma di oggetto di un identificatore URI (uniform resource identifier) e un pratico accesso alle parti dell'URI.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un URI è una rappresentazione compatta di una risorsa disponibile per l'applicazione nella intranet o Internet. Il <xref:System.Uri> classe definisce le proprietà e metodi per la gestione di URI, tra cui l'analisi, il confronto e combinazione. Il <xref:System.Uri> delle proprietà di classe sono di sola lettura; per creare un oggetto modificabile, usare il <xref:System.UriBuilder> classe.  
  
 URI relativo (ad esempio, "/ /New/index.htm") deve essere espanso rispetto a un URI di base in modo da renderli assoluti. Il <xref:System.Uri.MakeRelative%2A> metodo è fornito per convertire gli URI assoluti per gli URI relativi, quando necessario.  
  
 Il <xref:System.Uri> costruttori non ignora le stringhe URI se la stringa è un URI ben formato, incluso un identificatore di schema.  
  
 Il <xref:System.Uri> proprietà restituiscono una rappresentazione canonica dei dati nella codifica caratteri di escape con tutti i caratteri Unicode valori maggiori di 127 caratteri sostituiti con i relativi equivalenti esadecimale. Per inserire l'URI in forma canonica di <xref:System.Uri> costruttore esegue i passaggi seguenti:  
  
-   Converte lo schema URI in minuscolo.  
  
-   Converte il nome host in minuscolo.  
  
-   Se il nome host è un indirizzo IPv6, viene utilizzato l'indirizzo IPv6 canonico. ScopeId e altri dati facoltativi IPv6 vengono rimossi.  
  
-   Rimuove predefinito e i numeri di porta vuoto.

-   I caratteri di escape (noto anche come codificato in percentuale in ottetti) che non hanno uno scopo riservato vengono decodificati (noto anche come in corso senza codice di escape). Questi caratteri non riservati includono lettere maiuscole e lettere minuscole (% 41-% 5A e % 61-% 7A), cifre decimali (30-% 39), trattini (% 2D), punto (% 2E), un carattere di sottolineatura (% 5F) e tilde (% 7E).

-   Conversione in formato canonico il percorso per gli URI gerarchico compattando sequenze, ad esempio /., / /... /, e / o (o meno la sequenza viene sottoposto a escape). Si noti che esistono alcuni schemi per cui queste sequenze non vengono compattate.
  
-   Per gli URI gerarchico, se l'host non è stato terminato con una barra (/), viene aggiunto uno.  
  
-   Per impostazione predefinita, qualsiasi caratteri riservati nell'URI vengono sottoposti a escape in conformità con RFC 2396. Questo comportamento cambia se l'analisi International Resource Identifier o nome di dominio internazionali è abilitato nel quale case caratteri riservati nell'URI viene sottoposti a escape in conformità con RFC 3986 e RFC 3987.

 Come parte della canonizzazione nel costruttore per alcuni schemi, dot-segmenti e segmenti vuoti (/., / /.. /, e / o) vengono compattati (in altre parole, vengono rimossi). Gli schemi per i quali URI vengono compattati queste sequenze includono http, https, tcp, NET. pipe e NET. TCP. Per alcuni altri schemi, queste sequenze non vengono compattate. Di seguito è illustrato l'aspetto di questo tipo di compattazione in pratica.
  
```  
var uri = new Uri("http://myUrl/../.."); // http scheme, unescaped
OR
var uri = new Uri("http://myUrl/%2E%2E/%2E%2E"); // http scheme, escaped
OR
var uri = new Uri("ftp://myUrl/../.."); // ftp scheme, unescaped
OR
var uri = new Uri("ftp://myUrl/%2E%2E/%2E%2E"); // ftp scheme, escaped

Console.WriteLine(uri.AbsoluteUri);  
Console.WriteLine(uri.PathAndQuery);  
```  
  
 Quando si esegue questo codice, restituisce l'output seguente, con sequenze di escape senza codice di escape se necessario e quindi compattate.

```  
http://myUrl/  
/  
```  
  
 È possibile trasformare il contenuto del <xref:System.Uri> classe da un riferimento URI con escape con codificata a un riferimento URI leggibile tramite i <xref:System.Uri.ToString%2A> (metodo). Si noti che alcuni caratteri riservati vengano ancora utilizzare caratteri di escape nell'output del <xref:System.Uri.ToString%2A> (metodo). Si tratta di supportare la ricostruzione non ambigua di URI dal valore restituito da <xref:System.Uri.ToString%2A>.  
  
 Alcuni URI includono un identificatore di frammento o una query o entrambi. Un identificatore di frammento è qualsiasi testo che segue un simbolo di cancelletto (#), senza includere il simbolo cancelletto; il frammento di testo viene archiviato nel <xref:System.Uri.Fragment%2A> proprietà. Informazioni sulle query è qualsiasi testo che segue un punto interrogativo (?), l'URI; il testo della query viene archiviato nel <xref:System.Uri.Query%2A> proprietà.  
  
 In .NET Framework versione 1.1, se la stringa specificata da un costruttore contiene uno schema sconosciuto e "c:\\", gli inserimenti di classe Uri "/ /" dopo i due punti. Ad esempio, l'URI `xyz:c:\abc` viene convertito in `xyz://c:/abc`. In .NET Framework versione 2.0, questo comportamento è stata rimossa e la stringa di esempio viene convertita in `xyz:c:/abc`.  
  
> [!NOTE]
>  La classe URI supporta l'uso di indirizzi IP in entrambi notazione quad per il protocollo IPv4 ed esadecimale con due punti per il protocollo IPv6. Ricordarsi di racchiudere l'indirizzo IPv6 parentesi quadre, come in http://[::1].  
  
## <a name="international-resource-identifier-support"></a>Supporto dell'identificatore di risorse internazionale  
 Gli indirizzi Web vengono in genere espressi tramite uniform resource identifier costituiti da un set di caratteri molto limitato:  
  
-   Lettere ASCII maiuscole e minuscole dell'alfabeto inglese.  
  
-   Cifre comprese tra 0 e 9.  
  
-   Numero ridotto di altri simboli ASCII.  
  
 Le specifiche per gli URI sono documentate in RFC 2396, RFC 2732, RFC 3986 e RFC 3987, pubblicata da Internet Engineering Task Force (IETF).  
  
 Con la crescita di Internet, è sempre più necessario identificare le risorse che usano lingue diverse dall'inglese. Gli identificatori semplificano le operazioni a questo scopo e fanno sì che caratteri non ASCII (caratteri inclusi nel set di caratteri Unicode/ISO 10646) vengano riconosciuti come International Resource Identifier (IRI). Le specifiche per gli IRI sono documentate nella nota RFC 3987, pubblicata da IETF. L'uso di IRI permette a un URL di includere caratteri Unicode.  
  
 L'oggetto esistente <xref:System.Uri> classe è stata estesa in .NET Framework versione 3.5, 3.0 SP1 e 2.0 SP1 per garantire il supporto per IRI in base allo standard RFC 3987. Gli utenti delle versioni di .NET Framework precedenti alla versione 4.5 non visualizzeranno alcuna modifica rispetto al comportamento di .NET Framework 2.0 a meno che non abilitino in modo specifico. Questo garantisce la compatibilità delle applicazioni con le versioni precedenti di .NET Framework.  
  
 Per abilitare il supporto per IRI, è necessaria la modifica seguente:  
  
-   Specificare se si desidera applicare l'analisi IDN (Internationalized Domain Name) al nome di dominio e se devono essere applicati le regole di analisi IRI. Questa operazione può essere eseguita *Machine. config* o nella *app. config* file. Ad esempio, aggiungere quanto segue:  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 Gli utenti di .NET Framework 4.5 e versioni più recenti hanno sempre IRI abilitato. L'analisi IRI non può essere modificato utilizzando un *config* file.  
  
 L'abilitazione degli IDN comporta la conversione di tutte le etichette Unicode in un nome di dominio nei rispettivi equivalenti Punycode. I nomi Punycode contengono solo caratteri ASCII e iniziano sempre con il prefisso "xn--". Questo avviene per supportare i server DNS esistenti in Internet, in quanto la maggior parte dei server DNS supporta solo caratteri ASCII. Vedere il documento RFC 3940.  
  
 L'abilitazione di IRI e IDN influisce sul valore della proprietà <xref:System.Uri.DnsSafeHost%2A?displayProperty=nameWithType>. L'abilitazione di IRI e IDN può anche modificare il comportamento dei metodi <xref:System.Uri.Equals%2A>, <xref:System.Uri.OriginalString%2A>, <xref:System.Uri.GetComponents%2A> e <xref:System.Uri.IsWellFormedOriginalString%2A>.  
  
 Esistono tre possibili valori per IDN a seconda del server DNS che vengono usati:  
  
-   IDN abilitato = All  
  
     Questo valore convertirà qualsiasi nome di dominio Unicode negli equivalenti Punycode (nomi IDN).  
  
-   IDN abilitato = AllExceptIntranet  
  
     Questo valore convertirà tutti i nomi di dominio Unicode non nella Intranet locale per l'utilizzo degli equivalenti Punycode (nomi IDN). In questo caso, per gestire nomi internazionali sulla rete Intranet locale, i server DNS utilizzati per la rete Intranet devono supportare la risoluzione dei nomi Unicode.  
  
-   IDN abilitato = nessuno  
  
     Questo valore non convertirà alcun nome di dominio Unicode per l'utilizzo di Punycode Questo è il valore predefinito che è coerenza con il comportamento di .NET Framework 2.0.  
  
 Quando è abilitata l'analisi IRI (iriParsing attivato = `true`) la normalizzazione e il controllo dei caratteri vengono eseguiti in base alle regole IRI più recenti in RFC 3986 e RFC 3987. Quando l'analisi IRI è disabilitata, normalizzazione e il controllo dei caratteri vengono eseguiti in base allo standard RFC 2396 e RFC 2732 (per i valori letterali IPv6).  Nelle versioni di .NET Framework precedenti alla versione 4.5, il valore predefinito è `false`. In .NET Framework versione 4.5 e versioni successive, il valore predefinito è `true`, lo stato di abilitazione di analisi IRI non può essere modificata dalle impostazioni in un *config* file.  
  
 IRI e IDN operazioni di elaborazione durante la <xref:System.Uri> classe può anche essere controllata usando il <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType>, <xref:System.Configuration.IdnElement?displayProperty=nameWithType>, e <xref:System.Configuration.UriSection?displayProperty=nameWithType> classi delle impostazioni di configurazione. L'impostazione <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> abilita o disabilita l'elaborazione degli IRI nella classe <xref:System.Uri>. L'impostazione <xref:System.Configuration.IdnElement?displayProperty=nameWithType> abilita o disabilita l'elaborazione degli IDN nella classe <xref:System.Uri>. L'impostazione <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> controlla anche indirettamente gli IDN. L'elaborazione degli IRI deve essere abilitata perché sia possibile elaborare gli IDN. Se l'elaborazione degli IRI è disabilitata, l'elaborazione degli IDN usa l'impostazione predefinita, basata sul comportamento di .NET Framework 2.0 per motivi di compatibilità e i nomi IDN non vengono usati.  
  
 L'impostazione di configurazione per il <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> e <xref:System.Configuration.IdnElement?displayProperty=nameWithType> verrà letto una sola volta quando il primo <xref:System.Uri?displayProperty=nameWithType> classe viene costruita. Le modifiche apportate alle impostazioni di configurazione da questo momento in poi verranno ignorate.  
  
 La classe <xref:System.GenericUriParser?displayProperty=nameWithType> è stata estesa anche per consentire la creazione di un parser personalizzabile che supporta gli IRI e gli IDN. Il comportamento di un oggetto <xref:System.GenericUriParser?displayProperty=nameWithType> è specificato passando una combinazione bit per bit dei valori disponibili nell'enumerazione <xref:System.GenericUriParserOptions?displayProperty=nameWithType> al costruttore <xref:System.GenericUriParser?displayProperty=nameWithType>. Il tipo <xref:System.GenericUriParserOptions.IriParsing?displayProperty=nameWithType> indica che il parser supporta le regole specificate nel documento RFC 3987 per gli IRI (International Resource Identifier). Se l'utilizzo degli IRI dipende dai valori di configurazione illustrati in precedenza.  
  
 Il tipo <xref:System.GenericUriParserOptions.Idn?displayProperty=nameWithType> indica che il parser supporta l'analisi degli IDN (Internationalized Domain Name) dei nomi host. Se l'utilizzo di IDN dipende dai valori di configurazione illustrati in precedenza.  
  
## <a name="performance-considerations"></a>Considerazioni sulle prestazioni  
 Se si usa un *Web.config * file che contiene gli URI per inizializzare il tempo applicazione, altro è necessarie per elaborare gli URI, se gli identificatori di schema siano non standard. In tal caso, inizializzare le parti interessate dell'applicazione quando sono necessari gli URI, non all'ora di inizio.  
  
   
  
## Examples  
 L'esempio seguente crea un'istanza di <xref:System.Uri> classe e lo usa per creare un <xref:System.Net.WebRequest> istanza.  
  
 [!code-cpp[Classic Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>A causa di problemi di sicurezza, l'applicazione deve prestare attenzione quando si accettano <see cref="T:System.Uri" /> istanze da origini non attendibili e con <paramref name="dontEscape" /> impostato su <see langword="true" />. È possibile controllare la validità di una stringa URI chiamando il <see cref="M:System.Uri.IsWellFormedOriginalString" /> (metodo).</para>
    </block>
    <altmember cref="T:System.Configuration.IdnElement" />
    <altmember cref="T:System.Configuration.IriParsingElement" />
    <altmember cref="T:System.Configuration.UriSection" />
    <altmember cref="P:System.Uri.DnsSafeHost" />
    <altmember cref="M:System.Uri.MakeRelative(System.Uri)" />
    <altmember cref="M:System.Uri.IsWellFormedOriginalString" />
    <altmember cref="T:System.UriBuilder" />
    <related type="Article" href="http://msdn.microsoft.com/library/35883fe9-2d09-4d8b-80ca-cf23a941e459">Modifiche apportate allo spazio dei nomi System.Uri nella versione 2.0</related>
    <related type="Article" href="http://msdn.microsoft.com/library/b5e994c3-3535-4aff-8e1b-b69be22e9a22">Supporto di International Resource Identifier in System.UriSystem.Uri</related>
    <related type="Article" href="~/docs/framework/network-programming/index.md">Programmazione di rete in .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Uri" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString);" />
      <MemberSignature Language="F#" Value="new Uri : string -&gt; Uri" Usage="new System.Uri uriString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriString">Stringa che identifica la risorsa che deve essere rappresentata dall'istanza di <see cref="T:System.Uri" />. Si noti che un indirizzo IPv6 in formato di stringa deve essere racchiuso tra parentesi quadre. Ad esempio, "http://[2607:f8b0:400d:c06::69]".</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Uri" /> con l'URI specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un <xref:System.Uri> istanza da una stringa URI. Analizza l'URI, lo inserisce in formato canonico e rende escape richiesto.  
  
 Questo costruttore non garantisce che il <xref:System.Uri> fa riferimento a una risorsa accessibile.  
  
 Questo costruttore si presuppone che il `string` parametro fa riferimento a un URI assoluto ed è equivalente alla chiamata il <xref:System.Uri.%23ctor%2A> costruttore con <xref:System.UriKind> impostato su <xref:System.UriKind.Absolute>. Se il `string` parametro passato al costruttore è un URI relativo, questo costruttore genera un <xref:System.UriFormatException>.  
  
   
  
## Examples  
 L'esempio seguente crea una <xref:System.Uri> istanza con l'URI "http://www.contoso.com/".  
  
 [!code-cpp[Classic Uri.Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> è <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>In <see href="http://go.microsoft.com/fwlink/?LinkID=247912">.NET per app di Windows Store</see> o nella <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">libreria di classi portabile</see> rilevare invece l'eccezione della classe di base, <see cref="T:System.FormatException" />.</para>
          </block>
          <paramref name="uriString" /> è vuoto.  
  
oppure 
Lo schema specificato in <paramref name="uriString" /> non è formato correttamente. Vedere <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
oppure 
 <paramref name="uriString" /> contiene troppe barre.  
  
oppure 
La password specificata in <paramref name="uriString" /> non è valida.  
  
oppure 
Il nome host specificato in <paramref name="uriString" /> non è valido.  
  
oppure 
Il nome file specificato in <paramref name="uriString" /> non è valido.  
  
oppure 
Il nome utente specificato in <paramref name="uriString" /> non è valido.  
  
oppure 
Il nome host o il nome dell'autorità specificato in <paramref name="uriString" /> non può essere terminato da barre rovesciate.  
  
oppure 
Il numero di porta specificato in <paramref name="uriString" /> non è valido o non può essere analizzato.  
  
oppure 
La lunghezza di <paramref name="uriString" /> supera i 65519 caratteri.  
  
oppure 
La lunghezza dello schema specificato in <paramref name="uriString" /> supera i 1023 caratteri.  
  
oppure 
In <paramref name="uriString" /> è presente una sequenza di caratteri non valida.  
  
oppure 
Il percorso MS-DOS specificato in <paramref name="uriString" /> deve iniziare con c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Uri (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Uri(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new Uri : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Uri" Usage="new System.Uri (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Istanza della classe <see cref="T:System.Runtime.Serialization.SerializationInfo" /> contenente le informazioni necessarie per serializzare la nuova istanza di <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Istanza della classe <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenente l'origine del flusso serializzato associato alla nuova istanza di <see cref="T:System.Uri" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Uri" /> dalle istanze specificate delle classi <see cref="T:System.Runtime.Serialization.SerializationInfo" /> e <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore implementa il <xref:System.Runtime.Serialization.ISerializable> interfaccia di amministrazione del <xref:System.Uri> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il parametro <paramref name="serializationInfo" /> contiene l'URI <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">Il parametro <paramref name="serializationInfo" /> contiene un URI che è vuoto.  
  
oppure 
Lo schema specificato non ha un formato corretto. Vedere <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
oppure 
L'URI contiene troppe barre.  
  
oppure 
La password specificata nell'URI non è valida.  
  
oppure 
Il nome host specificato nell'URI non è valido.  
  
oppure 
Il nome file specificato nell'URI non è valido.  
  
oppure 
Il nome utente specificato nell'URI non è valido.  
  
oppure 
Il nome host o dell'autorità specificato nell'URI non può terminare con barre rovesciate.  
  
oppure 
Il numero di porta specificato nell'URI non è valido e non può essere analizzato.  
  
oppure 
La lunghezza dell'URI supera i 65519 caratteri.  
  
oppure 
La lunghezza dello schema specificato nell'URI supera i 1023 caratteri.  
  
oppure 
L'URI contiene una sequenza di caratteri non valida.  
  
oppure 
Il percorso MS-DOS specificato nell'URI deve iniziare con c:\\\\.</exception>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Serializzazione SOAP e XML</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : string * bool -&gt; Uri" Usage="new System.Uri (uriString, dontEscape)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="uriString">Stringa che identifica la risorsa che deve essere rappresentata dall'istanza di <see cref="T:System.Uri" />. Si noti che un indirizzo IPv6 in formato di stringa deve essere racchiuso tra parentesi quadre. Ad esempio, "http://[2607:f8b0:400d:c06::69]".</param>
        <param name="dontEscape">
          <see langword="true" /> se <c>uriString</c> è sottoposto a escape in modo completo, in caso contrario <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Uri" /> con l'URI specificato e con il controllo esplicito dell'escape dei caratteri.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un <xref:System.Uri> istanza da una stringa URI. Analizza l'URI e lo converte in formato canonico.  
  
 Il `dontEscape` parametro determina se i caratteri riservati vengono convertiti in sequenze di escape. Questo parametro deve essere impostato su `true` solo se si è certi che siano stati sottoposti a escape tutti i caratteri riservati nell'URI. Impostazione del valore su `true` per un URI che non sottoposto a escape completo può provocare comportamenti imprevisti. È consigliabile impostare sempre questo parametro su `false`.  
  
 Se `dontEscape` è impostata su `false`, il costruttore Usa sequenze di escape presenti caratteri riservati, controllare che tutte le occorrenze della forma di percentuale (%)) sono seguite da una sequenza di escape valida. Se la sequenza di caratteri seguente percentuale non è valida, la percentuale è sostituita da 25%.  
  
 Questo costruttore non garantisce che il <xref:System.Uri> fa riferimento a una risorsa accessibile.  
  
   
  
## Examples  
 L'esempio seguente crea una <xref:System.Uri> istanza dell'URI http://www.contoso.com/Hello%20World.htm. Perché l'URI contenuto viene sottoposto a escape ed è in forma canonica, il `dontEscape` parametro può essere impostato su `true`.  
  
 [!code-cpp[Classic Uri.Uri1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> è <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="uriString" /> è vuoto o contiene solo spazi.  
  
oppure 
Lo schema specificato in <paramref name="uriString" /> non è valido.  
  
oppure 
 <paramref name="uriString" /> contiene troppe barre.  
  
oppure 
La password specificata in <paramref name="uriString" /> non è valida.  
  
oppure 
Il nome host specificato in <paramref name="uriString" /> non è valido.  
  
oppure 
Il nome file specificato in <paramref name="uriString" /> non è valido.  
  
oppure 
Il nome utente specificato in <paramref name="uriString" /> non è valido.  
  
oppure 
Il nome host o il nome dell'autorità specificato in <paramref name="uriString" /> non può essere terminato da barre rovesciate.  
  
oppure 
Il numero di porta specificato in <paramref name="uriString" /> non è valido o non può essere analizzato.  
  
oppure 
La lunghezza di <paramref name="uriString" /> supera i 65519 caratteri.  
  
oppure 
La lunghezza dello schema specificato in <paramref name="uriString" /> supera i 1023 caratteri.  
  
oppure 
In <paramref name="uriString" /> è presente una sequenza di caratteri non valida.  
  
oppure 
Il percorso MS-DOS specificato in <paramref name="uriString" /> deve iniziare con c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="new Uri : string * UriKind -&gt; Uri" Usage="new System.Uri (uriString, uriKind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">Stringa che identifica la risorsa che deve essere rappresentata dall'istanza di <see cref="T:System.Uri" />. Si noti che un indirizzo IPv6 in formato di stringa deve essere racchiuso tra parentesi quadre. Ad esempio, "http://[2607:f8b0:400d:c06::69]".</param>
        <param name="uriKind">Specifica se la stringa URI è un URI relativo, un URI assoluto o se è indeterminata.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Uri" /> con l'URI specificato. Questo costruttore consente di specificare se la stringa URI è un URI relativo, un URI assoluto o se è indeterminata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URI assoluti e relativi presentano diverse restrizioni sui loro formato. Ad esempio, un URI relativo non richiede uno schema o un'autorità. Il valore specificato in `uriKind` deve corrispondere al tipo di URI passato `uriString`. Tuttavia, se <xref:System.UriKind.RelativeOrAbsolute> viene specificato, la stringa URI può essere relativo o assoluto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="uriKind" /> non è valido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> è <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>In <see href="http://go.microsoft.com/fwlink/?LinkID=247912">.NET per app di Windows Store</see> o nella <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">libreria di classi portabile</see> rilevare invece l'eccezione della classe di base, <see cref="T:System.FormatException" />.</para>
          </block>
          <paramref name="uriString" /> contiene un URI relativo e <paramref name="uriKind" /> è <see cref="F:System.UriKind.Absolute" />.  
  
oppure 
 <paramref name="uriString" /> contiene un URI assoluto e <paramref name="uriKind" /> è <see cref="F:System.UriKind.Relative" />.  
  
oppure 
 <paramref name="uriString" /> è vuoto.  
  
oppure 
Lo schema specificato in <paramref name="uriString" /> non è formato correttamente. Vedere <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
oppure 
 <paramref name="uriString" /> contiene troppe barre.  
  
oppure 
La password specificata in <paramref name="uriString" /> non è valida.  
  
oppure 
Il nome host specificato in <paramref name="uriString" /> non è valido.  
  
oppure 
Il nome file specificato in <paramref name="uriString" /> non è valido.  
  
oppure 
Il nome utente specificato in <paramref name="uriString" /> non è valido.  
  
oppure 
Il nome host o il nome dell'autorità specificato in <paramref name="uriString" /> non può essere terminato da barre rovesciate.  
  
oppure 
Il numero di porta specificato in <paramref name="uriString" /> non è valido o non può essere analizzato.  
  
oppure 
La lunghezza di <paramref name="uriString" /> supera i 65519 caratteri.  
  
oppure 
La lunghezza dello schema specificato in <paramref name="uriString" /> supera i 1023 caratteri.  
  
oppure 
In <paramref name="uriString" /> è presente una sequenza di caratteri non valida.  
  
oppure 
Il percorso MS-DOS specificato in <paramref name="uriString" /> deve iniziare con c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseUri">URI di base.</param>
        <param name="relativeUri">URI relativo da aggiungere all'URI di base.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Uri" /> basata sull'URI di base specificato e sulla stringa URI relativa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un <xref:System.Uri> istanza combinando le `baseUri` e il `relativeUri`. Se `relativeUri` è un URI assoluto (contenente una combinazione di nome host e, facoltativamente, un numero di porta), il <xref:System.Uri> istanza viene creata utilizzando solo `relativeUri`.  
 
 Se il `baseUri` è costituito da parti relativo (come `/api`), quindi deve terminare con una barra, la parte relativa (come `/api/`), se la parte del relativa `baseUri` deve essere mantenuto in costruito <xref:System.Uri>. 

 Inoltre, se il `relativeUri` inizia con una barra, quindi qualsiasi parte del relativo sostituirà il `baseUri`

 Questo costruttore non garantisce che il <xref:System.Uri> fa riferimento a una risorsa accessibile.  
  
   
  
## Examples  
 L'esempio seguente crea una nuova istanza della <xref:System.Uri> classe combinando gli URI relativi http://www.contoso.com /catalog/shownew.htm in modo da formare l'URI assoluto e http://www.contoso.com/catalog/shownew.htm.  
  
 [!code-cpp[Classic Uri.Uri3 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri3 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" /> non è un'istanza di <see cref="T:System.Uri" /> assoluta.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>In <see href="http://go.microsoft.com/fwlink/?LinkID=247912">.NET per app di Windows Store</see> o nella <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">libreria di classi portabile</see> rilevare invece l'eccezione della classe di base, <see cref="T:System.FormatException" />.</para>
          </block> L'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> è vuoto o contiene solo spazi.  
  
oppure 
Lo schema specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  
  
oppure 
L'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> contiene troppe barre.  
  
oppure 
La password specificata nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valida.  
  
oppure 
Il nome host specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  
  
oppure 
Il nome file specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  
  
oppure 
Il nome utente specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  
  
oppure 
Il nome host o il nome dell'autorità specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non può essere terminato da barre rovesciate.  
  
oppure 
Il numero di porta specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido o non può essere analizzato.  
  
oppure 
La lunghezza dell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> supera i 65519 caratteri.  
  
oppure 
La lunghezza dello schema specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> supera i 1023 caratteri.  
  
oppure 
Nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> è presente una sequenza di caratteri non valida.  
  
oppure 
Il percorso MS-DOS specificato in <paramref name="uriString" /> deve iniziare con c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, Uri relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, class System.Uri relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, Uri ^ relativeUri);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * Uri -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="baseUri">Oggetto <see cref="T:System.Uri" /> assoluto che costituisce la base per la nuova istanza di <see cref="T:System.Uri" />.</param>
        <param name="relativeUri">Istanza di <see cref="T:System.Uri" /> relativa combinata con <c>baseUri</c>.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Uri" /> sulla combinazione di un'istanza di <see cref="T:System.Uri" /> di base specificata e un'istanza di <see cref="T:System.Uri" /> relativa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un nuovo <xref:System.Uri> istanza combinando assoluto <xref:System.Uri> istanza `baseUri`, con un valore relativo <xref:System.Uri> istanza, `relativeUri`. Se `relativeUri` assoluto <xref:System.Uri> istanza (contenente una combinazione di nome host e, facoltativamente, un numero di porta), il <xref:System.Uri> istanza viene creata utilizzando solo `relativeUri`.  
 
 Se il `baseUri` è costituito da parti relativo (come `/api`), quindi deve terminare con una barra, la parte relativa (come `/api/`), se la parte del relativa `baseUri` deve essere mantenuto in costruito <xref:System.Uri>. 

 Inoltre, se il `relativeUri` inizia con una barra, quindi qualsiasi parte del relativo sostituirà il `baseUri`
 
 Questo costruttore non garantisce che il <xref:System.Uri> fa riferimento a una risorsa accessibile.  
  
   
  
## Examples  
 Questo esempio viene creato un oggetto assoluto <xref:System.Uri> istanza `absoluteUri`e un valore relativo <xref:System.Uri> istanza, `relativeUri`. Una nuova <xref:System.Uri> istanza, `combinedUri`, viene quindi creato da queste due istanze.  
  
 [!code-cpp[NCLUriEnhancements#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#2)]
 [!code-csharp[NCLUriEnhancements#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#2)]
 [!code-vb[NCLUriEnhancements#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="baseUri" /> non è un'istanza di <see cref="T:System.Uri" /> assoluta.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" /> non è un'istanza di <see cref="T:System.Uri" /> assoluta.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>In <see href="http://go.microsoft.com/fwlink/?LinkID=247912">.NET per app di Windows Store</see> o nella <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">libreria di classi portabile</see> rilevare invece l'eccezione della classe di base, <see cref="T:System.FormatException" />.</para>
          </block> L'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> è vuoto o contiene solo spazi.  
  
oppure 
Lo schema specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  
  
oppure 
L'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> contiene troppe barre.  
  
oppure 
La password specificata nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valida.  
  
oppure 
Il nome host specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  
  
oppure 
Il nome file specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  
  
oppure 
Il nome utente specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  
  
oppure 
Il nome host o il nome dell'autorità specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non può essere terminato da barre rovesciate.  
  
oppure 
Il numero di porta specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido o non può essere analizzato.  
  
oppure 
La lunghezza dell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> supera i 65519 caratteri.  
  
oppure 
La lunghezza dello schema specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> supera i 1023 caratteri.  
  
oppure 
Nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> è presente una sequenza di caratteri non valida.  
  
oppure 
Il percorso MS-DOS specificato in <paramref name="uriString" /> deve iniziare con c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri, bool dontEscape);" />
      <MemberSignature Language="F#" Value="new Uri : Uri * string * bool -&gt; Uri" Usage="new System.Uri (baseUri, relativeUri, dontEscape)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="baseUri">URI di base.</param>
        <param name="relativeUri">URI relativo da aggiungere all'URI di base.</param>
        <param name="dontEscape">
          <see langword="true" /> se <c>uriString</c> è sottoposto a escape in modo completo, in caso contrario <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Uri" /> basata sugli URI di base e relativi specificati, con controllo esplicito dell'escape dei caratteri.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore crea un <xref:System.Uri> istanza combinando `baseUri` e `relativeUri`. Se l'URI passato `relativeUri` è un URI assoluto (contenente una combinazione di nome host e, facoltativamente, un numero di porta), il <xref:System.Uri> istanza viene creata utilizzando solo `relativeUri`.  
  
 Il `dontEscape` parametro determina se i caratteri riservati vengono convertiti in sequenze di escape. Questo parametro deve essere impostato su `true` solo se si è certi che siano stati sottoposti a escape tutti i caratteri riservati nell'URI. Impostazione del valore su `true` per un URI che non sottoposto a escape completo può provocare comportamenti imprevisti. È consigliabile impostare sempre questo parametro su `false`. Se `dontEscape` è impostata su `false`, il costruttore Usa sequenze di escape presenti caratteri riservati, controllare che tutte le occorrenze della forma di percentuale (%)) sono seguite da una sequenza di escape valida. Se la sequenza di caratteri seguente percentuale non è valida, la percentuale è sostituita da 25%.  
  
 Questo costruttore non garantisce che il <xref:System.Uri> fa riferimento a una risorsa accessibile.  
  
   
  
## Examples  
 L'esempio seguente crea una nuova istanza di <xref:System.Uri> classe combinando gli URI relativi http://www.contoso.com Hello%20World.htm in modo da formare un URI assoluto e.  
  
 [!code-cpp[Classic Uri.Uri4 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri4 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" /> non è un'istanza di <see cref="T:System.Uri" /> assoluta.</exception>
        <exception cref="T:System.UriFormatException">L'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> è vuoto o contiene solo spazi.  
  
oppure 
Lo schema specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  
  
oppure 
L'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> contiene troppe barre.  
  
oppure 
La password specificata nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valida.  
  
oppure 
Il nome host specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  
  
oppure 
Il nome file specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  
  
oppure 
Il nome utente specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido.  
  
oppure 
Il nome host o il nome dell'autorità specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non può essere terminato da barre rovesciate.  
  
oppure 
Il numero di porta specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> non è valido o non può essere analizzato.  
  
oppure 
La lunghezza dell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> supera i 65519 caratteri.  
  
oppure 
La lunghezza dello schema specificato nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> supera i 1023 caratteri.  
  
oppure 
Nell'URI formato dalla combinazione di <paramref name="baseUri" /> e <paramref name="relativeUri" /> è presente una sequenza di caratteri non valida.  
  
oppure 
Il percorso MS-DOS specificato in <paramref name="uriString" /> deve iniziare con c:\\\\.</exception>
        <block subset="none" type="usage">
          <para>Per problemi di sicurezza, l'applicazione non deve chiamare questo costruttore con le stringhe URI da origini non attendibili e con <paramref name="dontEscape" /> impostato su <see langword="true" />. In alternativa, è possibile controllare la validità di una stringa URI chiamando il <see cref="M:System.Uri.IsWellFormedOriginalString" /> metodo prima di chiamare questo costruttore.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AbsolutePath">
      <MemberSignature Language="C#" Value="public string AbsolutePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsolutePath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsolutePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsolutePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsolutePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsolutePath : string" Usage="System.Uri.AbsolutePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il percorso assoluto dell'URI.</summary>
        <value>Oggetto <see cref="T:System.String" /> contenente il percorso assoluto della risorsa.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.AbsolutePath%2A> proprietà contiene le informazioni sul percorso usata dal server per risolvere le richieste di informazioni. In genere questo è il percorso per le informazioni desiderate nel file system del server, anche se può inoltre indicare l'applicazione o il server deve eseguire per fornire le informazioni di script.  
  
 Le informazioni sui percorsi non include lo schema, nome host o parte di query dell'URI.  
  
   
  
## Examples  
 Nell'esempio seguente scrive nella console /catalog/shownew.htm il percorso.  
  
 [!code-cpp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsolutePath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="AbsoluteUri">
      <MemberSignature Language="C#" Value="public string AbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsoluteUri As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsoluteUri { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AbsoluteUri : string" Usage="System.Uri.AbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'URI assoluto.</summary>
        <value>Oggetto <see cref="T:System.String" /> contenente l'URI intero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.AbsoluteUri%2A> proprietà include l'URI intero archiviato nel <xref:System.Uri> istanza, inclusi tutti i frammenti e stringhe di query.  
  
   
  
## Examples  
 L'esempio seguente scrive il contenuto completo del <xref:System.Uri> istanza nella console. Nell'esempio illustrato, http://www.contoso.com/catalog/shownew.htm?date=today viene scritto nella console.  
  
 [!code-cpp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="Authority">
      <MemberSignature Language="C#" Value="public string Authority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Authority" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Authority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authority As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Authority { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Authority : string" Usage="System.Uri.Authority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome host DNS (Domain Name System) o l'indirizzo IP e il numero di porta per un server.</summary>
        <value>Oggetto <see cref="T:System.String" /> contenente il componente autorità dell'URI rappresentato da questa istanza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.Authority%2A> proprietà è in genere un nome host del server DNS o indirizzo IP. Questa proprietà potrebbe includere il numero di porta del servizio se è diversa dalla porta predefinita per l'URI. Se il <xref:System.Uri.Authority%2A> componente contiene caratteri riservati, questi vengono sottoposti a escape nel valore della stringa restituito da questa proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente scrive il nome host (www.contoso.com) e il numero di porta (8080) del server nella console.  
  
 [!code-cpp[Classic Uri.Authority Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Authority Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Authority Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Authority Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Authority Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Authority Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="Canonicalize">
      <MemberSignature Language="C#" Value="protected virtual void Canonicalize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Canonicalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Canonicalize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Canonicalize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Canonicalize();" />
      <MemberSignature Language="F#" Value="abstract member Canonicalize : unit -&gt; unit&#xA;override this.Canonicalize : unit -&gt; unit" Usage="uri.Canonicalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte in formato canonico l'URI archiviato internamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La versione dell'URI canonica viene archiviata internamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questo metodo è valido solo per URI assoluti.</exception>
        <exception cref="T:System.UriFormatException">L'URI non è formato correttamente.</exception>
      </Docs>
    </Member>
    <Member MemberName="CheckHostName">
      <MemberSignature Language="C#" Value="public static UriHostNameType CheckHostName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UriHostNameType CheckHostName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckHostName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckHostName (name As String) As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UriHostNameType CheckHostName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member CheckHostName : string -&gt; UriHostNameType" Usage="System.Uri.CheckHostName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome host da convalidare. Può essere un indirizzo IPv4 o IPv6 oppure un nome host Internet.</param>
        <summary>Determina se il nome host specificato è un nome DNS valido.</summary>
        <returns>Oggetto <see cref="T:System.UriHostNameType" /> che indica il tipo del nome host. Se non è possibile determinare il tipo del nome host o se il nome host è <see langword="null" /> oppure è una stringa di lunghezza zero, questo metodo restituisce <see cref="F:System.UriHostNameType.Unknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.CheckHostName%2A> metodo controlla che il nome host specificato soddisfi i requisiti per un nome host Internet valido. Non, tuttavia, esegue una ricerca del nome host per verificare l'esistenza dell'host.  
  
   
  
## Examples  
 L'esempio seguente controlla se il nome host è valido.  
  
 [!code-cpp[Classic Uri.CheckHostName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.CheckHostName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.CheckHostName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSchemeName">
      <MemberSignature Language="C#" Value="public static bool CheckSchemeName (string schemeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CheckSchemeName(string schemeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSchemeName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckSchemeName (schemeName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CheckSchemeName(System::String ^ schemeName);" />
      <MemberSignature Language="F#" Value="static member CheckSchemeName : string -&gt; bool" Usage="System.Uri.CheckSchemeName schemeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="schemeName">Nome dello schema da convalidare.</param>
        <summary>Determina se il nome dello schema specificato è valido.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se il nome dello schema è valido; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo controlla il nome dello schema per la validità in base alla RFC 2396 per impostazione predefinita. Se è abilitato International Resource Identifier (IRI) o l'analisi IDN (Internationalized Domain Name), questo metodo controlla il nome dello schema per la validità in base alla RFC 3986. Il nome dello schema deve iniziare con una lettera e deve contenere solo lettere, cifre e i caratteri ".", "+" o "-".  
  
 Per altre informazioni sul supporto IRI in, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
   
  
## Examples  
 L'esempio seguente crea un <xref:System.Uri> dell'istanza e verifica se il nome dello schema è valido.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSecurity">
      <MemberSignature Language="C#" Value="protected virtual void CheckSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CheckSecurity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSecurity" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CheckSecurity ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CheckSecurity();" />
      <MemberSignature Language="F#" Value="abstract member CheckSecurity : unit -&gt; unit&#xA;override this.CheckSecurity : unit -&gt; unit" Usage="uri.CheckSecurity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>La chiamata a questo metodo non ha effetto.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(class System.Uri uri1, class System.Uri uri2, valuetype System.UriComponents partsToCompare, valuetype System.UriFormat compareFormat, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Compare(System.Uri,System.Uri,System.UriComponents,System.UriFormat,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (uri1 As Uri, uri2 As Uri, partsToCompare As UriComponents, compareFormat As UriFormat, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(Uri ^ uri1, Uri ^ uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : Uri * Uri * UriComponents * UriFormat * StringComparison -&gt; int" Usage="System.Uri.Compare (uri1, uri2, partsToCompare, compareFormat, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
        <Parameter Name="partsToCompare" Type="System.UriComponents" />
        <Parameter Name="compareFormat" Type="System.UriFormat" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="uri1">Primo oggetto <see cref="T:System.Uri" />.</param>
        <param name="uri2">Secondo oggetto <see cref="T:System.Uri" />.</param>
        <param name="partsToCompare">Combinazione bit per bit dei valori di <see cref="T:System.UriComponents" /> che specifica le parti di <c>uri1</c> e <c>uri2</c> da confrontare.</param>
        <param name="compareFormat">Uno dei valori di <see cref="T:System.UriFormat" /> che specifica l'escape dei caratteri usato durante il confronto dei componenti dell'URI.</param>
        <param name="comparisonType">Uno dei valori di <see cref="T:System.StringComparison" />.</param>
        <summary>Confronta le parti specificate dei due URI usando le regole di confronto specificate.</summary>
        <returns>Valore <see cref="T:System.Int32" /> che indica la relazione lessicale tra i componenti <see cref="T:System.Uri" /> confrontati.  
  
 <list type="table"><listheader><term> Valore 
 </term><description> Significato 
 </description></listheader><item><term> Minore di zero 
 </term><description><paramref name="uri1" /> è minore di <paramref name="uri2" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="uri1" /> è uguale a <paramref name="uri2" />.  
  
 </description></item><item><term> Maggiore di zero 
 </term><description><paramref name="uri1" /> è maggiore di <paramref name="uri2" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se entrambe `uri1` e `uri2` sono `null`, questo metodo restituisce 0. Quando si confrontano i valori URI, un URI relativo è sempre minore di un URI assoluto e un URI diverso da null è sempre maggiore di un URI null. Per i casi in cui entrambe `uri1` e `uri2` non sono `null` e sono entrambi gli URI relativi, o entrambi gli URI assoluto, il <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> metodo esegue il confronto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore valido di <see cref="T:System.StringComparison" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DnsSafeHost">
      <MemberSignature Language="C#" Value="public string DnsSafeHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DnsSafeHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.DnsSafeHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DnsSafeHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DnsSafeHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DnsSafeHost : string" Usage="System.Uri.DnsSafeHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un nome host che, dopo la rimozione dei caratteri di escape, se necessario, può essere usato in sicurezza per la risoluzione DNS.</summary>
        <value>Oggetto <see cref="T:System.String" /> che contiene la parte host dell'URI in un formato appropriato per la risoluzione DNS oppure stringa host originale, se è già adatto per la risoluzione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per gli indirizzi IPv6, le parentesi quadre ([]) vengono rimossi e <xref:System.Net.IPAddress.ScopeId%2A> è impostata, se ne viene specificato quando è stata costruita questa istanza.

Se è stata usata una stringa con caratteri di escape per costruire l'istanza (ad esempio, "http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), quindi DnsSafeHost restituisce una stringa con caratteri di escape. Unescape qualsiasi stringa con caratteri di escape restituita da `DnsSafeHost` prima di usare tale stringa per la risoluzione DNS (vedere l'esempio). Se è stata usata una stringa senza caratteri di escape non valida per costruire l'istanza (ad esempio, "http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm"), quindi DnsSafeHost restituisce una stringa senza caratteri di escape.
  
 Il <xref:System.Uri.DnsSafeHost%2A> proprietà è dipendente da impostazioni di configurazione, come descritto più avanti in questo argomento. Le impostazioni di configurazione non possono essere modificate dalle applicazioni Windows Store, che possono causare risultati incoerenti quando si usa <xref:System.Uri.DnsSafeHost%2A>. Il <xref:System.Uri.IdnHost%2A> proprietà viene fornita come l'alternativa all'uso <xref:System.Uri.DnsSafeHost%2A>, in quanto <xref:System.Uri.IdnHost%2A> viene garantito che siano sempre DNS sicuro, indipendentemente da quali corrente *app. config* impostazioni potrebbero essere.  
  
 Il <xref:System.Uri.DnsSafeHost%2A> proprietà è stata estesa in .NET Framework versione 3.5, 3.0 SP1 e 2.0 SP1 per fornire International Resource Identifier (IRI) supportano base RFC 3987. Gli utenti non noteranno alcun cambiamento dal comportamento di .NET Framework 2.0, a meno che non abilitino in modo specifico gli URI. Questo garantisce la compatibilità delle applicazioni con le versioni precedenti di .NET Framework.  
  
 Per abilitare il supporto per IRI, sono necessarie le due modifiche seguenti:  
  
1.  Aggiungere la riga seguente per il *Machine. config* file nella directory di .NET Framework 2.0  
  
     \<section name="uri" type="System.Configuration.UriSection, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />  
  
2.  Specificare se si desidera applicare l'analisi IDN (Internationalized Domain Name) al nome di dominio e se devono essere applicati le regole di analisi IRI. Questa operazione può essere eseguita *Machine. config* o nella *app. config* file. Ad esempio, aggiungere quanto segue:  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 L'abilitazione degli IDN comporta la conversione di tutte le etichette Unicode in un nome di dominio nei rispettivi equivalenti Punycode. I nomi Punycode contengono solo caratteri ASCII e iniziano sempre con il prefisso "xn--". Questo avviene per supportare i server DNS esistenti in Internet, in quanto la maggior parte dei server DNS supporta solo caratteri ASCII. Vedere il documento RFC 3940.  
  
 L'attivazione di IDN interessa solo il valore della <xref:System.Uri.DnsSafeHost%2A> proprietà.  
  
 Esistono tre possibili valori per IDN a seconda del server DNS che vengono usati:  
  
-   IDN abilitato = All  
  
     Questo valore convertirà qualsiasi nome di dominio Unicode negli equivalenti Punycode (nomi IDN).  
  
-   IDN abilitato = AllExceptIntranet  
  
     Questo valore convertirà tutti i nomi di dominio Unicode esterni per l'utilizzo degli equivalenti Punycode (nomi IDN). In questo caso, per gestire nomi internazionali sulla rete Intranet locale, è necessario che i server DNS utilizzati per la rete Intranet supportino i nomi Unicode.  
  
-   IDN abilitato = nessuno  
  
     Questo valore non convertirà alcun nome di dominio Unicode per l'utilizzo di Punycode Questo è il valore predefinito che è coerenza con il comportamento di .NET Framework 2.0.  
  
 Attivando l'analisi IRI (iriParsing attivato = `true`) eseguirà la normalizzazione e regole di carattere di controllo in base a IRI più recenti nella specifica RFC 3987. Il valore predefinito è `false` e la normalizzazione e i caratteri di controllo in base alla RFC 2396 e RFC 2732 (per i valori letterali IPv6).  
  
 Per altre informazioni sul supporto IRI in, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
   
  
## Examples  
 L'esempio seguente crea un <xref:System.Uri> istanza da una stringa. Viene illustrata la differenza tra il valore restituito da <xref:System.Uri.Host%2A>, che restituisce il nome host o l'indirizzo specificato nell'URI e il valore restituito da <xref:System.Uri.DnsSafeHost%2A>, che restituisce un indirizzo che è possibile utilizzare nella risoluzione DNS.  
  
 [!code-cpp[NCLUriEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#4)]
 [!code-csharp[NCLUriEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#4)]
 [!code-vb[NCLUriEnhancements#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#4)]  

 Come spiegato nella sezione Osservazioni, unescape il nome host prima di risolvere. È possibile usare la <xref:System.Uri.UnescapeDataString%2A> metodo unescape il nome host ed è possibile risolverlo chiamando il <xref:System.Net.Dns.GetHostEntry%2A> (metodo).

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uri.Equals comparand" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand">Istanza di <see cref="T:System.Uri" /> o identificatore URI da confrontare con l'istanza corrente.</param>
        <summary>Verifica l'uguaglianza tra due istanze di <see cref="T:System.Uri" />.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se le due istanze rappresentano lo stesso URI; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.Equals%2A> metodo confronta le due istanze indipendentemente dalle informazioni sull'utente (<xref:System.Uri.UserInfo%2A>) e di frammento (<xref:System.Uri.Fragment%2A>) parti che potrebbero contenere. Si consideri ad esempio gli URI http://www.contoso.com/index.htm#search e http://user:password@www.contoso.com/index.htm, il <xref:System.Uri.Equals%2A> metodo restituirebbe `true`.  
  
 Eventuale <xref:System.Uri> istanza è costituita da un nome host di Unicode e `comparand` parametro contiene un <xref:System.Uri> istanza o un identificatore che è costituita da un nome host con il nome di host equivalente Punycode, quindi <xref:System.Uri.Equals%2A> restituisce `true` sono abilitate solo se il supporto IDN (Internationalized Domain Name) e International Resource Identifier (IRI). I nomi Punycode contengono solo caratteri ASCII e iniziano sempre con il prefisso "xn--".  
  
 Per altre informazioni sul supporto IRI in, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
> [!NOTE]
>  In .NET Framework versioni 1.0 e 1.1 la <xref:System.Uri.Query%2A> viene inoltre ignorato.  
  
> [!NOTE]
>  Il <xref:System.Uri.Equals%2A> può essere sottoposto a override in una classe derivata, prestare attenzione in quanto un'entità dannosa è stato possibile modificare il metodo. Utilizzare questo metodo non per eseguire controlli di sicurezza, a meno che non si sa che questa istanza proviene da una fonte attendibile.  
  
   
  
## Examples  
 Questo esempio vengono creati due <xref:System.Uri> istanze dalle stringhe e vengono quindi confrontati per determinare se rappresentano lo stesso valore. `address1` e `address2` sono uguali, in quanto il <xref:System.Uri.Fragment%2A> parte viene ignorata per questo confronto. Il risultato viene scritto nella console.  
  
 [!code-cpp[NCLUriExamples#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#8)]
 [!code-csharp[NCLUriExamples#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#8)]
 [!code-vb[NCLUriExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#8)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per impedire che deriva da codice parzialmente attendibile <see cref="T:System.Uri" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="protected virtual void Escape ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Escape() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Escape" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Escape ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Escape();" />
      <MemberSignature Language="F#" Value="abstract member Escape : unit -&gt; unit&#xA;override this.Escape : unit -&gt; unit" Usage="uri.Escape " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte qualsiasi carattere unsafe o riservato presente nel componente percorso della relativa rappresentazione in caratteri esadecimali.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">L'URI passato dal costruttore non è valido. Questa eccezione può essere generata se un URI presenta troppi caratteri o se è relativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeDataString">
      <MemberSignature Language="C#" Value="public static string EscapeDataString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeDataString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeDataString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeDataString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeDataString : string -&gt; string" Usage="System.Uri.EscapeDataString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">Stringa di cui effettuare l'escape.</param>
        <summary>Converte una stringa nella relativa rappresentazione escape.</summary>
        <returns>Oggetto <see cref="T:System.String" /> che contiene la rappresentazione escape di <paramref name="stringToEscape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, il <xref:System.Uri.EscapeDataString%2A> metodo converte tutti i caratteri, ad eccezione dei caratteri RFC 2396 nella relativa rappresentazione esadecimale. Se è abilitato International Resource Identifier (IRI) o l'analisi IDN (Internationalized Domain Name), il <xref:System.Uri.EscapeDataString%2A> metodo converte tutti i caratteri, ad eccezione di RFC 3986 non riservati, nella relativa rappresentazione esadecimale. Tutti i caratteri Unicode vengono convertiti in formato UTF-8 prima della sequenza di escape.  
  
 Questo metodo presuppone che `stringToEscape` non contiene nessuna sequenza di escape.  
  
 Per impostazione predefinita, la stringa è codificata in base alle RFC 2396. Se è abilitato International Resource Identifier (IRI) o l'analisi IDN (Internationalized Domain Name), la stringa è codificata in base alle RFC 3986 e RFC 3987. Vedere le RFC per una definizione dei caratteri riservati e.  
  
 Per altre informazioni sul supporto IRI in, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToEscape" /> è <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>In <see href="http://go.microsoft.com/fwlink/?LinkID=247912">.NET per app di Windows Store</see> o nella <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">libreria di classi portabile</see> rilevare invece l'eccezione della classe di base, <see cref="T:System.FormatException" />.</para>
          </block>  
  
La lunghezza di <paramref name="stringToEscape" /> supera i 32766 caratteri.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeString">
      <MemberSignature Language="C#" Value="protected static string EscapeString (string str);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig string EscapeString(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function EscapeString (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::String ^ EscapeString(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member EscapeString : string -&gt; string" Usage="System.Uri.EscapeString str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Stringa da trasformare nella rispettiva rappresentazione escape.</param>
        <summary>Converte una stringa nella relativa rappresentazione escape.</summary>
        <returns>Rappresentazione escape della stringa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.EscapeString%2A> metodo converte i caratteri riservati RFC 2396 e tutti i caratteri con un valore di carattere maggiore di 127 caratteri nella rappresentazione esadecimale. Tutti i caratteri Unicode vengono convertiti in formato UTF-8 prima della sequenza di escape.  
  
 Per impostazione predefinita, la stringa è codificata in base alle RFC 2396. Se è abilitato International Resource Identifier (IRI) o l'analisi IDN (Internationalized Domain Name), la stringa è codificata in base alle RFC 3986 e RFC 3987.  
  
 Per altre informazioni sul supporto IRI in, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapeUriString">
      <MemberSignature Language="C#" Value="public static string EscapeUriString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeUriString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeUriString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeUriString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeUriString(System::String ^ stringToEscape);" />
      <MemberSignature Language="F#" Value="static member EscapeUriString : string -&gt; string" Usage="System.Uri.EscapeUriString stringToEscape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">Stringa di cui effettuare l'escape.</param>
        <summary>Converte una stringa URI nella relativa rappresentazione escape.</summary>
        <returns>Oggetto <see cref="T:System.String" /> che contiene la rappresentazione escape di <paramref name="stringToEscape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare la <xref:System.Uri.EscapeUriString%2A> per preparare una stringa senza caratteri di escape URI come parametro al metodo il <xref:System.Uri.%23ctor%2A> costruttore.  
  
 Per impostazione predefinita, il <xref:System.Uri.EscapeUriString%2A> metodo converte tutti i caratteri, ad eccezione dei caratteri non riservati RFC 2396, nella relativa rappresentazione esadecimale. Se è abilitato International Resource Identifier (IRI) o l'analisi IDN (Internationalized Domain Name), il <xref:System.Uri.EscapeUriString%2A> metodo converte tutti i caratteri, ad eccezione di RFC 3986 non riservati, nella relativa rappresentazione esadecimale. Tutti i caratteri Unicode vengono convertiti in formato UTF-8 prima della sequenza di escape.  
  
 Questo metodo presuppone che `stringToEscape` non contiene nessuna sequenza di escape.  
  
 Per impostazione predefinita, la stringa è codificata in base alle RFC 2396. Se è abilitato International Resource Identifier (IRI) o l'analisi IDN (Internationalized Domain Name), la stringa è codificata in base alle RFC 3986 e RFC 3987. Vedere le RFC per una definizione dei caratteri riservati e.  
  
 Per altre informazioni sul supporto IRI in, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToEscape" /> è <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>In <see href="http://go.microsoft.com/fwlink/?LinkID=247912">.NET per app di Windows Store</see> o nella <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">libreria di classi portabile</see> rilevare invece l'eccezione della classe di base, <see cref="T:System.FormatException" />.</para>
          </block>  
  
La lunghezza di <paramref name="stringToEscape" /> supera i 32766 caratteri.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fragment">
      <MemberSignature Language="C#" Value="public string Fragment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Fragment" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Fragment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Fragment As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Fragment { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Fragment : string" Usage="System.Uri.Fragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il frammento URI in sequenza escape.</summary>
        <value>Oggetto <see cref="T:System.String" /> che contiene informazioni sui frammenti URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.Fragment%2A> proprietà ottiene qualsiasi testo che segue un marcatore di frammento (#) nell'URI, compreso il marcatore di frammento stesso. L'URI specificato http://www.contoso.com/index.htm#main, il <xref:System.Uri.Fragment%2A> proprietà restituirebbe #main.  
  
 Il <xref:System.Uri.Fragment%2A> non verrà considerata in qualsiasi <xref:System.Uri.Equals%2A> confronto.  
  
   
  
## Examples  
 L'esempio seguente crea un <xref:System.Uri> dell'istanza e scrive le informazioni sul frammento nella console.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromHex">
      <MemberSignature Language="C#" Value="public static int FromHex (char digit);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FromHex(char digit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.FromHex(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHex (digit As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FromHex(char digit);" />
      <MemberSignature Language="F#" Value="static member FromHex : char -&gt; int" Usage="System.Uri.FromHex digit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="digit" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="digit">Cifra esadecimale (0-9, a-f, A-F) da convertire.</param>
        <summary>Ottiene il valore decimale di una cifra esadecimale.</summary>
        <returns>Valore <see cref="T:System.Int32" /> che contiene un numero compreso tra 0 e 15 corrispondente alla cifra esadecimale specificata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.FromHex%2A> metodo converte un carattere che rappresenta una cifra esadecimale (0-9, a-f, A-F) il valore decimale (da 0 a 15). Se `digit` non è una cifra esadecimale valida, un <xref:System.ArgumentException> viene generata un'eccezione.  
  
   
  
## Examples  
 Nell'esempio seguente determina se un carattere è un carattere esadecimale e, se si tratta, scrive il valore decimale corrispondente nella console.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="digit" /> non è una cifra esadecimale valida (0-9, a-f, A-F).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetComponents">
      <MemberSignature Language="C#" Value="public string GetComponents (UriComponents components, UriFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetComponents(valuetype System.UriComponents components, valuetype System.UriFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetComponents(System.UriComponents,System.UriFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetComponents (components As UriComponents, format As UriFormat) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetComponents(UriComponents components, UriFormat format);" />
      <MemberSignature Language="F#" Value="member this.GetComponents : UriComponents * UriFormat -&gt; string" Usage="uri.GetComponents (components, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="components" Type="System.UriComponents" />
        <Parameter Name="format" Type="System.UriFormat" />
      </Parameters>
      <Docs>
        <param name="components">Combinazione bit per bit dei valori di <see cref="T:System.UriComponents" /> che specifica quali parti dell'istanza corrente restituire al chiamante.</param>
        <param name="format">Uno dei valori di <see cref="T:System.UriFormat" /> che controlla come viene eseguito l'escape dei caratteri speciali.</param>
        <summary>Ottiene i componenti specificati dell'istanza corrente usando l'escape specificato per caratteri speciali.</summary>
        <returns>Oggetto <see cref="T:System.String" /> che contiene i componenti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.UriComponents.Query>, <xref:System.UriComponents.Fragment>, <xref:System.UriComponents.Scheme>, <xref:System.UriComponents.UserInfo>, <xref:System.UriComponents.Host>, <xref:System.UriComponents.Port>, e <xref:System.UriComponents.Path> components non include il delimitatore. È possibile combinare la <xref:System.UriComponents.KeepDelimiter> flag (tramite l'operatore OR bit per bit) con una qualsiasi di tali valori per ottenere il valore con il delimitatore. Per tutti gli altri <xref:System.UriComponents> valori e le combinazioni di valori, i delimitatori vengono inclusi nel valore restituito.  
  
 I componenti vengono restituiti nell'ordine in cui compaiono nell'URI. Ad esempio, se <xref:System.UriComponents.Scheme> viene specificato, verrà visualizzato per primo.  
  
 Quando il supporto IDN (Internationalized Domain Name) e International Resource Identifier (IRI) sono abilitati, il numero di caratteri restituiti nella <xref:System.String> aumenta. I nomi Punycode utilizzati per il supporto degli IRI contengano solo caratteri ASCII e iniziano sempre con il prefisso xn-. Quando gli IRI e IDN sono abilitate, i caratteri surrogati Unicode vengono gestiti correttamente dal <xref:System.Uri.GetComponents%2A> (metodo).  
  
 Per altre informazioni sul supporto IRI in, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
> [!NOTE]
>  Se il <xref:System.Uri.GetComponents%2A> metodo viene chiamato con `format` impostata su <xref:System.UriFormat.Unescaped> , è possibile usare il valore restituito come argomento a un <xref:System.Uri.%23ctor%2A> costruttore per creare un equivalente <xref:System.Uri>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="components" /> non è una combinazione di valori di <see cref="T:System.UriComponents" /> validi.</exception>
        <exception cref="T:System.InvalidOperationException">L'oggetto <see cref="T:System.Uri" /> corrente non è un URI assoluto. Non è possibile utilizzare URI relativi con questo metodo.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uri.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene il codice hash per l'URI.</summary>
        <returns>Oggetto <see cref="T:System.Int32" /> contenente il valore hash generato per questo URI.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente crea un <xref:System.Uri> dell'istanza e scrive il codice hash per la console.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLeftPart">
      <MemberSignature Language="C#" Value="public string GetLeftPart (UriPartial part);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetLeftPart(valuetype System.UriPartial part) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetLeftPart(System.UriPartial)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLeftPart (part As UriPartial) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetLeftPart(UriPartial part);" />
      <MemberSignature Language="F#" Value="member this.GetLeftPart : UriPartial -&gt; string" Usage="uri.GetLeftPart part" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="part" Type="System.UriPartial" />
      </Parameters>
      <Docs>
        <param name="part">Uno dei valori di <see cref="T:System.UriPartial" /> che specifica la fine della parte di URI da restituire.</param>
        <summary>Ottiene la parte specificata di un'istanza di <see cref="T:System.Uri" />.</summary>
        <returns>Oggetto <see cref="T:System.String" /> contenente la parte specificata dell'istanza di <see cref="T:System.Uri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.GetLeftPart%2A> metodo restituisce una stringa contenente la parte più a sinistra della stringa di URI, che termina con la parte specificata da `part`.  
  
 <xref:System.Uri.GetLeftPart%2A> include i delimitatori nei casi seguenti:  
  
-   <xref:System.UriPartial.Scheme> include il delimitatore di schema.  
  
-   <xref:System.UriPartial.Authority> non include il delimitatore di percorso.  
  
-   <xref:System.UriPartial.Path> sono inclusi i delimitatori nell'URI originale fino al delimitatore di frammento o query.  
  
-   <xref:System.UriPartial.Query> include il <xref:System.UriPartial.Path>, oltre alla query e il delimitatore.  
  
 Gli esempi seguenti illustrano un URI e i risultati della chiamata al metodo <xref:System.Uri.GetLeftPart%2A> con <xref:System.UriPartial.Scheme>, <xref:System.UriPartial.Authority>, <xref:System.UriPartial.Path>, o <xref:System.UriPartial.Query>.  
  
|URI|Scheme|Autorità|Path|Query|  
|---------|------------|---------------|----------|-----------|  
|http://www.contoso.com/index.htm?date=today|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm?date=today|  
|http://www.contoso.com/index.htm#main|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm|  
|mailto:user@contoso.com? subject = uri|mailto:|mailto:user@contoso.com|mailto:user@contoso.com? subject = uri|\<Nessuno >|  
|nntp://news.contoso.com/123456@contoso.com|nntp://|nntp://news.contoso.com|nntp://news.contoso.com/123456@contoso.com|nntp://news.contoso.com/123456@contoso.com|  
|news:123456@contoso.com|Novità:|news:123456@contoso.com|news:123456@contoso.com|\<Nessuno >|  
|file://server/filename.ext|file://|file://server|file://server/filename.ext|file://server/filename.ext|  
  
   
  
## Examples  
 L'esempio seguente crea un <xref:System.Uri> dell'istanza e scrive il percorso nella console.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'istanza di <see cref="T:System.Uri" /> corrente non è un'istanza assoluta.</exception>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="part" /> specificato non è valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="member this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="uri.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> contenente le informazioni necessarie per serializzare l'oggetto <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenente l'origine e la destinazione del flusso serializzato associato a <see cref="T:System.Uri" />.</param>
        <summary>Restituisce i dati necessari per serializzare l'istanza corrente.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per usare i metodi di serializzazione. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="HexEscape">
      <MemberSignature Language="C#" Value="public static string HexEscape (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string HexEscape(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexEscape(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexEscape (character As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ HexEscape(char character);" />
      <MemberSignature Language="F#" Value="static member HexEscape : char -&gt; string" Usage="System.Uri.HexEscape character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Carattere da convertire nella rappresentazione esadecimale.</param>
        <summary>Converte un carattere specificato nel relativo equivalente esadecimale.</summary>
        <returns>Rappresentazione esadecimale del carattere specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente converte un carattere nel relativo equivalente esadecimale e lo scrive nella console.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="character" /> è maggiore di 255.</exception>
      </Docs>
    </Member>
    <Member MemberName="HexUnescape">
      <MemberSignature Language="C#" Value="public static char HexUnescape (string pattern, ref int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char HexUnescape(string pattern, int32&amp; index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexUnescape(System.String,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexUnescape (pattern As String, ByRef index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char HexUnescape(System::String ^ pattern, int % index);" />
      <MemberSignature Language="F#" Value="static member HexUnescape : string *  -&gt; char" Usage="System.Uri.HexUnescape (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="pattern">Rappresentazione esadecimale di un carattere.</param>
        <param name="index">Posizione in <c>pattern</c> in cui ha inizio la rappresentazione esadecimale di un carattere.</param>
        <summary>Converte una rappresentazione esadecimale specificata di un carattere nel carattere corrispondente.</summary>
        <returns>Carattere rappresentato dalla codifica esadecimale alla posizione <paramref name="index" />. Se il carattere alla posizione <paramref name="index" /> non è in formato esadecimale, viene restituito il carattere alla posizione <paramref name="index" />. Il valore di <paramref name="index" /> viene incrementato per indicare il carattere che segue quello restituito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esempio di codice seguente determina se un carattere è esadecimale con codifica e, in questo caso, il carattere equivalente viene scritto nella console.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> è minore di 0 oppure maggiore o uguale al numero di caratteri di <paramref name="pattern" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Host" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Host : string" Usage="System.Uri.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il componente host di questa istanza.</summary>
        <value>Oggetto <see cref="T:System.String" /> che contiene il nome host. Si tratta in genere del nome host DNS o dell'indirizzo IP del server.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza di <xref:System.Uri.Authority%2A> proprietà, il valore della proprietà non include il numero di porta.  
  
   
  
## Examples  
 Nell'esempio seguente scrive nella console il nome host (www.contoso.com) del server.  
  
 [!code-cpp[Classic Uri.Host Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Host Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Host Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Host Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Host Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Host Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="HostNameType">
      <MemberSignature Language="C#" Value="public UriHostNameType HostNameType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.UriHostNameType HostNameType" />
      <MemberSignature Language="DocId" Value="P:System.Uri.HostNameType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HostNameType As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property UriHostNameType HostNameType { UriHostNameType get(); };" />
      <MemberSignature Language="F#" Value="member this.HostNameType : UriHostNameType" Usage="System.Uri.HostNameType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo del nome host specificato nell'URI.</summary>
        <value>Membro dell'enumerazione <see cref="T:System.UriHostNameType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente crea una <xref:System.Uri> istanza e le scritture di <xref:System.Uri.HostNameType%2A> nella console.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="IdnHost">
      <MemberSignature Language="C#" Value="public string IdnHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string IdnHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IdnHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IdnHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ IdnHost { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IdnHost : string" Usage="System.Uri.IdnHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Nome IDN (Internationalized Domain Name) conforme con RFC 3490 dell'host, che usa Punycode come appropriato. Questa stringa, dopo la rimozione dei caratteri di escape, se necessario, può essere usata in sicurezza per la risoluzione DNS.</summary>
        <value>Restituisce il nome dell'host, formattato con Punycode in base allo standard IDN<see cref="T:System.String" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà viene fornita per l'uso di protocolli di rete di livello inferiore che richiedono il nome di dominio in formato Punycode. Se il codice non richiede tale formato specifico, usare <xref:System.Uri.Host%2A> per il nome host.  
  
 Deprecate <xref:System.Uri.DnsSafeHost%2A> proprietà dipende *app* impostazioni, che non possono essere modificate dalle applicazioni Windows Store. IdnHost viene fornito come l'alternativa all'uso <xref:System.Uri.DnsSafeHost%2A>, in quanto <xref:System.Uri.IdnHost%2A> è garantito che siano sempre DNS sicuro, indipendentemente da quali corrente *app. config* impostazioni potrebbero essere.  

 Se è stata usata una stringa con caratteri di escape per costruire l'istanza (ad esempio, "http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), quindi IdnHost restituisce una stringa con caratteri di escape. È consigliabile unescape qualsiasi stringa con caratteri di escape restituita da IdnHost prima di usare tale stringa per la risoluzione DNS. Tenere presente che se è utilizzata una stringa senza caratteri di escape non valida per costruire l'istanza (ad esempio, "http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm"), quindi IdnHost restituisce una stringa senza caratteri di escape.


 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAbsoluteUri">
      <MemberSignature Language="C#" Value="public bool IsAbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsAbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbsoluteUri As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbsoluteUri { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbsoluteUri : bool" Usage="System.Uri.IsAbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'istanza di <see cref="T:System.Uri" /> è assoluta.</summary>
        <value>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se l'istanza di <see cref="T:System.Uri" /> è assoluta; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà è `true` se la stringa oppure <xref:System.Uri> istanza in cui è stato passato al costruttore può essere analizzato come assoluto <xref:System.Uri> istanza che contiene uno schema di un'autorità e un percorso. In caso contrario, il <xref:System.Uri> istanza viene considerata come relativa e omettere lo schema o altri componenti dell'URI.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBadFileSystemCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsBadFileSystemCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsBadFileSystemCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBadFileSystemCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsBadFileSystemCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsBadFileSystemCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsBadFileSystemCharacter : char -&gt; bool&#xA;override this.IsBadFileSystemCharacter : char -&gt; bool" Usage="uri.IsBadFileSystemCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Oggetto <see cref="T:System.Char" /> da verificare.</param>
        <summary>Ottiene un valore che indica se un carattere non è valido in un nome del file system.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se il carattere specificato non è valido; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il carattere viene analizzato in base alle regole per il file system NTFS.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBaseOf">
      <MemberSignature Language="C#" Value="public bool IsBaseOf (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsBaseOf(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBaseOf(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsBaseOf(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.IsBaseOf : Uri -&gt; bool" Usage="uri.IsBaseOf uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">Istanza di <see cref="T:System.Uri" /> specificata da testare.</param>
        <summary>Determina se l'istanza di <see cref="T:System.Uri" /> corrente è una base dell'istanza di <see cref="T:System.Uri" /> specificata.</summary>
        <returns>
          <see langword="true" /> se l'istanza di <see cref="T:System.Uri" /> corrente è una base di <paramref name="uri" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsBaseOf%2A> viene usato per confrontare l'oggetto corrente <xref:System.Uri> istanza specificata <xref:System.Uri> per determinare se questo URI è una base per l'oggetto specificato <xref:System.Uri>. Quando si confrontano due <xref:System.Uri> oggetti per stabilire una relazione di base, le informazioni dell'utente (<xref:System.Uri.UserInfo%2A>) non viene valutato. Quando si confrontano due URI (uri1 e uri2), uri1 costituisce la base del uri2 se, quando si ignora tutti gli elementi di uri2 dopo l'ultima barra (/), i due URI sono identici. Usando http://host/path/path/file?query come URI di base, la tabella riportata di seguito si tratti di una base per gli altri URI.  
  
|URI|http://host/path/path/file?query è la base di|  
|---------|------------------------------------------------------|  
|http://host/path/path/file/|sì|  
|http://host/path/path/#fragment|sì|  
|http://host/path/path/MoreDir/"|sì|  
|http://host/path/path/OtherFile?Query|sì|  
|http://host/path/path/|sì|  
|http://host/path/path/file|sì|  
|http://host/path/path|No|  
|http://host/path/path?query|No|  
|http://host/path/path#Fragment|No|  
|http://host/path/path2/|No|  
://host/path/path2/MoreDir|No|  
|http://host/path/File|No|  
  
   
  
## Examples  
 Questo esempio viene creato un <xref:System.Uri> istanza che rappresenta una base <xref:System.Uri> istanza. Crea quindi un secondo <xref:System.Uri> istanza da una stringa. Chiama <xref:System.Uri.IsBaseOf%2A> per determinare se l'istanza di base è la base della seconda istanza. Il risultato viene scritto nella console.  
  
 [!code-cpp[NCLUriEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#6)]
 [!code-csharp[NCLUriEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#6)]
 [!code-vb[NCLUriEnhancements#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uri" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefaultPort">
      <MemberSignature Language="C#" Value="public bool IsDefaultPort { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefaultPort" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsDefaultPort" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDefaultPort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDefaultPort { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefaultPort : bool" Usage="System.Uri.IsDefaultPort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il valore relativo alla porta dell'URI è quello predefinito per questo schema.</summary>
        <value>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se il valore della proprietà <see cref="P:System.Uri.Port" /> corrisponde alla porta predefinita per questo schema; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente crea un <xref:System.Uri> dell'istanza e viene verificato se utilizza la porta predefinita.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsExcludedCharacter">
      <MemberSignature Language="C#" Value="protected static bool IsExcludedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool IsExcludedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsExcludedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function IsExcludedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static bool IsExcludedCharacter(char character);" />
      <MemberSignature Language="F#" Value="static member IsExcludedCharacter : char -&gt; bool" Usage="System.Uri.IsExcludedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Oggetto <see cref="T:System.Char" /> da verificare.</param>
        <summary>Ottiene un valore che indica se il carattere specificato deve essere disposto in sequenza escape.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se il carattere specificato deve essere disposto in sequenza escape; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFile">
      <MemberSignature Language="C#" Value="public bool IsFile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFile" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsFile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFile As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFile { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFile : bool" Usage="System.Uri.IsFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la classe <see cref="T:System.Uri" /> specificata è un URI di file.</summary>
        <value>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se <see cref="T:System.Uri" /> è l'URI di un file; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.IsFile%2A> proprietà viene `true` quando il <xref:System.Uri.Scheme%2A> uguale a proprietà <xref:System.Uri.UriSchemeFile>.  
  
   
  
## Examples  
 L'esempio seguente crea un <xref:System.Uri> dell'istanza e determina se è un URI file.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsHexDigit">
      <MemberSignature Language="C#" Value="public static bool IsHexDigit (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexDigit(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexDigit (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexDigit(char character);" />
      <MemberSignature Language="F#" Value="static member IsHexDigit : char -&gt; bool" Usage="System.Uri.IsHexDigit character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Carattere da convalidare.</param>
        <summary>Determina se un carattere specificato è una cifra esadecimale valida.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se il carattere è una cifra esadecimale valida; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cifre esadecimali sono le cifre da 0 a 9 e le lettere A-F oppure a-f.  
  
   
  
## Examples  
 Nell'esempio seguente determina se un carattere è un carattere esadecimale e, se si tratta, scrive il valore decimale corrispondente nella console.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHexEncoding">
      <MemberSignature Language="C#" Value="public static bool IsHexEncoding (string pattern, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexEncoding(string pattern, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexEncoding(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexEncoding (pattern As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexEncoding(System::String ^ pattern, int index);" />
      <MemberSignature Language="F#" Value="static member IsHexEncoding : string * int -&gt; bool" Usage="System.Uri.IsHexEncoding (pattern, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pattern">Stringa da verificare.</param>
        <param name="index">Posizione in <c>pattern</c> di cui verificare la codifica esadecimale.</param>
        <summary>Determina se un carattere in una stringa è codificato in formato esadecimale.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se <paramref name="pattern" /> è un esadecimale codificato nella posizione specificata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.IsHexEncoding%2A> metodo verifica la codifica esadecimale che segue il modello "% hexhex" in una stringa, dove "hex" è una cifra da 0 a 9 o una lettera da A-F (maiuscole e minuscole).  
  
   
  
## Examples  
 Esempio di codice seguente determina se un carattere è esadecimale con codifica e, in questo caso, il carattere equivalente viene scritto nella console.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public bool IsLoopback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsLoopback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoopback { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoopback : bool" Usage="System.Uri.IsLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Uri" /> specificato fa riferimento all'host locale.</summary>
        <value>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se l'oggetto <see cref="T:System.Uri" /> corrente fa riferimento all'host locale; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsLoopback%2A> Restituisce `true` se l'URI specificato quando è stata creata questa istanza è stata loopback, 127.0.0.1 o localhost, o se non è stato specificato l'URI di informazioni sull'host (ad esempio, file:///c:Dir/file.txt). Tutti gli altri URI restituiscono `false`.  
  
   
  
## Examples  
 L'esempio seguente crea un <xref:System.Uri> dell'istanza e determina se fa riferimento a un host locale.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReservedCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsReservedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsReservedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsReservedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsReservedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsReservedCharacter(char character);" />
      <MemberSignature Language="F#" Value="abstract member IsReservedCharacter : char -&gt; bool&#xA;override this.IsReservedCharacter : char -&gt; bool" Usage="uri.IsReservedCharacter character" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">Oggetto <see cref="T:System.Char" /> da verificare.</param>
        <summary>Ottiene un valore che indica se il carattere specificato è un carattere riservato.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se il carattere specificato è un carattere riservato; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnc">
      <MemberSignature Language="C#" Value="public bool IsUnc { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnc" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsUnc" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnc As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnc { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnc : bool" Usage="System.Uri.IsUnc" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Uri" /> specificato è un percorso UNC (Universal Naming Convention).</summary>
        <value>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se <see cref="T:System.Uri" /> è un percorso UNC; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.IsUnc%2A> proprietà è `true` se l'oggetto specificato <xref:System.Uri> istanza è un percorso UNC (ad esempio \\\server\folder o file://server/folder). Questa proprietà restituisce sempre `true` se l'URI è conforme allo schema file:// e specifica un componente di host.  
  
   
  
## Examples  
 L'esempio seguente crea un <xref:System.Uri> dell'istanza e determina se è un percorso UNC.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedOriginalString">
      <MemberSignature Language="C#" Value="public bool IsWellFormedOriginalString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsWellFormedOriginalString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedOriginalString" />
      <MemberSignature Language="VB.NET" Value="Public Function IsWellFormedOriginalString () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsWellFormedOriginalString();" />
      <MemberSignature Language="F#" Value="member this.IsWellFormedOriginalString : unit -&gt; bool" Usage="uri.IsWellFormedOriginalString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica se la stringa usata per costruire questo oggetto <see cref="T:System.Uri" /> è ben formata e se non è necessario sottoporla ulteriormente a escape.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che è <see langword="true" /> se la stringa è ben formata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La stringa viene considerata ben formata in conformità con RFC 2396 e RFC 2732 per impostazione predefinita. Se è abilitato International Resource Identifier (IRI) o l'analisi IDN (Internationalized Domain Name), la stringa viene considerata sia in formato corretto in conformità con RFC 3986 e RFC 3987  
  
 La stringa viene considerata ben formata, pertanto il metodo restituisca false, se si verifica una delle condizioni seguenti.  
  
|Error|Esempio|  
|-----------|-------------|  
|La stringa non correttamente sottoposto a escape.|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) Nome|  
|La stringa è assoluto <xref:System.Uri> che rappresenta un file impliciti <xref:System.Uri>.|c:\\\directory\filename|  
|La stringa è un URI assoluto che non è presente una barra prima del percorso.|file://c:/directory/filename|  
|La stringa contiene barre rovesciate senza caratteri di escape anche se vengono considerate come le barre.|http:\\\host/path/file|  
|La stringa rappresenta un oggetto assoluto gerarchico <xref:System.Uri> e che non contenga "://".|www.contoso.com/path/file|  
|Il parser per il <xref:System.Uri.Scheme%2A?displayProperty=nameWithType> indica che la stringa originale non è ben formata.|L'esempio dipende dallo schema dell'URI.|  
  
 Per impostazione predefinita, la stringa utilizzata per costruire l'oggetto <xref:System.Uri> sono considerate ben formate in conformità con RFC 2396 e RFC 2732.  
  
 Quando sono abilitate International Resource Identifier (IRI) e il supporto IDN (Internationalized Domain Name), la stringa utilizzata per costruire l'oggetto <xref:System.Uri> sono considerate ben formate in conformità con RFC 3986 e RFC 3987. I nomi Punycode utilizzati per il supporto degli IRI contengano solo caratteri ASCII e iniziano sempre con il prefisso xn-.  
  
 Per altre informazioni sul supporto IRI in, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="http://www.ietf.org/">http://www.ietf.org</related>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedUriString">
      <MemberSignature Language="C#" Value="public static bool IsWellFormedUriString (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWellFormedUriString(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedUriString(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWellFormedUriString(System::String ^ uriString, UriKind uriKind);" />
      <MemberSignature Language="F#" Value="static member IsWellFormedUriString : string * UriKind -&gt; bool" Usage="System.Uri.IsWellFormedUriString (uriString, uriKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">Stringa usata per tentare di costruire un oggetto <see cref="T:System.Uri" />.</param>
        <param name="uriKind">Tipo di <see cref="T:System.Uri" /> in <c>uriString</c>.</param>
        <summary>Indica se la stringa è ben formata mediante un tentativo di costruire un URI con tale stringa e assicura che la stringa non deve essere ulteriormente sottoposta ad escape.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che è <see langword="true" /> se la stringa è ben formata; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nelle versioni di .NET precedenti alla versione 4.5, per impostazione predefinita la stringa viene considerata ben formate in conformità con RFC 2396 e RFC 2732. Se sono abilitato International Resource Identifier (IRI) o l'analisi IDN (Internationalized Domain Name), la stringa viene considerata ben formate in conformità con RFC 3986 e RFC 3987.  
  
 A partire da .NET 4.5, le stringhe sempre considerate ben formate in conformità con RFC 3986 e RFC 3987, o meno gli IRI o IDN sono abilitate. Si noti tuttavia che questo è solo true per le app destinate a .NET 4.5 o versione successiva. Le app destinate a .NET 4.0 richiamano il codice di compatibilità e verificano il comportamento precedente (pre-4.5).  
  
 La stringa viene considerata ben formata, pertanto il metodo restituisca false, se si verifica una delle condizioni seguenti  
  
|Error|Esempio|  
|-----------|-------------|  
|La stringa non correttamente sottoposto a escape.|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) Nome|  
|La stringa è assoluto <xref:System.Uri> che rappresenta un file impliciti <xref:System.Uri>.|c:\\\directory\filename|  
|La stringa è un URI assoluto che non è presente una barra prima del percorso.|file://c:/directory/filename|  
|La stringa contiene barre rovesciate senza caratteri di escape anche se essi verranno gestiti come barre|http:\\\host/path/file|  
|La stringa rappresenta un oggetto assoluto gerarchico <xref:System.Uri> e che non contenga "://"|www.contoso.com/path/file|  
|Il parser per il <xref:System.Uri.Scheme%2A> indica che la stringa originale non è ben formata.|L'esempio dipende dallo schema dell'URI.|  
|A partire da .NET 4.5, i relativi URI con un carattere due punti (': ') nel primo segmento non sono considerati ben formato.|2013.05.29_14:33:41|  
  
 Per altre informazioni sul supporto IRI in, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="http://www.ietf.org/">http://www.ietf.org</related>
      </Docs>
    </Member>
    <Member MemberName="LocalPath">
      <MemberSignature Language="C#" Value="public string LocalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalPath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.LocalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LocalPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalPath : string" Usage="System.Uri.LocalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una rappresentazione di un nome file nel formato del sistema operativo locale.</summary>
        <value>Oggetto <see cref="T:System.String" /> che contiene la rappresentazione del sistema operativo locale di un nome file.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà è non di escape. Se il percorso viene riconosciuto come un percorso di file di Windows, tutte le barre (/) vengono sostituite dalle barre rovesciate (\\).  
  
 Per l'URI `file://computer/file.ext`, è il percorso assoluto `/file.ext` e il percorso locale è `\\computer\file.ext`.  
  
   
  
## Examples  
 L'esempio seguente crea un <xref:System.Uri> dell'istanza e scrive il percorso locale alla console.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelative">
      <MemberSignature Language="C#" Value="public string MakeRelative (Uri toUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MakeRelative(class System.Uri toUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelative(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function MakeRelative (toUri As Uri) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MakeRelative(Uri ^ toUri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelative : Uri -&gt; string" Usage="uri.MakeRelative toUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use MakeRelativeUri(Uri uri). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="toUri">URI da confrontare con l'URI corrente.</param>
        <summary>Determina la differenza tra due istanze di <see cref="T:System.Uri" />.</summary>
        <returns>Se il nome host e lo schema di questa istanza di URI e <paramref name="toUri" /> sono identici, questo metodo restituisce un oggetto <see cref="T:System.String" /> che rappresenta un URI relativo che, quando aggiunto all'istanza URI corrente, restituisce il parametro <paramref name="toUri" />.  
  
Se il nome host o lo schema è differente, questo metodo restituisce un oggetto <see cref="T:System.String" /> che rappresenta il parametro <paramref name="toUri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tabella seguente mostra l'istanza, URI `toUri`e i risultati della chiamata al metodo <xref:System.Uri.MakeRelative%2A>.  
  
|Istanza URI corrente|`toUri`|Valore restituito|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|test/test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|../|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|test1/test1.txt|  
  
 Informazioni sull'utente, se presente nell'URI, viene ignorati.  
  
   
  
## Examples  
 L'esempio seguente crea 2 <xref:System.Uri> istanze. La differenza tra le informazioni sul percorso viene scritto nella console.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toUri" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questo metodo è valido solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelativeUri">
      <MemberSignature Language="C#" Value="public Uri MakeRelativeUri (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Uri MakeRelativeUri(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelativeUri(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri ^ MakeRelativeUri(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.MakeRelativeUri : Uri -&gt; Uri" Usage="uri.MakeRelativeUri uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">URI da confrontare con l'URI corrente.</param>
        <summary>Determina la differenza tra due istanze di <see cref="T:System.Uri" />.</summary>
        <returns>Se il nome host e lo schema di questa istanza di URI e <paramref name="uri" /> sono identici, questo metodo restituisce un oggetto <see cref="T:System.Uri" /> relativo che, se aggiunto all'istanza di URI corrente, restituisce <paramref name="uri" />.  
  
Se il nome host o lo schema è differente, questo metodo restituisce un oggetto <see cref="T:System.Uri" /> che rappresenta il parametro <paramref name="uri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tabella seguente mostra l'istanza, URI `toUri`e i risultati della chiamata al metodo <xref:System.Uri.MakeRelativeUri%2A>.  
  
|Istanza URI corrente|`toUri`|Valore restituito|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|test/test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|../|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|test1/test1.txt|  
  
 Informazioni sull'utente, se presente nell'URI, viene ignorati.  
  
   
  
## Examples  
 L'esempio seguente crea 2 <xref:System.Uri> istanze. La differenza tra le informazioni sul percorso viene scritto nella console.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uri" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Equality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Uri * Uri -&gt; bool" Usage="uri1 = uri2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">Istanza di <see cref="T:System.Uri" /> da confrontare con <c>uri2</c>.</param>
        <param name="uri2">Istanza di <see cref="T:System.Uri" /> da confrontare con <c>uri1</c>.</param>
        <summary>Determina se due istanze di <see cref="T:System.Uri" /> hanno lo stesso valore.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se le istanze di <see cref="T:System.Uri" /> sono equivalenti; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload viene utilizzato il <xref:System.Uri.Equals%2A> metodo per determinare se i due <xref:System.Uri> istanze sono equivalenti. <xref:System.Uri.UserInfo%2A> e <xref:System.Uri.Fragment%2A> contenuto viene ignorato quando si effettua il confronto.  
  
   
  
## Examples  
 Questo esempio crea tre <xref:System.Uri> istanze dalle stringhe e vengono quindi confrontati per determinare se rappresentano lo stesso valore. `Address1` e `Address2` sono uguali, in quanto il <xref:System.Uri.Fragment%2A> parte viene ignorata per questo confronto. Il risultato viene scritto nella console.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Inequality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Uri ^ uri1, Uri ^ uri2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Uri * Uri -&gt; bool" Usage="System.Uri.op_Inequality (uri1, uri2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">Istanza di <see cref="T:System.Uri" /> da confrontare con <c>uri2</c>.</param>
        <param name="uri2">Istanza di <see cref="T:System.Uri" /> da confrontare con <c>uri1</c>.</param>
        <summary>Determina se due istanze di <see cref="T:System.Uri" /> non hanno lo stesso valore.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se le due istanze di <see cref="T:System.Uri" /> non sono uguali; in caso contrario, <see langword="false" />. Se uno dei parametri è <see langword="null" />, questo metodo restituisce <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload viene utilizzato il <xref:System.Uri.Equals%2A> metodo per determinare se i due <xref:System.Uri> istanze non sono equivalenti. <xref:System.Uri.UserInfo%2A> e <xref:System.Uri.Fragment%2A> contenuto viene ignorato quando si effettua il confronto.  
  
   
  
## Examples  
 Questo esempio crea tre <xref:System.Uri> istanze dalle stringhe e vengono quindi confrontati per determinare se rappresentano lo stesso valore. `Address2` e `Address3` non sono uguali perché `Address3` contiene una <xref:System.Uri.Query%2A> che non viene trovato nel `Address2`. Il risultato viene scritto nella console.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalString">
      <MemberSignature Language="C#" Value="public string OriginalString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OriginalString" />
      <MemberSignature Language="DocId" Value="P:System.Uri.OriginalString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OriginalString { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalString : string" Usage="System.Uri.OriginalString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la stringa URI originale passata al costruttore <see cref="T:System.Uri" />.</summary>
        <value>Oggetto <see cref="T:System.String" /> contenente l'URI esatto specificato alla costruzione di questa istanza; in caso contrario, <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'URI specificato al costruttore contenuti spazi iniziali o finali, tali spazi vengono mantenuti.  
  
 Il valore restituito da questa proprietà è diverso da <xref:System.Uri.ToString%2A> e <xref:System.Uri.AbsoluteUri%2A>. <xref:System.Uri.ToString%2A> Restituisce il formato canonico senza caratteri escape dell'URI. <xref:System.Uri.AbsoluteUri%2A> Restituisce il formato dell'URI con caratteri di escape formato canonico.  
  
 Quando il supporto IDN (Internationalized Domain Name) e International Resource Identifier (IRI) sono abilitati, <xref:System.Uri.OriginalString%2A> restituisce la stringa originale non normalizzata con il nome host Punycode se ne è stato usato per inizializzare il <xref:System.Uri> istanza. I nomi Punycode contengono solo caratteri ASCII e iniziano sempre con il prefisso "xn--".  
  
 Per altre informazioni sul supporto IRI in, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
 Quando un <xref:System.Uri> oggetto viene serializzato, il <xref:System.Uri.OriginalString%2A> non viene mantenuto. Il processo di serializzazione utilizza completamente con caratteri di escape e in forma canonica <xref:System.Uri.AbsoluteUri%2A> proprietà durante la serializzazione. Per un <xref:System.Uri> che contiene un indirizzo IPv6, l'indirizzo IPv6 e l'ID ambito sono inclusi in serializzata <xref:System.Uri> oggetto.  
  
   
  
## Examples  
 L'esempio seguente crea un nuovo <xref:System.Uri> istanza da una stringa. Viene illustrata la differenza tra il valore restituito da <xref:System.Uri.OriginalString%2A>, che restituisce la stringa passata al costruttore e da una chiamata a <xref:System.Uri.ToString%2A>, che restituisce la forma canonica della stringa.  
  
 [!code-cpp[NCLUriEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#3)]
 [!code-csharp[NCLUriEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#3)]
 [!code-vb[NCLUriEnhancements#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="protected virtual void Parse ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Parse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Parse" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Parse ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Parse();" />
      <MemberSignature Language="F#" Value="abstract member Parse : unit -&gt; unit&#xA;override this.Parse : unit -&gt; unit" Usage="uri.Parse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Analizza l'URI dell'istanza corrente per assicurare che contenga tutte le parti richieste per un URI valido.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">L'URI passato dal costruttore non è valido.</exception>
      </Docs>
    </Member>
    <Member MemberName="PathAndQuery">
      <MemberSignature Language="C#" Value="public string PathAndQuery { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathAndQuery" />
      <MemberSignature Language="DocId" Value="P:System.Uri.PathAndQuery" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathAndQuery As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathAndQuery { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathAndQuery : string" Usage="System.Uri.PathAndQuery" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene le proprietà <see cref="P:System.Uri.AbsolutePath" /> e <see cref="P:System.Uri.Query" /> separate da un punto interrogativo (?).</summary>
        <value>Oggetto <see cref="T:System.String" /> che contiene le proprietà <see cref="P:System.Uri.AbsolutePath" /> e <see cref="P:System.Uri.Query" /> separate da un punto interrogativo (?).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.PathAndQuery%2A> proprietà contiene il percorso assoluto nel server e le informazioni di query inviato con la richiesta. È identica alla concatenazione di <xref:System.Uri.AbsolutePath%2A> e <xref:System.Uri.Query%2A> proprietà.  
  
 Il <xref:System.Uri.PathAndQuery%2A> proprietà viene sottoposto a escape in base alla RFC 2396 per impostazione predefinita. Se è abilitato International Resource Identifier (IRI) o l'analisi IDN (Internationalized Domain Name), il <xref:System.Uri.PathAndQuery%2A> proprietà verrà sottoposte a escape in base allo standard RFC 3986 e RFC 3987.  
  
 Per altre informazioni sul supporto IRI in, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
   
  
## Examples  
 L'esempio seguente scrive il percorso dell'URI (/ /catalog/shownew.htm) ed eseguire una query (date = today) informazioni nella console.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.PathAndQuery Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="Port">
      <MemberSignature Language="C#" Value="public int Port { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Port" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Port" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Port As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Port { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Port : int" Usage="System.Uri.Port" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di porta di questo URI.</summary>
        <value>Valore <see cref="T:System.Int32" /> contenente il numero di porta per questo URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il numero di porta definisce il protocollo di porta usato per contattare il server di cui viene fatto riferimento nell'URI. Se una porta non è specificata come parte dell'URI, il <xref:System.Uri.Port%2A> proprietà restituisce il valore predefinito per il protocollo. Se è presente alcun numero di porta predefinito, questa proprietà restituisce -1.  
  
   
  
## Examples  
 Nell'esempio seguente scrive nella console il numero di porta URI. In questo caso, il valore è il numero di porta predefinito per il protocollo HTTP, la porta 80.  
  
 [!code-cpp[Classic Uri.Port Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Port Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Port Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Port Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Port Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Port Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="Query">
      <MemberSignature Language="C#" Value="public string Query { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Query" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Query" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Query As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Query { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Query : string" Usage="System.Uri.Query" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene le informazioni sulle query incluse nell'URI specificato.</summary>
        <value>Oggetto <see cref="T:System.String" /> contenente le informazioni sulle query incluse nell'URI specificato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.Query%2A> proprietà contiene le informazioni sulle query incluse nell'URI. Informazioni sulle query separate dalle informazioni di percorso da un punto interrogativo (?) e continua fino alla fine dell'URI. Le informazioni restituite sono il punto interrogativo iniziale.  
  
 Per impostazione predefinita, le informazioni della query sono codificate in base alle RFC 2396. Se è abilitato International Resource Identifier (IRI) o l'analisi IDN (Internationalized Domain Name), le informazioni della query viene sottoposto a escape in base allo standard RFC 3986 e RFC 3987.  
  
 Per altre informazioni sul supporto IRI in, vedere la sezione Osservazioni per il <xref:System.Uri> classe.  
  
   
  
## Examples  
 L'esempio seguente scrive la query? date = today nella console.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#2)]
 [!code-vb[Classic Uri.PathAndQuery Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheme : string" Usage="System.Uri.Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome di schema per questo URI.</summary>
        <value>Oggetto <see cref="T:System.String" /> contenente lo schema per questo URI, convertito in caratteri minuscoli.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.Scheme%2A> proprietà restituisce lo schema utilizzato per inizializzare il <xref:System.Uri> istanza. Questa proprietà non indica che lo schema utilizzato per inizializzare il <xref:System.Uri> istanza è stata riconosciuta.  
  
 Nella tabella seguente vengono illustrati esempi di alcuni valori possibili restituiti dai <xref:System.Uri.Scheme%2A> proprietà.  
  
|Scheme|Descrizione|  
|------------|-----------------|  
|file|La risorsa è un file nel computer locale.|  
|ftp|La risorsa è accessibile tramite FTP.|  
|gopher|La risorsa è accessibile tramite il protocollo Gopher.|  
|http|La risorsa è accessibile tramite HTTP.|  
|https|La risorsa è accessibile tramite HTTP con crittografia SSL.|  
|LDAP|La risorsa è accessibile tramite il protocollo LDAP.|  
|mailto|La risorsa è un indirizzo di posta elettronica e si accede tramite il protocollo SMTP.|  
|net.pipe|La risorsa è accessibile tramite una named pipe.|  
|net.tcp|La risorsa è accessibile dall'endpoint TCP.|  
|news|La risorsa è accessibile tramite il protocollo NNTP.|  
|nntp|La risorsa è accessibile tramite il protocollo NNTP.|  
|telnet|La risorsa è accessibile tramite il protocollo TELNET.|  
|uuid|La risorsa è accessibile tramite un nome di endpoint UUID univoco per la comunicazione con un servizio.|  
  
   
  
## Examples  
 Nell'esempio seguente scrive nella console per il nome dello schema (http) il http://www.contoso.com/ URI.  
  
 [!code-cpp[Classic Uri.Scheme Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Scheme Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Scheme Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Scheme Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemeDelimiter">
      <MemberSignature Language="C#" Value="public static readonly string SchemeDelimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string SchemeDelimiter" />
      <MemberSignature Language="DocId" Value="F:System.Uri.SchemeDelimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SchemeDelimiter As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ SchemeDelimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable SchemeDelimiter : string" Usage="System.Uri.SchemeDelimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica i caratteri che separano lo schema del protocollo di comunicazione dalla parte di indirizzo dell'URI. Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente crea una stringa da <xref:System.Uri.UriSchemeHttp>, <xref:System.Uri.SchemeDelimiter>e un indirizzo. Oggetto <xref:System.Uri> istanza viene quindi creata dalla stringa.  
  
 [!code-cpp[NCLUriExamples#17](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#17)]
 [!code-csharp[NCLUriExamples#17](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#17)]
 [!code-vb[NCLUriExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Segments">
      <MemberSignature Language="C#" Value="public string[] Segments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Segments" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Segments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Segments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Segments { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Segments : string[]" Usage="System.Uri.Segments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una matrice contenente i segmenti di percorso che compongono l'URI specificato.</summary>
        <value>Matrice <see cref="T:System.String" /> contenente i segmenti di percorso che compongono l'URI specificato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.Segments%2A> proprietà restituisce una matrice di stringhe contenente i "segmenti" (sottostringhe) che formano il percorso dell'URI assoluto. Il primo segmento è ottenuto tramite l'analisi del percorso assoluto dal primo carattere fino a raggiungere una barra (/) o alla fine del percorso. Ogni segmento aggiuntiva in cui inizia il primo carattere dopo il segmento precedente e termina con la barra avanti o fine del percorso. (Percorso assoluto dell'URI contiene tutti gli elementi dopo l'host e la porta e prima della query e frammento).  
  
 Nell'esempio seguente mostra i segmenti e il percorso assoluto per due URI. Nel secondo esempio viene illustrato che il frammento e la query non fanno parte del percorso assoluto e non sono pertanto segmenti.  
  
 URI assoluto:  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm  
  
 Percorso assoluto:  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Segmenti:  
 - /
 - Capitoli /
 - Capitolo 1 /
 - Nelle sezioni /
 - Section1.htm  
  
 URI assoluto:  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm#page1?answer=NO  
  
 Percorso assoluto:  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Segmenti:  
 - /
 - Capitoli /
 - Capitolo 1 /
 - Nelle sezioni /
 - Section1.htm  
  
 Si noti che, poiché il percorso assoluto inizia con '/', il primo segmento contiene e nient'altro.  
  
   
  
## Examples  
 L'esempio seguente crea un <xref:System.Uri> istanza con 3 segmenti e visualizzati sullo schermo.  
  
 [!code-cpp[NCLUriExamples#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#5)]
 [!code-csharp[NCLUriExamples#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#5)]
 [!code-vb[NCLUriExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> contenente le informazioni necessarie per serializzare l'oggetto <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Oggetto <see cref="T:System.Runtime.Serialization.StreamingContext" /> contenente l'origine e la destinazione del flusso serializzato associato a <see cref="T:System.Uri" />.</param>
        <summary>Restituisce i dati necessari per serializzare l'istanza corrente.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per usare i metodi di serializzazione. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="uri.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene una rappresentazione in forma di stringa canonica per l'istanza di <see cref="T:System.Uri" /> specificata.</summary>
        <returns>Istanza di <see cref="T:System.String" /> che contiene la rappresentazione canonica senza caratteri escape dell'istanza di <see cref="T:System.Uri" />. Non viene effettuato l'escape di alcun carattere, ad eccezione di #, ? e %.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La stringa restituita da questo metodo non contiene informazioni sulla porta quando la porta è la porta predefinita per lo schema.  
  
> [!NOTE]
>  La stringa restituita dal <xref:System.Uri.ToString%2A> metodo può contenere caratteri di controllo che possono danneggiare lo stato di un'applicazione console. È possibile usare la <xref:System.Uri.GetComponents%2A> metodo con il <xref:System.UriFormat.SafeUnescaped?displayProperty=nameWithType> formato per rimuovere i caratteri di controllo dalla stringa restituita.  
  
   
  
## Examples  
 L'esempio seguente crea un nuovo <xref:System.Uri> istanza da una stringa. Viene illustrata la differenza tra il valore restituito da <xref:System.Uri.OriginalString%2A>, che restituisce la stringa passata al costruttore e da una chiamata a <xref:System.Uri.ToString%2A>, che restituisce la forma canonica della stringa.  
  
 [!code-cpp[NCLUriExamples#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#7)]
 [!code-csharp[NCLUriExamples#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#7)]
 [!code-vb[NCLUriExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#7)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per impedire che deriva da codice parzialmente attendibile <see cref="T:System.Uri" />. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryCreate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo oggetto <see cref="T:System.Uri" />. Se non è possibile creare l'oggetto <see cref="T:System.Uri" />, non viene generata alcuna eccezione.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (string uriString, UriKind uriKind, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(string uriString, valuetype System.UriKind uriKind, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.String,System.UriKind,System.Uri@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(System::String ^ uriString, UriKind uriKind, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : string * UriKind *  -&gt; bool" Usage="System.Uri.TryCreate (uriString, uriKind, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
        <Parameter Name="result" Type="System.Uri" RefType="out" />
      </Parameters>
      <Docs>
        <param name="uriString">Oggetto <see cref="T:System.String" /> che rappresenta l'oggetto <see cref="T:System.Uri" />.</param>
        <param name="uriKind">Tipo dell'URI.</param>
        <param name="result">Quando questo metodo viene restituito, contiene l'oggetto <see cref="T:System.Uri" /> costruito.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Uri" /> usando l'istanza di <see cref="T:System.String" /> specificata e un oggetto <see cref="T:System.UriKind" />.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se l'oggetto <see cref="T:System.Uri" /> è stato creato correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questo metodo restituisce `true`, il nuovo <xref:System.Uri> in `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, string relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, string relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.String,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As String, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, System::String ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * string *  -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="result" Type="System.Uri" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">Oggetto <see cref="T:System.Uri" /> di base.</param>
        <param name="relativeUri">Oggetto <see cref="T:System.Uri" /> relativo, rappresentato come oggetto <see cref="T:System.String" />, da aggiungere all'oggetto <see cref="T:System.Uri" /> di base.</param>
        <param name="result">Quando termina, questo metodo contiene un oggetto <see cref="T:System.Uri" /> costruito da <c>baseUri</c> e <c>relativeUri</c>. Questo parametro viene passato non inizializzato.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Uri" /> usando le istanze di <see cref="T:System.String" /> relativa e di base.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se l'oggetto <see cref="T:System.Uri" /> è stato creato correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questo metodo restituisce `true`, il nuovo <xref:System.Uri> in `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, Uri relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, class System.Uri relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.Uri,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As Uri, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, Uri ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : Uri * Uri *  -&gt; bool" Usage="System.Uri.TryCreate (baseUri, relativeUri, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
        <Parameter Name="result" Type="System.Uri" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">Oggetto <see cref="T:System.Uri" /> di base.</param>
        <param name="relativeUri">Oggetto <see cref="T:System.Uri" /> relativo da aggiungere all'oggetto <see cref="T:System.Uri" /> di base.</param>
        <param name="result">Quando termina, questo metodo contiene un oggetto <see cref="T:System.Uri" /> costruito da <c>baseUri</c> e <c>relativeUri</c>. Questo parametro viene passato non inizializzato.</param>
        <summary>Crea un nuovo oggetto <see cref="T:System.Uri" /> usando le istanze di <see cref="T:System.Uri" /> relativa e di base.</summary>
        <returns>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se l'oggetto <see cref="T:System.Uri" /> è stato creato correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questo metodo restituisce `true`, il nuovo <xref:System.Uri> in `result`.  
  
 Questo metodo costruisce l'URI, lo inserisce in forma canonica e lo convalida. Se si verifica un'eccezione non gestita, questo metodo intercetta. Se si desidera creare un <xref:System.Uri> vengano generate eccezioni utilizzare uno del <xref:System.Uri.%23ctor%2A> costruttori.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="protected virtual string Unescape (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string Unescape(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Unescape (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ Unescape(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member Unescape : string -&gt; string&#xA;override this.Unescape : string -&gt; string" Usage="uri.Unescape path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Oggetto <see cref="T:System.String" /> da convertire.</param>
        <summary>Converte la stringa specificata sostituendo qualsiasi sequenza di escape con la relativa rappresentazione senza caratteri escape.</summary>
        <returns>Oggetto <see cref="T:System.String" /> contenente il valore senza caratteri escape del parametro <paramref name="path" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnescapeDataString">
      <MemberSignature Language="C#" Value="public static string UnescapeDataString (string stringToUnescape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UnescapeDataString(string stringToUnescape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.UnescapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnescapeDataString (stringToUnescape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UnescapeDataString(System::String ^ stringToUnescape);" />
      <MemberSignature Language="F#" Value="static member UnescapeDataString : string -&gt; string" Usage="System.Uri.UnescapeDataString stringToUnescape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToUnescape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToUnescape">Stringa da convertire in stringa senza caratteri escape.</param>
        <summary>Converte una stringa nella relativa rappresentazione senza caratteri escape.</summary>
        <returns>Oggetto <see cref="T:System.String" /> che contiene la rappresentazione senza caratteri escape di <paramref name="stringToUnescape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È consigliabile utilizzarlo con cautela. Una stringa che è stato in precedenza senza caratteri escape unescaping può causare ambiguità e gli errori.  
  
 Gli spazi all'interno degli URI di escape molti browser Web in più caratteri ("+"); Tuttavia, il metodo di fatto che UnescapeDataString generi non converte più caratteri in spazi di perché questo comportamento non standard tutti gli schemi URI.  
  
   
  
## Examples  
 Esempio di codice seguente rimuove un URI e quindi converte uno più caratteri ("+") in spazi.  
  
 [!code-csharp[NCLUriExamples#19](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToUnescape" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Uri.EscapeDataString(System.String)" />
        <altmember cref="M:System.Uri.EscapeUriString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFile">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFile" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFile As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFile;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFile : string" Usage="System.Uri.UriSchemeFile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che l'URI è un puntatore a un file. Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework versione 1.1, un "`file:///path`"URI è stato convertito in"`file:/path`". Questo problema è stato corretto per la versione 2.0.  
  
   
  
## Examples  
 L'esempio seguente crea una <xref:System.Uri> dell'istanza e determina se lo schema è <xref:System.Uri.UriSchemeFile>.  
  
 [!code-cpp[NCLUriExamples#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#10)]
 [!code-csharp[NCLUriExamples#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#10)]
 [!code-vb[NCLUriExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFtp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFtp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFtp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFtp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFtp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFtp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeFtp : string" Usage="System.Uri.UriSchemeFtp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che l'accesso all'URI viene eseguito tramite FTP (File Transfer Protocol). Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente crea una <xref:System.Uri> dell'istanza e determina se lo schema è <xref:System.Uri.UriSchemeFtp>.  
  
 [!code-cpp[NCLUriExamples#15](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#15)]
 [!code-csharp[NCLUriExamples#15](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#15)]
 [!code-vb[NCLUriExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeGopher">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeGopher;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeGopher" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeGopher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeGopher As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeGopher;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeGopher : string" Usage="System.Uri.UriSchemeGopher" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che l'accesso all'URI viene eseguito tramite il protocollo Gopher. Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente crea una <xref:System.Uri> dell'istanza e determina se lo schema è <xref:System.Uri.UriSchemeGopher>.  
  
 [!code-cpp[NCLUriExamples#14](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#14)]
 [!code-csharp[NCLUriExamples#14](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#14)]
 [!code-vb[NCLUriExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttp : string" Usage="System.Uri.UriSchemeHttp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che l'accesso all'URI viene eseguito tramite HTTP (Hypertext Transfer Protocol). Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente crea una <xref:System.Uri> dell'istanza e determina se lo schema è <xref:System.Uri.UriSchemeHttp>.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttps">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttps;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttps" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttps" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttps As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttps;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeHttps : string" Usage="System.Uri.UriSchemeHttps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che l'accesso all'URI viene eseguito tramite HTTPS (Secure Hypertext Transfer Protocol). Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente crea una <xref:System.Uri> dell'istanza e determina se lo schema è <xref:System.Uri.UriSchemeHttps>.  
  
 [!code-cpp[NCLUriExamples#16](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#16)]
 [!code-csharp[NCLUriExamples#16](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#16)]
 [!code-vb[NCLUriExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeMailto">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeMailto;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeMailto" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeMailto" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeMailto As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeMailto;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeMailto : string" Usage="System.Uri.UriSchemeMailto" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che l'URI è un indirizzo di posta elettronica a cui si accede tramite SMTP (Simple Mail Transport Protocol). Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente crea una <xref:System.Uri> dell'istanza e determina se lo schema è <xref:System.Uri.UriSchemeMailto>.  
  
 [!code-cpp[NCLUriExamples#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#11)]
 [!code-csharp[NCLUriExamples#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#11)]
 [!code-vb[NCLUriExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetPipe">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetPipe;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetPipe" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetPipe" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetPipe As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetPipe;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetPipe : string" Usage="System.Uri.UriSchemeNetPipe" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che all'URI si accede tramite lo schema NetPipe usato da Windows Communication Foundation (WCF). Questo campo è di sola lettura.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetTcp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetTcp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetTcp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetTcp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetTcp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetTcp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNetTcp : string" Usage="System.Uri.UriSchemeNetTcp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che all'URI si accede tramite lo schema NetTcp usato da Windows Communication Foundation (WCF). Questo campo è di sola lettura.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNews">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNews;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNews" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNews" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNews As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNews;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNews : string" Usage="System.Uri.UriSchemeNews" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che l'URI è un newsgroup Internet a cui si accede tramite NNTP (Network News Transport Protocol). Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente crea una <xref:System.Uri> dell'istanza e determina se lo schema è <xref:System.Uri.UriSchemeNews>.  
  
 [!code-cpp[NCLUriExamples#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#12)]
 [!code-csharp[NCLUriExamples#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#12)]
 [!code-vb[NCLUriExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNntp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNntp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNntp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNntp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNntp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNntp;" />
      <MemberSignature Language="F#" Value=" staticval mutable UriSchemeNntp : string" Usage="System.Uri.UriSchemeNntp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che l'URI è un newsgroup Internet a cui si accede tramite NNTP (Network News Transport Protocol). Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il protocollo NNTP <xref:System.Uri> l'analisi degli errori in .NET Framework versione 1.1 sono state corrette.  
  
   
  
## Examples  
 L'esempio seguente crea una <xref:System.Uri> dell'istanza e determina se lo schema è <xref:System.Uri.UriSchemeNntp>.  
  
 [!code-cpp[NCLUriExamples#13](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#13)]
 [!code-csharp[NCLUriExamples#13](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#13)]
 [!code-vb[NCLUriExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserEscaped">
      <MemberSignature Language="C#" Value="public bool UserEscaped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UserEscaped" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserEscaped" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserEscaped As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UserEscaped { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserEscaped : bool" Usage="System.Uri.UserEscaped" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica che la stringa URI è stata sottoposta a escape completo prima della creazione dell'istanza di <see cref="T:System.Uri" />.</summary>
        <value>Valore <see cref="T:System.Boolean" /> che restituisce <see langword="true" /> se il parametro <paramref name="dontEscape" /> è stato impostato su <see langword="true" /> al momento della creazione dell'istanza di <see cref="T:System.Uri" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Uri.UserEscaped%2A> è impostata su `true` per indicare che la stringa utilizzata per creare il <xref:System.Uri> istanza è stata sottoposta a escape completo prima che è stato passato al costruttore, vale a dire, il `dontEscape` parametro della chiamata al costruttore è stato impostato su `true`.  
  
   
  
## Examples  
 L'esempio seguente crea un <xref:System.Uri> dell'istanza e determina se è stata sottoposta a escape completamente al momento della creazione.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInfo">
      <MemberSignature Language="C#" Value="public string UserInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserInfo" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserInfo { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInfo : string" Usage="System.Uri.UserInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome utente, la password o altre informazioni specifiche dell'utente associate all'URI specificato.</summary>
        <value>Oggetto <see cref="T:System.String" /> contenente le informazioni utente associate all'URI. Il valore restituito non include il carattere "@" riservato per la delimitazione della parte di informazioni utente dell'URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito da questa proprietà è in genere nel formato "nomeutente: password".  
  
   
  
## Examples  
 L'esempio seguente crea un <xref:System.Uri> dell'istanza e scrive le informazioni utente nella console.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Questa istanza rappresenta un URI relativo e questa proprietà è valida solo per URI assoluti.</exception>
      </Docs>
    </Member>
  </Members>
</Type>