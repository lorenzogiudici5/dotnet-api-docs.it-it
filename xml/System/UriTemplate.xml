<Type Name="UriTemplate" FullName="System.UriTemplate">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="728f9df1bd77a70d54ad92595c4118c3b41e0b65" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39926481" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UriTemplate" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UriTemplate extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.UriTemplate" />
  <TypeSignature Language="VB.NET" Value="Public Class UriTemplate" />
  <TypeSignature Language="C++ CLI" Value="public ref class UriTemplate" />
  <TypeSignature Language="F#" Value="type UriTemplate = class" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Web</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Classe che rappresenta un modello Uniform Resource Identifier (URI).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un modello URI consente di definire un set di URI strutturalmente simili. I modelli sono composti di due parti, un percorso e una query. Un percorso è costituito da una serie di segmenti delimitati da una barra (/). Ogni segmento può avere un valore letterale, un valore variabile (scritto tra parentesi graffe [{}], che deve corrispondere al contenuto di un solo segmento) o un carattere jolly (scritto come asterisco [*], che corrisponde al "resto del percorso") che deve essere visualizzato alla fine del percorso. L'espressione di query può essere interamente omessa. Se presente, specifica una serie non ordinata di coppie nome/valore. Gli elementi dell'espressione di query possono essere coppie letterali (?x=2) o coppie variabili (?x={valore}). Non è consentito usare valori non abbinati. Le stringhe seguenti rappresentano esempi validi di stringhe di modello:  
  
-   "previsioni/CA/Napoli"  
  
-   "previsioni/{regione}/{città}"  
  
-   "previsioni/*"  
  
-   "previsioni/{regione}/{città}?previsioni=oggi"  
  
-   "previsioni/{regione}/{città}?previsioni={giorno}"  
  
 I modelli URI appena elencati potrebbero essere utilizzati come struttura su cui basare le previsioni del tempo. I segmenti racchiusi fra parentesi graffe sono variabili. Gli altri segmenti rappresentano valori letterali. È possibile convertire un'istanza della classe <xref:System.UriTemplate> in un oggetto <xref:System.Uri> sostituendo le variabili con valori effettivi. Ad esempio, se nel modello "previsioni/{regione}/{città}" sostituiamo valori effettivi alle variabili "{regione}" e "{città}" otteniamo l'URI "previsioni/CA/Napoli". Per verificare se un determinato URI candidato corrisponde a un modello URI specificato è possibile chiamare il metodo <xref:System.UriTemplate.Match%28System.Uri%2CSystem.Uri%29>. Le istanze della classe <xref:System.UriTemplate> possono inoltre essere utilizzate per creare un oggetto <xref:System.Uri> a partire da un set di valori variabili. A tale scopo, chiamare il metodo <xref:System.UriTemplate.BindByName%28System.Uri%2CSystem.Collections.Specialized.NameValueCollection%29> o <xref:System.UriTemplate.BindByPosition%28System.Uri%2CSystem.String%5B%5D%29>.  
  
   
  
## Examples  
 Nel codice seguente viene illustrato come creare un'istanza di <xref:System.UriTemplate> e come associarla e confrontarla a un URI candidato.  
  
 [!code-csharp[UriTemplate#0](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplate/cs/snippets.cs#0)]
 [!code-vb[UriTemplate#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplate/vb/snippets.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.UriTemplate" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UriTemplate (string template);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string template) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplate.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (template As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UriTemplate(System::String ^ template);" />
      <MemberSignature Language="F#" Value="new UriTemplate : string -&gt; UriTemplate" Usage="new System.UriTemplate template" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="template" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="template">Modello.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.UriTemplate" /> con la stringa di modello specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare il costruttore.  
  
 [!code-csharp[UriTemplate#1](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplate/cs/snippets.cs#1)]
 [!code-vb[UriTemplate#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplate/vb/snippets.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UriTemplate (string template, bool ignoreTrailingSlash);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string template, bool ignoreTrailingSlash) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplate.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (template As String, ignoreTrailingSlash As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UriTemplate(System::String ^ template, bool ignoreTrailingSlash);" />
      <MemberSignature Language="F#" Value="new UriTemplate : string * bool -&gt; UriTemplate" Usage="new System.UriTemplate (template, ignoreTrailingSlash)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="template" Type="System.String" />
        <Parameter Name="ignoreTrailingSlash" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="template">Stringa di modello.</param>
        <param name="ignoreTrailingSlash">Valore che specifica se le barre finali "/" devono essere ignorate.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.UriTemplate" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `ignoreTrailingSlash` viene impostato su `true`, le barre finali alla fine del modello vengono ignorate quando si crea una corrispondenza con un URI candidato. Ad esempio, un modello, ad esempio "http://www.microsoft.com/customer/" corrisponderebbe URI candidati seguenti:  
  
-   "http://www.microsoft.com/customer/"  
  
-   "http://www.microsoft.com/customer"  
  
-   "http://www.microsoft.com/customer/?wsdl"  
  
-   "http://www.microsoft.com/customer?wsdl"  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UriTemplate (string template, System.Collections.Generic.IDictionary&lt;string,string&gt; additionalDefaults);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string template, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; additionalDefaults) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplate.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (template As String, additionalDefaults As IDictionary(Of String, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UriTemplate(System::String ^ template, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ additionalDefaults);" />
      <MemberSignature Language="F#" Value="new UriTemplate : string * System.Collections.Generic.IDictionary&lt;string, string&gt; -&gt; UriTemplate" Usage="new System.UriTemplate (template, additionalDefaults)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="template" Type="System.String" />
        <Parameter Name="additionalDefaults" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="template">Stringa di modello.</param>
        <param name="additionalDefaults">Dizionario che contiene un elenco di valori predefiniti per i parametri di modello.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.UriTemplate" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UriTemplate (string template, bool ignoreTrailingSlash, System.Collections.Generic.IDictionary&lt;string,string&gt; additionalDefaults);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string template, bool ignoreTrailingSlash, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; additionalDefaults) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplate.#ctor(System.String,System.Boolean,System.Collections.Generic.IDictionary{System.String,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (template As String, ignoreTrailingSlash As Boolean, additionalDefaults As IDictionary(Of String, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UriTemplate(System::String ^ template, bool ignoreTrailingSlash, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ additionalDefaults);" />
      <MemberSignature Language="F#" Value="new UriTemplate : string * bool * System.Collections.Generic.IDictionary&lt;string, string&gt; -&gt; UriTemplate" Usage="new System.UriTemplate (template, ignoreTrailingSlash, additionalDefaults)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="template" Type="System.String" />
        <Parameter Name="ignoreTrailingSlash" Type="System.Boolean" />
        <Parameter Name="additionalDefaults" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="template">Stringa di modello.</param>
        <param name="ignoreTrailingSlash">
          <see langword="true" /> se vengono ignorate le barre finali "/", in caso contrario <see langword="false" />.</param>
        <param name="additionalDefaults">Dizionario che contiene un elenco di valori predefiniti per i parametri di modello.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.UriTemplate" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BindByName">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuovo URI a partire dal modello e dalla raccolta di parametri.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindByName">
      <MemberSignature Language="C#" Value="public Uri BindByName (Uri baseAddress, System.Collections.Generic.IDictionary&lt;string,string&gt; parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Uri BindByName(class System.Uri baseAddress, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplate.BindByName(System.Uri,System.Collections.Generic.IDictionary{System.String,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Function BindByName (baseAddress As Uri, parameters As IDictionary(Of String, String)) As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri ^ BindByName(Uri ^ baseAddress, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.BindByName : Uri * System.Collections.Generic.IDictionary&lt;string, string&gt; -&gt; Uri" Usage="uriTemplate.BindByName (baseAddress, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseAddress" Type="System.Uri" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="baseAddress">Indirizzo di base.</param>
        <param name="parameters">Dizionario che contiene una raccolta di coppie nome/valore di parametro.</param>
        <summary>Crea un nuovo URI a partire dal modello e dalla raccolta di parametri.</summary>
        <returns>URI.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il [IDictionary\<stringa, stringa >](xref:System.Collections.Generic.IDictionary%602) parametro contiene una raccolta di coppie nome / valore di parametro. I parametri vengono confrontati con le variabili contenute nel modello. Questo confronto non fa distinzione fra maiuscole e minuscole.  
  
> [!NOTE]
>  La raccolta delle coppie nome/valore passata a questo metodo deve contenere una chiave per ogni variabile del modello. Le coppie aggiuntive nome/valore che non corrispondono alle variabili del modello vengono aggiunte alla stringa di query dell'URI finale.  
  
> [!IMPORTANT]
>  Per evitare che l'URI generato corrisponda al modello utilizzato per generarlo è possibile passare elementi di testo all'interno delle coppie nome/valore. Esempi di testo di questo tipo sono: '/', '..', '*', '{' e '}'.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindByName">
      <MemberSignature Language="C#" Value="public Uri BindByName (Uri baseAddress, System.Collections.Specialized.NameValueCollection parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Uri BindByName(class System.Uri baseAddress, class System.Collections.Specialized.NameValueCollection parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplate.BindByName(System.Uri,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function BindByName (baseAddress As Uri, parameters As NameValueCollection) As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri ^ BindByName(Uri ^ baseAddress, System::Collections::Specialized::NameValueCollection ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.BindByName : Uri * System.Collections.Specialized.NameValueCollection -&gt; Uri" Usage="uriTemplate.BindByName (baseAddress, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseAddress" Type="System.Uri" />
        <Parameter Name="parameters" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="baseAddress">Indirizzo di base.</param>
        <param name="parameters">Valori di parametro.</param>
        <summary>Crea un nuovo URI a partire dal modello e dalla raccolta di parametri.</summary>
        <returns>Una nuova istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il parametro <xref:System.Collections.Specialized.NameValueCollection> contiene una raccolta di coppie nome/valore di parametro. I parametri vengono confrontati con le variabili contenute nel modello. Questo confronto non fa distinzione fra maiuscole e minuscole. I valori passati in questa raccolta sono preceduti da caratteri di escape.  
  
> [!NOTE]
>  La raccolta delle coppie nome/valore passata al metodo <xref:System.UriTemplate.BindByName%28System.Uri%2CSystem.Collections.Specialized.NameValueCollection%29> deve contenere una chiave per ogni variabile del modello. Le coppie aggiuntive nome/valore che non corrispondono alle variabili del modello vengono aggiunte alla stringa di query dell'URI finale.  
  
> [!NOTE]
>  Per evitare che l'URI generato corrisponda al modello utilizzato per generarlo è possibile passare elementi di testo all'interno delle coppie nome/valore. Esempi di testo di questo tipo sono: '/', '..', '*', '{' e '}'.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare il metodo <xref:System.UriTemplate.BindByName%28System.Uri%2CSystem.Collections.Specialized.NameValueCollection%29>.  
  
 [!code-csharp[UriTemplate#4](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplate/cs/snippets.cs#4)]
 [!code-vb[UriTemplate#4](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplate/vb/snippets.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindByName">
      <MemberSignature Language="C#" Value="public Uri BindByName (Uri baseAddress, System.Collections.Generic.IDictionary&lt;string,string&gt; parameters, bool omitDefaults);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Uri BindByName(class System.Uri baseAddress, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; parameters, bool omitDefaults) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplate.BindByName(System.Uri,System.Collections.Generic.IDictionary{System.String,System.String},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function BindByName (baseAddress As Uri, parameters As IDictionary(Of String, String), omitDefaults As Boolean) As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri ^ BindByName(Uri ^ baseAddress, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ parameters, bool omitDefaults);" />
      <MemberSignature Language="F#" Value="member this.BindByName : Uri * System.Collections.Generic.IDictionary&lt;string, string&gt; * bool -&gt; Uri" Usage="uriTemplate.BindByName (baseAddress, parameters, omitDefaults)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseAddress" Type="System.Uri" />
        <Parameter Name="parameters" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="omitDefaults" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="baseAddress">URI contenente l'indirizzo di base.</param>
        <param name="parameters">Dizionario che contiene una raccolta di coppie nome/valore di parametro.</param>
        <param name="omitDefaults">
          <see langword="true" /> se i valori predefiniti vengono ignorati. In caso contrario, <see langword="false" />.</param>
        <summary>Crea un nuovo URI a partire dal modello e dalla raccolta di parametri.</summary>
        <returns>URI.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BindByName">
      <MemberSignature Language="C#" Value="public Uri BindByName (Uri baseAddress, System.Collections.Specialized.NameValueCollection parameters, bool omitDefaults);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Uri BindByName(class System.Uri baseAddress, class System.Collections.Specialized.NameValueCollection parameters, bool omitDefaults) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplate.BindByName(System.Uri,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function BindByName (baseAddress As Uri, parameters As NameValueCollection, omitDefaults As Boolean) As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri ^ BindByName(Uri ^ baseAddress, System::Collections::Specialized::NameValueCollection ^ parameters, bool omitDefaults);" />
      <MemberSignature Language="F#" Value="member this.BindByName : Uri * System.Collections.Specialized.NameValueCollection * bool -&gt; Uri" Usage="uriTemplate.BindByName (baseAddress, parameters, omitDefaults)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseAddress" Type="System.Uri" />
        <Parameter Name="parameters" Type="System.Collections.Specialized.NameValueCollection" />
        <Parameter Name="omitDefaults" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="baseAddress">Indirizzo di base.</param>
        <param name="parameters">Raccolta di coppie nome/valore di parametro.</param>
        <param name="omitDefaults">
          <see langword="true" /> se i valori predefiniti vengono ignorati; in caso contrario, <see langword="false" />.</param>
        <summary>Crea un nuovo URI a partire dal modello e dalla raccolta di parametri.</summary>
        <returns>URI.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BindByPosition">
      <MemberSignature Language="C#" Value="public Uri BindByPosition (Uri baseAddress, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Uri BindByPosition(class System.Uri baseAddress, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplate.BindByPosition(System.Uri,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BindByPosition (baseAddress As Uri, ParamArray values As String()) As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri ^ BindByPosition(Uri ^ baseAddress, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.BindByPosition : Uri * string[] -&gt; Uri" Usage="uriTemplate.BindByPosition (baseAddress, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseAddress" Type="System.Uri" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="baseAddress">Oggetto <see cref="T:System.Uri" /> contenente l'indirizzo di base.</param>
        <param name="values">Valori di parametro.</param>
        <summary>Crea un nuovo URI a partire dal modello e da una matrice di valori di parametro.</summary>
        <returns>Nuova istanza di <see cref="T:System.Uri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori di parametro sono associati in base alla posizione da sinistra verso destra. Il primo valore di parametro sostituisce la prima variabile trovata nel modello, il secondo valore di parametro sostituisce la seconda variabile e così via. Le variabili passate a questo metodo sono precedute da caratteri di escape.  
  
> [!NOTE]
>  Il numero di parametri passati nel parametro dei valori deve corrispondere al numero di variabili contenute nel modello. In caso contrario, viene generata un'eccezione <xref:System.FormatException>.  
  
> [!NOTE]
>  Per evitare che l'URI generato corrisponda al modello utilizzato per generarlo è possibile passare elementi di testo all'interno della matrice dei valori di parametro. Esempi di testo di questo tipo sono: '/', '.','..', '*', '{' e '}'. Questo concetto è illustrato nel codice riportato di seguito.  
  
 `UriTemplate template = new UriTemplate("far/{bat}/baz");`  
  
 `Uri uri = new Uri("http://localhost/Base");`  
  
 `Uri result = template.BindByPosition(uri, ".");   // returns Base/form/baz`  
  
 `Uri result = template.BindByPosition(uri, "..");  // returns Base/baz`  
  
 `Uri result = template.BindByPosition(uri, "x/y");  // returns Base/form/x/y/baz`  
  
 `Uri result = template.BindByPosition(uri, "{x}");  // returns Base/form/{x}/baz`  
  
 `Uri result = template.BindByPosition(uri, "*");  // returns Base/form/*/baz`  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare il metodo <xref:System.UriTemplate.BindByPosition%28System.Uri%2CSystem.String%5B%5D%29>.  
  
 [!code-csharp[UriTemplate#5](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplate/cs/snippets.cs#5)]
 [!code-vb[UriTemplate#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplate/vb/snippets.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Defaults">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,string&gt; Defaults { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; Defaults" />
      <MemberSignature Language="DocId" Value="P:System.UriTemplate.Defaults" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Defaults As IDictionary(Of String, String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ Defaults { System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Defaults : System.Collections.Generic.IDictionary&lt;string, string&gt;" Usage="System.UriTemplate.Defaults" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta di coppie nome/valore per tutti i valori di parametro predefiniti.</summary>
        <value>Un dizionario generico.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreTrailingSlash">
      <MemberSignature Language="C#" Value="public bool IgnoreTrailingSlash { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreTrailingSlash" />
      <MemberSignature Language="DocId" Value="P:System.UriTemplate.IgnoreTrailingSlash" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IgnoreTrailingSlash As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreTrailingSlash { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreTrailingSlash : bool" Usage="System.UriTemplate.IgnoreTrailingSlash" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica se le barre finali "/" presenti nel modello devono essere ignorate quando si creano corrispondenze con gli URI candidati.</summary>
        <value>
          <see langword="true" /> Se le barre finali "/" devono essere ignorati; in caso contrario <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public bool IsEquivalentTo (UriTemplate other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEquivalentTo(class System.UriTemplate other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplate.IsEquivalentTo(System.UriTemplate)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEquivalentTo (other As UriTemplate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEquivalentTo(UriTemplate ^ other);" />
      <MemberSignature Language="F#" Value="member this.IsEquivalentTo : UriTemplate -&gt; bool" Usage="uriTemplate.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UriTemplate" />
      </Parameters>
      <Docs>
        <param name="other">Oggetto <see cref="T:System.UriTemplate" /> da confrontare.</param>
        <summary>Indica se un modello <see cref="T:System.UriTemplate" /> è strutturalmente simile a un altro.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.UriTemplate" /> è strutturalmente equivalente a un altro; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Due istanze della classe <xref:System.UriTemplate> sono equivalenti se le relative stringhe letterali sono identiche e le relative variabili sono contenute negli stessi segmenti. Ad esempio "meteo/{regione}/{città}" è equivalente a "meteo/{campagna}/{comune}".  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare il metodo <xref:System.UriTemplate.IsEquivalentTo%28System.UriTemplate%29>.  
  
 [!code-csharp[UriTemplate#6](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplate/cs/snippets.cs#6)]
 [!code-vb[UriTemplate#6](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplate/vb/snippets.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public UriTemplateMatch Match (Uri baseAddress, Uri candidate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.UriTemplateMatch Match(class System.Uri baseAddress, class System.Uri candidate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplate.Match(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (baseAddress As Uri, candidate As Uri) As UriTemplateMatch" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UriTemplateMatch ^ Match(Uri ^ baseAddress, Uri ^ candidate);" />
      <MemberSignature Language="F#" Value="member this.Match : Uri * Uri -&gt; UriTemplateMatch" Usage="uriTemplate.Match (baseAddress, candidate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriTemplateMatch</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseAddress" Type="System.Uri" />
        <Parameter Name="candidate" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="baseAddress">Indirizzo di base.</param>
        <param name="candidate">Oggetto <see cref="T:System.Uri" /> da confrontare con il modello.</param>
        <summary>Tenta di creare una corrispondenza fra un oggetto <see cref="T:System.Uri" /> e un oggetto <see cref="T:System.UriTemplate" />.</summary>
        <returns>Un'istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la corrispondenza ha esito positivo, l'oggetto <xref:System.UriTemplateMatch> viene popolato con i segmenti URI, i valori delle variabili, i valori della stringa di query e i segmenti di caratteri jolly dell'URI candidato. Se invece la corrispondenza ha esito negativo, viene restituito `null`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare il metodo <xref:System.UriTemplate.Match%28System.Uri%2CSystem.Uri%29>.  
  
 [!code-csharp[UriTemplate#7](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplate/cs/snippets.cs#7)]
 [!code-vb[UriTemplate#7](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplate/vb/snippets.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSegmentVariableNames">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; PathSegmentVariableNames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; PathSegmentVariableNames" />
      <MemberSignature Language="DocId" Value="P:System.UriTemplate.PathSegmentVariableNames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathSegmentVariableNames As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ PathSegmentVariableNames { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathSegmentVariableNames : System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="System.UriTemplate.PathSegmentVariableNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta di nomi di variabili usati all'interno dei segmenti di percorso contenuti nel modello.</summary>
        <value>Raccolta di nomi di variabili visualizzati all'interno del segmento di percorso del modello.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La raccolta esclude i nomi di variabili visualizzati nella parte del modello relativa alla query.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come accedere alla proprietà <xref:System.UriTemplate.PathSegmentVariableNames%2A>.  
  
 [!code-csharp[UriTemplate#2](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplate/cs/snippets.cs#2)]
 [!code-vb[UriTemplate#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplate/vb/snippets.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryValueVariableNames">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; QueryValueVariableNames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; QueryValueVariableNames" />
      <MemberSignature Language="DocId" Value="P:System.UriTemplate.QueryValueVariableNames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property QueryValueVariableNames As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ QueryValueVariableNames { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.QueryValueVariableNames : System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="System.UriTemplate.QueryValueVariableNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta di nomi di variabili utilizzati all'interno della stringa di query contenuta nel modello.</summary>
        <value>Raccolta di nomi di variabili del modello visualizzati nella parte della stringa del modello relativa alla query.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa raccolta esclude i nomi di variabili visualizzati nella sezione della stringa del modello relativa al percorso.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come accedere alla proprietà <xref:System.UriTemplate.QueryValueVariableNames%2A>.  
  
 [!code-csharp[UriTemplate#3](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplate/cs/snippets.cs#3)]
 [!code-vb[UriTemplate#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplate/vb/snippets.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplate.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="uriTemplate.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una rappresentazione di stringa dell'istanza della classe <see cref="T:System.UriTemplate" />.</summary>
        <returns>Rappresentazione dell'istanza della classe <see cref="T:System.UriTemplate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come chiamare il metodo <xref:System.UriTemplate.ToString>.  
  
 [!code-csharp[UriTemplate#8](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplate/cs/snippets.cs#8)]
 [!code-vb[UriTemplate#8](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplate/vb/snippets.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>