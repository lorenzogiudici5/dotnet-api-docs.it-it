<Type Name="ResolveEventArgs" FullName="System.ResolveEventArgs">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e2985b3251ad8db5aed59f5b3d689e9e1101a65a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36428615" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ResolveEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ResolveEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.ResolveEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class ResolveEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResolveEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type ResolveEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce i dati per gli eventi di risoluzione dei caricatori, ad esempio gli eventi <see cref="E:System.AppDomain.TypeResolve" />, <see cref="E:System.AppDomain.ResourceResolve" />, <see cref="E:System.AppDomain.ReflectionOnlyAssemblyResolve" /> e <see cref="E:System.AppDomain.AssemblyResolve" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando il caricatore non è possibile risolvere un riferimento all'assembly e un gestore non è stata specificata per l'evento di risoluzione del caricatore appropriato, viene generato l'evento e il <xref:System.ResolveEventArgs> contiene informazioni sull'elemento da risolvere.  
  
-   Il <xref:System.ResolveEventArgs.Name%2A> proprietà contiene il nome dell'elemento da risolvere.  
  
-   Iniziano con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], il <xref:System.ResolveEventArgs.RequestingAssembly%2A> proprietà contiene l'assembly che ha richiesto un assembly che può fornire l'elemento denominato. Per altre informazioni, vedere la proprietà <xref:System.ResolveEventArgs.RequestingAssembly%2A>.  
  
 ]]></format>
    </remarks>
    <altmember cref="E:System.AppDomain.TypeResolve" />
    <altmember cref="E:System.AppDomain.ResourceResolve" />
    <altmember cref="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
    <altmember cref="E:System.AppDomain.AssemblyResolve" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.ResolveEventArgs" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResolveEventArgs (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ResolveEventArgs.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResolveEventArgs(System::String ^ name);" />
      <MemberSignature Language="F#" Value="new ResolveEventArgs : string -&gt; ResolveEventArgs" Usage="new System.ResolveEventArgs name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome di un elemento da risolvere.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.ResolveEventArgs" />, specificando il nome dell'elemento da risolvere.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere, questo costruttore viene chiamato solo da common language runtime.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResolveEventArgs (string name, System.Reflection.Assembly requestingAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Reflection.Assembly requestingAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ResolveEventArgs.#ctor(System.String,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, requestingAssembly As Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResolveEventArgs(System::String ^ name, System::Reflection::Assembly ^ requestingAssembly);" />
      <MemberSignature Language="F#" Value="new ResolveEventArgs : string * System.Reflection.Assembly -&gt; ResolveEventArgs" Usage="new System.ResolveEventArgs (name, requestingAssembly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="requestingAssembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="name">Nome di un elemento da risolvere.</param>
        <param name="requestingAssembly">Assembly la cui dipendenza è in fase di risoluzione.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.ResolveEventArgs" />, specificando il nome dell'elemento da risolvere e l'assembly la cui dipendenza è in fase di risoluzione.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ResolveEventArgs.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.ResolveEventArgs.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome dell'elemento da risolvere.</summary>
        <value>Nome dell'elemento da risolvere.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per il <xref:System.AppDomain.AssemblyResolve> evento, <xref:System.ResolveEventArgs.Name%2A> è il nome dell'assembly prima dell'applicazione di criteri.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestingAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly RequestingAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly RequestingAssembly" />
      <MemberSignature Language="DocId" Value="P:System.ResolveEventArgs.RequestingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RequestingAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Assembly ^ RequestingAssembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestingAssembly : System.Reflection.Assembly" Usage="System.ResolveEventArgs.RequestingAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'assembly la cui dipendenza è in fase di risoluzione.</summary>
        <value>Assembly che ha richiesto l'elemento specificato dalla proprietà <see cref="P:System.ResolveEventArgs.Name" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'assembly restituito da questa proprietà è un assembly che è stato possibile risolvere l'elemento specificato dal <xref:System.ResolveEventArgs.Name%2A> proprietà, perché l'elemento non esiste nell'assembly in questione, in una delle sue dipendenze caricati o in tutte le dipendenze il caricatore è stato trovato tramite l'individuazione tramite probe.  
  
 Ad esempio, si supponga che l'assembly corrente utilizzi il <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> metodo per caricare l'assembly da una directory esterna al percorso di sondaggio, per poter utilizzare la classe CA. Si supponga inoltre che la classe CA utilizza CB (classe), nell'assembly B e che l'assembly ha un riferimento in fase di compilazione all'assembly B, inoltre si trova all'esterno del percorso di sondaggio. Quando l'assembly corrente tenta di creare un'istanza di autorità di certificazione, il caricatore tenta di risolvere il riferimento all'assembly B. Tuttavia, poiché l'assembly è stato caricato tramite il <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> metodo, il caricatore non è possibile risolvere la dipendenza. Se esiste un gestore per il <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> , l'evento viene generato e il <xref:System.ResolveEventArgs.RequestingAssembly%2A> proprietà dell'oggetto risultante <xref:System.ResolveEventArgs> contiene l'oggetto assembly, perché l'assembly è l'assembly in cui Manca una dipendenza.  
  
 La semantica del <xref:System.ResolveEventArgs.RequestingAssembly%2A> proprietà varia a seconda di come è stato caricato l'assembly richiedente:  
  
-   Contesto di caricamento: il valore della proprietà potrebbe essere `null`. Il contesto di caricamento è indipendente dall'ordine di caricamento e l'identità del richiedente assembly non è necessariamente significativi. Un esempio diverso da null si verifica quando il <xref:System.Type.GetType%2A?displayProperty=nameWithType> metodo viene chiamato e il tipo specificato non è noto per l'assembly richiedente o una delle sue dipendenze.  
  
-   Contesto di caricamento: la proprietà può essere utilizzata come hint per la ricerca, ma il gestore dell'evento non deve ricevere più di una richiesta per un nome di assembly specificato.  
  
-   Alcun contesto (vale a dire, l'assembly richiedente è stato caricato tramite il <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> metodo, o come un flusso di byte o in modalità mista): il gestore può utilizzare il <xref:System.ResolveEventArgs.RequestingAssembly%2A> proprietà per caricare implementazioni diverse dello stesso assembly in base all'identità del richiesta di assembly.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.AppDomain.TypeResolve" />
        <altmember cref="E:System.AppDomain.ResourceResolve" />
        <altmember cref="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
        <altmember cref="E:System.AppDomain.AssemblyResolve" />
      </Docs>
    </Member>
  </Members>
</Type>