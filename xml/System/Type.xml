<Type Name="Type" FullName="System.Type">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a40925048dd06746d1e1cda2a76aa4ecaae1b916" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30731515" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta dichiarazioni di tipo: tipi classe, tipi interfaccia, tipi matrice, tipi di valore e di enumerazione, parametri di tipo, definizioni di tipo generico e tipi generici costruiti chiusi o aperti.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Type` è la radice di <xref:System.Reflection> funzionalità ed è lo strumento principale per accedere ai metadati. Utilizzare i membri di <xref:System.Type> per ottenere informazioni su una dichiarazione di tipo, sui membri di un tipo (ad esempio i costruttori, metodi, campi, proprietà ed eventi di una classe), nonché il modulo e assembly in cui è distribuita la classe.  
  
 Non sono necessarie autorizzazioni per il codice usare la reflection per ottenere informazioni sui tipi e i relativi membri, indipendentemente dal loro livelli di accesso. Non sono necessarie autorizzazioni per il codice usare la reflection per accedere ai membri pubblici o altri membri i cui livelli di accesso rendere visibile durante la compilazione normale. Tuttavia, in ordine per il codice usare la reflection per accedere ai membri che normalmente sarebbe accessibile, ad esempio metodi privati o interni o protetti i campi di un tipo di classe non eredita, il codice necessario <xref:System.Security.Permissions.ReflectionPermission>. Vedere [considerazioni sulla sicurezza per la Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).  
  
 `Type` è una classe base astratta che consente più implementazioni. Il sistema fornirà sempre la classe derivata `RuntimeType`. Nella reflection, tutte le classi che iniziano con la parola Runtime vengono create una sola volta per ogni oggetto nelle operazioni di confronto di sistema e supporto tecnico.  
  
> [!NOTE]
>  Negli scenari multithreading, non bloccare <xref:System.Type> oggetti per sincronizzare l'accesso a `static` dati. Altro codice, in cui si ha alcun controllo, inoltre potrebbe bloccare il tipo di classe. Ciò potrebbe comportare un deadlock. Invece, sincronizzare l'accesso ai dati statici bloccando private `static` oggetto.  
  
> [!NOTE]
>  Una classe derivata può accedere ai membri protetti delle classi di base del codice chiamante. Inoltre, l'accesso è consentito ai membri di assembly dell'assembly del codice chiamante. In una regola, se è consentito l'accesso in codice con associazione anticipata, è consentito anche al codice ad associazione tardiva.  
  
> [!NOTE]
>  Le interfacce che estendono le altre interfacce non ereditano i metodi definiti nelle interfacce estese.  
  
 Contenuto della sezione:  
  
 [I tipi rappresenta un oggetto di tipo?](#WhatTypes)   
 [Recupero di un oggetto di tipo](#Retrieve)   
 [Il confronto di uguaglianza degli oggetti di tipo](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>I tipi rappresenta un oggetto di tipo?  
 Questa classe è thread-safe. più thread possono leggere contemporaneamente da un'istanza di questo tipo. Un'istanza di <xref:System.Type> classe può rappresentare uno qualsiasi dei tipi seguenti:  
  
-   Classi  
  
-   Tipi valore  
  
-   Matrici  
  
-   Interfacce  
  
-   Enumerazioni  
  
-   Delegati  
  
-   Tipi generici costruiti e definizioni di tipo generico  
  
-   Digitare gli argomenti e parametri di tipi generici costruiti, definizioni di tipo generico e definizioni di metodo generico  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>Recupero di un oggetto di tipo  
 Il <xref:System.Type> associata a un particolare tipo di oggetto può essere ottenuto nei modi seguenti:  
  
-   L'istanza <xref:System.Object.GetType%2A?displayProperty=nameWithType> metodo restituisce un <xref:System.Type> oggetto che rappresenta il tipo di un'istanza. Poiché tutti i tipi gestiti derivano da <xref:System.Object>, <xref:System.Object.GetType%2A> metodo può essere chiamato in un'istanza di qualsiasi tipo.  
  
     L'esempio seguente chiama il <xref:System.Object.GetType%2A?displayProperty=nameWithType> metodo per determinare il tipo di runtime di ciascun oggetto nella matrice di oggetti.  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   Il metodo statico <xref:System.Type.GetType%2A?displayProperty=nameWithType> i metodi restituiscono un <xref:System.Type> oggetto che rappresenta un tipo specificato dal nome completo.  
  
-   Il <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, e <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> restituiscono `Type` gli oggetti che rappresentano i tipi definiti in un modulo. Il primo metodo è utilizzabile per ottenere una matrice di <xref:System.Type> oggetti per tutti i tipi pubblici e privati definiti in un modulo. (È possibile ottenere un'istanza di `Module` tramite il <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> metodo, o tramite il <xref:System.Type.Module%2A?displayProperty=nameWithType> proprietà.)  
  
-   Il <xref:System.Reflection.Assembly?displayProperty=nameWithType> oggetto contiene un numero di metodi per recuperare le classi definite in un assembly, tra cui <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, e <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.  
  
-   Il <xref:System.Type.FindInterfaces%2A> metodo restituisce un elenco filtrato dei tipi di interfaccia supportati da un tipo.  
  
-   Il <xref:System.Type.GetElementType%2A> metodo restituisce un `Type` oggetto che rappresenta l'elemento.  
  
-   Il <xref:System.Type.GetInterfaces%2A> e <xref:System.Type.GetInterface%2A> restituiscono <xref:System.Type> gli oggetti che rappresentano i tipi di interfaccia supportati da un tipo.  
  
-   Il <xref:System.Type.GetTypeArray%2A> il metodo restituisce una matrice di <xref:System.Type> gli oggetti che rappresentano i tipi specificati da un set arbitrario di oggetti. Gli oggetti sono specificati con una matrice di tipo <xref:System.Object>.  
  
-   Il <xref:System.Type.GetTypeFromProgID%2A> e <xref:System.Type.GetTypeFromCLSID%2A> vengono forniti metodi per l'interoperabilità COM. Restituiscono un <xref:System.Type> oggetto che rappresenta il tipo specificato da un `ProgID` o `CLSID`.  
  
-   Il <xref:System.Type.GetTypeFromHandle%2A> metodo è fornito per l'interoperabilità. Restituisce un `Type` oggetto che rappresenta il tipo specificato da un handle di classe.  
  
-   C# `typeof` (operatore), C++ `typeid` operatore e Visual Basic `GetType` operatore ottenere il `Type` oggetto per un tipo.  
  
-   Il <xref:System.Type.MakeGenericType%2A> metodo restituisce un <xref:System.Type> oggetto che rappresenta un tipo generico costruito, che è un tipo costruito aperto, se il relativo <xref:System.Type.ContainsGenericParameters%2A> restituisce proprietà `true`, e un tipo costruito chiuso in caso contrario. Un tipo generico può essere implementato solo se è chiuso.  
  
-   Il <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, e <xref:System.Type.MakeByRefType%2A> restituiscono <xref:System.Type> gli oggetti che rappresentano, rispettivamente, una matrice di un tipo specificato, un puntatore a un tipo specificato e il tipo di un parametro di riferimento (`ref` in c#, `ByRef`in Visual Basic).  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>Il confronto di uguaglianza degli oggetti di tipo  
 Oggetto <xref:System.Type> oggetto che rappresenta un tipo è univoco, vale a dire due <xref:System.Type> riferimenti fanno riferimento allo stesso oggetto solo se rappresentano lo stesso tipo. In questo modo per il confronto di <xref:System.Type> oggetti utilizzando l'uguaglianza dei riferimenti. Nell'esempio seguente vengono confrontate le <xref:System.Type> gli oggetti che rappresentano un numero di valori integer per determinare se sono dello stesso tipo.  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 L'esempio seguente illustra alcune funzionalità rappresentative di <xref:System.Type>. C# `typeof` (operatore) (`GetType` operatore in Visual Basic, `typeid` operatore in Visual C++) viene utilizzato per ottenere un <xref:System.Type> che rappresenta l'oggetto <xref:System.String>. Da questo <xref:System.Type> oggetto, il <xref:System.Type.GetMethod%2A> metodo viene utilizzato per ottenere un <xref:System.Reflection.MethodInfo> che rappresenta il <xref:System.String.Substring%2A> overload che accetta una posizione di inizio e una lunghezza.  
  
 Per identificare la firma di overload, l'esempio di codice crea una matrice temporanea contenente due <xref:System.Type> oggetti che rappresentano `int` (`Integer` in Visual Basic).  
  
> [!NOTE]
>  Per la precisione, la matrice contiene due riferimenti all'istanza di <xref:System.Type> che rappresenta `int` nel dominio applicazione corrente. Per qualsiasi tipo, è disponibile solo un'istanza di <xref:System.Type> per ogni dominio applicazione.  
  
 Nell'esempio di codice viene utilizzato il <xref:System.Reflection.MethodInfo> per richiamare il <xref:System.String.Substring%2A> metodo sulla stringa "Hello, World!" e visualizza il risultato.  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
    <block subset="none" type="overrides">
      <para>Quando si eredita da <see langword="Type" />, è necessario eseguire l'override dei membri seguenti:  
  
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para>
    </block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Type" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore viene richiamato dalle classi derivate durante la costruzione di oggetti di tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la classe <see cref="T:System.Reflection.Assembly" /> in cui è dichiarato il tipo. Per i tipi generici, ottiene la classe <see cref="T:System.Reflection.Assembly" /> in cui è definito il tipo generico.</summary>
        <value>Istanza di <see cref="T:System.Reflection.Assembly" /> che descrive l'assembly contenente il tipo corrente. Per i tipi generici, l'istanza descrive l'assembly contenente la definizione di tipo generico, non l'assembly che crea e usa un determinato tipo costruito.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'oggetto corrente <xref:System.Type> oggetto rappresenta un tipo generico costruito, questa proprietà restituisce l'assembly che contiene la definizione di tipo generico. Ad esempio, si supponga di crea un assembly denominato MyGenerics che contiene la definizione di tipo generico `MyGenericStack<T>` (`MyGenericStack(Of T)` in Visual Basic `generic<T> ref class MyGenericStack` in C++). Se si crea un'istanza di `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in un altro assembly, il <xref:System.Type.Assembly%2A> proprietà per il tipo costruito restituisce un <xref:System.Reflection.Assembly> oggetto che rappresenta MyGenerics.  
  
 Analogamente, se l'oggetto corrente <xref:System.Type> oggetto rappresenta un parametro generico non assegnato `T`, questa proprietà restituisce l'assembly che contiene il tipo generico che definisce `T`.  
  
 Se il <xref:System.Type.Assembly%2A?displayProperty=nameWithType> proprietà non è disponibile in una determinata implementazione di .NET, ad esempio .NET Core o la piattaforma Windows universale, utilizzare il <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> proprietà invece.      
  
 Questa proprietà è di sola lettura.  
  
   
  
## Examples  
 Nell'esempio seguente visualizza il nome dell'assembly associato alla classe e il nome completo del tipo.  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome qualificato dall'assembly del tipo, che include il nome dell'assembly da cui è stato caricato l'oggetto <see cref="T:System.Type" />.</summary>
        <value>Nome qualificato dall'assembly dell'oggetto <see cref="T:System.Type" />, che include il nome dell'assembly da cui è stato caricato <see cref="T:System.Type" /> oppure <see langword="null" /> se l'istanza corrente rappresenta un parametro di tipo generico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il nome di un tipo qualificato dall'assembly è costituito da nome del tipo, incluso il relativo spazio dei nomi, seguito da una virgola, seguita dal nome visualizzato dell'assembly. Il nome visualizzato di un assembly viene ottenuto utilizzando il <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> proprietà.  
  
> [!NOTE]
>  In .NET Framework versione 2.0, l'architettura del processore viene aggiunto all'identità dell'assembly e può essere specificato come parte di stringhe di nomi di assembly. Ad esempio, "ProcessorArchitecture = msil". Tuttavia, non è incluso nella stringa restituita dal <xref:System.Type.AssemblyQualifiedName%2A> proprietà, per motivi di compatibilità. Vedere <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 Tutti i compilatori che supportano common language runtime creano il nome semplice di una classe annidata e reflection costruisce un nome modificato quando si esegue la query in base alle convenzioni seguenti.  
  
|delimitatore|Significato|  
|---------------|-------------|  
|Barra rovesciata (\\)|Carattere di escape.|  
|Comma (,)|Precede il nome dell'Assembly.|  
|Segno più (+)|Precede una classe annidata.|  
|Punto (.)|Indica gli identificatori dello spazio dei nomi.|  
|parentesi quadre ([])|Dopo il nome di un tipo, indica una matrice di quel tipo.<br /><br /> oppure<br /><br /> Per un tipo generico, incluso l'elenco di argomenti di tipo generico.<br /><br /> oppure<br /><br /> All'interno di un elenco di argomenti di tipo, incluso un tipo qualificato dall'assembly.|  
  
 Il nome completo dell'assembly per una classe, ad esempio, potrebbe essere simile al seguente:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 Se lo spazio dei nomi contiene un segno più, ad esempio TopNamespace.Sub+Namespace, quindi sul segno più (+) potrebbe essere preceduto da un carattere di escape (\\) per evitare che venga interpretato come un separatore di annidamento. Reflection la stringa viene creata come indicato di seguito:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 A "+" diventa "\\+\\+" e un "\\"diventa"\\\\".  
  
 Questo nome completo può essere persistente e successivamente utilizzato per caricare il <xref:System.Type>. Per cercare e caricare un <xref:System.Type>, utilizzare <xref:System.Type.GetType%2A> o con il tipo di nome solo oppure con il nome di tipo completo dell'assembly. <xref:System.Type.GetType%2A> con il tipo di nome solo cercherà il <xref:System.Type> nell'assembly del chiamante, quindi nell'assembly System. <xref:System.Type.GetType%2A> con l'assembly completo del tipo cercherà il <xref:System.Type> in qualsiasi assembly.  
  
 I nomi dei tipi possono includere caratteri finali che indicano informazioni aggiuntive sul tipo, ad esempio se il tipo è un tipo riferimento, un tipo di puntatore o un tipo di matrice. Per recuperare il nome del tipo senza caratteri finali, utilizzare `t.GetElementType().ToString()`, dove `t` è il tipo.  
  
 Gli spazi sono rilevanti in tutti i componenti di nome di tipo tranne il nome dell'assembly. Il nome di assembly, spazi che precedono il separatore ',' sono rilevanti, ma gli spazi dopo il separatore ',' vengono ignorati.  
  
 Gli argomenti generici di tipi generici sono qualificato dal nome dell'assembly. Ad esempio, nel nome del tipo qualificato dall'assembly per `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic), `int` viene espanso al nome del tipo qualificato dall'assembly per <xref:System.Int32>.  
  
 Se l'oggetto corrente <xref:System.Type> oggetto rappresenta un parametro generico, questa proprietà restituisce `null`.  
  
   
  
## Examples  
 Nell'esempio seguente visualizza il nome dell'assembly associato alla classe e il nome completo del tipo.  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 L'esempio seguente confronta le stringhe restituite dal <xref:System.Type.ToString%2A> (metodo) e `Name`, <xref:System.Type.FullName%2A>, e <xref:System.Type.AssemblyQualifiedName%2A> proprietà.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene gli attributi associati all'oggetto <see cref="T:System.Type" />.</summary>
        <value>Oggetto <see cref="T:System.Reflection.TypeAttributes" /> che rappresenta il set di attributi di <see cref="T:System.Type" />, a meno che <see cref="T:System.Type" /> non rappresenti un parametro di tipo generico. In tal caso, il valore non è specificato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcuni membri del <xref:System.Reflection.TypeAttributes> enumerazione sono maschere che rappresentano un gruppo di valori. Ogni gruppo include un membro il cui valore sottostante è zero. Ad esempio, il valore sottostante del <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> membro nel <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> gruppo è zero, come il <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> membro nel <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> gruppo. Per questo motivo, è necessario utilizzare la maschera prima del test di tali valori. Nell'esempio viene illustrata una situazione di questo tipo.  
  
> [!TIP]
>  Per la maggior parte degli scopi, ad esempio proprietà <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, e <xref:System.Type.IsSpecialName%2A> sono più facili da utilizzare rispetto agli attributi di tipo.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà restituisce gli attributi della definizione di tipo generico. Ad esempio, gli attributi restituiti per `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) sono gli attributi di `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic).  
  
 Se corrente <xref:System.Type> rappresenta un parametro di tipo generico, vale a dire, se il <xref:System.Type.IsGenericParameter%2A> restituisce proprietà `true` : il <xref:System.Reflection.TypeAttributes> valore restituito da questa proprietà non è specificato.  
  
   
  
## Examples  
 Il seguente usesthe esempio <xref:System.Type.Attributes%2A> proprietà.  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo da cui l'oggetto <see cref="T:System.Type" /> corrente eredita direttamente.</summary>
        <value>Oggetto <see cref="T:System.Type" /> da cui <see cref="T:System.Type" /> corrente eredita direttamente o <see langword="null" /> se <see langword="Type" /> rappresenta la classe <see cref="T:System.Object" /> o un'interfaccia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo di base è il tipo da cui il tipo corrente eredita direttamente. <xref:System.Object> è l'unico tipo che non dispone di un tipo di base, pertanto `null` viene restituito come tipo di base del <xref:System.Object>.  
  
 Che ereditano da zero o più interfacce di base. Pertanto, questa proprietà restituisce `null` se il `Type` oggetto rappresenta un'interfaccia. Le interfacce di base possono essere determinate con <xref:System.Type.GetInterfaces%2A> o <xref:System.Type.FindInterfaces%2A>.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, il tipo di base riflette gli argomenti generici. Si considerino ad esempio le dichiarazioni seguenti:  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 Per il tipo costruito `C<int>` (`C(Of Integer)` in Visual Basic), il <xref:System.Type.BaseType%2A> restituisce proprietà `B<int>`.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di una definizione di tipo generico, <xref:System.Type.BaseType%2A> restituisce il vincolo di classe, vale a dire, la classe parametro di tipo deve ereditare. Se è presente alcun vincolo di classe, <xref:System.Type.BaseType%2A> restituisce <xref:System.Object?displayProperty=nameWithType>.  
  
 Questa proprietà è di sola lettura.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di <xref:System.Type.BaseType%2A> proprietà.  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 L'esempio seguente usa la ricorsione per elencare la gerarchia di ereditarietà completa di ogni classe nell'assembly. Nell'esempio viene definita una classe denominata `C` che deriva da una classe denominata `B`, che, a sua volta deriva da una classe denominata `A`.  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Type" /> dispone di parametri di tipo che non sono stati sostituiti da tipi specifici.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Type" /> è a sua volta un parametro di tipo generico o possiede parametri di tipo per i quali non sono stati forniti tipi specifici; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per creare un'istanza di un tipo, è non necessario alcun definizioni di tipo generico o i tipi costruiti aperti negli argomenti di tipo del tipo stesso, in tutti i tipi generici o in tutti gli elementi del tipo. In altre parole quando viene esaminato in modo ricorsivo, il tipo non deve contenere alcun parametro di tipo generico.  
  
 Poiché i tipi possono essere arbitrariamente complessi, stabilito questo aspetto è difficile. Per motivi di praticità e ridurre le probabilità di errore, il <xref:System.Type.ContainsGenericParameters%2A> proprietà fornisce un modo per distinguere tra tipi costruiti chiusi, possono essere creata un'istanza, standard e tipi costruiti aperti, che non può essere. Se il <xref:System.Type.ContainsGenericParameters%2A> restituisce proprietà `true`, il tipo non può essere creata un'istanza.  
  
 Il <xref:System.Type.ContainsGenericParameters%2A> proprietà di ricerca in modo ricorsivo per i parametri di tipo. Ad esempio, viene restituito `true` per una matrice i cui elementi sono di tipo `A<T>` (`A(Of T)` in Visual Basic), anche se la matrice non è generico. Ciò si differenzia dal comportamento del <xref:System.Type.IsGenericType%2A> proprietà, che restituisce `false` per le matrici.  
  
 Per un set di classi di esempio e una tabella che mostra i valori del <xref:System.Type.ContainsGenericParameters%2A> proprietà, vedere <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente definisce una classe generica con due parametri di tipo e quindi definisce una seconda classe generica da cui deriva la prima classe. Classe di base della classe derivata ha due argomenti di tipo: il primo è <xref:System.Int32> e il secondo è un parametro di tipo del tipo derivato. Nell'esempio vengono visualizzate informazioni su queste classi generiche, incluse le posizioni segnalati dal <xref:System.Type.GenericParameterPosition%2A> proprietà.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una classe <see cref="T:System.Reflection.MethodBase" /> che rappresenta il metodo dichiarante se la classe <see cref="T:System.Type" /> corrente rappresenta un parametro di tipo di un metodo generico.</summary>
        <value>Se l'oggetto <see cref="T:System.Type" /> corrente rappresenta un parametro di tipo di un metodo generico, una classe <see cref="T:System.Reflection.MethodBase" /> che rappresenta il metodo dichiarante; in caso contrario, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo dichiarante è una definizione di metodo generico. Vale a dire se <xref:System.Type.DeclaringMethod%2A> non restituisce `null`, quindi `DeclaringMethod.IsGenericMethodDefinition` restituisce `true`.  
  
 Il <xref:System.Type.DeclaringType%2A> e <xref:System.Type.DeclaringMethod%2A> identificano la definizione di tipo generico o di una definizione di metodo generico in cui è stato originariamente definito il parametro di tipo generico:  
  
-   Se il <xref:System.Type.DeclaringMethod%2A> proprietà restituisce un <xref:System.Reflection.MethodInfo>che <xref:System.Reflection.MethodInfo> rappresenta una definizione di metodo generico e corrente <xref:System.Type> oggetto rappresenta un parametro di tipo della definizione di metodo generico.  
  
-   Se il <xref:System.Type.DeclaringMethod%2A> restituisce proprietà `null`, quindi il <xref:System.Type.DeclaringType%2A> proprietà restituisce sempre un <xref:System.Type> oggetto che rappresenta una definizione di tipo generico e corrente <xref:System.Type> oggetto rappresenta un parametro di tipo del tipo generico definizione.  
  
-   Recupero di <xref:System.Type.DeclaringMethod%2A> su un tipo il cui <xref:System.Type.IsGenericParameter%2A> proprietà `false` genera un <xref:System.InvalidOperationException>.  
  
 Il <xref:System.Reflection.MethodBase> restituito dal <xref:System.Type.DeclaringMethod%2A> proprietà è un <xref:System.Reflection.MethodInfo> nel caso di un metodo generico, o un <xref:System.Reflection.ConstructorInfo> nel caso di un costruttore generico.  
  
> [!NOTE]
>  In .NET Framework versione 2.0, i costruttori generici non sono supportati.  
  
 Per un elenco delle condizioni invariabili relative ai termini usati dal processo di reflection generico, vedere i commenti sulla proprietà <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente definisce una classe che dispone di un metodo generico, viene assegnato un argomento di tipo al metodo e richiama il metodo generico costruito risultante. Visualizza anche informazioni sulla definizione di metodo generico e il metodo costruito. Quando si visualizzano informazioni sui parametri di tipo della definizione di metodo generico, nel `DisplayGenericMethodInfo` metodo, il codice di esempio viene mostrato il valore di <xref:System.Type.DeclaringMethod%2A> proprietà per il parametro di tipo generico del metodo.  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il tipo che dichiara il parametro di tipo generico o di tipo annidato corrente.</summary>
        <value>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo contenitore, se il tipo corrente è un tipo annidato, oppure la definizione di tipo generico, se il tipo corrente è un parametro di tipo di un tipo generico, oppure il tipo che dichiara il metodo generico, se il tipo corrente è un parametro di tipo di un metodo generico; in caso contrario, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'oggetto corrente <xref:System.Type> oggetto rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce la definizione di tipo generico.  
  
 Se l'oggetto corrente <xref:System.Type> oggetto rappresenta un parametro di tipo di un metodo generico, questa proprietà restituisce il tipo che contiene la definizione di metodo generico. Se il tipo è generico, viene restituita la definizione di tipo generico. Ovvero, il codice seguente restituisce la definizione di tipo generico del <xref:System.Collections.Generic.List%601> classe generica, che contiene il <xref:System.Collections.Generic.List%601.ConvertAll%2A> metodo generico:  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, la <xref:System.Type.DeclaringType%2A> e <xref:System.Type.DeclaringMethod%2A> identificano la definizione di tipo generico o la definizione di metodo generico in cui parametro di tipo generico è stato originariamente definito:  
  
-   Se il <xref:System.Type.DeclaringMethod%2A> proprietà restituisce un <xref:System.Reflection.MethodInfo>che <xref:System.Reflection.MethodInfo> rappresenta una definizione di metodo generico e corrente <xref:System.Type> oggetto rappresenta un parametro di tipo della definizione di metodo generico.  
  
-   Se il <xref:System.Type.DeclaringMethod%2A> restituisce proprietà `null`, quindi il <xref:System.Type.DeclaringType%2A> proprietà restituisce sempre un <xref:System.Type> oggetto che rappresenta una definizione di tipo generico e corrente <xref:System.Type> oggetto rappresenta un parametro di tipo del tipo generico definizione.  
  
-   Recupero di <xref:System.Type.DeclaringType%2A> su un tipo il cui <xref:System.Type.IsGenericParameter%2A> proprietà `false` genera un <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Questo esempio visualizza il tipo dichiarante di un metodo in una classe derivata.  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un riferimento al binder predefinito, il quale implementa regole interne per la selezione dei membri appropriati che devono essere chiamati con il metodo <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</summary>
        <value>Riferimento al binder predefinito usato dal sistema.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lo strumento di associazione predefiniti fornito con common language runtime è applicabile in tutte le circostanze più specializzate. Se è necessario uno strumento di associazione che segua regole diverse da quelle del gestore di associazione predefinito fornito, definire un tipo derivato dal <xref:System.Reflection.Binder> classe e passare un'istanza di quel tipo utilizzando il `binder` parametro di uno del <xref:System.Type.InvokeMember%2A> overload.  
  
 Reflection modella le regole di accessibilità di common type system. Ad esempio, se il chiamante è nello stesso assembly, il chiamante non necessita di autorizzazioni speciali per i membri interni. In caso contrario, il chiamante deve <xref:System.Security.Permissions.ReflectionPermission>. Ciò è coerente con la ricerca di membri che sono protetti, privato e così via.  
  
 Il principio generale è che <xref:System.Reflection.Binder.ChangeType%2A> deve eseguire solo conversione, che non comportano la perdita di dati. Un esempio di una conversione widening consiste nel convertire un valore che è un intero con segno a 32 bit su un valore che è un intero con segno a 64 bit. Questa operazione si differenzia dalla conversione, che potrebbe perdere dati. Un esempio di una conversione di narrowing è conversione di un intero con segno a 64 bit in un intero con segno a 32 bit.  
  
 Nella tabella seguente sono elencate le conversioni supportate dal gestore di associazione predefinito.  
  
|Tipo di origine|Tipo di destinazione|  
|-----------------|-----------------|  
|Qualsiasi tipo|Il tipo di base.|  
|Qualsiasi tipo|Interfaccia che implementa.|  
|Char|Unt16, UInt32, Int32, UInt64, Int64, Single, Double|  
|Byte|Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double|  
|SByte|Int16, Int32, Int64, Single, Double|  
|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  
|Int16|Int32, Int64, Single, Double|  
|UInt32|UInt64, Int64, Single, Double|  
|Int32|Int64, Single, Double|  
|UInt64|Single, Double|  
|Int64|Single, Double|  
|Single|Double|  
|Non-riferimento|In base al riferimento.|  
  
   
  
## Examples  
 Nell'esempio seguente ottiene il binder predefinito dal `DefaultBinder` , proprietà e richiama un membro di MyClass passando il `DefaultBinder` valore come parametro a <xref:System.Type.InvokeMember%2A>.  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Separa i nomi nello spazio dei nomi dell'oggetto <see cref="T:System.Type" />. Questo campo è di sola lettura.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta una matrice vuota di tipo <see cref="T:System.Type" />. Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato il `EmptyTypes` campo utilizzato in uno del `GetConstructor` metodi per ottenere un costruttore che non accetta parametri.  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se il tipo di sistema sottostante dell'oggetto <see cref="T:System.Type" /> corrente coincide con il tipo di sistema sottostante di <see cref="T:System.Object" /> o dell'oggetto <see cref="T:System.Type" /> specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Oggetto il cui tipo di sistema sottostante deve essere confrontato con il tipo di sistema sottostante dell'oggetto <see cref="T:System.Type" /> corrente. Affinché il confronto abbia esito positivo, deve essere possibile eseguire il cast o la conversione di <c>o</c> in un oggetto di tipo <see cref="T:System.Type" />.</param>
        <summary>Determina se il tipo di sistema sottostante dell'oggetto <see cref="T:System.Type" /> corrente coincide con il tipo di sistema sottostante dell'oggetto <see cref="T:System.Object" /> specificato.</summary>
        <returns>
          <see langword="true" /> se il tipo di sistema sottostante di <paramref name="o" /> coincide con il tipo di sistema sottostante del <see cref="T:System.Type" /> corrente. In caso contrario, <see langword="false" />. Questo metodo restituisce anche <see langword="false" /> se:  
  
-   <paramref name="o" /> è <see langword="null" />.  
  
-   Impossibile eseguire il cast o la conversione di <paramref name="o" /> in un oggetto <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue l'override del metodo <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Esegue il cast `o` a un oggetto di tipo <xref:System.Type> e chiama il <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> metodo.  
  
   
  
## Examples  
 L'esempio seguente usa <xref:System.Type.Equals%28System.Object%29> per confrontare i vari <xref:System.Type> oggetto istanze con vari <xref:System.Object> istanze.  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 Due elementi sono particolarmente non degni di nota nell'esempio:  
  
-   Il confronto di un <xref:System.Type> oggetto che rappresenta un intero con un <xref:System.Reflection.TypeInfo> oggetto che rappresenta un numero intero restituito `true` perché <xref:System.Reflection.TypeInfo> è derivato da <xref:System.Type>.  
  
-   Il confronto di un <xref:System.Type> oggetto che rappresenta un <xref:System.Collections.Generic.IList%601> oggetto (un tipo generico aperto) con un `List(Of String)` oggetto (un tipo generico chiuso) restituisce `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">Oggetto il cui tipo di sistema sottostante deve essere confrontato con il tipo di sistema sottostante dell'oggetto <see cref="T:System.Type" /> corrente.</param>
        <summary>Determina se il tipo di sistema sottostante dell'oggetto <see cref="T:System.Type" /> corrente coincide con il tipo di sistema sottostante dell'oggetto <see cref="T:System.Type" /> specificato.</summary>
        <returns>
          <see langword="true" /> se il tipo di sistema sottostante di <paramref name="o" /> coincide con il tipo di sistema sottostante del <see cref="T:System.Type" /> corrente. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente usa `Equals` per confrontare due tipi.  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il filtro membro usato sugli attributi. Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo campo contiene un riferimento al delegato utilizzato per il <xref:System.Type.FindMembers%2A> metodo. Il metodo incapsulato da questo delegato accetta due parametri: il primo è un <xref:System.Reflection.MemberInfo> oggetto e il secondo è un `Object`. Il metodo determina se il `MemberInfo` oggetto corrispondente ai criteri specificati per il `Object`. Il `Object` può essere assegnato il valore di uno qualsiasi dei campi per le classi <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, o <xref:System.Reflection.MethodImplAttributes>.  
  
 Ad esempio, il `Object` può essere assegnato il valore di un campo da `FieldAttributes` come pubblico. In tal caso, quando il `FilterAttribute` delegato viene richiamato, verrà restituito `true` solo se il metodo rappresentato dal `MemberInfo` oggetto è decorato con l'attributo di campo pubblico nei metadati.  
  
   
  
## Examples  
 Nell'esempio seguente viene ottenuto il `FilterAttribute` delegato, passarlo come parametro per il <xref:System.Type.FindMembers%2A> (metodo) e visualizza i membri specificati e i relativi attributi.  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il filtro membro usato sui nomi, che fa distinzione tra maiuscole e minuscole. Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo campo contiene un riferimento al delegato utilizzato per il <xref:System.Type.FindMembers%2A> metodo. Il metodo incapsulato da questo delegato accetta due parametri: il primo è un <xref:System.Reflection.MemberInfo> oggetto e il secondo è un `Object`. Il metodo determina se il `MemberInfo` oggetto corrispondente ai criteri specificati per il `Object`. Il `Object` viene assegnato un valore stringa, che può includere una parentesi finale "*" carattere jolly. Solo fine stringa jolly è supportata.  
  
 Ad esempio, il `Object` può essere assegnato il valore "Byte *". In tal caso, quando il `FilterName` delegato viene richiamato, verrà restituito `true` solo se il metodo rappresentato dal `MemberInfo` oggetto ha un nome che inizia con "Byte".  
  
   
  
## Examples  
 Esempio di codice seguente ottiene i metodi associati definito dall'utente `Application` tipo.  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta il filtro membro usato sui nomi che non fa distinzione tra maiuscole e minuscole. Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo campo contiene un riferimento al delegato utilizzato per il <xref:System.Type.FindMembers%2A> metodo. Il metodo incapsulato da questo delegato accetta due parametri: il primo è un <xref:System.Reflection.MemberInfo> oggetto e il secondo è un `Object`. Il metodo determina se il `MemberInfo` oggetto corrispondente ai criteri specificati per il `Object`. Il `Object` viene assegnato un valore stringa, che può includere una parentesi finale "*" carattere jolly. Solo fine stringa jolly è supportata.  
  
 Ad esempio, il `Object` può essere assegnato il valore "ByTe *". In tal caso, quando il `FilterName` delegato viene richiamato, viene restituito true solo se il metodo rappresentato dal `MemberInfo` oggetto ha un nome che inizia con "byte", ignorando i casi.  
  
   
  
## Examples  
 Nell'esempio seguente si ottiene il `MemberFilter` delegato, passarlo come parametro per il <xref:System.Type.FindMembers%2A> (metodo) e vengono visualizzati i metodi e i relativi attributi del `String` classe che iniziano con la lettera "c", ignorando il caso.  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">Delegato che confronta le interfacce con <c>filterCriteria</c>.</param>
        <param name="filterCriteria">Criteri di ricerca che determinano se un'interfaccia deve essere inclusa nella matrice restituita.</param>
        <summary>Restituisce una matrice di oggetti <see cref="T:System.Type" /> che rappresenta un elenco filtrato di interfacce implementate o ereditate dall'oggetto <see cref="T:System.Type" /> corrente.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Type" /> che rappresenta un elenco filtrato delle interfacce implementate o ereditate dall'oggetto <see cref="T:System.Type" /> corrente oppure matrice vuota di tipo <see cref="T:System.Type" /> se l'oggetto <see cref="T:System.Type" /> corrente non ha implementato né ereditato interfacce che corrispondono al filtro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere sottoposto a override da una classe derivata.  
  
 Il <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> e <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegati forniti dal <xref:System.Reflection.Module?displayProperty=nameWithType> classe potrebbe anche essere utilizzata in anziché il <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegato.  
  
 Tutte le interfacce implementate da questa classe vengono considerate durante la ricerca, se dichiarata da questa stessa classe o di una classe di base.  
  
 Questo metodo cerca nella gerarchia di classe di base, la restituzione di ognuna delle interfacce corrispondenti a ogni classe implementa nonché tutti i corrispondenti interfacce ognuno di tali implementa le interfacce (ovvero, la chiusura transitiva di interfacce corrispondenti viene restituita). Interfacce non duplicati vengono restituiti.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, <xref:System.Type.FindInterfaces%2A> cercate tutte le interfacce dichiarate nei vincoli sul parametro di tipo e tutte le interfacce ereditate tramite le interfacce dichiarate nei vincoli. Se l'oggetto corrente <xref:System.Type> rappresenta un argomento di tipo di un tipo generico, <xref:System.Type.FindInterfaces%2A> Cerca tutte le interfacce implementate dal tipo di corrispondenza con i vincoli o meno.  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A> può restituire le interfacce generiche, anche su tipi non generici. Ad esempio, è possibile implementare un tipo non generico `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic).  
  
   
  
## Examples  
 Nell'esempio seguente consente di trovare l'interfaccia specificata implementata o ereditata dal tipo specificato e quindi Visualizza i nomi di interfaccia.  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Un inizializzatore statico viene richiamato e genera un'eccezione.</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">Oggetto che indica il tipo di membro da cercare.</param>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire <see langword="null" />.</param>
        <param name="filter">Delegato che esegue il confronto e restituisce <see langword="true" /> se il membro in esame corrisponde a <c>filterCriteria</c>, in caso contrario <see langword="false" />. È possibile usare i delegati <see langword="FilterAttribute" />, <see langword="FilterName" /> e <see langword="FilterNameIgnoreCase" /> forniti da questa classe. Come criteri di ricerca, il primo usa i campi di <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> e <see langword="MethodImplAttributes" /> e gli altri due delegati usano gli oggetti <see langword="String" />.</param>
        <param name="filterCriteria">Criteri di ricerca che determinano se un membro viene restituito nella matrice di oggetti <see langword="MemberInfo" />.  
  
 I campi di <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> e <see langword="MethodImplAttributes" /> possono essere usati assieme al delegato <see langword="FilterAttribute" /> fornito da questa classe.</param>
        <summary>Restituisce una matrice filtrata di oggetti <see cref="T:System.Reflection.MemberInfo" /> del tipo di membro specificato.</summary>
        <returns>Matrice filtrata di oggetti <see cref="T:System.Reflection.MemberInfo" /> del tipo di membro specificato.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Reflection.MemberInfo" />, se l'oggetto <see cref="T:System.Type" /> corrente non dispone di membri del tipo <paramref name="memberType" /> corrispondenti ai criteri del filtro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere sottoposto a override da una classe derivata.  
  
 I membri includere proprietà, metodi, campi, eventi e così via.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire i membri da includere nella ricerca:  
  
-   È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un risultato.  
  
-   Specificare `BindingFlags.Instance` per includere i membri di istanza nella ricerca.  
  
-   Specificare `BindingFlags.Static` per includere i membri statici nella ricerca.  
  
-   Specificare `BindingFlags.Public` per includere i membri pubblici nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere i membri non pubblici (ovvero, i membri privati, interni e protetti) nella ricerca.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare le modalità di ricerca:  
  
-   `BindingFlags.DeclaredOnly` Per cercare solo i membri dichiarati nel <xref:System.Type>, non i membri sono stati ereditati.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 I valori validi per <xref:System.Type.MemberType%2A> definiti in <xref:System.Reflection.MemberInfo>. Se nessuno di tali membri non viene trovato, viene restituita una matrice vuota.  
  
 Per ottenere l'inizializzatore di classi (. cctor) tramite questo metodo, è necessario specificare <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic). È inoltre possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico o un metodo generico, <xref:System.Type.FindMembers%2A> elabora tutti i membri dichiarati dal vincolo di classe e i vincoli del parametro di tipo di interfaccia.  
  
   
  
## Examples  
 Nell'esempio seguente trova tutti i membri in una classe che soddisfano i criteri di ricerca specificato e quindi Visualizza i membri corrispondenti.  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il nome completo del tipo, comprendente il relativo spazio dei nomi ma non l'assembly.</summary>
        <value>Nome completo del tipo, incluso il relativo lo spazio dei nomi ma non l'assembly; oppure <see langword="null" /> se l'istanza corrente rappresenta un parametro di tipo generico, un tipo matrice, un tipo puntatore o un tipo <see langword="byref" /> basato su un parametro di tipo, o un tipo generico che non è una definizione di tipo generico ma contiene parametri di tipo non risolto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ad esempio, il nome completo del <xref:System.String> è di tipo `System.String`. Ciò si differenzia il nome qualificato dall'assembly restituito dal <xref:System.Type.AssemblyQualifiedName%2A> proprietà, che comprende il nome completo e il nome completo dell'assembly.  
  
 Se il tipo corrente rappresenta un tipo generico chiuso, gli argomenti di tipo nella stringa di risultato di <xref:System.Type.FullName%2A> proprietà vengono qualificati in base al nome completo dell'assembly, anche se la rappresentazione di stringa di tipo generico non è qualificata tramite il relativo full nome dell'assembly. Nell'esempio seguente viene illustrata la differenza nella proprietà nome completo per un tipo che rappresenta la definizione di tipo generico e uno che rappresenta un tipo generico chiuso.  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 Questa proprietà restituisce `null` se:  
  
-   Corrente <xref:System.Type> oggetto rappresenta un parametro di tipo di un tipo generico.  
  
     L'esempio seguente recupera il parametro di tipo di <xref:System.Nullable%601> tipo e tenta di visualizzare il relativo <xref:System.Type.FullName%2A> proprietà.  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   Corrente <xref:System.Type> oggetto rappresenta un tipo di matrice, un tipo di puntatore o un `byref` tipo basato su un parametro di tipo generico.  
  
     L'esempio seguente definisce un tipo generico, `Generictype1<T>`, con tre metodi: `Display(T[])`, che viene passata una matrice di tipo T. `HandleT(T)`, che viene passato un oggetto T; e `ChangeValue(ref T)`, che viene passato un oggetto T per riferimento. Poiché in c# e Visual Basic non consente di definire T come un puntatore nel `HandleT` (metodo), è necessario chiamare il <xref:System.Type.MakePointerType%2A> metodo il <xref:System.Type> oggetto che rappresenta il tipo di parametro del metodo per creare un puntatore a un tipo generico. L'output dell'esempio mostra che in tutti e tre i casi, il <xref:System.Type.FullName%2A> proprietà `null`.  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   Il tipo corrente contiene parametri di tipo generico che non sono stati sostituiti da tipi specifici (, ovvero il <xref:System.Type.ContainsGenericParameters%2A> restituisce proprietà `true`), ma il tipo non è una definizione di tipo generico (vale a dire il <xref:System.Type.IsGenericTypeDefinition%2A> restituisce proprietà `false`  
  
     Nell'esempio seguente, `Derived<T>` eredita da `Base<T>`. Il <xref:System.Type.BaseType%2A> proprietà ottiene il <xref:System.Type> oggetto che rappresenta il tipo di base di `Derived<T>`e il relativo <xref:System.Type.FullName%2A> restituisce proprietà `null`.  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     Per ottenere un <xref:System.Type.FullName%2A> non `null`, è possibile utilizzare il <xref:System.Type.GetGenericTypeDefinition%2A> metodo per ottenere la definizione di tipo generico, come illustrato nell'esempio.  
  
 Questa proprietà è di sola lettura.  
  
   
  
## Examples  
 Nell'esempio seguente visualizza il nome completo del tipo specificato.  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 L'esempio seguente confronta le stringhe restituite dal <xref:System.Type.ToString%2A> (metodo) e `Name`, <xref:System.Type.FullName%2A>, e <xref:System.Type.AssemblyQualifiedName%2A> proprietà.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una combinazione di flag <see cref="T:System.Reflection.GenericParameterAttributes" /> che descrivono la covariante e i vincoli speciali del parametro di tipo generico corrente.</summary>
        <value>Combinazione bit per bit di valori <see cref="T:System.Reflection.GenericParameterAttributes" /> che descrive la covariante e i vincoli speciali del parametro di tipo generico corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questa proprietà contiene i flag che descrivono se il parametro di tipo generico corrente è covariante e i flag che descrivono i vincoli speciali. Utilizzare il <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> valore per selezionare i flag di covarianza e utilizzare il <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> valore per selezionare i flag di vincolo.  
  
 Per un elenco delle condizioni invariabili relative ai termini usati dal processo di reflection generico, vedere i commenti sulla proprietà <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente definisce un tipo generico `Test` con due parametri di tipo con vincoli diversi. Quando viene eseguito il programma, i vincoli vengono esaminati utilizzando il <xref:System.Type.GenericParameterAttributes%2A> proprietà e <xref:System.Type.GetGenericParameterConstraints%2A> metodo.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'oggetto <see cref="T:System.Type" /> corrente non è un parametro di tipo generico, Quindi la proprietà <see cref="P:System.Type.IsGenericParameter" /> restituisce <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Il metodo richiamato non è supportato nella classe base.</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la posizione del parametro di tipo nell'elenco di parametri di tipo del tipo o del metodo generico che ha dichiarato il parametro, quando l'oggetto <see cref="T:System.Type" /> rappresenta un parametro di tipo di un tipo o un metodo generico.</summary>
        <value>Posizione del parametro di tipo nell'elenco dei parametri di tipo del tipo o del metodo generico che definisce il parametro. I numeri di posizione iniziano da 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.GenericParameterPosition%2A> proprietà restituisce la posizione di un parametro di tipo nell'elenco dei parametri della definizione di tipo generico o la definizione di metodo generico in cui è stato originariamente definito il parametro di tipo. Il <xref:System.Type.DeclaringType%2A> e <xref:System.Type.DeclaringMethod%2A> identificano la definizione di tipo o metodo generica:  
  
-   Se il <xref:System.Type.DeclaringMethod%2A> proprietà restituisce un <xref:System.Reflection.MethodInfo>che <xref:System.Reflection.MethodInfo> rappresenta una definizione di metodo generico e corrente <xref:System.Type> oggetto rappresenta un parametro di tipo della definizione di metodo generico.  
  
-   Se il <xref:System.Type.DeclaringMethod%2A> restituisce proprietà `null`, quindi il <xref:System.Type.DeclaringType%2A> proprietà restituisce sempre un <xref:System.Type> oggetto che rappresenta una definizione di tipo generico e corrente <xref:System.Type> oggetto rappresenta un parametro di tipo del tipo generico definizione.  
  
 Per fornire contesto corretto per il valore di <xref:System.Type.GenericParameterPosition%2A> proprietà, è necessario identificare il metodo appartiene a un parametro di tipo o un tipo generico. Si consideri ad esempio il valore restituito del metodo generico `GetSomething` nel codice seguente:  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 Il tipo restituito da `GetSomething` dipende dagli argomenti di tipo forniti a classe `A` e `GetSomething` stesso. È possibile ottenere un <xref:System.Reflection.MethodInfo> per `GetSomething`, e da cui è possibile ottenere il tipo restituito. Quando si esaminano i parametri di tipo del tipo restituito, <xref:System.Type.GenericParameterPosition%2A> restituisce 0 per entrambi. La posizione di `V` è 0 poiché `V` è il primo parametro di tipo nell'elenco di parametri di tipo per la classe `A`. La posizione di `X` è 0 poiché `X` è il primo parametro di tipo nell'elenco di parametri di tipo per `GetSomething`.  
  
> [!NOTE]
>  La chiamata di <xref:System.Type.GenericParameterPosition%2A> proprietà genera un'eccezione se l'oggetto corrente <xref:System.Type> non rappresenta un parametro di tipo. Quando si esaminano gli argomenti di tipo di un tipo costruito aperto, usare il <xref:System.Type.IsGenericParameter%2A> proprietà per indicare che sono parametri di tipo e i tipi. Il <xref:System.Type.IsGenericParameter%2A> restituisce proprietà `true` per un parametro di tipo; è quindi possibile utilizzare il <xref:System.Type.GenericParameterPosition%2A> metodo per ottenere la posizione e utilizzare il <xref:System.Type.DeclaringMethod%2A> e <xref:System.Type.DeclaringType%2A> proprietà per determinare il metodo generico o la definizione che definisce il tipo di .  
  
   
  
## Examples  
 Nell'esempio seguente definisce una classe generica con due parametri di tipo e una seconda classe generica da cui deriva la prima classe. Classe di base della classe derivata ha due argomenti di tipo: il primo è <xref:System.Int32>, e il secondo è un parametro di tipo del tipo derivato. Nell'esempio vengono visualizzate informazioni su queste classi generiche, incluse le posizioni segnalati dal <xref:System.Type.GenericParameterPosition%2A> proprietà.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il tipo corrente non rappresenta un parametro di tipo. Ciò significa che <see cref="P:System.Type.IsGenericParameter" /> restituisce <see langword="false" />.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una matrice di argomenti tipo generico per questo tipo.</summary>
        <value>Matrice di argomenti tipo generico per questo tipo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà ottiene solo gli argomenti di tipo generico; ovvero, i tipi che sono stati specificati i parametri di tipo generico del tipo corrente. Se il tipo corrente è una definizione di tipo generico, questa proprietà restituisce una matrice vuota.  
  
> [!NOTE]
>  Se un tipo generico viene utilizzato in un metodo generico o in un altro tipo generico, alcuni dei relativi argomenti di tipo generico potrebbe essere parametri di tipo generico del metodo o tipo contenitore.  
  
 Per ottenere i parametri di tipo generico di un tipo che rappresenta una definizione di tipo generico, utilizzare il <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> proprietà. Per ottenere un <xref:System.Reflection.TypeInfo> oggetto per l'oggetto corrente <xref:System.Type> oggetto, usare il <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> metodo di estensione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene il numero di dimensioni in una matrice.</summary>
        <returns>Intero che contiene il numero di dimensioni del tipo corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente visualizza il numero di dimensioni in una matrice.  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La funzionalità di questo metodo non è supportata nella classe base e deve invece essere implementata in una classe derivata.</exception>
        <exception cref="T:System.ArgumentException">Il tipo corrente non è una matrice.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, implementa la proprietà <see cref="P:System.Type.Attributes" /> e ottiene una maschera di bit che indica gli attributi associati a <see cref="T:System.Type" />.</summary>
        <returns>Oggetto <see cref="T:System.Reflection.TypeAttributes" /> che rappresenta il gruppo di attributi di <see cref="T:System.Type" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene un costruttore specifico dell'oggetto <see cref="T:System.Type" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano il numero, l'ordine e il tipo dei parametri per il costruttore desiderato.  
  
 oppure  
  
 Matrice vuota di oggetti <see cref="T:System.Type" /> per ottenere un costruttore che non accetta parametri. Tale matrice vuota viene fornita dal campo <see langword="static" /><see cref="F:System.Type.EmptyTypes" />.</param>
        <summary>Cerca un costruttore di istanza pubblica i cui parametri corrispondono ai tipi nella matrice specificata.</summary>
        <returns>Oggetto che rappresenta il costruttore dell'istanza pubblica i cui parametri corrispondono ai tipi nella matrice del tipo di parametro, se presente; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Overload di questo metodo cerca costruttori di istanza pubblici e non può essere utilizzato per ottenere un inizializzatore di classi (. cctor). Per ottenere un inizializzatore di classi, usare un overload che accetta <xref:System.Reflection.BindingFlags>e specificare <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic). È inoltre possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.  
  
 Se il costruttore richiesto non è pubblica, questo metodo restituisce `null`.  
  
> [!NOTE]
>  È possibile omettere i parametri per la ricerca di costruttori e metodi. È possibile omettere i parametri solo quando viene richiamato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.ConstructorInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato. Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questo metodo restituisce sempre `null`.  
  
   
  
## Examples  
 Nell'esempio seguente viene ottenuto il tipo di `MyClass`, ottiene il <xref:System.Reflection.ConstructorInfo> dell'oggetto e Visualizza la firma del costruttore.  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> è <see langword="null" />.  
  
 oppure  
  
 Uno degli elementi in <paramref name="types" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> è multidimensionale.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire <see langword="null" />.</param>
        <param name="binder">Oggetto che definisce una serie di proprietà e permette il binding, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.  
  
 oppure  
  
 Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">Matrice di oggetti <see cref="T:System.Type" /> che rappresenta numero, ordine e tipo dei parametri relativi al costruttore da ottenere.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Type" /> (ovvero Type[] types = new Type[0]) per ottenere un costruttore che non accetta parametri.  
  
 oppure  
  
 <see cref="F:System.Type.EmptyTypes" />.</param>
        <param name="modifiers">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresentano gli attributi associati all'elemento corrispondente nella matrice del tipo di parametro. Questo parametro non viene elaborato dal binder predefinito.</param>
        <summary>Cerca un costruttore i cui parametri corrispondono ai tipi e ai modificatori dell'argomento specificato, usando i vincoli di associazione specificati.</summary>
        <returns>Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> che rappresenta il costruttore corrispondente ai requisiti specificati, se presente; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se non esiste una corrispondenza esatta, la `binder` tenterà di assegnare forzatamente i tipi di parametro specificati nel `types` matrice per selezionare una corrispondenza. Se il `binder` non è in grado di selezionare una corrispondenza, quindi `null` viene restituito.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro può essere utilizzato per definire i costruttori da includere nella ricerca:  
  
-   È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un risultato.  
  
-   Specificare `BindingFlags.Public` per includere i costruttori pubblici nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere nella ricerca i costruttori pubblici (ovvero, i costruttori privati, interni e protetti).  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Per ottenere l'inizializzatore di classi (. cctor) tramite l'overload di questo metodo, è necessario specificare <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic). È inoltre possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.  
  
> [!NOTE]
>  È possibile omettere i parametri per la ricerca di costruttori e metodi. È possibile omettere i parametri solo quando viene richiamato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.ConstructorInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato. Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questo metodo restituisce sempre `null`.  
  
   
  
## Examples  
 Il programma seguente ottiene il tipo di `MyClass1` classe, ottiene il <xref:System.Reflection.ConstructorInfo> oggetto corrispondenza il flag di associazione specificati e viene visualizzata la firma del costruttore.  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> è <see langword="null" />.  
  
 oppure  
  
 Uno degli elementi in <paramref name="types" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> è multidimensionale.  
  
 oppure  
  
 <paramref name="modifiers" /> è multidimensionale.  
  
 oppure  
  
 <paramref name="types" /> e <paramref name="modifiers" /> non hanno la stessa lunghezza.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire <see langword="null" />.</param>
        <param name="binder">Oggetto che definisce una serie di proprietà e permette il binding, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.  
  
 oppure  
  
 Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Oggetto che specifica il set di regole da usare per l'ordine e il layout degli argomenti, la modalità di passaggio del valore restituito, i Registri di sistema usati per gli argomenti e la pulizia dello stack.</param>
        <param name="types">Matrice di oggetti <see cref="T:System.Type" /> che rappresenta numero, ordine e tipo dei parametri relativi al costruttore da ottenere.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Type" /> (ovvero Type[] types = new Type[0]) per ottenere un costruttore che non accetta parametri.</param>
        <param name="modifiers">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresenta gli attributi associati all'elemento corrispondente nella matrice <c>types</c>. Questo parametro non viene elaborato dal binder predefinito.</param>
        <summary>Cerca il costruttore i cui parametri corrispondono ai tipi di argomenti e ai modificatori specificati, usando i vincoli di associazione e la convenzione di chiamata specificati.</summary>
        <returns>Oggetto che rappresenta il costruttore corrispondente ai requisiti specificati, se è stato trovato; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anche se il binder predefinito elabora <xref:System.Reflection.ParameterModifier> (il `modifiers` parametro), è possibile utilizzare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per la scrittura di un gestore di associazione personalizzato che elaborano `modifiers`. `ParameterModifier` viene utilizzato solo quando una chiamata tramite l'interoperabilità COM, e vengono gestiti solo i parametri che vengono passati per riferimento.  
  
 Se non esiste una corrispondenza esatta, la `binder` tenterà di assegnare forzatamente i tipi di parametro specificati nel `types` matrice per selezionare una corrispondenza. Se il `binder` non è in grado di selezionare una corrispondenza, quindi `null` viene restituito.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro può essere utilizzato per definire i costruttori da includere nella ricerca:  
  
-   È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un risultato.  
  
-   Specificare `BindingFlags.Public` per includere i costruttori pubblici nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere nella ricerca i costruttori pubblici (ovvero, i costruttori privati, interni e protetti).  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Per ottenere l'inizializzatore di classi (. cctor) tramite questo metodo, è necessario specificare <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic). È inoltre possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.  
  
 La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.  
  
|Tipo di membro|Static|Non statico|  
|-----------------|------------|-----------------|  
|Costruttore|No|No|  
|Campo|No|Sì. Un campo è sempre Nascondi in base al nome e-firma.|  
|event|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
|Metodo|No|Sì. Un metodo (virtuale e non virtuale) può essere hide-by-name o Nascondi in base al nome e-firma.|  
|Tipo annidato|No|No|  
|Proprietà|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
  
1.  Nascondi in base al nome e-firma prende in considerazione tutte le parti della firma, compresi i modificatori personalizzati, restituire tipi, tipi di parametri, elementi sentinel e convenzioni di chiamata non gestite. Si tratta di un confronto binario.  
  
2.  Per la reflection, proprietà ed eventi sono Nascondi in base al nome e-firma. Se si dispone di una proprietà con sia un'operazione get e set nella classe base, ma la classe derivata contiene solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter sulla classe di base.  
  
3.  Attributi personalizzati non fanno parte di common type system.  
  
> [!NOTE]
>  È possibile omettere i parametri per la ricerca di costruttori e metodi. È possibile omettere i parametri solo quando viene richiamato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.ConstructorInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato. Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questo metodo restituisce sempre `null`.  
  
   
  
## Examples  
 Nell'esempio seguente viene ottenuto il tipo di `MyClass1`, ottiene il <xref:System.Reflection.ConstructorInfo> oggetto che corrisponde ai flag di associazione specificato e Visualizza la firma del costruttore.  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> è <see langword="null" />.  
  
 oppure  
  
 Uno degli elementi in <paramref name="types" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> è multidimensionale.  
  
 oppure  
  
 <paramref name="modifiers" /> è multidimensionale.  
  
 oppure  
  
 <paramref name="types" /> e <paramref name="modifiers" /> non hanno la stessa lunghezza.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire <see langword="null" />.</param>
        <param name="binder">Oggetto che definisce una serie di proprietà e permette il binding, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.  
  
 oppure  
  
 Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Oggetto che specifica il set di regole da usare per l'ordine e il layout degli argomenti, la modalità di passaggio del valore restituito, i Registri di sistema usati per gli argomenti e la pulizia dello stack.</param>
        <param name="types">Matrice di oggetti <see cref="T:System.Type" /> che rappresenta numero, ordine e tipo dei parametri relativi al costruttore da ottenere.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Type" /> (ovvero Type[] types = new Type[0]) per ottenere un costruttore che non accetta parametri.</param>
        <param name="modifiers">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresenta gli attributi associati all'elemento corrispondente nella matrice <c>types</c>. Questo parametro non viene elaborato dal binder predefinito.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, cerca un costruttore i cui parametri corrispondono ai modificatori e ai tipi di argomento specificati, usando i vincoli di associazione e la convenzione di denominazione specificati.</summary>
        <returns>Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> che rappresenta il costruttore corrispondente ai requisiti specificati, se presente; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anche se il binder predefinito elabora <xref:System.Reflection.ParameterModifier> (il `modifiers` parametro), è possibile utilizzare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per la scrittura di un gestore di associazione personalizzato che elaborano `modifiers`. `ParameterModifier` viene utilizzato solo quando una chiamata tramite l'interoperabilità COM, e vengono gestiti solo i parametri che vengono passati per riferimento.  
  
 Se non esiste una corrispondenza esatta, la `binder` tenterà di assegnare forzatamente i tipi di parametro specificati nel `types` matrice per selezionare una corrispondenza. Se il `binder` non è in grado di selezionare una corrispondenza, quindi `null` viene restituito.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro può essere utilizzato per definire i costruttori da includere nella ricerca:  
  
-   È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un risultato.  
  
-   Specificare `BindingFlags.Public` per includere i costruttori pubblici nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere nella ricerca i costruttori pubblici (ovvero, i costruttori privati, interni e protetti).  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Questo metodo implementa <xref:System.Type.GetConstructor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> è <see langword="null" />.  
  
 oppure  
  
 Uno degli elementi in <paramref name="types" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> è multidimensionale.  
  
 oppure  
  
 <paramref name="modifiers" /> è multidimensionale.  
  
 oppure  
  
 <paramref name="types" /> e <paramref name="modifiers" /> non hanno la stessa lunghezza.</exception>
        <exception cref="T:System.NotSupportedException">Il tipo corrente è un oggetto <see cref="T:System.Reflection.Emit.TypeBuilder" /> o <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene i costruttori dell'oggetto <see cref="T:System.Type" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce tutti i costruttori di tipo pubblico definiti per l'oggetto <see cref="T:System.Type" /> corrente.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.ConstructorInfo" /> che rappresentano tutti i costruttori di istanza pubblici definiti per l'oggetto <see cref="T:System.Type" /> corrente, senza l'inizializzatore di tipo (costruttore statico). Se per l'oggetto <see cref="T:System.Type" /> corrente non sono definiti costruttori di istanza pubblici o se l'oggetto <see cref="T:System.Type" /> corrente rappresenta un parametro di tipo nella definizione di un tipo o di un metodo generico, viene restituita una matrice vuota di tipo <see cref="T:System.Reflection.ConstructorInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.GetConstructors%2A> metodo non restituisce i costruttori in un ordine specifico, ad esempio ordine di dichiarazione. Il codice non deve dipendere dall'ordine in cui vengono restituiti i costruttori, perché tale ordine varia.  
  
 La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.  
  
|Tipo di membro|Static|Non statico|  
|-----------------|------------|-----------------|  
|Costruttore|No|No|  
|Campo|No|Sì. Un campo è sempre Nascondi in base al nome e-firma.|  
|event|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
|Metodo|No|Sì. Un metodo (virtuale e non virtuale) può essere hide-by-name o Nascondi in base al nome e-firma.|  
|Tipo annidato|No|No|  
|Proprietà|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
  
1.  Nascondi in base al nome e-firma prende in considerazione tutte le parti della firma, compresi i modificatori personalizzati, restituire tipi, tipi di parametri, elementi sentinel e convenzioni di chiamata non gestite. Si tratta di un confronto binario.  
  
2.  Per la reflection, proprietà ed eventi sono Nascondi in base al nome e-firma. Se si dispone di una proprietà con sia un'operazione get e set nella classe base, ma la classe derivata contiene solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter sulla classe di base.  
  
3.  Attributi personalizzati non fanno parte di common type system.  
  
 Overload di questo metodo chiama il <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> overload del metodo, con <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> in Visual Basic). Non verranno individuati gli inizializzatori di classi (. cctor). Per trovare gli inizializzatori di classi, usare un overload che accetta <xref:System.Reflection.BindingFlags>e specificare <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic). È inoltre possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.ConstructorInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato. Ad esempio, se classe `C<T>` ha un costruttore `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), la chiamata <xref:System.Type.GetConstructors%2A> su `C<int>` restituisce un <xref:System.Reflection.ConstructorInfo> che rappresenta `C(int t1)` in c# (`Sub New(ByVal t1 As Integer)` in Visual Basic).  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo generico, la <xref:System.Type.GetConstructors%2A> metodo restituisce una matrice vuota.  
  
   
  
## Examples  
 In questo esempio mostra l'output del <xref:System.Type.GetConstructors%2A> overload da una classe che dispone di due costruttori di istanza e un costruttore statico.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 L'output di questo codice è:  
  
 2  
  
 False  
  
 False  
  
 Poiché il <xref:System.Type.GetConstructors> overload utilizza solo <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> e <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, il costruttore statico non viene conteggiato dal `for` espressione né valutato da `IsStatic`.  
  
 Per trovare i costruttori statici, utilizzare il <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> overload e passare la combinazione (logico `OR`) di <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, come illustrato nell'esempio di codice seguente:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 L'output è ora:  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire <see langword="null" />.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, cerca i costruttori definiti per l'oggetto <see cref="T:System.Type" /> corrente, usando i <see langword="BindingFlags" /> specificati.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.ConstructorInfo" /> che rappresentano tutti i costruttori definiti per l'oggetto <see cref="T:System.Type" /> corrente corrispondente ai vincoli di binding specificati, compreso l'inizializzatore di tipo, se definito. Restituisce una matrice vuota di tipo <see cref="T:System.Reflection.ConstructorInfo" /> se per l'oggetto <see cref="T:System.Type" /> corrente non sono definiti costruttori, se nessuno dei costruttori definiti corrisponde ai vincoli di binding o se l'oggetto <see cref="T:System.Type" /> corrente rappresenta un parametro di tipo nella definizione di un tipo o di un metodo generico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.GetConstructors%2A> metodo non restituisce i costruttori in un ordine specifico, ad esempio ordine di dichiarazione. Il codice non deve dipendere dall'ordine in cui vengono restituiti i costruttori, perché tale ordine varia.  
  
 `bindingAttr` Consente di specificare se restituire solo i costruttori pubblici o costruttori pubblici e non pubblici.  
  
 Se non esiste una corrispondenza esatta, la `binder` tenterà di assegnare forzatamente i tipi di parametro specificati nel `types` matrice per selezionare una corrispondenza. Se il `binder` non è in grado di selezionare una corrispondenza, quindi `null` viene restituito.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro può essere utilizzato per definire i costruttori da includere nella ricerca:  
  
-   È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un risultato.  
  
-   Specificare `BindingFlags.Public` per includere i costruttori pubblici nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere nella ricerca i costruttori pubblici (ovvero, i costruttori privati, interni e protetti). I costruttori delle classi base non vengono restituiti.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Per ottenere l'inizializzatore di classi (. cctor) tramite l'overload di questo metodo, è necessario specificare <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic). È inoltre possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.ConstructorInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato. Ad esempio, se classe `C<T>` ha un costruttore `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), la chiamata <xref:System.Type.GetConstructors%2A> su `C<int>` restituisce un <xref:System.Reflection.ConstructorInfo> che rappresenta `C(int t1)` in c# (`Sub New(ByVal t1 As Integer)` in Visual Basic).  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo generico, la <xref:System.Type.GetConstructors%2A> metodo restituisce una matrice vuota.  
  
   
  
## Examples  
 In questo esempio mostra l'output del <xref:System.Type.GetConstructors> overload da una classe che dispone di due costruttori di istanza e un costruttore statico.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 L'output di questo codice è:  
  
 2  
  
 False  
  
 False  
  
 Poiché il <xref:System.Type.GetConstructors%2A> overload utilizza solo <xref:System.Reflection.BindingFlags.Public> e <xref:System.Reflection.BindingFlags.Instance>, il costruttore statico non viene conteggiato dal `for` espressione né valutato da `IsStatic`.  
  
 Per trovare i costruttori statici, utilizzare il <xref:System.Type.GetConstructors%2A> overload e passare la combinazione (OR logico) di <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, come illustrato nell'esempio di codice seguente:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 L'output è ora:  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cerca i membri definiti per l'oggetto <see cref="T:System.Type" /> corrente per cui è impostato il <see cref="T:System.Reflection.DefaultMemberAttribute" />.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.MemberInfo" /> che rappresentano tutti i membri predefiniti dell'oggetto <see cref="T:System.Type" /> corrente.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Reflection.MemberInfo" />, se per l'oggetto <see cref="T:System.Type" /> corrente non esistono membri predefiniti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.GetDefaultMembers%2A> metodo non restituisce i membri in un ordine specifico, ad esempio in ordine alfabetico o ordine di dichiarazione. Il codice non deve dipendere dall'ordine in cui vengono restituiti i membri, perché tale ordine varia.  
  
 Questo metodo può essere sottoposto a override da una classe derivata.  
  
 I membri includere proprietà, metodi, campi, eventi e così via.  
  
 La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.  
  
|Tipo di membro|Static|Non statico|  
|-----------------|------------|-----------------|  
|Costruttore|No|No|  
|Campo|No|Sì. Un campo è sempre Nascondi in base al nome e-firma.|  
|event|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
|Metodo|No|Sì. Un metodo (virtuale e non virtuale) può essere hide-by-name o Nascondi in base al nome e-firma.|  
|Tipo annidato|No|No|  
|Proprietà|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
  
1.  Nascondi in base al nome e-firma prende in considerazione tutte le parti della firma, compresi i modificatori personalizzati, restituire tipi, tipi di parametri, elementi sentinel e convenzioni di chiamata non gestite. Si tratta di un confronto binario.  
  
2.  Per la reflection, proprietà ed eventi sono Nascondi in base al nome e-firma. Se si dispone di una proprietà con sia un'operazione get e set nella classe base, ma la classe derivata contiene solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter sulla classe di base.  
  
3.  Attributi personalizzati non fanno parte di common type system.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MemberInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato. Ad esempio, se classe `C<T>` dispone di una proprietà `P` che restituisce `T`, la chiamata <xref:System.Type.GetDefaultMembers%2A> su `C<int>` restituisce `int P` in c# (`Property P As Integer` in Visual Basic).  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questo metodo cerca i membri del vincolo di classe o i membri di <xref:System.Object> se è presente alcun vincolo di classe.  
  
   
  
## Examples  
 Nell'esempio seguente recupera le informazioni di membro predefinito di `MyClass` e visualizza i membri predefiniti.  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, restituisce l'oggetto <see cref="T:System.Type" /> dell'oggetto incluso in modo diretto o mediante riferimento tramite matrice, puntatore o tipo di riferimento.</summary>
        <returns>Oggetto <see cref="T:System.Type" /> dell'oggetto incluso o a cui fa riferimento la matrice, il puntatore o il tipo di riferimento corrente oppure <see langword="null" /> se l'oggetto <see cref="T:System.Type" /> corrente non è una matrice né un puntatore, non viene passato per riferimento oppure rappresenta un tipo generico o un parametro di tipo nella definizione di un tipo o di un metodo generico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce `null` per la <xref:System.Array> classe.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di `GetElementType` metodo.  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valore di cui recuperare il nome.</param>
        <summary>Restituisce il nome della costante avente il valore specificato, per il tipo di enumerazione corrente.</summary>
        <returns>Nome del membro del tipo di enumerazione corrente avente il valore specificato oppure <see langword="null" /> se tale costante non viene rilevata.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Il tipo corrente non è un'enumerazione.  
  
 oppure  
  
 Il tipo di <paramref name="value" /> non corrisponde al tipo corrente. Inoltre, il relativo tipo sottostante non corrisponde a quello del tipo corrente.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce i nomi dei membri del tipo di enumerazione corrente.</summary>
        <returns>Matrice contenente i nomi dei membri dell'enumerazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi della matrice di valori restituiti vengono ordinati in base ai valori binari (ovvero, i valori senza segno) delle costanti enumerate. Se la matrice contiene costanti enumerate con lo stesso valore, non è specificato l'ordine dei nomi corrispondenti.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il tipo corrente non è un'enumerazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il tipo sottostante del tipo di enumerazione corrente.</summary>
        <returns>Tipo sottostante dell'enumerazione corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, il tipo sottostante di un'enumerazione in c# e Visual Basic è <xref:System.Int32>. È possibile specificare altri tipi di integer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il tipo corrente non è un'enumerazione.  
  
 oppure  
  
 Il tipo di enumerazione non è valido perché contiene più di un campo di istanza.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una matrice dei valori delle costanti nel tipo di enumerazione corrente.</summary>
        <returns>Matrice contenente i valori. Gli elementi della matrice sono ordinati in base ai valori binari (ad esempio, i valori senza segno) delle costanti dell'enumerazione.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Il tipo corrente non è un'enumerazione.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene un evento specifico dichiarato o ereditato dall'oggetto <see cref="T:System.Type" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Stringa contenente il nome di un evento dichiarato o ereditato dall'oggetto <see cref="T:System.Type" /> corrente.</param>
        <summary>Restituisce l'oggetto <see cref="T:System.Reflection.EventInfo" /> che rappresenta l'evento pubblico specificato.</summary>
        <returns>Oggetto che rappresenta l'evento pubblico specificato dichiarato o ereditato dall'oggetto <see cref="T:System.Type" /> corrente, se disponibile; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un evento è considerato pubblico per la reflection se dispone di almeno un metodo o una funzione di accesso pubblico. In caso contrario, l'evento viene considerato privato ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerlo.  
  
 La ricerca di `name` tra maiuscole e minuscole. La ricerca include gli eventi di istanza pubblico statico e pubblico.  
  
 La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.  
  
|Tipo di membro|Static|Non statico|  
|-----------------|------------|-----------------|  
|Costruttore|No|No|  
|Campo|No|Sì. Un campo è sempre Nascondi in base al nome e-firma.|  
|event|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
|Metodo|No|Sì. Un metodo (virtuale e non virtuale) può essere hide-by-name o Nascondi in base al nome e-firma.|  
|Tipo annidato|No|No|  
|Proprietà|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
  
1.  Nascondi in base al nome e-firma prende in considerazione tutte le parti della firma, compresi i modificatori personalizzati, restituire tipi, tipi di parametri, elementi sentinel e convenzioni di chiamata non gestite. Si tratta di un confronto binario.  
  
2.  Per la reflection, proprietà ed eventi sono Nascondi in base al nome e-firma. Se si dispone di una proprietà con sia un'operazione get e set nella classe base, ma la classe derivata contiene solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter sulla classe di base.  
  
3.  Attributi personalizzati non fanno parte di common type system.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.EventInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cerca gli eventi del vincolo di classe.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Reflection.EventInfo> dell'oggetto e ottiene l'evento per una classe di pulsanti per l'evento specificato.  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Stringa contenente il nome di un evento dichiarato o ereditato dall'oggetto <see cref="T:System.Type" /> corrente.</param>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire <see langword="null" />.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, restituisce l'oggetto <see cref="T:System.Reflection.EventInfo" /> che rappresenta l'evento specificato, usando i vincoli di binding specificati.</summary>
        <returns>Oggetto che rappresenta l'evento specificato dichiarato o ereditato dall'oggetto <see cref="T:System.Type" /> corrente, se disponibile; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire gli eventi da includere nella ricerca:  
  
-   È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un risultato.  
  
-   Specificare `BindingFlags.Public` per includere gli eventi pubblici nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere gli eventi pubblici (vale a dire eventi privati, interni e protetti) nella ricerca.  
  
-   Specificare `BindingFlags.FlattenHierarchy` includere `public` e `protected` membri statici nella gerarchia; `private` membri statici nelle classi ereditate non sono inclusi.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare le modalità di ricerca:  
  
-   `BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.  
  
-   `BindingFlags.DeclaredOnly` Per cercare solo gli eventi dichiarati sul <xref:System.Type>, non gli eventi di quelli ereditati.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Un evento è considerato pubblico per la reflection se dispone di almeno un metodo o una funzione di accesso pubblico. In caso contrario, l'evento viene considerato privato ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerlo.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.EventInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cerca gli eventi del vincolo di classe.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> metodo per cercare un tipo di un evento pubblico o non pubblico denominato "Clic" che non è `static` (`Shared` in Visual Basic).  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene gli eventi dichiarati o ereditati dall'oggetto <see cref="T:System.Type" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce tutti gli eventi pubblici dichiarati o ereditati dall'oggetto <see cref="T:System.Type" /> corrente.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.EventInfo" /> che rappresentano tutti gli eventi pubblici dichiarati o ereditati dall'oggetto <see cref="T:System.Type" /> corrente.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Reflection.EventInfo" />, se per l'oggetto <see cref="T:System.Type" /> corrente non esistono eventi pubblici.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un evento è considerato pubblico per la reflection se dispone di almeno un metodo o una funzione di accesso pubblico. In caso contrario, l'evento viene considerato privato ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerlo.  
  
 Il <xref:System.Type.GetEvents%2A> metodo non restituisce gli eventi in un ordine specifico, ad esempio in ordine alfabetico o ordine di dichiarazione. Il codice non deve dipendere dall'ordine in cui vengono restituiti gli eventi, perché tale ordine varia.  
  
 Questo metodo può essere sottoposto a override da una classe derivata.  
  
 La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.  
  
|Tipo di membro|Static|Non statico|  
|-----------------|------------|-----------------|  
|Costruttore|No|No|  
|Campo|No|Sì. Un campo è sempre Nascondi in base al nome e-firma.|  
|event|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
|Metodo|No|Sì. Un metodo (virtuale e non virtuale) può essere hide-by-name o Nascondi in base al nome e-firma.|  
|Tipo annidato|No|No|  
|Proprietà|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
  
1.  Nascondi in base al nome e-firma prende in considerazione tutte le parti della firma, compresi i modificatori personalizzati, restituire tipi, tipi di parametri, elementi sentinel e convenzioni di chiamata non gestite. Si tratta di un confronto binario.  
  
2.  Per la reflection, proprietà ed eventi sono Nascondi in base al nome e-firma. Se si dispone di una proprietà con sia un'operazione get e set nella classe base, ma la classe derivata contiene solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter sulla classe di base.  
  
3.  Attributi personalizzati non fanno parte di common type system.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.EventInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cerca gli eventi del vincolo di classe.  
  
   
  
## Examples  
 Nell'esempio seguente si ottiene una matrice di <xref:System.Reflection.EventInfo> gli oggetti, ottiene tutti gli eventi per un `Button` classe e visualizza i nomi degli eventi. Per compilare l'esempio di Visual Basic, utilizzare la seguente riga di comando:  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire <see langword="null" />.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, cerca gli eventi dichiarati o ereditati dall'oggetto <see cref="T:System.Type" /> corrente, usando i vincoli di binding specificati.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.EventInfo" /> che rappresentano tutti gli eventi dichiarati o ereditati dalla classe <see cref="T:System.Type" /> corrente e che corrispondono ai vincoli di binding specificati.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Reflection.EventInfo" />, se l'oggetto <see cref="T:System.Type" /> corrente non dispone di eventi oppure se nessuno degli eventi corrisponde ai vincoli di binding.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.GetEvents%2A> metodo non restituisce gli eventi in un ordine specifico, ad esempio in ordine alfabetico o ordine di dichiarazione. Il codice non deve dipendere dall'ordine in cui vengono restituiti gli eventi, perché tale ordine varia.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire gli eventi da includere nella ricerca:  
  
-   È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un risultato.  
  
-   Specificare `BindingFlags.Public` per includere gli eventi pubblici nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere gli eventi pubblici (vale a dire eventi privati, interni e protetti) nella ricerca. Solo protetti e vengono restituiti gli eventi interni delle classi di base; gli eventi privati delle classi base non vengono restituiti.  
  
-   Specificare `BindingFlags.FlattenHierarchy` includere `public` e `protected` membri statici nella gerarchia; `private` membri statici nelle classi ereditate non sono inclusi.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare le modalità di ricerca:  
  
-   `BindingFlags.DeclaredOnly` Per cercare solo gli eventi dichiarati sul <xref:System.Type>, non gli eventi di quelli ereditati.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Un evento è considerato pubblico per la reflection se dispone di almeno un metodo o una funzione di accesso pubblico. In caso contrario, l'evento viene considerato privato ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerlo.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.EventInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cerca gli eventi del vincolo di classe.  
  
   
  
## Examples  
 Nell'esempio seguente si ottiene una matrice di <xref:System.Reflection.EventInfo> gli oggetti che corrispondono ai flag di associazione specificati, ottiene tutti gli eventi per un `Button` classe e visualizza i nomi degli eventi. Per compilare l'esempio di Visual Basic, utilizzare la seguente riga di comando:  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene un campo specifico dell'oggetto <see cref="T:System.Type" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome del campo dati da ottenere.</param>
        <summary>Cerca il campo pubblico con il nome specificato.</summary>
        <returns>Oggetto che rappresenta il campo pubblico con il nome specificato, se disponibile; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La ricerca di `name` tra maiuscole e minuscole. La ricerca include campi di istanza pubblici static e public.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.FieldInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cerca i campi del vincolo di classe.  
  
   
  
## Examples  
 Nell'esempio seguente ottiene la `Type` dell'oggetto per la classe specificata, ottiene il <xref:System.Reflection.FieldInfo> oggetto per il campo e viene visualizzato il valore del campo.  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Questo oggetto <see cref="T:System.Type" /> è un oggetto <see cref="T:System.Reflection.Emit.TypeBuilder" /> il cui metodo <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> non è stato ancora chiamato.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome del campo dati da ottenere.</param>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire <see langword="null" />.</param>
        <summary>Cerca il campo specificato, usando i vincoli di associazione specificati.</summary>
        <returns>Oggetto che rappresenta il campo corrispondente ai requisiti specificati, se è stato trovato; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.  
  
|Tipo di membro|Static|Non statico|  
|-----------------|------------|-----------------|  
|Costruttore|No|No|  
|Campo|No|Sì. Un campo è sempre Nascondi in base al nome e-firma.|  
|event|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
|Metodo|No|Sì. Un metodo (virtuale e non virtuale) può essere hide-by-name o Nascondi in base al nome e-firma.|  
|Tipo annidato|No|No|  
|Proprietà|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
  
1.  Nascondi in base al nome e-firma prende in considerazione tutte le parti della firma, compresi i modificatori personalizzati, restituire tipi, tipi di parametri, elementi sentinel e convenzioni di chiamata non gestite. Si tratta di un confronto binario.  
  
2.  Per la reflection, proprietà ed eventi sono Nascondi in base al nome e-firma. Se si dispone di una proprietà con sia un'operazione get e set nella classe base, ma la classe derivata contiene solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter sulla classe di base.  
  
3.  Attributi personalizzati non fanno parte di common type system.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire i campi da includere nella ricerca:  
  
-   È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un risultato.  
  
-   Specificare `BindingFlags.Public` per includere i campi pubblici nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere i campi non pubblici (ovvero, i campi privati, interni e protetti) nella ricerca.  
  
-   Specificare `BindingFlags.FlattenHierarchy` includere `public` e `protected` membri statici nella gerarchia; `private` membri statici nelle classi ereditate non sono inclusi.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare le modalità di ricerca:  
  
-   `BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.  
  
-   `BindingFlags.DeclaredOnly` Per cercare solo i campi dichiarati sul <xref:System.Type>, non i campi sono stati ereditati.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.FieldInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cerca i campi del vincolo di classe.  
  
   
  
## Examples  
 Nell'esempio seguente viene ottenuto il `Type` dell'oggetto per la classe specificata, ottiene il <xref:System.Reflection.FieldInfo> oggetto per il campo che corrisponde ai flag di associazione specificato e visualizza il valore del campo.  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene i campi dell'oggetto <see cref="T:System.Type" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce tutti i campi pubblici dell'oggetto <see cref="T:System.Type" /> corrente.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.FieldInfo" /> che rappresentano tutti i campi pubblici definiti per l'oggetto <see cref="T:System.Type" /> corrente.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Reflection.FieldInfo" />, se non è definito alcun campo pubblico per l'oggetto <see cref="T:System.Type" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.GetFields%2A> metodo non restituisce i campi in un ordine specifico, ad esempio in ordine alfabetico o ordine di dichiarazione. Il codice non deve dipendere dall'ordine in cui vengono restituiti i campi, poiché tale ordine varia.  
  
 La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.  
  
|Tipo di membro|Static|Non statico|  
|-----------------|------------|-----------------|  
|Costruttore|No|No|  
|Campo|No|Sì. Un campo è sempre Nascondi in base al nome e-firma.|  
|event|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
|Metodo|No|Sì. Un metodo (virtuale e non virtuale) può essere hide-by-name o Nascondi in base al nome e-firma.|  
|Tipo annidato|No|No|  
|Proprietà|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
  
1.  Nascondi in base al nome e-firma prende in considerazione tutte le parti della firma, compresi i modificatori personalizzati, restituire tipi, tipi di parametri, elementi sentinel e convenzioni di chiamata non gestite. Si tratta di un confronto binario.  
  
2.  Per la reflection, proprietà ed eventi sono Nascondi in base al nome e-firma. Se si dispone di una proprietà con sia un'operazione get e set nella classe base, ma la classe derivata contiene solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter sulla classe di base.  
  
3.  Attributi personalizzati non fanno parte di common type system.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.FieldInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cerca i campi pubblici del vincolo di classe.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato un utilizzo della `GetFields()` metodo.  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire <see langword="null" />.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, cerca i campi definiti per l'oggetto <see cref="T:System.Type" /> corrente, usando i vincoli di binding specificati.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.FieldInfo" /> che rappresentano tutti i campi definiti per l'oggetto <see cref="T:System.Type" /> corrente corrispondente ai vincoli di binding specificati.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Reflection.FieldInfo" />, se non è definito alcun campo per l'oggetto <see cref="T:System.Type" /> corrente oppure se nessuno dei campi definiti corrisponde ai vincoli di binding.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.GetFields%2A> metodo non restituisce i campi in un ordine specifico, ad esempio in ordine alfabetico o ordine di dichiarazione. Il codice non deve dipendere dall'ordine in cui vengono restituiti i campi, poiché tale ordine varia.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire i campi da includere nella ricerca:  
  
-   È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un risultato.  
  
-   Specificare `BindingFlags.Public` per includere i campi pubblici nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere i campi non pubblici (ovvero, i campi privati, interni e protetti) nella ricerca. Solo protetti e vengono restituiti i campi interni delle classi base; i campi privati delle classi base non vengono restituiti.  
  
-   Specificare `BindingFlags.FlattenHierarchy` includere `public` e `protected` membri statici nella gerarchia; `private` membri statici nelle classi ereditate non sono inclusi.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare le modalità di ricerca:  
  
-   `BindingFlags.DeclaredOnly` Per cercare solo i campi dichiarati sul <xref:System.Type>, non i campi sono stati ereditati.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.FieldInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cerca i campi pubblici del vincolo di classe.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato un utilizzo della `GetFields(BindingFlags)` metodo.  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una matrice di oggetti <see cref="T:System.Type" /> che rappresentano gli argomenti di tipo di un tipo generico chiuso o i parametri di tipo di una definizione di tipo generico.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Type" /> che rappresentano gli argomenti di tipo di un tipo generico. Restituisce una matrice vuota se il tipo corrente non è un tipo generico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli elementi della matrice vengono restituiti nell'ordine in cui compaiono nell'elenco di argomenti di tipo per il tipo generico.  
  
-   Se il tipo corrente è un tipo costruito chiuso (vale a dire il <xref:System.Type.ContainsGenericParameters%2A> restituisce proprietà `false`), la matrice restituita dal <xref:System.Type.GetGenericArguments%2A> metodo contiene i tipi che sono stati assegnati ai parametri di tipo generico della definizione di tipo generico .  
  
-   Se il tipo corrente è una definizione di tipo generico, la matrice contiene i parametri di tipo.  
  
-   Se il tipo corrente è un tipo costruito aperto (ovvero, il <xref:System.Type.ContainsGenericParameters%2A> restituisce proprietà `true`) in tipi specifici non sono stati assegnati a tutti i parametri di tipo e i parametri di tipo di inclusione di tipi o metodi generici, la matrice contiene tipi e parametri di tipo. Utilizzare il <xref:System.Type.IsGenericParameter%2A> proprietà per distinguerli. Per una dimostrazione di questo scenario, vedere l'esempio di codice per il <xref:System.Type.ContainsGenericParameters%2A> proprietà.  
  
 Per un elenco delle condizioni invariabili relative ai termini usati dal processo di reflection generico, vedere i commenti sulla proprietà <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Type.GetGenericArguments%2A> metodo per visualizzare gli argomenti di tipo di un tipo costruito e i parametri di tipo della relativa definizione di tipo generico.  
  
 Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <xref:System.Type.IsGenericTypeDefinition%2A> proprietà. Vedere l'esempio più esaustivo per l'output di esempio.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il metodo richiamato non è supportato nella classe base. Le classi derivate devono fornire un'implementazione.</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una matrice di oggetti <see cref="T:System.Type" /> che rappresentano i vincoli sul parametro di tipo generico corrente.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Type" /> che rappresentano i vincoli sul parametro di tipo generico corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni vincolo su un parametro di tipo generico viene espresso come un <xref:System.Type> oggetto. Utilizzare il <xref:System.Type.IsClass%2A> proprietà per determinare se un vincolo è il vincolo di classe di base; se la proprietà restituisce `false`, il vincolo è un vincolo di interfaccia. Se un parametro di tipo senza vincoli di classe e senza vincoli di interfaccia, viene restituita una matrice vuota.  
  
 Per un elenco delle condizioni invariabili relative ai termini usati dal processo di reflection generico, vedere i commenti sulla proprietà <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente definisce un tipo generico `Test` con due parametri di tipo con vincoli diversi. Quando viene eseguito il programma, i vincoli vengono esaminati utilizzando il <xref:System.Type.GenericParameterAttributes%2A> proprietà e <xref:System.Type.GetGenericParameterConstraints%2A> metodo.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'oggetto <see cref="T:System.Type" /> corrente non è un parametro di tipo generico, Quindi la proprietà <see cref="P:System.Type.IsGenericParameter" /> restituisce <see langword="false" />.</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un oggetto <see cref="T:System.Type" /> che rappresenta una definizione di tipo generico da cui è possibile costruire il tipo generico corrente.</summary>
        <returns>Oggetto <see cref="T:System.Type" /> che rappresenta un tipo generico da cui è possibile costruire il tipo corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una definizione di tipo generico è un modello da cui è possibile costruire altri tipi. Ad esempio, dalla definizione di tipo generico `G<T>` (espressi nella sintassi c#; `G(Of T)` in Visual Basic o `generic <typename T> ref class G` in C++) è possibile costruire e creare istanze del tipo `G<int>` (`G(Of Integer)` in Visual Basic). Dato un <xref:System.Type> oggetto che rappresenta questo tipo costruito, il <xref:System.Type.GetGenericTypeDefinition%2A> metodo restituisce la definizione di tipo generico.  
  
 Se due tipi costruiti vengono creati dalla stessa definizione di tipo generico, utilizzando gli stessi argomenti di tipo, il <xref:System.Type.GetGenericTypeDefinition%2A> metodo restituisce lo stesso <xref:System.Type> oggetto per entrambi i tipi.  
  
 Se si chiama il <xref:System.Type.GetGenericTypeDefinition%2A> metodo su un <xref:System.Type> oggetto già rappresenta una definizione di tipo generico, restituisce l'oggetto corrente <xref:System.Type>.  
  
> [!IMPORTANT]
>  Una matrice di tipi generici non è generico. Nel codice c# `A<int>[] v;` o il codice Visual Basic `Dim v() As A(Of Integer)`, il tipo della variabile `v` non è generico. Utilizzare <xref:System.Type.IsGenericType%2A> per determinare se un tipo è generico prima di chiamare <xref:System.Type.GetGenericTypeDefinition%2A>.  
  
 Per un elenco delle condizioni invariabili relative ai termini usati dal processo di reflection generico, vedere i commenti sulla proprietà <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente crea un'istanza di un tipo costruito utilizzando la creazione di istanza comune e quindi utilizza il <xref:System.Type.GetType%2A> e <xref:System.Type.GetGenericTypeDefinition%2A> metodi per recuperare il tipo costruito e definizione di tipo generico. Questo esempio viene utilizzato il generico <xref:System.Collections.Generic.Dictionary%602> tipo; rappresenta il tipo costruito un <xref:System.Collections.Generic.Dictionary%602> di `Test` oggetti con chiavi di stringa.  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il tipo corrente non è generico.  Ciò significa che <see cref="P:System.Type.IsGenericType" /> restituisce <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Il metodo richiamato non è supportato nella classe base. Le classi derivate devono fornire un'implementazione.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il codice hash per l'istanza.</summary>
        <returns>Codice hash per l'istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue l'override del metodo <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L'esempio seguente mostra il codice hash del `System.Windows.Forms.Button` classe.  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene un'interfaccia specifica implementata o ereditata dall'oggetto <see cref="T:System.Type" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome dell'interfaccia da ottenere. Per le interfacce generiche, si tratta del nome alterato.</param>
        <summary>Cerca l'interfaccia con il nome specificato.</summary>
        <returns>Oggetto che rappresenta l'interfaccia con il nome specificato, implementata o ereditata dall'oggetto <see cref="T:System.Type" /> corrente, se presente; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La ricerca di `name` tra maiuscole e minuscole.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Type> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questo metodo vengono cercati i vincoli di interfaccia ed eventuali interfacce ereditate dai vincoli di classe o interfaccia.  
  
> [!NOTE]
>  Per le interfacce generiche, la `name` parametro corrisponde al nome alterato, che termina con un accento grave (\`) e il numero di parametri di tipo. Questo vale per le definizioni di interfaccia generica e interfacce generiche costruite. Ad esempio, per trovare `IExample<T>` (`IExample(Of T)` in Visual Basic) o `IExample<string>` (`IExample(Of String)` in Visual Basic), cercare ``"IExample`1"``.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Type.GetInterface%28System.String%29> metodo per la ricerca di <xref:System.Collections.Hashtable> classe per il <xref:System.Runtime.Serialization.IDeserializationCallback> interfaccia ed elenca i metodi dell'interfaccia.  
  
 L'esempio di codice viene inoltre illustrato il <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> overload del metodo e <xref:System.Type.GetInterfaceMap%2A> metodo.  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">L'oggetto <see cref="T:System.Type" /> corrente rappresenta un tipo che implementa la stessa interfaccia generica con argomenti di tipo differenti.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome dell'interfaccia da ottenere. Per le interfacce generiche, si tratta del nome alterato.</param>
        <param name="ignoreCase">
          <see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole nella parte di <c> name</c> che specifica il nome semplice dell'interfaccia. Nella parte in cui viene specificato lo spazio dei nomi è necessario fare distinzione tra maiuscole e minuscole.  
  
 oppure  
  
 <see langword="false" /> per eseguire una ricerca di tutte le parti di <c>name</c> facendo distinzione tra maiuscole e minuscole.</param>
        <summary>Quando è sottoposto a override in una classe derivata, cerca l'interfaccia specificata, indicando se la ricerca del nome dell'interfaccia viene eseguita senza fare distinzione tra maiuscole e minuscole.</summary>
        <returns>Oggetto che rappresenta l'interfaccia con il nome specificato, implementata o ereditata dall'oggetto <see cref="T:System.Type" /> corrente, se presente; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `ignoreCase` parametro si applica solo al nome semplice dell'interfaccia, non allo spazio dei nomi. La parte di `name` che specifica lo spazio dei nomi deve avere lettere maiuscole o minuscole o l'interfaccia non verrà trovato. Ad esempio, la stringa "System. IComparable" trova il <xref:System.IComparable> interfaccia, ma la stringa "System. IComparable" non.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Type> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questo metodo vengono cercati i vincoli di interfaccia ed eventuali interfacce ereditate dai vincoli di classe o interfaccia.  
  
> [!NOTE]
>  Per le interfacce generiche, la `name` parametro corrisponde al nome alterato, che termina con un accento grave (\`) e il numero di parametri di tipo. Questo vale per le definizioni di interfaccia generica e interfacce generiche costruite. Ad esempio, per trovare `IExample<T>` (`IExample(Of T)` in Visual Basic) o `IExample<string>` (`IExample(Of String)` in Visual Basic), cercare `"IExample`1"'.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> metodo per eseguire una ricerca di distinzione tra maiuscole e le <xref:System.Collections.Hashtable> classe per il <xref:System.Collections.IEnumerable> interfaccia.  
  
 L'esempio di codice viene inoltre illustrato il <xref:System.Type.GetInterface%28System.String%29> overload del metodo e <xref:System.Type.GetInterfaceMap%2A> metodo.  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">L'oggetto <see cref="T:System.Type" /> corrente rappresenta un tipo che implementa la stessa interfaccia generica con argomenti di tipo differenti.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">Tipo dell'interfaccia per cui recuperare un mapping.</param>
        <summary>Restituisce un mapping di interfaccia per il tipo di interfaccia specificato.</summary>
        <returns>Oggetto che rappresenta il mapping dell'interfaccia per il parametro <paramref name="interfaceType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La mappa dell'interfaccia indica la modalità di mapping di un'interfaccia in membri effettivi in una classe che implementa tale interfaccia.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, i parametri vengono sostituiti dagli argomenti di tipo appropriati negli elementi di tipo di <xref:System.Reflection.InterfaceMapping> restituito da questo metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene chiamato il <xref:System.Type.GetInterfaceMap%2A> metodo per determinare come <xref:System.IFormatProvider> interfaccia esegue il mapping a <xref:System.Globalization.CultureInfo> metodi e come <xref:System.IAppDomainSetup> interfaccia esegue il mapping a <xref:System.AppDomainSetup> proprietà. Si noti che, in quanto il <xref:System.IAppDomainSetup> interfaccia definisce un set di proprietà, l'oggetto restituito <xref:System.Reflection.InterfaceMapping> oggetto include separato <xref:System.Reflection.MethodInfo> gli oggetti per ottenere una proprietà e funzioni di accesso set.  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="interfaceType" /> non è implementato dal tipo corrente.  
  
 oppure  
  
 Il parametro <paramref name="interfaceType" /> non contiene riferimenti a un'interfaccia.  
  
 oppure  
  
 <paramref name="interfaceType" /> è un'interfaccia generica e il tipo corrente è un tipo di matrice.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="interfaceType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">L'oggetto <see cref="T:System.Type" /> corrente rappresenta un parametro di tipo generico; ovvero la proprietà <see cref="P:System.Type.IsGenericParameter" /> è <see langword="true" />.</exception>
        <exception cref="T:System.NotSupportedException">Il metodo richiamato non è supportato nella classe base. Le classi derivate devono fornire un'implementazione.</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, ottiene tutte le interfacce implementate o ereditate dall'oggetto <see cref="T:System.Type" /> corrente.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Type" /> che rappresentano tutte le interfacce implementate o ereditate dall'oggetto <see cref="T:System.Type" /> corrente.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Type" />, se non vengono implementate o ereditate interfacce dall'oggetto <see cref="T:System.Type" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.GetInterfaces%2A> metodo non restituisce le interfacce in un ordine specifico, ad esempio in ordine alfabetico o ordine di dichiarazione. Il codice non deve dipendere dall'ordine in cui vengono restituite le interfacce, perché tale ordine varia.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Type> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questo metodo vengono cercati i vincoli di interfaccia ed eventuali interfacce ereditate dai vincoli di classe o interfaccia.  
  
   
  
## Examples  
 Nell'esempio seguente ottiene il tipo della classe specificata e consente di visualizzare tutte le interfacce che il tipo implementa o eredita. Per compilare l'esempio di Visual Basic, utilizzare i comandi del compilatore seguenti:  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Un inizializzatore statico viene richiamato e genera un'eccezione.</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene i membri specificati dell'oggetto <see cref="T:System.Type" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome dei membri pubblici da ottenere.</param>
        <summary>Cerca i membri pubblici con il nome specificato.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.MemberInfo" /> che rappresentano i membri pubblici con il nome specificato, se presenti; in caso contrario, matrice vuota.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La ricerca di `name` tra maiuscole e minuscole. La ricerca include i membri di istanza pubblico statico e pubblico.  
  
 I membri includere proprietà, metodi, campi, eventi e così via.  
  
 Il <xref:System.Type.GetMember%2A> metodo non restituisce i membri in un ordine specifico, ad esempio in ordine alfabetico o ordine di dichiarazione. Il codice non deve dipendere dall'ordine in cui vengono restituiti i membri, perché tale ordine varia.  
  
 Questo overload del metodo non sarà possibile trovare gli inizializzatori di classi (. cctor). Per trovare gli inizializzatori di classi, usare un overload che accetta <xref:System.Reflection.BindingFlags>e specificare <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic). È inoltre possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.  
  
 La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.  
  
|Tipo di membro|Static|Non statico|  
|-----------------|------------|-----------------|  
|Costruttore|No|No|  
|Campo|No|Sì. Un campo è sempre Nascondi in base al nome e-firma.|  
|event|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
|Metodo|No|Sì. Un metodo (virtuale e non virtuale) può essere hide-by-name o Nascondi in base al nome e-firma.|  
|Tipo annidato|No|No|  
|Proprietà|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
  
1.  Nascondi in base al nome e-firma prende in considerazione tutte le parti della firma, compresi i modificatori personalizzati, restituire tipi, tipi di parametri, elementi sentinel e convenzioni di chiamata non gestite. Si tratta di un confronto binario.  
  
2.  Per la reflection, proprietà ed eventi sono Nascondi in base al nome e-firma. Se si dispone di una proprietà con sia un'operazione get e set nella classe base, ma la classe derivata contiene solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter sulla classe di base.  
  
3.  Attributi personalizzati non fanno parte di common type system.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MemberInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questo metodo cerca i membri del vincolo di classe o i membri di <xref:System.Object> se è presente alcun vincolo di classe.  
  
> [!NOTE]
>  Per i metodi generici, non includere gli argomenti di tipo in `name`. Ad esempio, il codice c# `GetMember("MyMethod<int>")` esegue la ricerca di un membro con il nome del testo "`MyMethod<int>`", anziché per un metodo denominato `MyMethod` che dispone di un argomento generico di tipo `int`.  
  
   
  
## Examples  
 L'esempio seguente visualizza tutti i membri del `String` classe che iniziano con la lettera C.  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome dei membri da ottenere.</param>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire una matrice vuota.</param>
        <summary>Cerca i membri specificati, usando i vincoli di associazione specificati.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.MemberInfo" /> che rappresentano i membri pubblici con il nome specificato, se presenti; in caso contrario, matrice vuota.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere sottoposto a override da una classe derivata.  
  
 I membri includere proprietà, metodi, campi, eventi e così via.  
  
 Il <xref:System.Type.GetMember%2A> metodo non restituisce i membri in un ordine specifico, ad esempio in ordine alfabetico o ordine di dichiarazione. Il codice non deve dipendere dall'ordine in cui vengono restituiti i membri, perché tale ordine varia.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire i membri da includere nella ricerca:  
  
-   È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un risultato.  
  
-   Specificare `BindingFlags.Public` per includere i membri pubblici nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere i membri non pubblici (ovvero, i membri privati, interni e protetti) nella ricerca.  
  
-   Specificare `BindingFlags.FlattenHierarchy` includere `public` e `protected` membri statici nella gerarchia; `private` membri statici nelle classi ereditate non sono inclusi.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare le modalità di ricerca:  
  
-   `BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.  
  
-   `BindingFlags.DeclaredOnly` Per cercare solo i membri dichiarati nel <xref:System.Type>, non i membri sono stati ereditati.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Per ottenere l'inizializzatore di classi (. cctor) tramite l'overload di questo metodo, è necessario specificare ". cctor" per `name`, e <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) per `bindingAttr`. È inoltre possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MemberInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questo metodo cerca i membri del vincolo di classe o i membri di <xref:System.Object> se è presente alcun vincolo di classe.  
  
> [!NOTE]
>  Per i metodi generici, non includere gli argomenti di tipo in `name`. Ad esempio, il codice c# `GetMember("MyMethod<int>")` esegue la ricerca di un membro con il nome del testo "`MyMethod<int>`", anziché per un metodo denominato `MyMethod` che dispone di un argomento generico di tipo `int`.  
  
   
  
## Examples  
 Nell'esempio seguente consente di visualizzare tutti i membri statici pubblici del `myString` classe che iniziano con la lettera C.  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome dei membri da ottenere.</param>
        <param name="type">Valore da cercare.</param>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire una matrice vuota.</param>
        <summary>Cerca i membri specificati del tipo di membro specificato usando i vincoli di associazione specificati.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.MemberInfo" /> che rappresentano i membri pubblici con il nome specificato, se presenti; in caso contrario, matrice vuota.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I membri includere proprietà, metodi, campi, eventi e così via.  
  
 Il <xref:System.Type.GetMember%2A> metodo non restituisce i membri in un ordine specifico, ad esempio in ordine alfabetico o ordine di dichiarazione. Il codice non deve dipendere dall'ordine in cui vengono restituiti i membri, perché tale ordine varia.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire i membri da includere nella ricerca:  
  
-   È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un risultato.  
  
-   Specificare `BindingFlags.Public` per includere i membri pubblici nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere i membri non pubblici (ovvero, i membri privati, interni e protetti) nella ricerca.  
  
-   Specificare `BindingFlags.FlattenHierarchy` includere `public` e `protected` membri statici nella gerarchia; `private` membri statici nelle classi ereditate non sono inclusi.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare le modalità di ricerca:  
  
-   `BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.  
  
-   `BindingFlags.DeclaredOnly` Per cercare solo i membri dichiarati nel <xref:System.Type>, non i membri sono stati ereditati.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Per ottenere l'inizializzatore di classi (. cctor) tramite l'overload di questo metodo, è necessario specificare ". cctor" per `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> per `type`, e <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) per `bindingAttr`. È inoltre possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MemberInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questo metodo cerca i membri del vincolo di classe o i membri di <xref:System.Object> se è presente alcun vincolo di classe.  
  
> [!NOTE]
>  Per i metodi generici, non includere gli argomenti di tipo in `name`. Ad esempio, il codice c# `GetMember("MyMethod<int>")` esegue la ricerca di un membro con il nome del testo "`MyMethod<int>`", anziché per un metodo denominato `MyMethod` che dispone di un argomento generico di tipo `int`.  
  
   
  
## Examples  
 L'esempio seguente visualizza tutti i metodi del `myString` classe che iniziano con la lettera C.  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Una classe derivata deve fornire un'implementazione.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene i membri (proprietà, metodi, campi, eventi e così via) dell'oggetto <see cref="T:System.Type" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce tutti i membri pubblici dell'oggetto <see cref="T:System.Type" /> corrente.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.MemberInfo" /> che rappresentano tutti i membri pubblici dell'oggetto <see cref="T:System.Type" /> corrente.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Reflection.MemberInfo" />, se per l'oggetto <see cref="T:System.Type" /> corrente non esistono membri pubblici.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I membri includere proprietà, metodi, campi, eventi e così via.  
  
 Il <xref:System.Type.GetMembers%2A> metodo non restituisce i membri in un ordine specifico, ad esempio in ordine alfabetico o ordine di dichiarazione. Il codice non deve dipendere dall'ordine in cui vengono restituiti i membri, perché tale ordine varia.  
  
 Overload di questo metodo chiama il <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> overload del metodo, con <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in Visual Basic). Non verranno individuati gli inizializzatori di classi (. cctor). Per trovare gli inizializzatori di classi, usare un overload che accetta <xref:System.Reflection.BindingFlags>e specificare <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic). È inoltre possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.  
  
 La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.  
  
|Tipo di membro|Static|Non statico|  
|-----------------|------------|-----------------|  
|Costruttore|No|No|  
|Campo|No|Sì. Un campo è sempre Nascondi in base al nome e-firma.|  
|event|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
|Metodo|No|Sì. Un metodo (virtuale e non virtuale) può essere hide-by-name o Nascondi in base al nome e-firma.|  
|Tipo annidato|No|No|  
|Proprietà|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
  
1.  Nascondi in base al nome e-firma prende in considerazione tutte le parti della firma, compresi i modificatori personalizzati, restituire tipi, tipi di parametri, elementi sentinel e convenzioni di chiamata non gestite. Si tratta di un confronto binario.  
  
2.  Per la reflection, proprietà ed eventi sono Nascondi in base al nome e-firma. Se si dispone di una proprietà con sia un'operazione get e set nella classe base, ma la classe derivata contiene solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter sulla classe di base.  
  
3.  Attributi personalizzati non fanno parte di common type system.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MemberInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questo metodo cerca i membri del vincolo di classe o i membri di <xref:System.Object> se è presente alcun vincolo di classe.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Type.GetMembers> overload del metodo per raccogliere informazioni su tutti i membri pubblici di una classe specificata.  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero (<see cref="F:System.Reflection.BindingFlags.Default" />), per restituire una matrice vuota.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, cerca i membri definiti per l'oggetto <see cref="T:System.Type" /> corrente, usando i vincoli di binding specificati.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.MemberInfo" /> che rappresentano tutti i membri definiti per l'oggetto <see cref="T:System.Type" /> corrente corrispondenti ai vincoli di binding specificati.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Reflection.MemberInfo" />, se non vi sono membri definiti per l'oggetto <see cref="T:System.Type" /> corrente oppure se nessuno dei membri definiti corrisponde ai vincoli di binding.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I membri includere proprietà, metodi, campi, eventi e così via.  
  
 Il <xref:System.Type.GetMembers%2A> metodo non restituisce i membri in un ordine specifico, ad esempio in ordine alfabetico o ordine di dichiarazione. Il codice non deve dipendere dall'ordine in cui vengono restituiti i membri, perché tale ordine varia.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire i membri da includere nella ricerca:  
  
-   È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un risultato.  
  
-   Specificare `BindingFlags.Public` per includere i membri pubblici nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere i membri non pubblici (ovvero, i membri privati, interni e protetti) nella ricerca. Solo protetti e vengono restituiti i membri interni delle classi base; membri privati delle classi base non vengono restituiti.  
  
-   Specificare `BindingFlags.FlattenHierarchy` includere `public` e `protected` membri statici nella gerarchia; `private` membri statici nelle classi ereditate non sono inclusi.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare le modalità di ricerca:  
  
-   `BindingFlags.DeclaredOnly` Per cercare solo i membri dichiarati nel <xref:System.Type>, non i membri sono stati ereditati.  
  
 Chiamare questo metodo solo con il `Public` flag o solo il `NonPublic` flag restituirà i membri specificati e non richiede altri flag di qualsiasi.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Per ottenere l'inizializzatore di classi (. cctor) tramite l'overload di questo metodo, è necessario specificare <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic). È inoltre possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.  
  
 Se l'oggetto T:System.Type corrente rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MemberInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questo metodo cerca i membri del vincolo di classe o i membri di <xref:System.Object> se è presente alcun vincolo di classe.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> overload del metodo per raccogliere informazioni su tutti i membri di istanza pubblici di una classe specificata.  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene un metodo specifico dell'oggetto <see cref="T:System.Type" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome del metodo pubblico da ottenere.</param>
        <summary>Cerca il metodo pubblico con il nome specificato.</summary>
        <returns>Oggetto che rappresenta il metodo pubblico con il nome specificato, se è stato trovato; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La ricerca di `name` tra maiuscole e minuscole. La ricerca include i metodi di istanza pubblico statico e pubblico.  
  
 Se un metodo di overload e dispone di più di un metodo pubblico, il <xref:System.Type.GetMethod%28System.String%29> metodo genera un <xref:System.Reflection.AmbiguousMatchException> eccezione. Nell'esempio seguente, viene generata un'eccezione perché non esiste più di un overload pubblico del <xref:System.Int32.ToString%2A?displayProperty=nameWithType> metodo.  D'altra parte, perché il `Person.ToString` override dei metodi <xref:System.Object.ToString%2A?displayProperty=nameWithType> e pertanto non sia sovraccarico, il <xref:System.Type.GetMethod%28System.String%29> metodo è in grado di recuperare il <xref:System.Reflection.MethodInfo> oggetto.  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 È possibile eseguire una delle operazioni seguenti per recuperare un metodo specifico:  
  
-   Chiamare il <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> (metodo) e specificare un `bindingAttr` argomento che identifica il metodo. Ad esempio, se l'eccezione viene generata perché un tipo ha un valore statico e un overload di istanza, è possibile specificare un `bindingAttr` argomento di <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.  
  
-   Chiamare un overload di <xref:System.Type.GetMethod%2A> metodo che include un `types` parametro che definisce i tipi di parametri del metodo.  
  
-   Chiamare il <xref:System.Type.GetMethods> metodo per recuperare una matrice contenente tutti i metodi pubblici appartenenti a un tipo. È possibile quindi eseguire l'iterazione in modo da identificare i metodi duplicati denominati `name`.  
  
 Se l'oggetto T:System.Type corrente rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MethodInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questo metodo cerca i metodi del vincolo di classe o i metodi di <xref:System.Object> se è presente alcun vincolo di classe.  
  
> [!NOTE]
>  Per i metodi generici, non includere gli argomenti di tipo in `name`. Ad esempio, il codice c# `GetMember("MyMethod<int>")` esegue la ricerca di un membro con il nome del testo "`MyMethod<int>`", anziché per un metodo denominato `MyMethod` che dispone di un argomento generico di tipo `int`.  
  
   
  
## Examples  
 Nell'esempio seguente viene ottenuto un metodo denominato `MethodA`.  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">È stato trovato più di un metodo con il nome specificato.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome del metodo da ottenere.</param>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire <see langword="null" />.</param>
        <summary>Cerca il metodo specificato, usando i vincoli di binding specificati.</summary>
        <returns>Oggetto che rappresenta il metodo corrispondente ai requisiti specificati, se presente; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire i metodi da includere nella ricerca:  
  
-   È necessario specificare <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> o <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> per ottenere un risultato.  
  
-   Specificare <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> per includere i metodi pubblici nella ricerca.  
  
-   Specificare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> per includere nella ricerca i metodi non pubblici (vale a dire metodi privati, interni e protetti).  
  
-   Specificare <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> includere `public` e `protected` membri statici nella gerarchia; `private` membri statici nelle classi ereditate non sono inclusi.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare le modalità di ricerca:  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> per ignorare la distinzione di `name`.  
  
-   <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> Per cercare solo i metodi dichiarati nel <xref:System.Type>, non i metodi quelli ereditati.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Se un metodo viene sottoposto a overload e più di un overload soddisfa i vincoli specificati per il `bindingAttr` argomento, il metodo genera un <xref:System.Reflection.AmbiguousMatchException> eccezione. Nell'esempio seguente, viene generata un'eccezione perché:  
  
-   Il `TestClass` tipo dispone di due overload di istanza pubblici del `DisplayValue` metodo `DisplayValue(String)` e `DisplayValue(String, Object[])`.  
  
-   Il `TestClass` tipo dispone di due overload di istanza pubblici del `Equals` uno dei quali viene ereditato dal metodo <xref:System.Object>: `Equals(TestClass)` e `Equals(Object)`.  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 È possibile eseguire una delle operazioni seguenti per recuperare un metodo specifico:  
  
-   Modificare i vincoli di associazione. Nell'esempio precedente, il tentativo di recuperare un'istanza pubblica `Equals` metodo che viene dichiarato dal tipo e non è stato ereditato recupera `Equals(TestClass)`.  
  
-   Chiamare un overload di <xref:System.Type.GetMethod%2A> metodo che include un `types` parametro che definisce i tipi di parametri del metodo.  
  
-   Chiamare il <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> metodo per recuperare una matrice contenente tutti i metodi appartenenti a un tipo che hanno gli attributi di associazione specificati. È possibile quindi eseguire l'iterazione in modo da identificare i metodi duplicati denominati `name`. Questo approccio è illustrato nel gestore dell'esempio precedente per il <xref:System.Reflection.AmbiguousMatchException> eccezione.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MethodInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questo metodo cerca i metodi del vincolo di classe o i metodi di <xref:System.Object> se è presente alcun vincolo di classe.  
  
> [!NOTE]
>  Per i metodi generici, non includere gli argomenti di tipo in `name`. Ad esempio, il codice c# `GetMember("MyMethod<int>")` esegue la ricerca di un membro con il nome del testo "`MyMethod<int>`", anziché per un metodo denominato `MyMethod` che dispone di un argomento generico di tipo `int`.  
  
   
  
## Examples  
 Nell'esempio seguente ottiene il metodo corrispondente ai flag di associazione specificato.  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">È stato trovato più di un metodo con il nome specificato e corrispondente ai vincoli di associazione specificati.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome del metodo pubblico da ottenere.</param>
        <param name="types">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano numero, ordine e tipo dei parametri relativi al metodo da ottenere.  
  
 oppure  
  
 Matrice vuota di oggetti <see cref="T:System.Type" /> (come fornita dal campo <see cref="F:System.Type.EmptyTypes" />) per ottenere un metodo che non accetta parametri.</param>
        <summary>Cerca il metodo pubblico specificato i cui parametri corrispondono ai tipi di argomenti specificati.</summary>
        <returns>Oggetto che rappresenta il metodo pubblico i cui parametri corrispondono ai tipi di argomenti specificati, se è stato trovato; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La ricerca di `name` tra maiuscole e minuscole. La ricerca include i metodi di istanza pubblico statico e pubblico.  
  
> [!NOTE]
>  È possibile omettere i parametri per la ricerca di costruttori e metodi. È possibile omettere i parametri solo quando viene richiamato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MethodInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questo metodo cerca i metodi del vincolo di classe o i metodi di <xref:System.Object> se è presente alcun vincolo di classe.  
  
> [!NOTE]
>  Il `name` parametro non può includere gli argomenti di tipo. Ad esempio, il codice c# `GetMethod("MyGenericMethod<int>")` esegue la ricerca di un metodo con il nome del testo "`MyGenericMethod<int>`", anziché per un metodo denominato `MyGenericMethod` che dispone di un argomento generico di tipo `int`. Utilizzare invece `GetMethod("MyGenericMethod")` con il parametro appropriato nel `types` matrice.  
  
   
  
## Examples  
 Nell'esempio seguente vengono determinati overload di `MethodA`, specificando un'ampia gamma di tipi di argomento.  
  
> [!NOTE]
>  Il [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] esempio presenta i requisiti di `/unsafe` l'opzione del compilatore.  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 L'esempio seguente recupera <xref:System.Reflection.MethodInfo> gli oggetti che rappresentano il `Add` metodi di un tipo non generico (il <xref:System.Collections.ArrayList> classe), un tipo generico aperto (il <xref:System.Collections.Generic.List%601> classe) e un tipo generico chiuso (il `List(Of String)` tipo.  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 Nell'esempio viene definito un `GetAddMethod` metodo che recupera l'oggetto appropriato <xref:System.Reflection.MethodInfo> oggetto. Per fornire il `types` argomento per un tipo generico aperto, chiama il <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metodo. Per fornire il `types` argomento per un tipo generico chiuso, viene recuperato il valore del <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Sono stati trovati più metodi con il nome e i parametri specificati.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="types" /> è <see langword="null" />.  
  
 oppure  
  
 Uno degli elementi in <paramref name="types" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> è multidimensionale.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome del metodo pubblico da ottenere.</param>
        <param name="types">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano numero, ordine e tipo dei parametri relativi al metodo da ottenere.  
  
 oppure  
  
 Matrice vuota di oggetti <see cref="T:System.Type" /> (come fornita dal campo <see cref="F:System.Type.EmptyTypes" />) per ottenere un metodo che non accetta parametri.</param>
        <param name="modifiers">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresenta gli attributi associati all'elemento corrispondente nella matrice <c>types</c>. Da usare solo quando si effettuano chiamate tramite l'interoperabilità COM e vengono gestiti solo i parametri passati per riferimento. Questo parametro non viene elaborato dal binder predefinito.</param>
        <summary>Cerca il metodo pubblico specificato i cui parametri corrispondono ai modificatori e ai tipi di argomenti specificati.</summary>
        <returns>Oggetto che rappresenta il metodo pubblico corrispondente ai requisiti specificati, se è stato trovato; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anche se il binder predefinito elabora <xref:System.Reflection.ParameterModifier> (il `modifiers` parametro), è possibile utilizzare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per la scrittura di un gestore di associazione personalizzato che elaborano `modifiers`. `ParameterModifier` viene utilizzato solo quando una chiamata tramite l'interoperabilità COM, e vengono gestiti solo i parametri che vengono passati per riferimento.  
  
 La ricerca di `name` tra maiuscole e minuscole. La ricerca include i metodi di istanza pubblico statico e pubblico.  
  
> [!NOTE]
>  È possibile omettere i parametri per la ricerca di costruttori e metodi. È possibile omettere i parametri solo quando viene richiamato.  
  
 Se l'oggetto T:System.Type corrente rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MethodInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questo metodo cerca i metodi del vincolo di classe o i metodi di <xref:System.Object> se è presente alcun vincolo di classe.  
  
> [!NOTE]
>  Per i metodi generici, non includere gli argomenti di tipo in `name`. Ad esempio, il codice c# `GetMethod("MyMethod<int>")` esegue la ricerca di un membro con il nome del testo "`MyMethod<int>`", anziché per un metodo denominato `MyMethod` che dispone di un argomento generico di tipo `int`. Utilizzare invece `GetMethod("MyMethod")` con il parametro appropriato nel `types` matrice.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Sono stati trovati più metodi con il nome e i parametri specificati.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="types" /> è <see langword="null" />.  
  
 oppure  
  
 Uno degli elementi in <paramref name="types" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> è multidimensionale.  
  
 oppure  
  
 <paramref name="modifiers" /> è multidimensionale.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome del metodo da ottenere.</param>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire <see langword="null" />.</param>
        <param name="binder">Oggetto che definisce una serie di proprietà e permette il binding, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.  
  
 oppure  
  
 Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano numero, ordine e tipo dei parametri relativi al metodo da ottenere.  
  
 oppure  
  
 Matrice vuota di oggetti <see cref="T:System.Type" /> (come fornita dal campo <see cref="F:System.Type.EmptyTypes" />) per ottenere un metodo che non accetta parametri.</param>
        <param name="modifiers">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresenta gli attributi associati all'elemento corrispondente nella matrice <c>types</c>. Da usare solo quando si effettuano chiamate tramite l'interoperabilità COM e vengono gestiti solo i parametri passati per riferimento. Questo parametro non viene elaborato dal binder predefinito.</param>
        <summary>Cerca il metodo specificato i cui parametri corrispondono ai tipi di argomenti e ai modificatori specificati, usando i vincoli di associazione specificati.</summary>
        <returns>Oggetto che rappresenta il metodo corrispondente ai requisiti specificati, se presente; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anche se il binder predefinito elabora <xref:System.Reflection.ParameterModifier> (il `modifiers` parametro), è possibile utilizzare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per la scrittura di un gestore di associazione personalizzato che elaborano `modifiers`. `ParameterModifier` viene utilizzato solo quando una chiamata tramite l'interoperabilità COM, e vengono gestiti solo i parametri che vengono passati per riferimento.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire i metodi da includere nella ricerca:  
  
-   È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un risultato.  
  
-   Specificare `BindingFlags.Public` per includere i metodi pubblici nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere i metodi non pubblici (vale a dire metodi privati, interni e protetti) nella ricerca.  
  
-   Specificare `BindingFlags.FlattenHierarchy` includere `public` e `protected` membri statici nella gerarchia; `private` membri statici nelle classi ereditate non sono inclusi.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare le modalità di ricerca:  
  
-   `BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.  
  
-   `BindingFlags.DeclaredOnly` Per cercare solo i metodi dichiarati nel <xref:System.Type>, non i metodi quelli ereditati.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  È possibile omettere i parametri per la ricerca di costruttori e metodi. È possibile omettere i parametri solo quando viene richiamato.  
  
 Se l'oggetto T:System.Type corrente rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MethodInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questo metodo cerca i metodi del vincolo di classe o i metodi di <xref:System.Object> se è presente alcun vincolo di classe.  
  
> [!NOTE]
>  Per i metodi generici, non includere gli argomenti di tipo in `name`. Ad esempio, il codice c# `GetMember("MyMethod<int>")` esegue la ricerca di un membro con il nome del testo "`MyMethod<int>`", anziché per un metodo denominato `MyMethod` che dispone di un argomento generico di tipo `int`.  
  
   
  
## Examples  
 Nell'esempio seguente vengono determinati overload di `MethodA`, specificando i vincoli di associazione e una varietà di tipi di argomento.  
  
> [!NOTE]
>  Il [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] esempio presenta i requisiti di `/unsafe` l'opzione del compilatore.  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">È stato trovato più di un metodo con il nome specificato e corrispondente ai vincoli di associazione specificati.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="types" /> è <see langword="null" />.  
  
 oppure  
  
 Uno degli elementi in <paramref name="types" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> è multidimensionale.  
  
 oppure  
  
 <paramref name="modifiers" /> è multidimensionale.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome del metodo da ottenere.</param>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire <see langword="null" />.</param>
        <param name="binder">Oggetto che definisce una serie di proprietà e permette il binding, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.  
  
 oppure  
  
 Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Oggetto che specifica il set di regole da usare per la disposizione e il layout degli argomenti, la modalità di passaggio del valore restituito, i registri usati per gli argomenti e la pulizia dello stack.</param>
        <param name="types">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano numero, ordine e tipo dei parametri relativi al metodo da ottenere.  
  
 oppure  
  
 Matrice vuota di oggetti <see cref="T:System.Type" /> (come fornita dal campo <see cref="F:System.Type.EmptyTypes" />) per ottenere un metodo che non accetta parametri.</param>
        <param name="modifiers">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresenta gli attributi associati all'elemento corrispondente nella matrice <c>types</c>. Da usare solo quando si effettuano chiamate tramite l'interoperabilità COM e vengono gestiti solo i parametri passati per riferimento. Questo parametro non viene elaborato dal binder predefinito.</param>
        <summary>Cerca il metodo specificato i cui parametri corrispondono ai tipi di argomenti e ai modificatori specificati, usando i vincoli di associazione e la convenzione di chiamata specificati.</summary>
        <returns>Oggetto che rappresenta il metodo corrispondente ai requisiti specificati, se presente; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anche se il binder predefinito elabora <xref:System.Reflection.ParameterModifier> (il `modifiers` parametro), è possibile utilizzare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per la scrittura di un gestore di associazione personalizzato che elaborano `modifiers`. `ParameterModifier` viene utilizzato solo quando una chiamata tramite l'interoperabilità COM, e vengono gestiti solo i parametri che vengono passati per riferimento.  
  
 La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `GetXXX` metodi durante la reflection su un tipo.  
  
|Tipo di membro|Static|Non statico|  
|-----------------|------------|-----------------|  
|Costruttore|No|No|  
|Campo|No|Sì. Un campo è sempre Nascondi in base al nome e-firma.|  
|event|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
|Metodo|No|Sì. Un metodo (virtuale e non virtuale) può essere hide-by-name o Nascondi in base al nome e-firma.|  
|Tipo annidato|No|No|  
|Proprietà|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
  
1.  Nascondi in base al nome e-firma prende in considerazione tutte le parti della firma, compresi i modificatori personalizzati, restituire tipi, tipi di parametri, elementi sentinel e convenzioni di chiamata non gestite. Si tratta di un confronto binario.  
  
2.  Per la reflection, proprietà ed eventi sono Nascondi in base al nome e-firma. Se si dispone di una proprietà con sia un'operazione get e set nella classe base, ma la classe derivata contiene solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter sulla classe di base.  
  
3.  Attributi personalizzati non fanno parte di common type system.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire i metodi da includere nella ricerca:  
  
-   È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un risultato.  
  
-   Specificare `BindingFlags.Public` per includere i metodi pubblici nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere i metodi non pubblici (vale a dire metodi privati, interni e protetti) nella ricerca.  
  
-   Specificare `BindingFlags.FlattenHierarchy` includere `public` e `protected` membri statici nella gerarchia; `private` membri statici nelle classi ereditate non sono inclusi.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare le modalità di ricerca:  
  
-   `BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.  
  
-   `BindingFlags.DeclaredOnly` Per cercare solo i metodi dichiarati nel <xref:System.Type>, non i metodi quelli ereditati.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  È possibile omettere i parametri per la ricerca di costruttori e metodi. È possibile omettere i parametri solo quando viene richiamato.  
  
 Se l'oggetto T:System.Type corrente rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MethodInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questo metodo cerca i metodi del vincolo di classe o i metodi di <xref:System.Object> se è presente alcun vincolo di classe.  
  
> [!NOTE]
>  Per i metodi generici, non includere gli argomenti di tipo in `name`. Ad esempio, il codice c# `GetMember("MyMethod<int>")` esegue la ricerca di un membro con il nome del testo "`MyMethod<int>`", anziché per un metodo denominato `MyMethod` che dispone di un argomento generico di tipo `int`.  
  
   
  
## Examples  
 Nell'esempio seguente vengono determinati overload di `MethodA`, che specifica i vincoli di associazione, convenzioni di chiamata e un'ampia gamma di tipi di argomento.  
  
> [!NOTE]
>  Il [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] esempio presenta i requisiti di `/unsafe` l'opzione del compilatore.  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">È stato trovato più di un metodo con il nome specificato e corrispondente ai vincoli di associazione specificati.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="types" /> è <see langword="null" />.  
  
 oppure  
  
 Uno degli elementi in <paramref name="types" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> è multidimensionale.  
  
 oppure  
  
 <paramref name="modifiers" /> è multidimensionale.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome del metodo da ottenere.</param>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire <see langword="null" />.</param>
        <param name="binder">Oggetto che definisce una serie di proprietà e permette il binding, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.  
  
 oppure  
  
 Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Oggetto che specifica il set di regole da usare per l'ordine e il layout degli argomenti, la modalità di passaggio del valore restituito, i registri usati per gli argomenti e il processo di pulizia dello stack.</param>
        <param name="types">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano numero, ordine e tipo dei parametri relativi al metodo da ottenere.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Type" /> (ovvero, Type[] types = new Type[0]) per ottenere un metodo che non accetta parametri.  
  
 oppure  
  
 <see langword="null" />. Se <c>types</c> è <see langword="null" />, gli argomenti non corrispondono.</param>
        <param name="modifiers">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresenta gli attributi associati all'elemento corrispondente nella matrice <c>types</c>. Questo parametro non viene elaborato dal binder predefinito.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, cerca il metodo specificato i cui parametri corrispondono ai modificatori e ai tipi di argomento definiti, usando i vincoli di associazione e la convenzione di denominazione specificati.</summary>
        <returns>Oggetto che rappresenta il metodo corrispondente ai requisiti specificati, se presente; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anche se il binder predefinito elabora <xref:System.Reflection.ParameterModifier> (il `modifiers` parametro), è possibile utilizzare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per la scrittura di un gestore di associazione personalizzato che elaborano `modifiers`. `ParameterModifier` viene utilizzato solo quando una chiamata tramite l'interoperabilità COM, e vengono gestiti solo i parametri che vengono passati per riferimento.  
  
 Se `types` è `null`, gli argomenti non corrispondono.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire i metodi da includere nella ricerca:  
  
-   È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un risultato.  
  
-   Specificare `BindingFlags.Public` per includere i metodi pubblici nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere nella ricerca i metodi non pubblici (vale a dire metodi privati, interni e protetti).  
  
-   Specificare `BindingFlags.FlattenHierarchy` includere `public` e `protected` membri statici nella gerarchia; `private` membri statici nelle classi ereditate non sono inclusi.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare le modalità di ricerca:  
  
-   `BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.  
  
-   `BindingFlags.DeclaredOnly` Per cercare solo i metodi dichiarati nel <xref:System.Type>, non i metodi quelli ereditati.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">È stato trovato più di un metodo con il nome specificato e corrispondente ai vincoli di associazione specificati.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> è multidimensionale.  
  
 oppure  
  
 <paramref name="modifiers" /> è multidimensionale.  
  
 oppure  
  
 <paramref name="types" /> e <paramref name="modifiers" /> non hanno la stessa lunghezza.</exception>
        <exception cref="T:System.NotSupportedException">Il tipo corrente è un oggetto <see cref="T:System.Reflection.Emit.TypeBuilder" /> o <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene i metodi dell'oggetto <see cref="T:System.Type" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce tutti i metodi pubblici dell'oggetto <see cref="T:System.Type" /> corrente.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.MethodInfo" /> che rappresentano tutti i metodi pubblici definiti per l'oggetto <see cref="T:System.Type" /> corrente.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Reflection.MethodInfo" />, se non sono definiti metodi pubblici per l'oggetto <see cref="T:System.Type" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.GetMethods%2A> metodo non restituisce i metodi in un ordine specifico, ad esempio in ordine alfabetico o ordine di dichiarazione. Il codice non deve dipendere dall'ordine in cui vengono restituiti metodi perché tale ordine varia.  
  
 I costruttori non sono inclusi nella matrice di metodi restituiti da questa chiamata. Effettuare una chiamata separata a `GetConstructors()` per ottenere i metodi del costruttore.  
  
 La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.  
  
|Tipo di membro|Static|Non statico|  
|-----------------|------------|-----------------|  
|Costruttore|No|No|  
|Campo|No|Sì. Un campo è sempre Nascondi in base al nome e-firma.|  
|event|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
|Metodo|No|Sì. Un metodo (virtuale e non virtuale) può essere hide-by-name o Nascondi in base al nome e-firma.|  
|Tipo annidato|No|No|  
|Proprietà|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
  
1.  Nascondi in base al nome e-firma prende in considerazione tutte le parti della firma, compresi i modificatori personalizzati, restituire tipi, tipi di parametri, elementi sentinel e convenzioni di chiamata non gestite. Si tratta di un confronto binario.  
  
2.  Per la reflection, proprietà ed eventi sono Nascondi in base al nome e-firma. Se si dispone di una proprietà con sia un'operazione get e set nella classe base, ma la classe derivata contiene solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter sulla classe di base.  
  
3.  Attributi personalizzati non fanno parte di common type system.  
  
> [!NOTE]
>  È possibile omettere i parametri per la ricerca di costruttori e metodi. È possibile omettere i parametri solo quando viene richiamato.  
  
 Se l'oggetto T:System.Type corrente rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MethodInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questo metodo cerca i metodi del vincolo di classe o i metodi di <xref:System.Object> se è presente alcun vincolo di classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire <see langword="null" />.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, cerca i metodi definiti per l'oggetto <see cref="T:System.Type" /> corrente, usando i vincoli di binding specificati.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.MethodInfo" /> che rappresentano tutti i metodi definiti per l'oggetto <see cref="T:System.Type" /> corrente, corrispondente ai vincoli di binding specificati.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Reflection.MethodInfo" />, se non è definito alcun metodo per l'oggetto <see cref="T:System.Type" /> corrente oppure se nessuno dei metodi definiti corrisponde ai vincoli di binding.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.GetMethods%2A> metodo non restituisce i metodi in un ordine specifico, ad esempio in ordine alfabetico o ordine di dichiarazione. Il codice non deve dipendere dall'ordine in cui vengono restituiti metodi perché tale ordine varia.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire i metodi da includere nella ricerca:  
  
-   È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un risultato.  
  
-   Specificare `BindingFlags.Public` per includere i metodi pubblici nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere nella ricerca i metodi non pubblici (vale a dire metodi privati, interni e protetti). Solo protetti e vengono restituiti metodi interni delle classi base; metodi privati delle classi base non vengono restituiti.  
  
-   Specificare `BindingFlags.FlattenHierarchy` includere `public` e `protected` membri statici nella gerarchia; `private` membri statici nelle classi ereditate non sono inclusi.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare le modalità di ricerca:  
  
-   `BindingFlags.DeclaredOnly` Per cercare solo i metodi dichiarati nel <xref:System.Type>, non i metodi quelli ereditati.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  È possibile omettere i parametri per la ricerca di costruttori e metodi. È possibile omettere i parametri solo quando viene richiamato.  
  
 Se l'oggetto T:System.Type corrente rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MethodInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questo metodo cerca i metodi del vincolo di classe o i metodi di <xref:System.Object> se è presente alcun vincolo di classe.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una classe con due metodi pubblici e un metodo protetto, crea un `Type` oggetto corrispondente a `MyTypeClass`, ottiene tutti i metodi pubblici e non pubblici e ne visualizza i nomi.  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene un tipo specifico annidato all'interno dell'oggetto <see cref="T:System.Type" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome del tipo annidato da ottenere.</param>
        <summary>Cerca il tipo annidato pubblico con il nome specificato.</summary>
        <returns>Oggetto che rappresenta il tipo annidato pubblico con il nome specificato, se disponibile; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La ricerca di `name` tra maiuscole e minuscole.  
  
 Utilizzare il nome semplice della classe annidata per `name`. Non qualificarlo con il nome della classe esterna. Per una classe annidata di tipo generica, utilizzare il nome modificato, vale a dire, aggiungere un accento grave e il numero di argomenti generici. Ad esempio, utilizzare la stringa "interna\`1" per ottenere il tipo generico annidato classe `Inner<T>` (`Inner(Of T)` in Visual Basic). Non includere la sintassi specifica del linguaggio per i parametri di tipo.  
  
 La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.  
  
|Tipo di membro|Static|Non statico|  
|-----------------|------------|-----------------|  
|Costruttore|No|No|  
|Campo|No|Sì. Un campo è sempre Nascondi in base al nome e-firma.|  
|event|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
|Metodo|No|Sì. Un metodo (virtuale e non virtuale) può essere hide-by-name o Nascondi in base al nome e-firma.|  
|Tipo annidato|No|No|  
|Proprietà|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
  
1.  Nascondi in base al nome e-firma prende in considerazione tutte le parti della firma, compresi i modificatori personalizzati, restituire tipi, tipi di parametri, elementi sentinel e convenzioni di chiamata non gestite. Si tratta di un confronto binario.  
  
2.  Per la reflection, proprietà ed eventi sono Nascondi in base al nome e-firma. Se si dispone di una proprietà con sia un'operazione get e set nella classe base, ma la classe derivata contiene solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter sulla classe di base.  
  
3.  Attributi personalizzati non fanno parte di common type system.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cerca i tipi annidati del vincolo di classe.  
  
 Se un tipo annidato è generico, questo metodo restituisce la definizione di tipo generico. Questo vale anche se il tipo generico contenitore è un tipo costruito chiuso.  
  
> [!NOTE]
>  Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico definito in c#, Visual Basic o C++, i relativi tipi annidati sono tutti generici, anche se non dispongono di propri parametri generici. Ciò non avviene necessariamente di tipi annidati definiti in assembly dinamici o compilati con il [Ilasm.exe (Assembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Per informazioni sui tipi generici annidati e sulla costruzione di tipi generici annidati dalle definizioni di tipo generico, vedere <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome del tipo annidato da ottenere.</param>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire <see langword="null" />.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, cerca il tipo annidato specificato, usando i vincoli di binding specificati.</summary>
        <returns>Oggetto che rappresenta il tipo annidato corrispondente ai requisiti specificati, se è stato trovato; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il nome semplice della classe annidata per `name`. Non qualificarlo con il nome della classe esterna. Per una classe annidata di tipo generica, utilizzare il nome modificato, vale a dire, aggiungere un accento grave e il numero di parametri generici. Ad esempio, utilizzare la stringa "interna\`1" per ottenere il tipo generico annidato classe `Inner<T>` (`Inner(Of T)` in Visual Basic). Non includere la sintassi specifica del linguaggio per i parametri di tipo.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> filtro flag possono essere utilizzati per definire annidati di tipi da includere nella ricerca:  
  
-   È necessario specificare <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> o <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> per ottenere un risultato.  
  
-   Specificare <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> per includere i tipi annidati pubblici nella ricerca.  
  
-   Specificare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> per includere nella ricerca i tipi annidati pubblici (vale a dire, privati, interni e protetti tipi annidati).  
  
 Questo metodo restituisce solo i tipi annidati del tipo corrente. Non esegue la ricerca di classi di base del tipo corrente. Per individuare i tipi nidificati nelle classi di base, è necessario seguire la gerarchia di ereditarietà, la chiamata <xref:System.Type.GetNestedType%2A> a ogni livello.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> e <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> vengono ignorati.  
  
 Chiamare questo metodo solo con il <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag o solo il <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag restituirà tipi annidati specificati e non richiede altri flag di qualsiasi.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cerca i tipi annidati del vincolo di classe.  
  
 Se un tipo annidato è generico, questo metodo restituisce la definizione di tipo generico. Questo vale anche se il tipo generico contenitore è un tipo costruito chiuso.  
  
> [!NOTE]
>  Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico definito in c#, Visual Basic o C++, i relativi tipi annidati sono tutti generici, anche se non dispongono di propri parametri generici. Ciò non avviene necessariamente di tipi annidati definiti in assembly dinamici o compilati con il [Ilasm.exe (Assembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Per informazioni sui tipi generici annidati e sulla costruzione di tipi generici annidati dalle definizioni di tipo generico, vedere <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene i tipi annidati all'interno dell'oggetto <see cref="T:System.Type" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce i tipi pubblici annidati all'interno dell'oggetto <see cref="T:System.Type" /> corrente.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Type" /> che rappresenta i tipi pubblici annidati nell'oggetto <see cref="T:System.Type" /> corrente (la ricerca non è ricorsiva), oppure matrice vuota di tipo <see cref="T:System.Type" /> se nessun tipo pubblico è annidato nell'oggetto <see cref="T:System.Type" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.GetNestedTypes%2A> metodo non restituisce i tipi in un ordine specifico, ad esempio in ordine alfabetico o ordine di dichiarazione. Il codice non deve dipendere dall'ordine in cui vengono restituiti tipi perché tale ordine varia.  
  
 Vengono restituiti solo i tipi pubblici annidati immediatamente nel tipo corrente; la ricerca non è ricorsiva.  
  
 La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.  
  
|Tipo di membro|Static|Non statico|  
|-----------------|------------|-----------------|  
|Costruttore|No|No|  
|Campo|No|Sì. Un campo è sempre Nascondi in base al nome e-firma.|  
|event|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
|Metodo|No|Sì. Un metodo (virtuale e non virtuale) può essere hide-by-name o Nascondi in base al nome e-firma.|  
|Tipo annidato|No|No|  
|Proprietà|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
  
1.  Nascondi in base al nome e-firma prende in considerazione tutte le parti della firma, compresi i modificatori personalizzati, restituire tipi, tipi di parametri, elementi sentinel e convenzioni di chiamata non gestite. Si tratta di un confronto binario.  
  
2.  Per la reflection, proprietà ed eventi sono Nascondi in base al nome e-firma. Se si dispone di una proprietà con sia un'operazione get e set nella classe base, ma la classe derivata contiene solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter sulla classe di base.  
  
3.  Attributi personalizzati non fanno parte di common type system.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cerca i tipi annidati del vincolo di classe.  
  
 Se un tipo annidato è generico, questo metodo restituisce la definizione di tipo generico. Questo vale anche se il tipo generico contenitore è un tipo costruito chiuso.  
  
> [!NOTE]
>  Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico definito in c#, Visual Basic o C++, i relativi tipi annidati sono tutti generici, anche se non dispongono di propri parametri generici. Ciò non avviene necessariamente di tipi annidati definiti in assembly dinamici o compilati con il [Ilasm.exe (Assembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Per informazioni sui tipi generici annidati e sulla costruzione di tipi generici annidati dalle definizioni di tipo generico, vedere <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 L'esempio seguente definisce una classe annidata e `struct` in `MyClass`e quindi Ottiene gli oggetti di tipi annidati mediante il tipo di `MyClass`.  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire <see langword="null" />.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, cerca i tipi annidati nell'oggetto <see cref="T:System.Type" /> corrente, usando i vincoli di binding specificati.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Type" /> che rappresenta tutti i tipi annidati nell'oggetto <see cref="T:System.Type" /> corrente che corrispondono ai vincoli di binding specificati (la ricerca non è ricorsiva), oppure matrice vuota di tipo <see cref="T:System.Type" />, se non viene trovato alcun tipo annidato che corrisponde ai vincoli di binding.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La ricerca per i tipi annidati non è ricorsiva.  
  
 Il <xref:System.Type.GetNestedTypes%2A> metodo non restituisce i tipi in un ordine specifico, ad esempio in ordine alfabetico o ordine di dichiarazione. Il codice non deve dipendere dall'ordine in cui vengono restituiti tipi perché tale ordine varia.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> filtro flag possono essere utilizzati per definire annidati di tipi da includere nella ricerca:  
  
-   È necessario specificare <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> o <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> per ottenere un risultato.  
  
-   Specificare <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> per includere i tipi annidati pubblici nella ricerca.  
  
-   Specificare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> per includere nella ricerca i tipi annidati pubblici (vale a dire, privati, interni e protetti tipi annidati).  
  
 Questo metodo restituisce solo i tipi annidati del tipo corrente. Non esegue la ricerca di classi di base del tipo corrente. Per individuare i tipi nidificati nelle classi di base, è necessario seguire la gerarchia di ereditarietà, la chiamata <xref:System.Type.GetNestedTypes%2A> a ogni livello.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> e <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> vengono ignorati.  
  
 Chiamare questo metodo solo con il <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag o solo il <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag restituirà tipi annidati specificati e non richiede altri flag di qualsiasi.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cerca i tipi annidati del vincolo di classe.  
  
 Se un tipo annidato è generico, questo metodo restituisce la definizione di tipo generico. Questo vale anche se il tipo generico contenitore è un tipo costruito chiuso.  
  
> [!NOTE]
>  Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico definito in c#, Visual Basic o C++, i relativi tipi annidati sono tutti generici, anche se non dispongono di propri parametri generici. Ciò non avviene necessariamente di tipi annidati definiti in assembly dinamici o compilati con il [Ilasm.exe (Assembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Per informazioni sui tipi generici annidati e sulla costruzione di tipi generici annidati dalle definizioni di tipo generico, vedere <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente crea due classi pubbliche annidate e due classi nidificate protette e visualizza le informazioni per le classi che corrisponde ai vincoli di associazione specificati.  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene le proprietà dell'oggetto <see cref="T:System.Type" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce tutte le proprietà pubbliche dell'oggetto <see cref="T:System.Type" /> corrente.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.PropertyInfo" /> che rappresentano tutte le proprietà pubbliche dell'oggetto <see cref="T:System.Type" /> corrente.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Reflection.PropertyInfo" />, se l'oggetto <see cref="T:System.Type" /> corrente non possiede delle proprietà pubbliche.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo overload equivale alla chiamata di <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> eseguire l'overload con un `bindingAttr` uguale all'argomento `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in c# e `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic. Restituisce tutte le istanza pubblica e le proprietà statiche, sia quelli definiti dal tipo rappresentato dall'oggetto corrente <xref:System.Type> oggetto nonché quelle ereditate dai relativi tipi di base.  
  
 Una proprietà è considerata pubblica per la reflection se dispone di almeno una funzione di accesso pubblico. In caso contrario, la proprietà viene considerata privata ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerlo.  
  
 Il <xref:System.Type.GetProperties%2A> metodo non restituisce le proprietà in un ordine specifico, ad esempio in ordine alfabetico o ordine di dichiarazione. Il codice non deve dipendere dall'ordine in cui vengono restituite le proprietà, perché tale ordine varia.  
  
 La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.  
  
|Tipo di membro|Static|Non statico|  
|-----------------|------------|-----------------|  
|Costruttore|No|No|  
|Campo|No|Sì. Un campo è sempre Nascondi in base al nome e-firma.|  
|event|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
|Metodo|No|Sì. Un metodo (virtuale e non virtuale) può essere hide-by-name o Nascondi in base al nome e-firma.|  
|Tipo annidato|No|No|  
|Proprietà|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
  
1.  Nascondi in base al nome e-firma prende in considerazione tutte le parti della firma, compresi i modificatori personalizzati, restituire tipi, tipi di parametri, elementi sentinel e convenzioni di chiamata non gestite. Si tratta di un confronto binario.  
  
2.  Per la reflection, proprietà ed eventi sono Nascondi in base al nome e-firma. Se si dispone di una proprietà con sia un'operazione get e set nella classe base, ma la classe derivata contiene solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter sulla classe di base.  
  
3.  Attributi personalizzati non fanno parte di common type system.  
  
 Se l'oggetto T:System.Type corrente rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.PropertyInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cerca le proprietà del vincolo di classe.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'uso del metodo `GetProperties`.  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire <see langword="null" />.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, cerca le proprietà dell'oggetto <see cref="T:System.Type" /> corrente, usando i vincoli di binding specificati.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Reflection.PropertyInfo" /> che rappresenta tutte le proprietà dell'oggetto <see cref="T:System.Type" /> corrente corrispondenti ai vincoli di binding specificati.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Reflection.PropertyInfo" />, se l'oggetto <see cref="T:System.Type" /> corrente non dispone di proprietà oppure se nessuna delle proprietà corrisponde ai vincoli di binding.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una proprietà è considerata pubblica per la reflection se dispone di almeno una funzione di accesso pubblico. In caso contrario, la proprietà viene considerata privata ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerlo.  
  
 Il <xref:System.Type.GetProperties%2A> metodo non restituisce le proprietà in un ordine specifico, ad esempio in ordine alfabetico o ordine di dichiarazione. Il codice non deve dipendere dall'ordine in cui vengono restituite le proprietà, perché tale ordine varia.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> filtro flag possono essere utilizzati per definire annidati di tipi da includere nella ricerca:  
  
-   È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un risultato.  
  
-   Specificare `BindingFlags.Public` per includere le proprietà pubbliche nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere proprietà pubblici (proprietà, private, interne e protette) nella ricerca. Solo protetti e vengono restituite le proprietà interne delle classi di base; le proprietà private delle classi base non vengono restituite.  
  
-   Specificare `BindingFlags.FlattenHierarchy` includere `public` e `protected` membri statici nella gerarchia; `private` membri statici nelle classi ereditate non sono inclusi.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare le modalità di ricerca:  
  
-   `BindingFlags.DeclaredOnly` eseguire la ricerca solo le proprietà dichiarate sul <xref:System.Type>, non proprietà quelli ereditati.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Una proprietà è considerata pubblica per la reflection se dispone di almeno una funzione di accesso pubblico. In caso contrario, la proprietà viene considerata privata ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerlo.  
  
 Se l'oggetto T:System.Type corrente rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.PropertyInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cerca le proprietà del vincolo di classe.  
  
   
  
## Examples  
 L'esempio seguente definisce una classe denominata `PropertyClass` che include sei proprietà: due sono pubblici, uno è privato, uno è protetto, uno è interno (`Friend` in Visual Basic), e uno è protected internal (`Protected Friend` in Visual Basic). Vengono quindi visualizzate alcune informazioni di proprietà di base (il nome della proprietà e il tipo, se è in lettura/scrittura e la visibilità del relativo `get` e `set` le funzioni di accesso) per le proprietà che corrispondono ai vincoli di associazione specificati.  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene una proprietà specifica dell'oggetto <see cref="T:System.Type" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome della proprietà pubblica da ottenere.</param>
        <summary>Cerca la proprietà pubblica con il nome specificato.</summary>
        <returns>Oggetto che rappresenta la proprietà pubblica con il nome specificato, se presente; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La ricerca di `name` tra maiuscole e minuscole. La ricerca include proprietà di istanza pubblico statico e pubblico.  
  
 Una proprietà è considerata pubblica per la reflection se dispone di almeno una funzione di accesso pubblico. In caso contrario, la proprietà viene considerata privata ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerlo.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.PropertyInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cerca le proprietà del vincolo di classe.  
  
 Situazioni in cui <xref:System.Reflection.AmbiguousMatchException> si verifica includono quanto segue:  
  
-   Un tipo contiene due proprietà indicizzate con lo stesso nome ma diversi numeri di parametri. Per risolvere l'ambiguità, utilizzare l'overload del metodo di <xref:System.Type.GetProperty%2A> metodo che specifica i tipi di parametro.  
  
-   Un tipo derivato dichiara una proprietà che nasconde una proprietà ereditata con lo stesso nome, utilizzando il `new` modificatore (`Shadows` in Visual Basic). Per risolvere l'ambiguità, utilizzare il <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> l'overload di metodo e aggiungere il <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> flag per restringere la ricerca di membri che non vengono ereditati.  
  
## <a name="indexers-and-default-properties"></a>Gli indicizzatori e le proprietà predefinite  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] hanno la sintassi semplificata per l'accesso alle proprietà indicizzate e consentire una proprietà indicizzata da un valore predefinito per il relativo tipo. Ad esempio, se la variabile `myList` fa riferimento a un <xref:System.Collections.ArrayList>, la sintassi `myList[3]` (`myList(3)` in Visual Basic) recupera l'elemento con indice 3. È possibile eseguire l'overload di proprietà.  
  
 In c#, questa funzionalità viene chiamata un indicizzatore e non è possibile farvi riferimento in base al nome. Per impostazione predefinita, un indicizzatore c# presente nei metadati come una proprietà indicizzata denominata "Item". Tuttavia, uno sviluppatore di libreria di classi è possibile utilizzare il <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attributo per modificare il nome dell'indicizzatore nei metadati. Ad esempio, il <xref:System.String> classe dispone di un indicizzatore denominato <xref:System.String.Chars%2A>. Proprietà indicizzate create utilizzando linguaggi diversi da c# possono avere nomi diversi da elementi, nonché.  
  
 Per determinare se un tipo ha una proprietà predefinita, utilizzare il <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metodo da testare per la <xref:System.Reflection.DefaultMemberAttribute> attributo. Se il tipo ha <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> proprietà restituisce il nome della proprietà predefinita.  
  
   
  
## Examples  
 Nell'esempio seguente viene recuperato il `Type` oggetto di una classe definita dall'utente, viene recuperata una proprietà di tale classe e visualizza il nome della proprietà.  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 Internamente, questa proprietà è definita nei metadati con il nome "Item". Qualsiasi tentativo di ottenere `PropertyInfo` tramite reflection è necessario specificare il nome interno per restituire correttamente la `PropertyInfo` proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">È stata trovata più di una proprietà con il nome specificato.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome della proprietà da ottenere.</param>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire <see langword="null" />.</param>
        <summary>Cerca la proprietà specificata, usando i vincoli di associazione specificati.</summary>
        <returns>Oggetto che rappresenta la proprietà corrispondente ai requisiti specificati, se presente; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una proprietà è considerata pubblica per la reflection se dispone di almeno una funzione di accesso pubblico. In caso contrario, la proprietà viene considerata privata ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerlo.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire le proprietà da includere nella ricerca:  
  
-   È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un risultato.  
  
-   Specificare `BindingFlags.Public` per includere le proprietà pubbliche nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere proprietà pubblici (proprietà, private, interne e protette) nella ricerca.  
  
-   Specificare `BindingFlags.FlattenHierarchy` includere `public` e `protected` membri statici nella gerarchia; `private` membri statici nelle classi ereditate non sono inclusi.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare le modalità di ricerca:  
  
-   `BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.  
  
-   `BindingFlags.DeclaredOnly` eseguire la ricerca solo le proprietà dichiarate sul <xref:System.Type>, non proprietà quelli ereditati.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.PropertyInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cerca le proprietà del vincolo di classe.  
  
 Situazioni in cui <xref:System.Reflection.AmbiguousMatchException> si verifica includono quanto segue:  
  
-   Un tipo contiene due proprietà indicizzate con lo stesso nome ma diversi numeri di parametri. Per risolvere l'ambiguità, utilizzare l'overload del metodo di <xref:System.Type.GetProperty%2A> metodo che specifica i tipi di parametro.  
  
-   Un tipo derivato dichiara una proprietà che nasconde una proprietà ereditata con lo stesso nome, utilizzando il `new` modificatore (`Shadows` in Visual Basic). Per risolvere l'ambiguità, includere <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> per restringere la ricerca di membri che non vengono ereditati.  
  
## <a name="indexers-and-default-properties"></a>Gli indicizzatori e le proprietà predefinite  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] hanno la sintassi semplificata per l'accesso alle proprietà indicizzate e consentire una proprietà indicizzata da un valore predefinito per il relativo tipo. Ad esempio, se la variabile `myList` fa riferimento a un <xref:System.Collections.ArrayList>, la sintassi `myList[3]` (`myList(3)` in Visual Basic) recupera l'elemento con indice 3. È possibile eseguire l'overload di proprietà.  
  
 In c#, questa funzionalità viene chiamata un indicizzatore e non è possibile farvi riferimento in base al nome. Per impostazione predefinita, un indicizzatore c# presente nei metadati come una proprietà indicizzata denominata "Item". Tuttavia, uno sviluppatore di libreria di classi è possibile utilizzare il <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attributo per modificare il nome dell'indicizzatore nei metadati. Ad esempio, il <xref:System.String> classe dispone di un indicizzatore denominato <xref:System.String.Chars%2A>. Proprietà indicizzate create utilizzando linguaggi diversi da c# possono avere nomi diversi da elementi, nonché.  
  
 Per determinare se un tipo ha una proprietà predefinita, utilizzare il <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metodo da testare per la <xref:System.Reflection.DefaultMemberAttribute> attributo. Se il tipo ha <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> proprietà restituisce il nome della proprietà predefinita.  
  
   
  
## Examples  
 Nell'esempio seguente recupera il tipo di una classe definita dall'utente, viene recuperata una proprietà di tale classe e visualizza il nome della proprietà in base ai vincoli di associazione specificati.  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">È stata trovata più di una proprietà con il nome specificato e corrispondente ai vincoli di associazione specificati.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome della proprietà pubblica da ottenere.</param>
        <param name="returnType">Tipo restituito della proprietà.</param>
        <summary>Cerca la proprietà pubblica con il nome e il tipo restituito specificati.</summary>
        <returns>Oggetto che rappresenta la proprietà pubblica con il nome specificato, se presente; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una proprietà è considerata pubblica per la reflection se dispone di almeno una funzione di accesso pubblico. In caso contrario, la proprietà viene considerata privata ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerlo.  
  
 La ricerca di `name` tra maiuscole e minuscole. La ricerca include proprietà di istanza pubblico statico e pubblico.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.PropertyInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cerca le proprietà del vincolo di classe.  
  
## <a name="indexers-and-default-properties"></a>Gli indicizzatori e le proprietà predefinite  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] hanno la sintassi semplificata per l'accesso alle proprietà indicizzate e consentire una proprietà indicizzata da un valore predefinito per il relativo tipo. Ad esempio, se la variabile `myList` fa riferimento a un <xref:System.Collections.ArrayList>, la sintassi `myList[3]` (`myList(3)` in Visual Basic) recupera l'elemento con indice 3. È possibile eseguire l'overload di proprietà.  
  
 In c#, questa funzionalità viene chiamata un indicizzatore e non è possibile farvi riferimento in base al nome. Per impostazione predefinita, un indicizzatore c# presente nei metadati come una proprietà indicizzata denominata "Item". Tuttavia, uno sviluppatore di libreria di classi è possibile utilizzare il <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attributo per modificare il nome dell'indicizzatore nei metadati. Ad esempio, il <xref:System.String> classe dispone di un indicizzatore denominato <xref:System.String.Chars%2A>. Proprietà indicizzate create utilizzando linguaggi diversi da c# possono avere nomi diversi da elementi, nonché.  
  
 Per determinare se un tipo ha una proprietà predefinita, utilizzare il <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metodo da testare per la <xref:System.Reflection.DefaultMemberAttribute> attributo. Se il tipo ha <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> proprietà restituisce il nome della proprietà predefinita.  
  
   
  
## Examples  
 Nell'esempio seguente viene definita una classe con una proprietà e recupera il nome e il tipo della proprietà.  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">È stata trovata più di una proprietà con il nome specificato.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" /> o <paramref name="returnType" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome della proprietà pubblica da ottenere.</param>
        <param name="types">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano numero, ordine e tipo dei parametri relativi alla proprietà indicizzata da ottenere.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Type" /> (ovvero, Type[] types = new Type[0]) per ottenere una proprietà non indicizzata.</param>
        <summary>Cerca la proprietà pubblica specificata i cui parametri corrispondono ai tipi di argomenti specificati.</summary>
        <returns>Oggetto che rappresenta la proprietà pubblica i cui parametri corrispondono ai tipi di argomenti specificati, se presente; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una proprietà è considerata pubblica per la reflection se dispone di almeno una funzione di accesso pubblico. In caso contrario, la proprietà viene considerata privata ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerlo.  
  
 La ricerca di `name` tra maiuscole e minuscole. La ricerca include proprietà di istanza pubblico statico e pubblico.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.PropertyInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cerca le proprietà del vincolo di classe.  
  
## <a name="indexers-and-default-properties"></a>Gli indicizzatori e le proprietà predefinite  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] hanno la sintassi semplificata per l'accesso alle proprietà indicizzate e consentire una proprietà indicizzata da un valore predefinito per il relativo tipo. Ad esempio, se la variabile `myList` fa riferimento a un <xref:System.Collections.ArrayList>, la sintassi `myList[3]` (`myList(3)` in Visual Basic) recupera l'elemento con indice 3. È possibile eseguire l'overload di proprietà.  
  
 In c#, questa funzionalità viene chiamata un indicizzatore e non è possibile farvi riferimento in base al nome. Per impostazione predefinita, un indicizzatore c# presente nei metadati come una proprietà indicizzata denominata "Item". Tuttavia, uno sviluppatore di libreria di classi è possibile utilizzare il <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attributo per modificare il nome dell'indicizzatore nei metadati. Ad esempio, il <xref:System.String> classe dispone di un indicizzatore denominato <xref:System.String.Chars%2A>. Proprietà indicizzate create utilizzando linguaggi diversi da c# possono avere nomi diversi da elementi, nonché.  
  
 Per determinare se un tipo ha una proprietà predefinita, utilizzare il <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metodo da testare per la <xref:System.Reflection.DefaultMemberAttribute> attributo. Se il tipo ha <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> proprietà restituisce il nome della proprietà predefinita.  
  
   
  
## Examples  
 Nell'esempio seguente viene recuperato il `Type` oggetto di una classe definita dall'utente, viene recuperata la proprietà di tale classe e visualizza il nome della proprietà e il tipo della proprietà come specificato dagli argomenti passati a `GetProperty`.  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">È stata trovata più di una proprietà con il nome specificato e corrispondente ai tipi di argomento specificati.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="types" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> è multidimensionale.</exception>
        <exception cref="T:System.NullReferenceException">Un elemento di <paramref name="types" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome della proprietà pubblica da ottenere.</param>
        <param name="returnType">Tipo restituito della proprietà.</param>
        <param name="types">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano numero, ordine e tipo dei parametri relativi alla proprietà indicizzata da ottenere.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Type" /> (ovvero, Type[] types = new Type[0]) per ottenere una proprietà non indicizzata.</param>
        <summary>Cerca la proprietà pubblica specificata i cui parametri corrispondono ai tipi di argomenti specificati.</summary>
        <returns>Oggetto che rappresenta la proprietà pubblica i cui parametri corrispondono ai tipi di argomenti specificati, se presente; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una proprietà è considerata pubblica per la reflection se dispone di almeno una funzione di accesso pubblico. In caso contrario, la proprietà viene considerata privata ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerlo.  
  
 La ricerca di `name` tra maiuscole e minuscole. La ricerca include proprietà di istanza pubblico statico e pubblico.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.PropertyInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cerca le proprietà del vincolo di classe.  
  
## <a name="indexers-and-default-properties"></a>Gli indicizzatori e le proprietà predefinite  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] hanno la sintassi semplificata per l'accesso alle proprietà indicizzate e consentire una proprietà indicizzata da un valore predefinito per il relativo tipo. Ad esempio, se la variabile `myList` fa riferimento a un <xref:System.Collections.ArrayList>, la sintassi `myList[3]` (`myList(3)` in Visual Basic) recupera l'elemento con indice 3. È possibile eseguire l'overload di proprietà.  
  
 In c#, questa funzionalità viene chiamata un indicizzatore e non è possibile farvi riferimento in base al nome. Per impostazione predefinita, un indicizzatore c# presente nei metadati come una proprietà indicizzata denominata "Item". Tuttavia, uno sviluppatore di libreria di classi è possibile utilizzare il <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attributo per modificare il nome dell'indicizzatore nei metadati. Ad esempio, il <xref:System.String> classe dispone di un indicizzatore denominato <xref:System.String.Chars%2A>. Proprietà indicizzate create utilizzando linguaggi diversi da c# possono avere nomi diversi da elementi, nonché.  
  
 Per determinare se un tipo ha una proprietà predefinita, utilizzare il <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metodo da testare per la <xref:System.Reflection.DefaultMemberAttribute> attributo. Se il tipo ha <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> proprietà restituisce il nome della proprietà predefinita.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">È stata trovata più di una proprietà con il nome specificato e corrispondente ai tipi di argomento specificati.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="types" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> è multidimensionale.</exception>
        <exception cref="T:System.NullReferenceException">Un elemento di <paramref name="types" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome della proprietà pubblica da ottenere.</param>
        <param name="returnType">Tipo restituito della proprietà.</param>
        <param name="types">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano numero, ordine e tipo dei parametri relativi alla proprietà indicizzata da ottenere.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Type" /> (ovvero, Type[] types = new Type[0]) per ottenere una proprietà non indicizzata.</param>
        <param name="modifiers">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresenta gli attributi associati all'elemento corrispondente nella matrice <c>types</c>. Questo parametro non viene elaborato dal binder predefinito.</param>
        <summary>Cerca la proprietà pubblica specificata i cui parametri corrispondono ai tipi di argomenti e ai modificatori specificati.</summary>
        <returns>Oggetto che rappresenta la proprietà pubblica corrispondente ai requisiti specificati, se è stato trovato; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una proprietà è considerata pubblica per la reflection se dispone di almeno una funzione di accesso pubblico. In caso contrario, la proprietà viene considerata privata ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerlo.  
  
 Anche se il binder predefinito elabora <xref:System.Reflection.ParameterModifier> (il `modifiers` parametro), è possibile utilizzare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per la scrittura di un gestore di associazione personalizzato che elaborano `modifiers`. `ParameterModifier` viene utilizzato solo quando una chiamata tramite l'interoperabilità COM, e vengono gestiti solo i parametri che vengono passati per riferimento.  
  
 La ricerca di `name` tra maiuscole e minuscole. La ricerca include proprietà di istanza pubblico statico e pubblico.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.PropertyInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cerca le proprietà del vincolo di classe.  
  
## <a name="indexers-and-default-properties"></a>Gli indicizzatori e le proprietà predefinite  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] hanno la sintassi semplificata per l'accesso alle proprietà indicizzate e consentire una proprietà indicizzata da un valore predefinito per il relativo tipo. Ad esempio, se la variabile `myList` fa riferimento a un <xref:System.Collections.ArrayList>, la sintassi `myList[3]` (`myList(3)` in Visual Basic) recupera l'elemento con indice 3. È possibile eseguire l'overload di proprietà.  
  
 In c#, questa funzionalità viene chiamata un indicizzatore e non è possibile farvi riferimento in base al nome. Per impostazione predefinita, un indicizzatore c# presente nei metadati come una proprietà indicizzata denominata "Item". Tuttavia, uno sviluppatore di libreria di classi è possibile utilizzare il <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attributo per modificare il nome dell'indicizzatore nei metadati. Ad esempio, il <xref:System.String> classe dispone di un indicizzatore denominato <xref:System.String.Chars%2A>. Proprietà indicizzate create utilizzando linguaggi diversi da c# possono avere nomi diversi da elementi, nonché.  
  
 Per determinare se un tipo ha una proprietà predefinita, utilizzare il <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metodo da testare per la <xref:System.Reflection.DefaultMemberAttribute> attributo. Se il tipo ha <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> proprietà restituisce il nome della proprietà predefinita.  
  
   
  
## Examples  
 Nell'esempio seguente viene ottenuto un `Type` oggetto corrispondente a `MyPropertyClass`, e la proprietà indicizzata di questa classe viene recuperata utilizzando gli argomenti passati al `GetProperty` metodo.  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">È stata trovata più di una proprietà con il nome specificato e corrispondente ai tipi di argomento e modificatori specificati.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="types" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> è multidimensionale.  
  
 oppure  
  
 <paramref name="modifiers" /> è multidimensionale.  
  
 oppure  
  
 <paramref name="types" /> e <paramref name="modifiers" /> non hanno la stessa lunghezza.</exception>
        <exception cref="T:System.NullReferenceException">Un elemento di <paramref name="types" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome della proprietà da ottenere.</param>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire <see langword="null" />.</param>
        <param name="binder">Oggetto che definisce una serie di proprietà e permette il binding, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.  
  
 oppure  
  
 Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="returnType">Tipo restituito della proprietà.</param>
        <param name="types">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano numero, ordine e tipo dei parametri relativi alla proprietà indicizzata da ottenere.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Type" /> (ovvero, Type[] types = new Type[0]) per ottenere una proprietà non indicizzata.</param>
        <param name="modifiers">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresenta gli attributi associati all'elemento corrispondente nella matrice <c>types</c>. Questo parametro non viene elaborato dal binder predefinito.</param>
        <summary>Cerca la proprietà specificata i cui parametri corrispondono ai tipi di argomenti e ai modificatori specificati, usando i vincoli di associazione specificati.</summary>
        <returns>Oggetto che rappresenta la proprietà corrispondente ai requisiti specificati, se presente; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una proprietà è considerata pubblica per la reflection se dispone di almeno una funzione di accesso pubblico. In caso contrario, la proprietà viene considerata privata ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerlo.  
  
 Anche se il binder predefinito elabora <xref:System.Reflection.ParameterModifier> (il `modifiers` parametro), è possibile utilizzare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per la scrittura di un gestore di associazione personalizzato che elaborano `modifiers`. `ParameterModifier` viene utilizzato solo quando una chiamata tramite l'interoperabilità COM, e vengono gestiti solo i parametri che vengono passati per riferimento.  
  
 La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.  
  
|Tipo di membro|Static|Non statico|  
|-----------------|------------|-----------------|  
|Costruttore|No|No|  
|Campo|No|Sì. Un campo è sempre Nascondi in base al nome e-firma.|  
|event|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
|Metodo|No|Sì. Un metodo (virtuale e non virtuale) può essere hide-by-name o Nascondi in base al nome e-firma.|  
|Tipo annidato|No|No|  
|Proprietà|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
  
1.  Nascondi in base al nome e-firma prende in considerazione tutte le parti della firma, compresi i modificatori personalizzati, restituire tipi, tipi di parametri, elementi sentinel e convenzioni di chiamata non gestite. Si tratta di un confronto binario.  
  
2.  Per la reflection, proprietà ed eventi sono Nascondi in base al nome e-firma. Se si dispone di una proprietà con sia un'operazione get e set nella classe base, ma la classe derivata contiene solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter sulla classe di base.  
  
3.  Attributi personalizzati non fanno parte di common type system.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire le proprietà da includere nella ricerca:  
  
-   È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un risultato.  
  
-   Specificare `BindingFlags.Public` per includere le proprietà pubbliche nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere proprietà pubblici (proprietà, private, interne e protette) nella ricerca.  
  
-   Specificare `BindingFlags.FlattenHierarchy` includere `public` e `protected` membri statici nella gerarchia; `private` membri statici nelle classi ereditate non sono inclusi.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare le modalità di ricerca:  
  
-   `BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.  
  
-   `BindingFlags.DeclaredOnly` eseguire la ricerca solo le proprietà dichiarate sul <xref:System.Type>, non proprietà quelli ereditati.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.PropertyInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cerca le proprietà del vincolo di classe.  
  
## <a name="indexers-and-default-properties"></a>Gli indicizzatori e le proprietà predefinite  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] hanno la sintassi semplificata per l'accesso alle proprietà indicizzate e consentire una proprietà indicizzata da un valore predefinito per il relativo tipo. Ad esempio, se la variabile `myList` fa riferimento a un <xref:System.Collections.ArrayList>, la sintassi `myList[3]` (`myList(3)` in Visual Basic) recupera l'elemento con indice 3. È possibile eseguire l'overload di proprietà.  
  
 In c#, questa funzionalità viene chiamata un indicizzatore e non è possibile farvi riferimento in base al nome. Per impostazione predefinita, un indicizzatore c# presente nei metadati come una proprietà indicizzata denominata "Item". Tuttavia, uno sviluppatore di libreria di classi è possibile utilizzare il <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attributo per modificare il nome dell'indicizzatore nei metadati. Ad esempio, il <xref:System.String> classe dispone di un indicizzatore denominato <xref:System.String.Chars%2A>. Proprietà indicizzate create utilizzando linguaggi diversi da c# possono avere nomi diversi da elementi, nonché.  
  
 Per determinare se un tipo ha una proprietà predefinita, utilizzare il <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metodo da testare per la <xref:System.Reflection.DefaultMemberAttribute> attributo. Se il tipo ha <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> proprietà restituisce il nome della proprietà predefinita.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">È stata trovata più di una proprietà con il nome specificato e corrispondente ai vincoli di associazione specificati.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="types" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> è multidimensionale.  
  
 oppure  
  
 <paramref name="modifiers" /> è multidimensionale.  
  
 oppure  
  
 <paramref name="types" /> e <paramref name="modifiers" /> non hanno la stessa lunghezza.</exception>
        <exception cref="T:System.NullReferenceException">Un elemento di <paramref name="types" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome della proprietà da ottenere.</param>
        <param name="bindingAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.  
  
 oppure  
  
 Zero, per restituire <see langword="null" />.</param>
        <param name="binder">Oggetto che definisce un set di proprietà e consente l'associazione, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.  
  
 oppure  
  
 Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="returnType">Tipo restituito della proprietà.</param>
        <param name="types">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano numero, ordine e tipo dei parametri relativi alla proprietà indicizzata da ottenere.  
  
 oppure  
  
 Matrice vuota di tipo <see cref="T:System.Type" /> (ovvero, Type[] types = new Type[0]) per ottenere una proprietà non indicizzata.</param>
        <param name="modifiers">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresenta gli attributi associati all'elemento corrispondente nella matrice <c>types</c>. Questo parametro non viene elaborato dal binder predefinito.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, cerca la proprietà specificata i cui parametri corrispondono ai modificatori e ai tipi di argomenti definiti, usando i vincoli di associazione specificati.</summary>
        <returns>Oggetto che rappresenta la proprietà corrispondente ai requisiti specificati, se presente; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anche se il binder predefinito elabora <xref:System.Reflection.ParameterModifier> (il `modifiers` parametro), è possibile utilizzare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per la scrittura di un gestore di associazione personalizzato che elaborano `modifiers`. `ParameterModifier` viene utilizzato solo quando una chiamata tramite l'interoperabilità COM, e vengono gestiti solo i parametri che vengono passati per riferimento.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire le proprietà da includere nella ricerca:  
  
-   È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un risultato.  
  
-   Specificare `BindingFlags.Public` per includere le proprietà pubbliche nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere proprietà pubblici (proprietà, private, interne e protette) nella ricerca.  
  
-   Specificare `BindingFlags.FlattenHierarchy` includere `public` e `protected` membri statici nella gerarchia; `private` membri statici nelle classi ereditate non sono inclusi.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare le modalità di ricerca:  
  
-   `BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.  
  
-   `BindingFlags.DeclaredOnly` eseguire la ricerca solo le proprietà dichiarate sul <xref:System.Type>, non proprietà quelli ereditati.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">È stata trovata più di una proprietà con il nome specificato e corrispondente ai vincoli di associazione specificati.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.  
  
 oppure  
  
 <paramref name="types" /> è <see langword="null" />.  
  
 oppure  
  
 Uno degli elementi in <paramref name="types" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> è multidimensionale.  
  
 oppure  
  
 <paramref name="modifiers" /> è multidimensionale.  
  
 oppure  
  
 <paramref name="types" /> e <paramref name="modifiers" /> non hanno la stessa lunghezza.</exception>
        <exception cref="T:System.NotSupportedException">Il tipo corrente è un oggetto <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" /> o <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Type" /> che rappresenta il tipo specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Type" /> corrente.</summary>
        <returns>Oggetto <see cref="T:System.Type" /> corrente.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Viene richiamato un inizializzatore di classi e viene generata un'eccezione.</exception>
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">Nome qualificato dall'assembly del tipo da ottenere. Vedere <see cref="P:System.Type.AssemblyQualifiedName" />. Se il tipo è incluso nell'assembly attualmente in esecuzione o in Mscorlib.dll, è sufficiente specificare il nome del tipo qualificato in base al relativo spazio dei nomi.</param>
        <summary>Ottiene l'oggetto <see cref="T:System.Type" /> con il nome specificato, eseguendo una ricerca con distinzione tra maiuscole e minuscole.</summary>
        <returns>Tipo con il nome specificato, se presente; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare il <xref:System.Type.GetType%2A> per ottenere un <xref:System.Type> dell'oggetto per un tipo in un altro assembly, se si conosce il nome completo dello spazio dei nomi. <xref:System.Type.GetType%2A> causa il caricamento dell'assembly specificato in `typeName`. È inoltre possibile caricare un assembly mediante il <xref:System.Reflection.Assembly.Load%2A> (metodo) e quindi utilizzare il <xref:System.Type.GetType%2A> o <xref:System.Reflection.Assembly.GetTypes%2A> metodi del <xref:System.Reflection.Assembly> classe per ottenere <xref:System.Type> oggetti. Se un tipo in un assembly noto al programma in fase di compilazione, è preferibile utilizzare in c#, <xref:System.Type.GetType%2A> in Visual Basic o c++.  
  
> [!NOTE]
>  Se `typeName` non viene trovato, la chiamata al <xref:System.Type.GetType%28System.String%29> restituisce `null`. Non generare un'eccezione. Per controllare se viene generata un'eccezione, chiamare l'overload del metodo di <xref:System.Type.GetType%2A> metodo che presenta un `throwOnError` parametro.  
  
 <xref:System.Type.GetType%2A> funziona solo su assembly caricati dal disco. Se si chiama <xref:System.Type.GetType%2A> per cercare un tipo definito in un assembly dinamico mediante il <xref:System.Reflection.Emit> services, è possibile ottenere un comportamento incoerente. Il comportamento varia a seconda che l'assembly dinamico persistente, vale a dire, creata utilizzando il `RunAndSave` o `Save` modalità di accesso di <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumerazione. Se l'assembly dinamico è permanente ed è stato scritto su disco prima `GetType` viene chiamato, il caricatore trova l'assembly salvato su disco, carica l'assembly e recupera il tipo di tale assembly. Se l'assembly non è stato salvato su disco quando `GetType` viene chiamato il metodo restituisce `null`. `GetType` non riconosce gli assembly dinamici temporanei; Pertanto, la chiamata `GetType` per recuperare un tipo di un temporaneo restituisce l'assembly dinamico `null`.  
  
 Per utilizzare `GetType` su un modulo dinamico, sottoscrivere il <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> eventi e chiamate `GetType` prima del salvataggio. In caso contrario, si otterrà due copie dell'assembly in memoria.  
  
 La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.  
  
|Tipo di membro|Static|Non statico|  
|-----------------|------------|-----------------|  
|Costruttore|No|No|  
|Campo|No|Sì. Un campo è sempre Nascondi in base al nome e-firma.|  
|event|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
|Metodo|No|Sì. Un metodo (virtuale e non virtuale) può essere hide-by-name o Nascondi in base al nome e-firma.|  
|Tipo annidato|No|No|  
|Proprietà|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
  
1.  Nascondi in base al nome e-firma prende in considerazione tutte le parti della firma, compresi i modificatori personalizzati, restituire tipi, tipi di parametri, elementi sentinel e convenzioni di chiamata non gestite. Si tratta di un confronto binario.  
  
2.  Per la reflection, proprietà ed eventi sono Nascondi in base al nome e-firma. Se si dispone di una proprietà con sia un'operazione get e set nella classe base, ma la classe derivata contiene solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter sulla classe di base.  
  
3.  Attributi personalizzati non fanno parte di common type system.  
  
 Le matrici o tipi COM non vengono cercati a meno che non sono già stati caricati nella tabella delle classi disponibili.  
  
 `typeName` può essere il nome del tipo qualificato dal relativo spazio dei nomi o un nome completo dell'assembly che include una specifica di nome di assembly. Vedere <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Se `typeName` include lo spazio dei nomi ma non il nome dell'assembly, questo metodo cerca solo assembly dell'oggetto chiamante e mscorlib. dll, nell'ordine. Se typeName è un nome completo con il nome parziale o completo dell'assembly, questo metodo cerca nell'assembly specificato. Se l'assembly dispone di un nome sicuro, è necessario un nome di assembly completo.  
  
 Il <xref:System.Type.AssemblyQualifiedName%2A> proprietà restituisce un nome completo del tipo, inclusi i tipi annidati, il nome dell'assembly e argomenti di tipo generico. Tutti i compilatori che supportano common language runtime creeranno il nome semplice di una classe annidata, e reflection quando richiesta, in conformità con le seguenti convenzioni di un nome alterato.  
  
> [!NOTE]
>  In .NET Framework versione 2.0, l'architettura del processore viene aggiunto all'identità dell'assembly e può essere specificato come parte di stringhe di nomi di assembly. Ad esempio, "ProcessorArchitecture = msil". Tuttavia, non è incluso nella stringa restituita dal <xref:System.Type.AssemblyQualifiedName%2A> proprietà, per motivi di compatibilità. È inoltre possibile caricare tipi creando un <xref:System.Reflection.AssemblyName> oggetto e passarlo a un overload appropriato del <xref:System.Reflection.Assembly.Load%2A> metodo. È quindi possibile utilizzare il <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> per caricare i tipi dall'assembly. Vedere anche <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|delimitatore|Significato|  
|---------------|-------------|  
|Barra rovesciata (\\)|Carattere di escape.|  
|Apice inverso (')|Precede una o più cifre che rappresenta il numero di parametri di tipo, alla fine del nome di un tipo generico.|  
|parentesi quadre ([])|Racchiudere un elenco di argomenti di tipo generico, per un tipo generico costruito. all'interno di un elenco di argomenti, racchiudere un tipo qualificato dall'assembly.|  
|Comma (,)|Precede il nome dell'Assembly.|  
|Punto (.)|Indica gli identificatori dello spazio dei nomi.|  
|Segno più (+)|Precede una classe annidata.|  
  
 Il nome completo per una classe, ad esempio, potrebbe essere simile al seguente:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Se lo spazio dei nomi sono stati TopNamespace.Sub+Namespace, quindi la stringa sarebbe necessario anteporre il segno più (+) con un carattere di escape (\\) per evitare che venga interpretato come un separatore di annidamento. Reflection genera questa stringa, come indicato di seguito:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A "+" diventa "\\+\\+" e un "\\"diventa"\\\\".  
  
 Questo nome completo può essere persistente e successivamente utilizzato per caricare il <xref:System.Type>. Per cercare e caricare un <xref:System.Type>, utilizzare <xref:System.Type.GetType%2A> o con il tipo di nome solo oppure con il nome di tipo completo dell'assembly. <xref:System.Type.GetType%2A> con il tipo di nome solo cercherà il <xref:System.Type> nell'assembly del chiamante, quindi nell'assembly System. <xref:System.Type.GetType%2A> con l'assembly completo del tipo cercherà il <xref:System.Type> in qualsiasi assembly.  
  
 I nomi dei tipi possono includere caratteri finali che indicano informazioni aggiuntive sul tipo, ad esempio se il tipo è un tipo riferimento, un tipo di puntatore o un tipo di matrice. Per recuperare il nome del tipo senza caratteri finali, utilizzare `t.GetElementType().ToString()`, dove `t` è il tipo.  
  
 Gli spazi sono rilevanti in tutti i componenti di nome di tipo tranne il nome dell'assembly. Il nome di assembly, spazi che precedono il separatore ',' sono rilevanti, ma gli spazi dopo il separatore ',' vengono ignorati.  
  
 Il nome di un tipo generico termina con un apice inverso (\`) seguito da cifre che rappresenta il numero di argomenti di tipo generico. Lo scopo di questo tipo di modifica dei nomi è consentire ai compilatori di supportare i tipi generici con lo stesso nome ma con un numero diverso di parametri di tipo, che si verificano nello stesso ambito. Ad esempio, la reflection restituisce i nomi alterati `Tuple`1` and `tupla`2` uno dei metodi generici `Tuple(Of T)` e `Tuple(Of T0, T1)` in Visual Basic o `Tuple<T>` tupla e`\<T0, T1>` in Visual c#.  
  
 Per i tipi generici, l'elenco di argomenti di tipo è racchiuso tra parentesi e gli argomenti di tipo sono separati da virgole. Ad esempio, un oggetto generico <xref:System.Collections.Generic.Dictionary%602> presenta due parametri di tipo. Oggetto <xref:System.Collections.Generic.Dictionary%602> di `MyType` con chiavi di tipo <xref:System.String> potrebbe essere rappresentato nel modo seguente:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Per specificare un tipo qualificato dall'assembly all'interno di un elenco di argomenti, racchiudere il tipo completo dell'assembly all'interno di parentesi quadre. In caso contrario, le virgole per separare le parti del nome completo dell'assembly vengono interpretate come delimitatori ulteriori argomenti di tipo. Ad esempio, un <xref:System.Collections.Generic.Dictionary%602> di `MyType` fromMyAssembly.dll, con chiavi di tipo <xref:System.String>, può essere specificato come indicato di seguito:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Un tipo qualificato dall'assembly può essere racchiuso tra parentesi quadre solo quando viene visualizzato all'interno di un elenco di parametri di tipo. Le regole per la ricerca di assembly per i tipi completi e non qualificati in elenchi di parametri di tipo sono come le regole per i tipi non generici non qualificati e completi.  
  
 Tipi nullable sono un tipo speciale di tipi generici. Ad esempio, un valore nullable <xref:System.Int32> è rappresentato dalla stringa "System.Nullable'1[System.Int32]".  
  
> [!NOTE]
>  In c#, C++ e Visual Basic è inoltre possibile ottenere i tipi nullable che utilizzano operatori di tipo. Ad esempio, il valore nullable <xref:System.Boolean> tipo restituito dal `typeof(Nullable<bool>)` in c#, da `Nullable<Boolean>::typeid` in C++ e da `GetType(Nullable(Of Boolean))` in Visual Basic.  
  
 La tabella seguente illustra la sintassi da utilizzare con `GetType` per vari tipi.  
  
|Per ottenere|Usa|  
|------------|---------|  
|Un valore nullable <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|Un puntatore non gestito a `MyType`|`Type.GetType("MyType*")`|  
|Un puntatore non gestito a un puntatore a `MyType`|`Type.GetType("MyType**")`|  
|Un puntatore gestito o un riferimento a `MyType`|`Type.GetType("MyType&")`. Si noti che, a differenza dei puntatori, i riferimenti sono limitati a un solo livello.|  
|Una classe padre e una classe annidata|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Una matrice unidimensionale con limite inferiore pari a 0|`Type.GetType("MyType[]")`|  
|Una matrice unidimensionale con limite inferiore sconosciuto|`Type.GetType("MyType[*]")`|  
|Una matrice di n-dimensionale|Una virgola (,) all'interno delle parentesi un totale di volte in cui n-1. Ad esempio, `System.Object[,,]` rappresenta un oggetto tridimensionale `Object` matrice.|  
|Matrice di matrici unidimensionali|`Type.GetType("MyType[][]")`|  
|Una matrice bidimensionale rettangolare con limiti inferiori sconosciuti|`Type.GetType("MyType[,]")`|  
|Un tipo generico con un argomento di tipo|`Type.GetType("MyGenericType`1[MyType]")`|  
|Un tipo generico con due argomenti di tipo|`Type.GetType("MyGenericType`2[MyType,AnotherType]")'|  
|Un tipo generico con due argomenti di tipo qualificato dall'assembly|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")'|  
|Un tipo generico con un argomento di tipo qualificato dall'assembly completo dell'assembly|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")'|  
|Un tipo generico il cui argomento di tipo è un tipo generico con due argomenti di tipo|`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 Nell'esempio seguente recupera il tipo di `System.Int32` e utilizza tale oggetto di tipo per visualizzare il <xref:System.Type.FullName%2A> proprietà `System.Int32`.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Viene richiamato un inizializzatore di classi e viene generata un'eccezione.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> rappresenta un tipo generico che ha un tipo di puntatore, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> tra i relativi argomenti di tipo.  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta un tipo generico che ha un numero errato di argomenti di tipo.  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta un tipo generico e uno dei relativi argomenti di tipo non soddisfa i vincoli per il parametro di tipo corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> rappresenta una matrice di <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 In [.NET per app di Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) rilevare invece l'eccezione della classe di base, <see cref="T:System.IO.IOException" />.  
  
</para>
          </block>  
  
 L'assembly o una delle relative dipendenze è stato trovato, ma non può essere caricato.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly o una delle relative dipendenze non è valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'assembly è stato compilato con una versione successiva.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nome qualificato dall'assembly del tipo da ottenere. Vedere <see cref="P:System.Type.AssemblyQualifiedName" />. Se il tipo è incluso nell'assembly attualmente in esecuzione o in Mscorlib.dll, è sufficiente specificare il nome del tipo qualificato in base al relativo spazio dei nomi.</param>
        <param name="throwOnError">
          <see langword="true" /> per generare un'eccezione se non è possibile trovare il tipo; <see langword="false" /> per restituire <see langword="null" />. Se si specifica <see langword="false" /> vengono eliminate alcune condizioni di eccezione, ma non tutte. Vedere la sezione relativa alle eccezioni.</param>
        <summary>Ottiene l'oggetto <see cref="T:System.Type" /> con il nome specificato, eseguendo una ricerca con distinzione tra maiuscole e minuscole e specificando se generare un'eccezione in caso il tipo non venga trovato.</summary>
        <returns>Tipo con il nome specificato. Se il tipo non viene trovato, il parametro <paramref name="throwOnError" /> specifica se viene restituito <see langword="null" /> o se viene generata un'eccezione. In alcuni casi, viene generata un'eccezione indipendentemente dal valore di <paramref name="throwOnError" />. Vedere la sezione relativa alle eccezioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare il <xref:System.Type.GetType%2A> per ottenere un <xref:System.Type> dell'oggetto per un tipo in un altro assembly, se si conosce il nome completo dello spazio dei nomi. <xref:System.Type.GetType%2A> causa il caricamento dell'assembly specificato in `typeName`. È inoltre possibile caricare un assembly mediante il <xref:System.Reflection.Assembly.Load%2A> (metodo) e quindi utilizzare il <xref:System.Type.GetType%2A> o <xref:System.Reflection.Assembly.GetTypes%2A> metodi del <xref:System.Reflection.Assembly> classe per ottenere <xref:System.Type> oggetti. Se un tipo in un assembly noto al programma in fase di compilazione, è preferibile utilizzare `typeof` in c#, <xref:System.Type.GetType%2A> in Visual Basic o `typeid` in C++.  
  
 `GetType` funziona solo su assembly caricati dal disco. Se si chiama `GetType` per cercare un tipo definito in un assembly dinamico mediante il <xref:System.Reflection.Emit> services, è possibile ottenere un comportamento incoerente. Il comportamento varia a seconda che l'assembly dinamico persistente, vale a dire, creata utilizzando il `RunAndSave` o `Save` modalità di accesso di <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumerazione. Se l'assembly dinamico è permanente ed è stato scritto su disco prima `GetType` viene chiamato, il caricatore trova l'assembly salvato su disco, carica l'assembly e recupera il tipo di tale assembly. Se l'assembly non è stato salvato su disco quando `GetType` viene chiamato il metodo restituisce `null`. `GetType` non riconosce gli assembly dinamici temporanei; Pertanto, la chiamata `GetType` per recuperare un tipo di un temporaneo restituisce l'assembly dinamico `null`.  
  
 Per utilizzare `GetType` su un modulo dinamico, sottoscrivere il <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> eventi e chiamate `GetType` prima del salvataggio. In caso contrario, si otterrà due copie dell'assembly in memoria.  
  
 Il `throwOnError` parametro specifica che cosa avviene quando non viene trovato, il tipo e vengono eliminate alcune condizioni di eccezione, come descritto nella sezione eccezioni. Alcune eccezioni vengono generate indipendentemente dal valore di `throwOnError`. Se il tipo è stato trovato ma non può essere caricato, ad esempio un <xref:System.TypeLoadException> viene generata anche se `throwOnError` è `false`.  
  
 La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.  
  
|Tipo di membro|Static|Non statico|  
|-----------------|------------|-----------------|  
|Costruttore|No|No|  
|Campo|No|Sì. Un campo è sempre Nascondi in base al nome e-firma.|  
|event|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
|Metodo|No|Sì. Un metodo (virtuale e non virtuale) può essere hide-by-name o Nascondi in base al nome e-firma.|  
|Tipo annidato|No|No|  
|Proprietà|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
  
1.  Nascondi in base al nome e-firma prende in considerazione tutte le parti della firma, compresi i modificatori personalizzati, restituire tipi, tipi di parametri, elementi sentinel e convenzioni di chiamata non gestite. Si tratta di un confronto binario.  
  
2.  Per la reflection, proprietà ed eventi sono Nascondi in base al nome e-firma. Se si dispone di una proprietà con sia un'operazione get e set nella classe base, ma la classe derivata contiene solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter sulla classe di base.  
  
3.  Attributi personalizzati non fanno parte di common type system.  
  
 Le matrici o tipi COM non vengono cercati a meno che non sono già stati caricati nella tabella delle classi disponibili.  
  
 `typeName` può essere il nome del tipo qualificato dal relativo spazio dei nomi o un nome completo dell'assembly che include una specifica di nome di assembly. Vedere <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Se `typeName` include lo spazio dei nomi ma non il nome dell'assembly, questo metodo cerca solo assembly dell'oggetto chiamante e mscorlib. dll, nell'ordine. Se typeName è un nome completo con il nome parziale o completo dell'assembly, questo metodo cerca nell'assembly specificato. Se l'assembly dispone di un nome sicuro, è necessario un nome di assembly completo.  
  
 Il <xref:System.Type.AssemblyQualifiedName%2A> proprietà restituisce un nome completo del tipo, inclusi i tipi annidati, il nome dell'assembly e argomenti generici. Tutti i compilatori che supportano common language runtime creeranno il nome semplice di una classe annidata, e reflection quando richiesta, in conformità con le seguenti convenzioni di un nome alterato.  
  
> [!NOTE]
>  In .NET Framework versione 2.0, l'architettura del processore viene aggiunto all'identità dell'assembly e può essere specificato come parte di stringhe di nomi di assembly. Ad esempio, "ProcessorArchitecture = msil". Tuttavia, non è incluso nella stringa restituita dal <xref:System.Type.AssemblyQualifiedName%2A> proprietà, per motivi di compatibilità. È inoltre possibile caricare tipi creando un <xref:System.Reflection.AssemblyName> oggetto e passarlo a un overload appropriato del <xref:System.Reflection.Assembly.Load%2A> metodo. È quindi possibile utilizzare il <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> per caricare i tipi dall'assembly. Vedere anche <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|delimitatore|Significato|  
|---------------|-------------|  
|Barra rovesciata (\\)|Carattere di escape.|  
|Apice inverso (')|Precede una o più cifre che rappresenta il numero di parametri di tipo, alla fine del nome di un tipo generico.|  
|parentesi quadre ([])|Racchiudere un elenco di argomenti di tipo generico, per un tipo generico costruito. all'interno di un elenco di argomenti, racchiudere un tipo qualificato dall'assembly.|  
|Comma (,)|Precede il nome dell'Assembly.|  
|Punto (.)|Indica gli identificatori dello spazio dei nomi.|  
|Segno più (+)|Precede una classe annidata.|  
  
 Il nome completo per una classe, ad esempio, potrebbe essere simile al seguente:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Se lo spazio dei nomi sono stati TopNamespace.Sub+Namespace, quindi la stringa sarebbe necessario anteporre il segno più (+) con un carattere di escape (\\) per evitare che venga interpretato come un separatore di annidamento. Reflection genera questa stringa, come indicato di seguito:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A "+" diventa "\\+\\+" e un "\\"diventa"\\\\".  
  
 Questo nome completo può essere persistente e successivamente utilizzato per caricare il <xref:System.Type>. Per cercare e caricare un <xref:System.Type>, utilizzare <xref:System.Type.GetType%2A> o con il tipo di nome solo oppure con il nome di tipo completo dell'assembly. <xref:System.Type.GetType%2A> con il tipo di nome solo cercherà il <xref:System.Type> nell'assembly del chiamante, quindi nell'assembly System. <xref:System.Type.GetType%2A> con l'assembly completo del tipo cercherà il <xref:System.Type> in qualsiasi assembly.  
  
 I nomi dei tipi possono includere caratteri finali che indicano informazioni aggiuntive sul tipo, ad esempio se il tipo è un tipo riferimento, un tipo di puntatore o un tipo di matrice. Per recuperare il nome del tipo senza caratteri finali, utilizzare `t.GetElementType().ToString()`, dove `t` è il tipo.  
  
 Gli spazi sono rilevanti in tutti i componenti di nome di tipo tranne il nome dell'assembly. Il nome di assembly, spazi che precedono il separatore ',' sono rilevanti, ma gli spazi dopo il separatore ',' vengono ignorati.  
  
 Il nome di un tipo generico termina con un apice inverso (\`) seguito da cifre che rappresenta il numero di argomenti di tipo generico. Lo scopo di questo tipo di modifica dei nomi è consentire ai compilatori di supportare i tipi generici con lo stesso nome ma con un numero diverso di parametri di tipo, che si verificano nello stesso ambito. Ad esempio, la reflection restituisce i nomi alterati `Tuple`1` and `tupla`2` uno dei metodi generici `Tuple(Of T)` e `Tuple(Of T0, T1)` in Visual Basic o `Tuple<T>` tupla e`\<T0, T1>` in Visual c#.  
  
 Per i tipi generici, l'elenco di argomenti di tipo è racchiuso tra parentesi e gli argomenti di tipo sono separati da virgole. Ad esempio, un oggetto generico <xref:System.Collections.Generic.Dictionary%602> presenta due parametri di tipo. Oggetto <xref:System.Collections.Generic.Dictionary%602> di `MyType` con chiavi di tipo <xref:System.String> potrebbe essere rappresentato nel modo seguente:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Per specificare un tipo qualificato dall'assembly all'interno di un elenco di argomenti, racchiudere il tipo completo dell'assembly all'interno di parentesi quadre. In caso contrario, le virgole per separare le parti del nome completo dell'assembly vengono interpretate come delimitatori ulteriori argomenti di tipo. Ad esempio, un <xref:System.Collections.Generic.Dictionary%602> di `MyType` da MyAssembly. dll, con chiavi di tipo <xref:System.String>, può essere specificato come indicato di seguito:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Un tipo qualificato dall'assembly può essere racchiuso tra parentesi quadre solo quando viene visualizzato all'interno di un elenco di parametri di tipo. Le regole per la ricerca di assembly per i tipi completi e non qualificati in elenchi di parametri di tipo sono come le regole per i tipi non generici non qualificati e completi.  
  
 Tipi nullable sono un tipo speciale di tipi generici. Ad esempio, un valore nullable <xref:System.Int32> è rappresentato dalla stringa "System.Nullable'1[System.Int32]".  
  
> [!NOTE]
>  In c#, C++ e Visual Basic è inoltre possibile ottenere i tipi nullable che utilizzano operatori di tipo. Ad esempio, il valore nullable <xref:System.Boolean> tipo restituito dal `typeof(Nullable<bool>)` in c#, da `Nullable<Boolean>::typeid` in C++ e da `GetType(Nullable(Of Boolean))` in Visual Basic.  
  
 La tabella seguente illustra la sintassi da utilizzare con `GetType` per vari tipi.  
  
|Per ottenere|Usa|  
|------------|---------|  
|Un valore nullable <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|Un puntatore non gestito a `MyType`|`Type.GetType("MyType*")`|  
|Un puntatore non gestito a un puntatore a `MyType`|`Type.GetType("MyType**")`|  
|Un puntatore gestito o un riferimento a `MyType`|`Type.GetType("MyType&")`. Si noti che, a differenza dei puntatori, i riferimenti sono limitati a un solo livello.|  
|Una classe padre e una classe annidata|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Una matrice unidimensionale con limite inferiore pari a 0|`Type.GetType("MyArray[]")`|  
|Una matrice unidimensionale con limite inferiore sconosciuto|`Type.GetType("MyArray[*]")`|  
|Una matrice di n-dimensionale|Una virgola (,) all'interno delle parentesi un totale di volte in cui n-1. Ad esempio, `System.Object[,,]` rappresenta un oggetto tridimensionale `Object` matrice.|  
|Una matrice bidimensionale|`Type.GetType("MyArray[][]")`|  
|Una matrice bidimensionale rettangolare con limiti inferiori sconosciuti|`Type.GetType("MyArray[,]")`|  
|Un tipo generico con un argomento di tipo|`Type.GetType("MyGenericType`1[MyType]")`|  
|Un tipo generico con due argomenti di tipo|`Type.GetType("MyGenericType`2[MyType,AnotherType]")'|  
|Un tipo generico con due argomenti di tipo qualificato dall'assembly|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")'|  
|Un tipo generico con un argomento di tipo qualificato dall'assembly completo dell'assembly|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")'|  
|Un tipo generico il cui argomento di tipo è un tipo generico con due argomenti di tipo|`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 Nell'esempio seguente recupera il tipo di `System.Int32` e utilizza tale oggetto di tipo per visualizzare il <xref:System.Type.FullName%2A> proprietà `System.Int32`. Se un oggetto di tipo fa riferimento a un assembly che non esiste, questo esempio genera un'eccezione.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Viene richiamato un inizializzatore di classi e viene generata un'eccezione.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> è <see langword="true" /> e il tipo non è stato trovato.  
  
 oppure  
  
 <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> contiene caratteri non validi, ad esempio una scheda incorporata.  
  
 oppure  
  
 <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> è una stringa vuota.  
  
 oppure  
  
 <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> rappresenta un tipo di matrice con una dimensione non valida.  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta una matrice di <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /> è <see langword="true" /> e la sintassi di <paramref name="typeName" /> non è valida. Ad esempio: "MyType[,*,]".  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta un tipo generico che ha un tipo di puntatore, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> tra i relativi argomenti di tipo.  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta un tipo generico che ha un numero errato di argomenti di tipo.  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta un tipo generico e uno dei relativi argomenti di tipo non soddisfa i vincoli per il parametro di tipo corrispondente.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> è <see langword="true" /> e l'assembly o una delle sue dipendenze non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 In [.NET per app di Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) rilevare invece l'eccezione della classe di base, <see cref="T:System.IO.IOException" />.  
  
</para>
          </block>  
  
 L'assembly o una delle relative dipendenze è stato trovato, ma non può essere caricato.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly o una delle relative dipendenze non è valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'assembly è stato compilato con una versione successiva.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nome qualificato dall'assembly del tipo da ottenere. Vedere <see cref="P:System.Type.AssemblyQualifiedName" />. Se il tipo è incluso nell'assembly attualmente in esecuzione o in Mscorlib.dll, è sufficiente specificare il nome del tipo qualificato in base al relativo spazio dei nomi.</param>
        <param name="throwOnError">
          <see langword="true" /> per generare un'eccezione se il tipo non viene trovato; <see langword="false" /> per restituire <see langword="null" />. Specificando <see langword="false" /> inoltre si eliminano alcune condizioni dell'eccezione, ma non tutte. Vedere la sezione relativa alle eccezioni.</param>
        <param name="ignoreCase">
          <see langword="true" /> per eseguire una ricerca di <c>typeName</c> senza distinzione tra maiuscole e minuscole, <see langword="false" /> per eseguire una ricerca di <c>typeName</c> con distinzione tra maiuscole e minuscole.</param>
        <summary>Ottiene l'oggetto <see cref="T:System.Type" /> con il nome specificato, che indica se generare un'eccezione quando viene trovato il tipo e se eseguire una ricerca con distinzione tra maiuscole e minuscole.</summary>
        <returns>Tipo con il nome specificato. Se il tipo non viene trovato, il parametro <paramref name="throwOnError" /> specifica se viene restituito <see langword="null" /> o se viene generata un'eccezione. In alcuni casi, viene generata un'eccezione indipendentemente dal valore di <paramref name="throwOnError" />. Vedere la sezione relativa alle eccezioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare il <xref:System.Type.GetType%2A> per ottenere un <xref:System.Type> dell'oggetto per un tipo in un altro assembly, se si conosce il nome completo dello spazio dei nomi. <xref:System.Type.GetType%2A> causa il caricamento dell'assembly specificato in `typeName`. È inoltre possibile caricare un assembly mediante il <xref:System.Reflection.Assembly.Load%2A> (metodo) e quindi utilizzare il <xref:System.Type.GetType%2A> o <xref:System.Reflection.Assembly.GetTypes%2A> metodi del <xref:System.Reflection.Assembly> classe per ottenere <xref:System.Type> oggetti. Se un tipo in un assembly noto al programma in fase di compilazione, è preferibile utilizzare `typeof` in c#, <xref:System.Type.GetType%2A> in Visual Basic o `typeid` in C++.  
  
 `GetType` funziona solo su assembly caricati dal disco. Se si chiama `GetType` per cercare un tipo definito in un assembly dinamico mediante il <xref:System.Reflection.Emit> services, è possibile ottenere un comportamento incoerente. Il comportamento varia a seconda che l'assembly dinamico persistente, vale a dire, creata utilizzando il `RunAndSave` o `Save` modalità di accesso di <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumerazione. Se l'assembly dinamico è permanente ed è stato scritto su disco prima `GetType` viene chiamato, il caricatore trova l'assembly salvato su disco, carica l'assembly e recupera il tipo di tale assembly. Se l'assembly non è stato salvato su disco quando `GetType` viene chiamato il metodo restituisce `null`. `GetType` non riconosce gli assembly dinamici temporanei; Pertanto, la chiamata `GetType` per recuperare un tipo di un temporaneo restituisce l'assembly dinamico `null`.  
  
 Per utilizzare `GetType` su un modulo dinamico, sottoscrivere il <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> eventi e chiamate `GetType` prima del salvataggio. In caso contrario, si otterrà due copie dell'assembly in memoria.  
  
 Il `throwOnError` parametro specifica che cosa avviene quando non viene trovato, il tipo e vengono eliminate alcune condizioni di eccezione, come descritto nella sezione eccezioni. Alcune eccezioni vengono generate indipendentemente dal valore di `throwOnError`. Se il tipo è stato trovato ma non può essere caricato, ad esempio un <xref:System.TypeLoadException> viene generata anche se `throwOnError` è `false`.  
  
 La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.  
  
|Tipo di membro|Static|Non statico|  
|-----------------|------------|-----------------|  
|Costruttore|No|No|  
|Campo|No|Sì. Un campo è sempre Nascondi in base al nome e-firma.|  
|event|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
|Metodo|No|Sì. Un metodo (virtuale e non virtuale) può essere hide-by-name o Nascondi in base al nome e-firma.|  
|Tipo annidato|No|No|  
|Proprietà|Non applicabile|La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà. La reflection gestisce proprietà come Nascondi in base al nome e-firma. Vedere la nota 2 di seguito.|  
  
1.  Nascondi in base al nome e-firma prende in considerazione tutte le parti della firma, compresi i modificatori personalizzati, restituire tipi, tipi di parametri, elementi sentinel e convenzioni di chiamata non gestite. Si tratta di un confronto binario.  
  
2.  Per la reflection, proprietà ed eventi sono Nascondi in base al nome e-firma. Se si dispone di una proprietà con sia un'operazione get e set nella classe base, ma la classe derivata contiene solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter sulla classe di base.  
  
3.  Attributi personalizzati non fanno parte di common type system.  
  
 Le matrici o tipi COM non vengono cercati a meno che non sono già stati caricati nella tabella delle classi disponibili.  
  
 `typeName` può essere il nome del tipo qualificato dal relativo spazio dei nomi o un nome completo dell'assembly che include una specifica di nome di assembly. Vedere <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Se `typeName` include lo spazio dei nomi ma non il nome dell'assembly, questo metodo cerca solo assembly dell'oggetto chiamante e mscorlib. dll, nell'ordine. Se typeName è un nome completo con il nome parziale o completo dell'assembly, questo metodo cerca nell'assembly specificato. Se l'assembly dispone di un nome sicuro, è necessario un nome di assembly completo.  
  
 Il <xref:System.Type.AssemblyQualifiedName%2A> proprietà restituisce un nome completo del tipo, inclusi i tipi annidati, il nome dell'assembly e gli argomenti di tipo. Tutti i compilatori che supportano common language runtime creeranno il nome semplice di una classe annidata, e reflection quando richiesta, in conformità con le seguenti convenzioni di un nome alterato.  
  
> [!NOTE]
>  In .NET Framework versione 2.0, l'architettura del processore viene aggiunto all'identità dell'assembly e può essere specificato come parte di stringhe di nomi di assembly. Ad esempio, "ProcessorArchitecture = msil". Tuttavia, non è incluso nella stringa restituita dal <xref:System.Type.AssemblyQualifiedName%2A> proprietà, per motivi di compatibilità. È inoltre possibile caricare tipi creando un <xref:System.Reflection.AssemblyName> oggetto e passarlo a un overload appropriato del <xref:System.Reflection.Assembly.Load%2A> metodo. È quindi possibile utilizzare il <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> per caricare i tipi dall'assembly. Vedere anche <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|delimitatore|Significato|  
|---------------|-------------|  
|Barra rovesciata (\\)|Carattere di escape.|  
|Apice inverso (')|Precede una o più cifre che rappresenta il numero di parametri di tipo, alla fine del nome di un tipo generico.|  
|parentesi quadre ([])|Racchiudere un elenco di argomenti di tipo generico, per un tipo generico costruito. all'interno di un elenco di argomenti, racchiudere un tipo qualificato dall'assembly.|  
|Comma (,)|Precede il nome dell'Assembly.|  
|Punto (.)|Indica gli identificatori dello spazio dei nomi.|  
|Segno più (+)|Precede una classe annidata.|  
  
 Il nome completo per una classe, ad esempio, potrebbe essere simile al seguente:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Se lo spazio dei nomi sono stati TopNamespace.Sub+Namespace, quindi la stringa sarebbe necessario anteporre il segno più (+) con un carattere di escape (\\) per evitare che venga interpretato come un separatore di annidamento. Reflection genera questa stringa, come indicato di seguito:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A "+" diventa "\\+\\+" e un "\\"diventa"\\\\".  
  
 Questo nome completo può essere persistente e successivamente utilizzato per caricare il <xref:System.Type>. Per cercare e caricare un <xref:System.Type>, utilizzare <xref:System.Type.GetType%2A> o con il tipo di nome solo oppure con il nome di tipo completo dell'assembly. <xref:System.Type.GetType%2A> con il tipo di nome solo cercherà il <xref:System.Type> nell'assembly del chiamante, quindi nell'assembly System. <xref:System.Type.GetType%2A> con l'assembly completo del tipo cercherà il <xref:System.Type> in qualsiasi assembly.  
  
 I nomi dei tipi possono includere caratteri finali che indicano informazioni aggiuntive sul tipo, ad esempio se il tipo è un tipo riferimento, un tipo di puntatore o un tipo di matrice. Per recuperare il nome del tipo senza caratteri finali, utilizzare `t.GetElementType().ToString()`, dove `t` è il tipo.  
  
 Gli spazi sono rilevanti in tutti i componenti di nome di tipo tranne il nome dell'assembly. Il nome di assembly, spazi che precedono il separatore ',' sono rilevanti, ma gli spazi dopo il separatore ',' vengono ignorati.  
  
 Il nome di un tipo generico termina con un apice inverso (\`) seguito da cifre che rappresenta il numero di argomenti di tipo generico. Lo scopo di questo tipo di modifica dei nomi è consentire ai compilatori di supportare i tipi generici con lo stesso nome ma con un numero diverso di parametri di tipo, che si verificano nello stesso ambito. Ad esempio, la reflection restituisce i nomi alterati `Tuple`1` and `tupla`2` uno dei metodi generici `Tuple(Of T)` e `Tuple(Of T0, T1)` in Visual Basic o `Tuple<T>` tupla e`\<T0, T1>` in Visual c#.  
  
 Per i tipi generici, l'elenco di argomenti di tipo è racchiuso tra parentesi e gli argomenti di tipo sono separati da virgole. Ad esempio, un oggetto generico <xref:System.Collections.Generic.Dictionary%602> presenta due parametri di tipo. Oggetto <xref:System.Collections.Generic.Dictionary%602> di `MyType` con chiavi di tipo <xref:System.String> potrebbe essere rappresentato nel modo seguente:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Per specificare un tipo qualificato dall'assembly all'interno di un elenco di argomenti, racchiudere il tipo completo dell'assembly all'interno di parentesi quadre. In caso contrario, le virgole per separare le parti del nome completo dell'assembly vengono interpretate come delimitatori ulteriori argomenti di tipo. Ad esempio, un <xref:System.Collections.Generic.Dictionary%602> di `MyType` da MyAssembly. dll, con chiavi di tipo <xref:System.String>, può essere specificato come indicato di seguito:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Un tipo qualificato dall'assembly può essere racchiuso tra parentesi quadre solo quando viene visualizzato all'interno di un elenco di parametri di tipo. Le regole per la ricerca di assembly per i tipi completi e non qualificati in elenchi di parametri di tipo sono come le regole per i tipi non generici non qualificati e completi.  
  
 Tipi nullable sono un tipo speciale di tipi generici. Ad esempio, un valore nullable <xref:System.Int32> è rappresentato dalla stringa "System.Nullable'1[System.Int32]".  
  
> [!NOTE]
>  In c#, C++ e Visual Basic è inoltre possibile ottenere i tipi nullable che utilizzano operatori di tipo. Ad esempio, il valore nullable <xref:System.Boolean> tipo restituito dal `typeof(Nullable<bool>)` in c#, da `Nullable<Boolean>::typeid` in C++ e da `GetType(Nullable(Of Boolean))` in Visual Basic.  
  
 La tabella seguente illustra la sintassi da utilizzare con `GetType` per vari tipi.  
  
|Per ottenere|Usa|  
|------------|---------|  
|Un valore nullable <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|Un puntatore non gestito a `MyType`|`Type.GetType("MyType*")`|  
|Un puntatore non gestito a un puntatore a `MyType`|`Type.GetType("MyType**")`|  
|Un puntatore gestito o un riferimento a `MyType`|`Type.GetType("MyType&")`. Si noti che, a differenza dei puntatori, i riferimenti sono limitati a un solo livello.|  
|Una classe padre e una classe annidata|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Una matrice unidimensionale con limite inferiore pari a 0|`Type.GetType("MyArray[]")`|  
|Una matrice unidimensionale con limite inferiore sconosciuto|`Type.GetType("MyArray[*]")`|  
|Una matrice di n-dimensionale|Una virgola (,) all'interno delle parentesi un totale di volte in cui n-1. Ad esempio, `System.Object[,,]` rappresenta un oggetto tridimensionale `Object` matrice.|  
|Una matrice bidimensionale|`Type.GetType("MyArray[][]")`|  
|Una matrice bidimensionale rettangolare con limiti inferiori sconosciuti|`Type.GetType("MyArray[,]")`|  
|Un tipo generico con un argomento di tipo|`Type.GetType("MyGenericType`1[MyType]")`|  
|Un tipo generico con due argomenti di tipo|`Type.GetType("MyGenericType`2[MyType,AnotherType]")'|  
|Un tipo generico con due argomenti di tipo qualificato dall'assembly|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")'|  
|Un tipo generico con un argomento di tipo qualificato dall'assembly completo dell'assembly|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")'|  
|Un tipo generico il cui argomento di tipo è un tipo generico con due argomenti di tipo|`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Viene richiamato un inizializzatore di classi e viene generata un'eccezione.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> è <see langword="true" /> e il tipo non è stato trovato.  
  
 oppure  
  
 <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> contiene caratteri non validi, ad esempio una scheda incorporata.  
  
 oppure  
  
 <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> è una stringa vuota.  
  
 oppure  
  
 <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> rappresenta un tipo di matrice con una dimensione non valida.  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta una matrice di <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /> è <see langword="true" /> e la sintassi di <paramref name="typeName" /> non è valida. Ad esempio: "MyType[,*,]".  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta un tipo generico che ha un tipo di puntatore, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> tra i relativi argomenti di tipo.  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta un tipo generico che ha un numero errato di argomenti di tipo.  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta un tipo generico e uno dei relativi argomenti di tipo non soddisfa i vincoli per il parametro di tipo corrispondente.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> è <see langword="true" /> e l'assembly o una delle sue dipendenze non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">L'assembly o una delle relative dipendenze è stato trovato, ma non può essere caricato.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly o una delle relative dipendenze non è valido.  
  
 oppure  
  
 Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'assembly è stato compilato con una versione successiva.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">Nome del tipo da ottenere. Se viene specificato il parametro <c>typeResolver</c>, il nome del tipo può essere qualsiasi stringa che <c>typeResolver</c> è in grado di risolvere. Se viene specificato il parametro <c>assemblyResolver</c> o viene usata la risoluzione del tipo standard, <c>typeName</c> deve essere un nome qualificato dall'assembly (vedere <see cref="P:System.Type.AssemblyQualifiedName" />), a meno che il tipo non si trovi nell'assembly attualmente in esecuzione o in Mscorlib.dll, nel qual caso è sufficiente indicare il nome del tipo qualificato in base al relativo spazio dei nomi.</param>
        <param name="assemblyResolver">Metodo che individua e restituisce l'assembly specificato in <c>typeName</c>. Il nome dell'assembly viene passato ad <c>assemblyResolver</c> come oggetto <see cref="T:System.Reflection.AssemblyName" />. Se <c>typeName</c> non contiene il nome di un assembly, <c>assemblyResolver</c> non viene chiamato. Se non si specifica <c>assemblyResolver</c>, viene eseguita la risoluzione dell'assembly standard.  
  
 Attenzione   Non passare metodi da chiamanti non noti o non attendibili. In caso contrario, potrebbe verificarsi un'elevazione di privilegi per codice dannoso. Usare solo i metodi forniti o con cui si ha dimestichezza.</param>
        <param name="typeResolver">Metodo che individua e restituisce il tipo specificato da <c>typeName</c> dall'assembly restituito da <c>assemblyResolver</c> o dalla risoluzione dell'assembly standard. Se non viene indicato alcun assembly, il metodo <c>typeResolver</c> può specificarne uno. Il metodo accetta inoltre un parametro che specifica se eseguire una ricerca senza fare distinzione tra maiuscole e minuscole. <see langword="false" /> viene passato al parametro.  
  
 Attenzione   Non passare metodi da chiamanti non noti o non attendibili.</param>
        <summary>Ottiene il tipo con il nome specificato, fornendo facoltativamente metodi personalizzati per risolvere l'assembly e il tipo.</summary>
        <returns>Tipo con il nome specificato, oppure <see langword="null" /> se il tipo non viene trovato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli scenari di questo metodo e i dettagli sull'utilizzo di `assemblyResolver` e `typeResolver` parametri possono essere trovati nel <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> overload del metodo.  
  
> [!NOTE]
>  Se `typeName` non viene trovato, la chiamata al <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> restituisce `null`. Non generare un'eccezione. Per controllare se viene generata un'eccezione, chiamare l'overload del metodo di <xref:System.Type.GetType%2A> metodo che presenta un `throwOnError` parametro.  
  
 Chiamare questo overload del metodo corrisponde al chiamante di <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> overload del metodo e specificando `false` per il `throwOnError` e `ignoreCase` parametri.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Viene richiamato un inizializzatore di classi e viene generata un'eccezione.</exception>
        <exception cref="T:System.ArgumentException">Si verifica un errore quando <paramref name="typeName" /> viene analizzato in un nome del tipo e un nome dell'assembly (ad esempio, quando il nome del tipo semplice include un carattere speciale senza codice di escape).  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta un tipo generico che ha un tipo di puntatore, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> tra i relativi argomenti di tipo.  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta un tipo generico che ha un numero errato di argomenti di tipo.  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta un tipo generico e uno dei relativi argomenti di tipo non soddisfa i vincoli per il parametro di tipo corrispondente.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> rappresenta una matrice di <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException">L'assembly o una delle relative dipendenze è stato trovato, ma non può essere caricato.  
  
 oppure  
  
 <paramref name="typeName" /> contiene un nome dell'assembly non valido.  
  
 oppure  
  
 <paramref name="typeName" /> è un nome dell'assembly valido senza un nome di tipi.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly o una delle relative dipendenze non è valido.  
  
 oppure  
  
 L'assembly è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nome del tipo da ottenere. Se viene specificato il parametro <c>typeResolver</c>, il nome del tipo può essere qualsiasi stringa che <c>typeResolver</c> è in grado di risolvere. Se viene specificato il parametro <c>assemblyResolver</c> o viene usata la risoluzione del tipo standard, <c>typeName</c> deve essere un nome qualificato dall'assembly (vedere <see cref="P:System.Type.AssemblyQualifiedName" />), a meno che il tipo non si trovi nell'assembly attualmente in esecuzione o in Mscorlib.dll, nel qual caso è sufficiente indicare il nome del tipo qualificato in base al relativo spazio dei nomi.</param>
        <param name="assemblyResolver">Metodo che individua e restituisce l'assembly specificato in <c>typeName</c>. Il nome dell'assembly viene passato ad <c>assemblyResolver</c> come oggetto <see cref="T:System.Reflection.AssemblyName" />. Se <c>typeName</c> non contiene il nome di un assembly, <c>assemblyResolver</c> non viene chiamato. Se non si specifica <c>assemblyResolver</c>, viene eseguita la risoluzione dell'assembly standard.  
  
 Attenzione   Non passare metodi da chiamanti non noti o non attendibili. In caso contrario, potrebbe verificarsi un'elevazione di privilegi per codice dannoso. Usare solo i metodi forniti o con cui si ha dimestichezza.</param>
        <param name="typeResolver">Metodo che individua e restituisce il tipo specificato da <c>typeName</c> dall'assembly restituito da <c>assemblyResolver</c> o dalla risoluzione dell'assembly standard. Se non viene fornito alcun assembly, il metodo può fornirne uno. Il metodo accetta inoltre un parametro che specifica se eseguire una ricerca senza fare distinzione tra maiuscole e minuscole. <see langword="false" /> viene passato al parametro.  
  
 Attenzione   Non passare metodi da chiamanti non noti o non attendibili.</param>
        <param name="throwOnError">
          <see langword="true" /> per generare un'eccezione se non è possibile trovare il tipo; <see langword="false" /> per restituire <see langword="null" />. Se si specifica <see langword="false" /> vengono eliminate alcune condizioni di eccezione, ma non tutte. Vedere la sezione relativa alle eccezioni.</param>
        <summary>Ottiene il tipo con il nome specificato, indicando se generare un'eccezione se il tipo non viene trovato e fornendo facoltativamente metodi personalizzati per risolvere l'assembly e il tipo.</summary>
        <returns>Tipo con il nome specificato. Se il tipo non viene trovato, il parametro <paramref name="throwOnError" /> specifica se viene restituito <see langword="null" /> o se viene generata un'eccezione. In alcuni casi, viene generata un'eccezione indipendentemente dal valore di <paramref name="throwOnError" />. Vedere la sezione relativa alle eccezioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli scenari di questo metodo e i dettagli sull'utilizzo di `assemblyResolver` e `typeResolver` parametri possono essere trovati nel <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> overload del metodo.  
  
 Chiamare questo overload del metodo corrisponde al chiamante di <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> overload del metodo e specificando `false` per il `ignoreCase` parametro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Viene richiamato un inizializzatore di classi e viene generata un'eccezione.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> è <see langword="true" /> e il tipo non è stato trovato.  
  
 oppure  
  
 <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> contiene caratteri non validi, ad esempio una scheda incorporata.  
  
 oppure  
  
 <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> è una stringa vuota.  
  
 oppure  
  
 <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> rappresenta un tipo di matrice con una dimensione non valida.  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta una matrice di <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">Si verifica un errore quando <paramref name="typeName" /> viene analizzato in un nome del tipo e un nome dell'assembly (ad esempio, quando il nome del tipo semplice include un carattere speciale senza codice di escape).  
  
 oppure  
  
 <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> contiene sintassi non valida (ad esempio, "MyType [,*,]").  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta un tipo generico che ha un tipo di puntatore, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> tra i relativi argomenti di tipo.  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta un tipo generico che ha un numero errato di argomenti di tipo.  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta un tipo generico e uno dei relativi argomenti di tipo non soddisfa i vincoli per il parametro di tipo corrispondente.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> è <see langword="true" /> e l'assembly o una delle sue dipendenze non è stato trovato.  
  
 oppure  
  
 <paramref name="typeName" /> contiene un nome dell'assembly non valido.  
  
 oppure  
  
 <paramref name="typeName" /> è un nome dell'assembly valido senza un nome di tipi.</exception>
        <exception cref="T:System.IO.FileLoadException">L'assembly o una delle relative dipendenze è stato trovato, ma non può essere caricato.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly o una delle relative dipendenze non è valido.  
  
 oppure  
  
 L'assembly è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nome del tipo da ottenere. Se viene specificato il parametro <c>typeResolver</c>, il nome del tipo può essere qualsiasi stringa che <c>typeResolver</c> è in grado di risolvere. Se viene specificato il parametro <c>assemblyResolver</c> o viene usata la risoluzione del tipo standard, <c>typeName</c> deve essere un nome qualificato dall'assembly (vedere <see cref="P:System.Type.AssemblyQualifiedName" />), a meno che il tipo non si trovi nell'assembly attualmente in esecuzione o in Mscorlib.dll, nel qual caso è sufficiente indicare il nome del tipo qualificato in base al relativo spazio dei nomi.</param>
        <param name="assemblyResolver">Metodo che individua e restituisce l'assembly specificato in <c>typeName</c>. Il nome dell'assembly viene passato ad <c>assemblyResolver</c> come oggetto <see cref="T:System.Reflection.AssemblyName" />. Se <c>typeName</c> non contiene il nome di un assembly, <c>assemblyResolver</c> non viene chiamato. Se non si specifica <c>assemblyResolver</c>, viene eseguita la risoluzione dell'assembly standard.  
  
 Attenzione   Non passare metodi da chiamanti non noti o non attendibili. In caso contrario, potrebbe verificarsi un'elevazione di privilegi per codice dannoso. Usare solo i metodi forniti o con cui si ha dimestichezza.</param>
        <param name="typeResolver">Metodo che individua e restituisce il tipo specificato da <c>typeName</c> dall'assembly restituito da <c>assemblyResolver</c> o dalla risoluzione dell'assembly standard. Se non viene fornito alcun assembly, il metodo può fornirne uno. Il metodo accetta inoltre un parametro che specifica se eseguire una ricerca senza fare distinzione tra maiuscole e minuscole. Il valore di <c>ignoreCase</c> viene passato a quel parametro.  
  
 Attenzione   Non passare metodi da chiamanti non noti o non attendibili.</param>
        <param name="throwOnError">
          <see langword="true" /> per generare un'eccezione se non è possibile trovare il tipo; <see langword="false" /> per restituire <see langword="null" />. Se si specifica <see langword="false" /> vengono eliminate alcune condizioni di eccezione, ma non tutte. Vedere la sezione relativa alle eccezioni.</param>
        <param name="ignoreCase">
          <see langword="true" /> per eseguire una ricerca di <c>typeName</c> senza distinzione tra maiuscole e minuscole, <see langword="false" /> per eseguire una ricerca di <c>typeName</c> con distinzione tra maiuscole e minuscole.</param>
        <summary>Ottiene il tipo con il nome specificato, indicando se eseguire una ricerca facendo distinzione tra maiuscole e minuscole e se generare un'eccezione se il tipo non viene trovato e fornendo facoltativamente metodi personalizzati per risolvere l'assembly e il tipo.</summary>
        <returns>Tipo con il nome specificato. Se il tipo non viene trovato, il parametro <paramref name="throwOnError" /> specifica se viene restituito <see langword="null" /> o se viene generata un'eccezione. In alcuni casi, viene generata un'eccezione indipendentemente dal valore di <paramref name="throwOnError" />. Vedere la sezione relativa alle eccezioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo overload del metodo e gli overload associati (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> e <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) per sostituire l'implementazione predefinita del <xref:System.Type.GetType%2A> (metodo) con implementazioni più flessibile. Fornendo i propri metodi di cui risolvere i nomi dei tipi e i nomi degli assembly che li contengono, è possibile eseguire le operazioni seguenti:  
  
-   Controllare la versione di un assembly con un tipo viene caricato da.  
  
-   Fornire un'altra posizione per cercare un nome di tipo che non include un nome di assembly.  
  
-   Caricare gli assembly con nomi di assembly parziali.  
  
-   Restituire le sottoclassi di <xref:System.Type?displayProperty=nameWithType> che non vengono creati da common language runtime (CLR).  
  
 Ad esempio, di serializzazione a tolleranza di versione questo metodo consente di cercare un assembly con nome "adatta" con un nome parziale. Altri overload di <xref:System.Type.GetType%2A> metodo richiede un nome di tipo qualificato dall'assembly, che include il numero di versione.  
  
 Potrebbe essere necessario implementazioni alternative del sistema di tipi restituire le sottoclassi di <xref:System.Type?displayProperty=nameWithType> che non vengono create da CLR, tutti i tipi che vengono restituiti da altri overload di <xref:System.Type.GetType%2A> metodo sono tipi di runtime.  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>Note sull'utilizzo  
 Questo overload del metodo e gli overload associati analizzano `typeName` nel nome di un tipo e il nome di un assembly e quindi la risoluzione dei nomi. Risoluzione del nome dell'assembly si verifica prima della risoluzione del nome del tipo, perché un nome di tipo deve essere risolto nel contesto di un assembly.  
  
> [!NOTE]
>  Se non si ha familiarità con il concetto di nomi di tipo qualificato dall'assembly, vedere il <xref:System.Type.AssemblyQualifiedName%2A> proprietà.  
  
 Se `typeName` non è un nome completo dell'assembly, la risoluzione dell'assembly viene ignorata. I nomi dei tipi non qualificati possono essere risolti nel contesto di mscorlib. dll o assembly attualmente in esecuzione o, facoltativamente, è possibile specificare un assembly nel `typeResolver` parametro. Gli effetti di inclusione o omettere il nome dell'assembly per tipi diversi di risoluzione dei nomi vengono visualizzati come una tabella di [Risoluzione mista](#mixed_name_resolution) sezione.  
  
 Note sull'utilizzo generale:  
  
-   Non passare metodi da `assemblyResolver` o `typeResolver` se provengono da chiamanti non noti o non attendibili. Usare solo i metodi forniti o con cui si ha dimestichezza.  
  
    > [!CAUTION]
    >  Con i metodi da chiamanti non noti o non attendibili potrebbe causare l'elevazione dei privilegi per codice dannoso.  
  
-   Se si omette il `assemblyResolver` e/o `typeResolver` parametri, il valore della `throwOnError` parametro viene passato ai metodi che eseguono la risoluzione predefinita.  
  
-   Se `throwOnError` è `true`, questo metodo genera un <xref:System.TypeLoadException> quando `typeResolver` restituisce `null`e un <xref:System.IO.FileNotFoundException> quando `assemblyResolver` restituisce `null`.  
  
-   Questo metodo non intercetta le eccezioni generate dalle `assemblyResolver` e `typeResolver`. Si è responsabili di eventuali eccezioni generate dai metodi di sistema di risoluzione.  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>Risoluzione degli assembly  
 Il `assemblyResolver` metodo riceve un <xref:System.Reflection.AssemblyName> oggetto, che viene generato analizzando il nome dell'assembly incluso nella stringa `typeName`. Se `typeName` non contiene un nome di assembly, `assemblyResolver` non viene chiamato e `null` viene passato a `typeResolver`.  
  
 Se `assemblyResolver` non è fornito, standard di assembly di probe viene utilizzato per individuare l'assembly. Se `assemblyResolver` viene fornito il <xref:System.Type.GetType%2A> metodo non esegue una ricerca standard; in tal caso è necessario assicurarsi che il `assemblyResolver` in grado di gestire tutti gli assembly vengono passati.  
  
 Il `assemblyResolver` metodo dovrebbe restituire `null` se l'assembly non può essere risolto. Se `assemblyResolver` restituisce `null`, `typeResolver` non viene chiamato e si verifica alcuna ulteriore elaborazione; inoltre, se `throwOnError` è `true`, <xref:System.IO.FileNotFoundException> viene generata un'eccezione.  
  
 Se il <xref:System.Reflection.AssemblyName> che viene passata a `assemblyResolver` è un elemento parziale sono nome, uno o più delle relative parti `null`. Ad esempio, se dispone di alcuna versione, il <xref:System.Reflection.AssemblyName.Version%2A> proprietà `null`. Se il <xref:System.Reflection.AssemblyName.Version%2A> proprietà, il <xref:System.Reflection.AssemblyName.CultureInfo%2A> , proprietà e <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> metodo tutte restituito `null`, quindi solo il nome semplice dell'assembly è stato fornito. Il `assemblyResolver` metodo può usare o ignorare tutte le parti del nome dell'assembly.  
  
 Gli effetti delle opzioni di risoluzione assembly diversi vengono visualizzati come una tabella di [Risoluzione mista](#mixed_name_resolution) sezione, per i nomi di tipo semplice e completo di assembly.  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>Risoluzione dei tipi  
 Se `typeName` non specifica un nome di assembly, `typeResolver` viene sempre chiamato. Se `typeName` specifica un nome di assembly, `typeResolver` viene chiamato solo quando il nome dell'assembly è stato risolto. Se `assemblyResolver` o dell'assembly standard restituisce `null`, `typeResolver` non viene chiamato.  
  
 Il `typeResolver` metodo riceve tre argomenti:  
  
-   L'assembly da cercare o `null` se `typeName` non contiene un nome di assembly.  
  
-   Il nome del tipo semplice. Nel caso di un tipo annidato, questo è il tipo di contenitore più esterno. Nel caso di un tipo generico, questo è il nome semplice di tipo generico.  
  
-   Un valore booleano che è `true` se nel caso di nomi di tipo viene ignorato.  
  
 L'implementazione determina il modo in cui che vengono utilizzati questi argomenti. Il `typeResolver` metodo dovrebbe restituire `null` se risulta impossibile risolvere il tipo. Se `typeResolver` restituisce `null` e `throwOnError` è `true`, questo overload di <xref:System.Type.GetType%2A> genera un <xref:System.TypeLoadException>.  
  
 Gli effetti delle opzioni di risoluzione di diverso tipo vengono visualizzati come una tabella di [Risoluzione mista](#mixed_name_resolution) sezione, per i nomi di tipo semplice e completo di assembly.  
  
#### <a name="resolving-nested-types"></a>Risoluzione dei tipi annidati  
 Se `typeName` è un tipo annidato, solo il nome del contenuto più esterno contenente il tipo viene passato a `typeResolver`. Quando `typeResolver` restituisce questo tipo, il <xref:System.Type.GetNestedType%2A> metodo viene chiamato in modo ricorsivo fino a quando il tipo annidato più interno è stato risolto.  
  
#### <a name="resolving-generic-types"></a>Risoluzione di tipi generici  
 Il <xref:System.Type.GetType%2A> viene chiamato in modo ricorsivo per risolvere i tipi generici: per risolvere il tipo generico stesso e quindi di risolvere i relativi argomenti di tipo. Se un argomento di tipo è generico, <xref:System.Type.GetType%2A> viene chiamato in modo ricorsivo per risolvere i relativi argomenti di tipo e così via.  
  
 La combinazione di `assemblyResolver` e `typeResolver` forniti deve essere in grado di risolvere tutti i livelli di questo tipo di ricorsione. Ad esempio, si supponga di fornire un `assemblyResolver` che controlla il caricamento di `MyAssembly`. Si supponga che si desidera risolvere il tipo generico `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic). È possibile passare il nome di tipo generico seguente:  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 Si noti che `MyType` è l'argomento di tipo solo qualificato dall'assembly. I nomi del <xref:System.Collections.Generic.Dictionary%602> e <xref:System.String> classi non sono completi di assembly. Il `typeResolver` deve essere in grado di gestire un assembly o `null`, perché riceverà `null` per <xref:System.Collections.Generic.Dictionary%602> e <xref:System.String>. È possibile gestire tale caso chiamando un overload di <xref:System.Type.GetType%2A> metodo che accetta una stringa, poiché entrambi i nomi dei tipi non qualificati sono in mscorlib. dll:  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 Il `assemblyResolver` metodo non viene chiamato per il tipo di dizionario e il tipo di stringa, perché i nomi di tipo non sono completi di assembly.  
  
 Si supponga ora che invece di `System.String`, il primo tipo di argomento generico è `YourType`, da `YourAssembly`:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 Poiché questo assembly è mscorlib né nell'assembly attualmente in esecuzione, è possibile risolvere `YourType` senza un nome completo dell'assembly. Poiché il `assemblyResolve` sarà chiamato in modo ricorsivo, deve essere in grado di gestire questa situazione. Anziché restituire `null` per gli assembly diverso da `MyAssembly`, esegue il caricamento di un assembly utilizzando l'interfaccia fornita <xref:System.Reflection.AssemblyName> oggetto.  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 Torna alla [note sull'utilizzo](#usage_notes).  
  
#### <a name="resolving-type-names-with-special-characters"></a>Risoluzione dei nomi di tipo con caratteri speciali  
 Alcuni caratteri hanno significati speciali nei nomi completi di assembly. Se un nome di tipo semplice contiene questi caratteri, i caratteri provocano errori di analisi quando il nome semplice fa parte di un nome completo dell'assembly. Per evitare gli errori di analisi, è necessario eseguire l'escape dei caratteri speciali con una barra rovesciata prima di poter passare il nome completo dell'assembly per il <xref:System.Type.GetType%2A> metodo. Ad esempio, se un tipo è denominato `Strange]Type`, il carattere di escape deve essere aggiunto prima la parentesi quadra come segue: `Strange\]Type`.  
  
> [!NOTE]
>  I nomi con caratteri speciali non possono essere creati in Visual Basic o c#, ma possono essere creati utilizzando Microsoft intermediate language (MSIL) o creazione di assembly dinamici.  
  
 Nella tabella seguente mostra i caratteri speciali per i nomi dei tipi.  
  
|Carattere|Significato|  
|---------------|-------------|  
|`,` (virgola)|Delimitatore per i nomi completi di assembly.|  
|`[]` (le parentesi quadre)|Come una coppia di suffisso, indica un tipo di matrice. come una coppia di delimitatori racchiude elenchi di argomenti generici e nomi completi di assembly.|  
|`&` e commerciale (&)|Come un suffisso, indica che un tipo è un tipo di riferimento.|  
|`*` (asterisco)|Come un suffisso, indica che un tipo è un tipo di puntatore.|  
|`+` (più)|Delimitatore per i tipi annidati.|  
|`\` (barra rovesciata)|Carattere di escape.|  
  
 Proprietà, ad esempio <xref:System.Type.AssemblyQualifiedName%2A> restituito corretto carattere di escape stringhe. È necessario passare stringhe con caratteri di escape in modo corretto per il <xref:System.Type.GetType%2A> metodo. A sua volta, il <xref:System.Type.GetType%2A> metodo passa i nomi correttamente forzati a `typeResolver` e per i metodi di risoluzione del tipo predefinito. Se è necessario confrontare un nome a un nome senza caratteri escape in `typeResolver`, è necessario rimuovere i caratteri di escape.  
  
 Torna alla [note sull'utilizzo](#usage_notes).  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>Risoluzione dei nomi misto  
 Nella tabella seguente sono riepilogate le interazioni tra `assemblyResolver`, `typeResolver`e la risoluzione dei nomi predefinito per tutte le combinazioni di nome del tipo e assembly in `typeName`:  
  
|Contenuto del nome del tipo|Metodo resolver degli assembly|Metodo con tipo di sistema di risoluzione|Risultato|  
|---------------------------|------------------------------|--------------------------|------------|  
|tipo di assembly|Null|Null|Equivale a chiamare il <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> overload del metodo.|  
|tipo di assembly|fornito|Null|`assemblyResolver` Restituisce l'assembly oppure `null` se risulta impossibile risolvere l'assembly. Se l'assembly viene risolto, il <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> overload del metodo viene utilizzato per caricare il tipo dell'assembly; in caso contrario, non viene eseguito alcun tentativo per risolvere il tipo.|  
|tipo di assembly|Null|fornito|Equivale alla conversione il nome dell'assembly in un <xref:System.Reflection.AssemblyName> oggetto e la chiamata di <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> overload del metodo per ottenere l'assembly. Se l'assembly viene risolto, viene passato a `typeResolver`; in caso contrario, `typeResolver` non viene chiamato e non esiste nessun ulteriore tentativo di risolvere il tipo.|  
|tipo di assembly|fornito|fornito|`assemblyResolver` Restituisce l'assembly oppure `null` se risulta impossibile risolvere l'assembly. Se l'assembly viene risolto, viene passato a `typeResolver`; in caso contrario, `typeResolver` non viene chiamato e non esiste nessun ulteriore tentativo di risolvere il tipo.|  
|tipo|null, fornito|Null|Equivale a chiamare il <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> overload del metodo. Poiché il nome dell'assembly non viene fornito, viene effettuata la ricerca solo mscorlib. dll e assembly attualmente in esecuzione. Se `assemblyResolver` viene fornito, viene ignorato.|  
|tipo|null, fornito|fornito|`typeResolver` viene chiamato e `null` viene passato per l'assembly. `typeResolver` può fornire un tipo da qualsiasi assembly, inclusi gli assembly caricati per lo scopo. Se `assemblyResolver` viene fornito, viene ignorato.|  
|assembly|null, fornito|null, fornito|Oggetto <xref:System.IO.FileLoadException> viene generata, perché il nome dell'assembly viene analizzato come se fosse un nome di tipo qualificato dall'assembly. Ciò comporta un nome di assembly non valido.|  
  
 Torna alla: [note sull'utilizzo](#usage_notes), [risoluzione degli assembly](#resolving_assemblies), [la risoluzione dei tipi](#resolving_types).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Viene richiamato un inizializzatore di classi e viene generata un'eccezione.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> è <see langword="true" /> e il tipo non è stato trovato.  
  
 oppure  
  
 <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> contiene caratteri non validi, ad esempio una scheda incorporata.  
  
 oppure  
  
 <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> è una stringa vuota.  
  
 oppure  
  
 <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> rappresenta un tipo di matrice con una dimensione non valida.  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta una matrice di <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">Si verifica un errore quando <paramref name="typeName" /> viene analizzato in un nome del tipo e un nome dell'assembly (ad esempio, quando il nome del tipo semplice include un carattere speciale senza codice di escape).  
  
 oppure  
  
 <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> contiene sintassi non valida (ad esempio, "MyType [,*,]").  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta un tipo generico che ha un tipo di puntatore, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> tra i relativi argomenti di tipo.  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta un tipo generico che ha un numero errato di argomenti di tipo.  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta un tipo generico e uno dei relativi argomenti di tipo non soddisfa i vincoli per il parametro di tipo corrispondente.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> è <see langword="true" /> e l'assembly o una delle sue dipendenze non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">L'assembly o una delle relative dipendenze è stato trovato, ma non può essere caricato.  
  
 oppure  
  
 <paramref name="typeName" /> contiene un nome dell'assembly non valido.  
  
 oppure  
  
 <paramref name="typeName" /> è un nome dell'assembly valido senza un nome di tipi.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly o una delle relative dipendenze non è valido.  
  
 oppure  
  
 L'assembly è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">Matrice di oggetti i cui tipi devono essere determinati.</param>
        <summary>Ottiene i tipi di oggetti nella matrice specificata.</summary>
        <returns>Matrice di oggetti <see cref="T:System.Type" /> che rappresentano i tipi degli elementi corrispondenti in <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Type.GetTypeArray%2A> metodo elenco dei tipi degli elementi della matrice.  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> è <see langword="null" />.  
  
 oppure  
  
 Uno o più degli elementi in <paramref name="args" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Gli inizializzatori di classi vengono richiamati e almeno uno genera un'eccezione.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Tipo il cui codice di tipo sottostante deve essere ottenuto.</param>
        <summary>Ottiene il codice di tipo sottostante dell'oggetto <see cref="T:System.Type" /> specificato.</summary>
        <returns>Codice del tipo sottostante o <see cref="F:System.TypeCode.Empty" /> se <paramref name="type" /> è <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si eredita da <xref:System.Type>, è possibile modificare il comportamento di questo metodo eseguendo l'override di <xref:System.Type.GetTypeCodeImpl%2A> metodo.  
  
   
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato come la <xref:System.TypeCode> enumerazione può essere utilizzata. In un blocco decisionale all'interno di `WriteObjectInfo` (metodo), il <xref:System.TypeCode> di un <xref:System.Object> parametro viene esaminato e viene scritto un messaggio appropriato nella console.  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il codice del tipo sottostante di questa istanza di <see cref="T:System.Type" />.</summary>
        <returns>Codice del tipo sottostante.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo fornisce l'implementazione per il `static` (in c#) o `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> metodo. Quando si eredita da <xref:System.Type>, è possibile eseguire l'override di questo metodo per fornire la propria implementazione di <xref:System.Type.GetTypeCode%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene il tipo associato all'identificatore di classe specificato (CLSID).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">CLSID del tipo da ottenere.</param>
        <summary>Ottiene il tipo associato all'identificatore di classe specificato (CLSID).</summary>
        <returns>
          <see langword="System.__ComObject" /> indipendentemente dalla validità del CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.GetTypeFromCLSID%2A> metodo supporta l'accesso ad associazione tardiva a oggetti COM non gestiti da applicazioni .NET Framework quando si conosce l'identificatore di classe dell'oggetto COM (CLSID).  L'identificatore di classe per le classi COM è definito nella chiave HKEY_CLASSES_ROOT\CLSID del Registro di sistema. È possibile recuperare il valore di <xref:System.Type.IsCOMObject%2A> proprietà per determinare se il tipo restituito da questo metodo è un oggetto COM.  
  
> [!TIP]
>  È possibile chiamare il <xref:System.Type.GetTypeFromProgID%2A> metodo per l'accesso ad associazione tardiva a COM il cui identificatore programmatico (ProgID) si è certi di oggetti.  
  
 Creazione di un oggetto COM non gestito dal relativo CLSID è un processo in due passaggi:  
  
1.  Ottenere un <xref:System.Type> oggetto che rappresenta il`__ComObject` che corrisponde al CLSID chiamando il <xref:System.Type.GetTypeFromCLSID%2A> metodo.  
  
2.  Chiamare il <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metodo per creare un'istanza dell'oggetto COM.  
  
 Vedere l'esempio per un'illustrazione.  
  
 Il <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> overload ignora qualsiasi eccezione che può verificarsi quando si crea un <xref:System.Type> basato sul `clsid` argomento. Si noti che viene generata alcuna eccezione se `clsid` non viene trovato nel Registro di sistema.  
  
   
  
## Examples  
 Nell'esempio seguente usa il CLSID di Microsoft Word [oggetto applicazione](http://msdn.microsoft.com/library/office/ff838565.aspx) per recuperare un tipo COM che rappresenta l'applicazione di Microsoft Word. Quindi creata un'istanza del tipo chiamando il <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> (metodo) e chiude chiamando il [Application. Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) (metodo).  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Questo metodo è destinato all'uso quando si lavora con gli oggetti COM, non con gli oggetti di .NET Framework. Tutti oggetti gestiti, inclusi quelli che sono visibili a COM (vale a dire i <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attributo è <see langword="true" />) un GUID che viene restituito dal <see cref="P:System.Type.GUID" /> proprietà. Anche se il metodo restituisce un <see cref="T:System.Type" /> oggetto che corrisponde al GUID di .NET Framework gli oggetti, non è possibile utilizzare <see cref="T:System.Type" /> oggetto per creare un'istanza del tipo chiamando il <see cref="M:System.Activator.CreateInstance(System.Type)" /> metodo, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 Al contrario, il <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> deve essere utilizzata solo per recuperare il GUID di un oggetto COM non gestito e il valore risultante <see cref="T:System.Type" /> oggetto passato per il <see cref="M:System.Activator.CreateInstance(System.Type)" /> method deve rappresentare un oggetto COM non gestito.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">CLSID del tipo da ottenere.</param>
        <param name="throwOnError">
          <see langword="true" /> per generare qualsiasi eccezione si verifichi.  
  
 oppure  
  
 <see langword="false" /> per ignorare qualsiasi eccezione si verifichi.</param>
        <summary>Ottiene il tipo associato all'identificatore di classe specificato (CLSID) e indica se generare un'eccezione qualora si verifichi un errore durante il caricamento del tipo.</summary>
        <returns>
          <see langword="System.__ComObject" /> indipendentemente dalla validità del CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.GetTypeFromCLSID%2A> metodo supporta l'accesso ad associazione tardiva a oggetti COM non gestiti da applicazioni .NET Framework quando si conosce l'identificatore di classe dell'oggetto COM (CLSID).  L'identificatore di classe per le classi COM è definito nella chiave HKEY_CLASSES_ROOT\CLSID del Registro di sistema. È possibile recuperare il valore di <xref:System.Type.IsCOMObject%2A> proprietà per determinare se il tipo restituito da questo metodo è un oggetto COM.  
  
> [!TIP]
>  È possibile chiamare il <xref:System.Type.GetTypeFromProgID%2A> metodo per l'accesso ad associazione tardiva a COM il cui identificatore programmatico (ProgID) si è certi di oggetti.  
  
 Creazione di un oggetto COM non gestito dal relativo CLSID è un processo in due passaggi:  
  
1.  Ottenere un <xref:System.Type> oggetto che rappresenta il `__ComObject` che corrisponde al CLSID chiamando il <xref:System.Type.GetTypeFromCLSID%2A> metodo.  
  
2.  Chiamare il <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metodo per creare un'istanza dell'oggetto COM.  
  
 Vedere l'esempio per un'illustrazione.  
  
 Eccezioni, ad esempio <xref:System.OutOfMemoryException> viene generata quando si specifica `true` per `throwOnError`, ma non avrà esito negativo per il CLSID di annullare la registrazione.  
  
   
  
## Examples  
 Nell'esempio seguente usa il CLSID di Microsoft Word [oggetto applicazione](http://msdn.microsoft.com/library/office/ff838565.aspx) per recuperare un tipo COM che rappresenta l'applicazione di Microsoft Word. Quindi creata un'istanza del tipo chiamando il <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> (metodo) e chiude chiamando il [Application. Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) (metodo). Se si verifica un errore durante il caricamento del tipo, viene generata un'eccezione.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Questo metodo è destinato all'uso quando si lavora con gli oggetti COM, non con gli oggetti di .NET Framework. Tutti oggetti gestiti, inclusi quelli che sono visibili a COM (vale a dire i <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attributo è <see langword="true" />) un GUID che viene restituito dal <see cref="P:System.Type.GUID" /> proprietà. Anche se il metodo restituisce un <see cref="T:System.Type" /> oggetto che corrisponde al GUID di .NET Framework gli oggetti, non è possibile utilizzare <see cref="T:System.Type" /> oggetto per creare un'istanza del tipo chiamando il <see cref="M:System.Activator.CreateInstance(System.Type)" /> metodo, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 Al contrario, il <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> deve essere utilizzata solo per recuperare il GUID di un oggetto COM non gestito e il valore risultante <see cref="T:System.Type" /> oggetto passato per il <see cref="M:System.Activator.CreateInstance(System.Type)" /> method deve rappresentare un oggetto COM non gestito.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">CLSID del tipo da ottenere.</param>
        <param name="server">Server da cui caricare il tipo. Se il nome del server è <see langword="null" />, il metodo verrà automaticamente ripristinato sul computer locale.</param>
        <summary>Ottiene il tipo associato all'identificatore di classe specificato (CLSID) dal server specificato.</summary>
        <returns>
          <see langword="System.__ComObject" /> indipendentemente dalla validità del CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.GetTypeFromCLSID%2A> metodo supporta l'accesso ad associazione tardiva a oggetti COM non gestiti da applicazioni .NET Framework quando si conosce l'identificatore di classe dell'oggetto COM (CLSID).  L'identificatore di classe per le classi COM è definito nella chiave HKEY_CLASSES_ROOT\CLSID del Registro di sistema. È possibile recuperare il valore di <xref:System.Type.IsCOMObject%2A> proprietà per determinare se il tipo restituito da questo metodo è un oggetto COM.  
  
> [!TIP]
>  È possibile chiamare il <xref:System.Type.GetTypeFromProgID%2A> metodo per l'accesso ad associazione tardiva a COM il cui identificatore programmatico (ProgID) si è certi di oggetti.  
  
 Creazione di un oggetto COM non gestito dal relativo CLSID è un processo in due passaggi:  
  
1.  Ottenere un <xref:System.Type> oggetto che rappresenta il `__ComObject` che corrisponde al CLSID chiamando il <xref:System.Type.GetTypeFromCLSID%2A> metodo.  
  
2.  Chiamare il <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metodo per creare un'istanza dell'oggetto COM.  
  
   
  
## Examples  
 Nell'esempio seguente usa il CLSID di Microsoft Word [oggetto applicazione](http://msdn.microsoft.com/library/office/ff838565.aspx) per recuperare un tipo COM che rappresenta l'applicazione di Microsoft Word da un server denominato computer17.central.contoso.com. Quindi creata un'istanza del tipo chiamando il <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> (metodo) e chiude chiamando il [Application. Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) (metodo).  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Questo metodo è destinato all'uso quando si lavora con gli oggetti COM, non con gli oggetti di .NET Framework. Tutti oggetti gestiti, inclusi quelli che sono visibili a COM (vale a dire i <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attributo è <see langword="true" />) un GUID che viene restituito dal <see cref="P:System.Type.GUID" /> proprietà. Anche se il metodo restituisce un <see cref="T:System.Type" /> oggetto che corrisponde al GUID di .NET Framework gli oggetti, non è possibile utilizzare <see cref="T:System.Type" /> oggetto per creare un'istanza del tipo chiamando il <see cref="M:System.Activator.CreateInstance(System.Type)" /> metodo, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 Al contrario, il <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> deve essere utilizzata solo per recuperare il GUID di un oggetto COM non gestito e il valore risultante <see cref="T:System.Type" /> oggetto passato per il <see cref="M:System.Activator.CreateInstance(System.Type)" /> method deve rappresentare un oggetto COM non gestito.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">CLSID del tipo da ottenere.</param>
        <param name="server">Server da cui caricare il tipo. Se il nome del server è <see langword="null" />, il metodo verrà automaticamente ripristinato sul computer locale.</param>
        <param name="throwOnError">
          <see langword="true" /> per generare qualsiasi eccezione si verifichi.  
  
 oppure  
  
 <see langword="false" /> per ignorare qualsiasi eccezione si verifichi.</param>
        <summary>Ottiene il tipo associato all'identificatore di classe specificato (CLSID) dal server specificato e indica se generare un'eccezione in caso di errore durante il caricamento del tipo.</summary>
        <returns>
          <see langword="System.__ComObject" /> indipendentemente dalla validità del CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.GetTypeFromCLSID%2A> metodo supporta l'accesso ad associazione tardiva a oggetti COM non gestiti da applicazioni .NET Framework quando si conosce l'identificatore di classe dell'oggetto COM (CLSID).  L'identificatore di classe per le classi COM è definito nella chiave HKEY_CLASSES_ROOT\CLSID del Registro di sistema. È possibile recuperare il valore di <xref:System.Type.IsCOMObject%2A> proprietà per determinare se il tipo restituito da questo metodo è un oggetto COM.  
  
> [!TIP]
>  È possibile chiamare il <xref:System.Type.GetTypeFromProgID%2A> metodo per l'accesso ad associazione tardiva a COM il cui identificatore programmatico (ProgID) si è certi di oggetti.  
  
 Creazione di un oggetto COM non gestito dal relativo CLSID è un processo in due passaggi:  
  
1.  Ottenere un <xref:System.Type> oggetto che rappresenta il `__ComObject` che corrisponde al CLSID chiamando il <xref:System.Type.GetTypeFromCLSID%2A> metodo.  
  
2.  Chiamare il <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metodo per creare un'istanza dell'oggetto COM.  
  
 Eccezioni, ad esempio <xref:System.OutOfMemoryException> viene generata quando si specifica `true` per `throwOnError`, ma non avrà esito negativo per il CLSID di annullare la registrazione.  
  
   
  
## Examples  
 Nell'esempio seguente usa il CLSID di Microsoft Word [oggetto applicazione](http://msdn.microsoft.com/library/office/ff838565.aspx) per recuperare un tipo COM che rappresenta l'applicazione di Microsoft Word da un server denominato computer17.central.contoso.com. Quindi creata un'istanza del tipo chiamando il <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> (metodo) e chiude chiamando il [Application. Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) (metodo). Se si verifica un errore durante il caricamento del tipo, viene generata un'eccezione.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Questo metodo è destinato all'uso quando si lavora con gli oggetti COM, non con gli oggetti di .NET Framework. Tutti oggetti gestiti, inclusi quelli che sono visibili a COM (vale a dire i <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attributo è <see langword="true" />) un GUID che viene restituito dal <see cref="P:System.Type.GUID" /> proprietà. Sebbene il <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> metodo restituisce un <see cref="T:System.Type" /> oggetto che corrisponde al GUID di un determinato oggetto gestito, non è possibile utilizzare <see cref="T:System.Type" /> oggetto per creare un'istanza del tipo chiamando il <see cref="M:System.Activator.CreateInstance(System.Type)" /> metodo, come nell'esempio seguente Mostra.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 Al contrario, il <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> deve essere utilizzata solo per recuperare il GUID di un oggetto COM non gestito e il valore risultante <see cref="T:System.Type" /> oggetto passato per il <see cref="M:System.Activator.CreateInstance(System.Type)" /> method deve rappresentare un oggetto COM non gestito.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Oggetto che fa riferimento al tipo.</param>
        <summary>Ottiene il tipo a cui fa riferimento l'handle del tipo specificato.</summary>
        <returns>Tipo al quale l'oggetto <see cref="T:System.RuntimeTypeHandle" /> specificato fa riferimento, oppure <see langword="null" /> se la proprietà <see cref="P:System.RuntimeTypeHandle.Value" /> di <paramref name="handle" /> è <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli handle sono validi solo nel dominio dell'applicazione in cui sono stati ottenuti.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Type.GetTypeFromHandle%2A> metodo per ottenere un <xref:System.Type> dell'oggetto da un <xref:System.RuntimeTypeHandle> fornito dal <xref:System.Type.GetTypeHandle%2A> metodo.  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Viene richiamato un inizializzatore di classi e viene generata un'eccezione.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ottiene il tipo associato all'ID di programma specificato (ProgID).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">ProgID del tipo da ottenere.</param>
        <summary>Ottiene il tipo associato all'ID di programma specificato (ProgID), restituendo Null se si verifica un errore durante il caricamento dell'oggetto <see cref="T:System.Type" />.</summary>
        <returns>Tipo associato al ProgID specificato, se <paramref name="progID" /> è una voce valida del Registro di sistema e vi è associato un tipo; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per il supporto COM. ProgID non sono utilizzati in Microsoft .NET Framework, perché sono stati sostituiti dal concetto di spazio dei nomi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">ProgID del tipo da ottenere.</param>
        <param name="throwOnError">
          <see langword="true" /> per generare qualsiasi eccezione si verifichi.  
  
 oppure  
  
 <see langword="false" /> per ignorare qualsiasi eccezione si verifichi.</param>
        <summary>Ottiene il tipo associato all'ID di programma specificato (ProgID) e indica se generare un'eccezione qualora si verifichi un errore durante il caricamento del tipo.</summary>
        <returns>Tipo associato all'ID di programma specificato (ProgID) se <paramref name="progID" /> è una voce valida del Registro di sistema e vi è associato un tipo; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per il supporto COM. Gli ID di programma non sono utilizzati in Microsoft .NET Framework, perché sono stati sostituiti dal concetto di spazio dei nomi.  
  
   
  
## Examples  
 Nell'esempio seguente recupera un tipo passando un ProgID, che specifica se generare un'eccezione se il valore ProgID non valido. Viene quindi visualizzato il ClassID relativa al ProgID, insieme a eventuali messaggi di eccezione applicabili.  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Il ProgID specificato non è registrato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">ProgID del tipo da ottenere.</param>
        <param name="server">Server da cui caricare il tipo. Se il nome del server è <see langword="null" />, il metodo verrà automaticamente ripristinato sul computer locale.</param>
        <summary>Ottiene il tipo associato all'ID di programma (ProgID) specificato dal server specificato, restituendo Null se si verifica un errore durante il caricamento del tipo.</summary>
        <returns>Tipo associato all'ID di programma specificato (ProgID) se <paramref name="progID" /> è una voce valida del Registro di sistema e vi è associato un tipo; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per il supporto COM. Gli ID di programma non sono utilizzati in Microsoft .NET Framework, perché sono stati sostituiti dal concetto di spazio dei nomi.  
  
   
  
## Examples  
 Nell'esempio seguente recupera un tipo passando un nome del ProgID e un server. Nell'esempio viene quindi visualizzato il ClassID correlato al ProgID o genera un'eccezione se il valore ProgID o il nome del server non è valido.  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="prodID" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">ProgID dell'oggetto <see cref="T:System.Type" /> da ottenere.</param>
        <param name="server">Server da cui caricare il tipo. Se il nome del server è <see langword="null" />, il metodo verrà automaticamente ripristinato sul computer locale.</param>
        <param name="throwOnError">
          <see langword="true" /> per generare qualsiasi eccezione si verifichi.  
  
 oppure  
  
 <see langword="false" /> per ignorare qualsiasi eccezione si verifichi.</param>
        <summary>Ottiene il tipo associato all'ID di programma specificato (ProgID) dal server specificato e indica se generare un'eccezione qualora si verifichi un errore durante il caricamento del tipo.</summary>
        <returns>Tipo associato all'ID di programma specificato (ProgID) se <paramref name="progID" /> è una voce valida del Registro di sistema e vi è associato un tipo; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per il supporto COM. Gli ID di programma non sono utilizzati in Microsoft .NET Framework, perché sono stati sostituiti dal concetto di spazio dei nomi.  
  
   
  
## Examples  
 Nell'esempio seguente recupera un tipo passando un nome del ProgID e un server. Viene quindi visualizzato il ClassID relativa al ProgID, che specifica se generare un'eccezione se il valore ProgID o il nome del server non è valido.  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Il progID specificato non è registrato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Oggetto per il quale ottenere l'handle di tipo.</param>
        <summary>Ottiene l'handle per l'oggetto <see cref="T:System.Type" /> di un oggetto specificato.</summary>
        <returns>Handle per l'oggetto <see cref="T:System.Type" /> del <see cref="T:System.Object" /> specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli handle sono validi solo nel dominio dell'applicazione in cui sono stati ottenuti.  
  
   
  
## Examples  
 L'esempio seguente definisce la classe `MyClass1`, ottiene un'istanza e recupera l'handle di runtime dell'oggetto.  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il GUID associato all'oggetto <see cref="T:System.Type" />.</summary>
        <value>GUID associato all'oggetto <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un GUID è associato un tipo utilizzando il <xref:System.Runtime.InteropServices.GuidAttribute> attributo.  
  
   
  
## Examples  
 L'esempio seguente crea la classe `MyClass1` con un metodo pubblico, viene creato un `Type` oggetto corrispondente a `MyClass1`e ottiene il <xref:System.Guid> struttura utilizzando il `GUID` proprietà del `Type` classe.  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Type" /> corrente comprende o si riferisce a un altro tipo, ovvero se l'oggetto <see cref="T:System.Type" /> corrente è una matrice, un puntatore o viene passato per riferimento.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Type" /> è una matrice, un puntatore oppure è passato per riferimento; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ad esempio, Type.GetType("Int32[]"). HasElementType restituisce `true`, ma Type.GetType("Int32"). HasElementType restituisce `false`. HasElementType restituisce `true` per "Int32 *" e "Int32 &".  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico o un parametro di tipo nella definizione di un tipo generico o un metodo generico, questa proprietà restituisce sempre `false`.  
  
   
  
## Examples  
 L'esempio seguente restituisce `true` o `false` a seconda se l'oggetto è una matrice, un tipo riferimento o puntatore.  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, implementa la proprietà <see cref="P:System.Type.HasElementType" /> e determina se l'oggetto <see cref="T:System.Type" /> corrente include o contiene riferimenti a un altro tipo, ovvero se l'oggetto <see cref="T:System.Type" /> corrente è costituito da una matrice o da un puntatore o è passato come riferimento.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Type" /> è una matrice, un puntatore oppure è passato per riferimento; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ad esempio, Type.GetType("Int32[]"). HasElementTypeImpl restituisce `true`, ma Type.GetType("Int32"). HasElementTypeImpl restituisce `false`. HasElementTypeImpl restituisce `true` per "Int32 *" e "Int32 &".  
  
   
  
## Examples  
 L'esempio seguente definisce la classe `MyTypeDelegator`, che esegue l'override di `HasElementTypeImpl` metodo. La classe principale cerca di `HasElementType` proprietà e consente di visualizzare il tipo di elemento.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Richiama un membro specifico dell'oggetto <see cref="T:System.Type" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome del costruttore, del metodo, della proprietà o del membro del campo da richiamare.  
  
 oppure  
  
 Stringa vuota ("") per richiamare il membro predefinito.  
  
 oppure  
  
 Per i membri <see langword="IDispatch" />, stringa che rappresenta DispID, ad esempio "[DispID=3]".</param>
        <param name="invokeAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca. L'accesso può essere uno dei <see langword="BindingFlags" />, ad esempio <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> e così via. Il tipo di ricerca non deve essere specificato. Se il tipo di ricerca viene omesso, vengono usati <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />.</param>
        <param name="binder">Oggetto che definisce una serie di proprietà e permette il binding, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.  
  
 oppure  
  
 Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />. Si noti che potrebbe essere necessario definire in modo esplicito un oggetto <see cref="T:System.Reflection.Binder" /> per richiamare correttamente overload di metodo con argomenti variabili.</param>
        <param name="target">Oggetto su cui richiamare il membro specificato.</param>
        <param name="args">Matrice che contiene gli argomenti da passare al membro da richiamare.</param>
        <summary>Chiama il membro specificato, usando i vincoli di associazione specificati e associando l'elenco di argomenti specificato.</summary>
        <returns>Oggetto che rappresenta il valore restituito di un membro richiamato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Non è possibile utilizzare <xref:System.Type.InvokeMember%2A> per richiamare un metodo generico.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire i membri da includere nella ricerca:  
  
-   Specificare `BindingFlags.Public` per includere i membri pubblici nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere i membri non pubblici (ovvero, i membri privati e protetti) nella ricerca.  
  
-   Specificare `BindingFlags.FlattenHierarchy` per includere i membri statici nella gerarchia.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare le modalità di ricerca:  
  
-   `BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.  
  
-   `BindingFlags.DeclaredOnly` Per cercare solo i membri dichiarati nel <xref:System.Type>, non i membri sono stati ereditati.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di chiamata può essere utilizzato per indicare l'azione da intraprendere con il membro:  
  
-   `CreateInstance` per richiamare un costruttore. `name` viene ignorato. Non è valido con altri flag di chiamata.  
  
-   `InvokeMethod` per richiamare un metodo, ma non un costruttore o un inizializzatore di tipo. Non è valido con `SetField` o `SetProperty`. Se `InvokeMethod` è specificato da solo, `BindingFlags.Public`, `BindingFlags.Instance`, e `BindingFlags.Static` vengono inclusi automaticamente.  
  
-   `GetField` Per ottenere il valore di un campo. Non è valido con `SetField`.  
  
-   `SetField` Per impostare il valore di un campo. Non è valido con `GetField`.  
  
-   `GetProperty` Per ottenere una proprietà. Non è valido con `SetProperty`.  
  
-   `SetProperty` Per impostare una proprietà. Non è valido con `GetProperty`.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Verrà richiamato un metodo se si verificano entrambe le condizioni seguenti:  
  
-   Il numero di parametri della dichiarazione del metodo è uguale al numero di argomenti in di `args` matrice (a meno che gli argomenti predefiniti vengono definiti sul membro e `BindingFlags.OptionalParamBinding` è specificato).  
  
-   Il tipo di ciascun argomento può essere convertito dal gestore di associazione per il tipo del parametro.  
  
 Lo strumento di associazione troverà tutti i metodi di corrispondenza. Questi metodi vengono rilevati in base al tipo di associazione richiesta (<xref:System.Reflection.BindingFlags> valori `InvokeMethod`, `GetProperty`e così via). Il set di metodi verrà filtrato per il nome, numero di argomenti e un set di modificatori di ricerca definiti nel gestore di associazione.  
  
 Dopo aver selezionato il metodo, viene richiamato. A questo punto viene controllato l'accesso facilitato. È possibile specificare quale set di metodi vengono ricercati in base all'attributo di accessibilità associato al metodo. Il <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> metodo il <xref:System.Reflection.Binder> è responsabile della selezione del metodo da richiamare. Il binder predefinito consente di selezionare la corrispondenza più specifica.  
  
 Restrizioni di accesso vengono ignorate per il codice completamente attendibile. ovvero costruttori privati, metodi, campi e proprietà accessibili e richiamate tramite <xref:System.Reflection> ogni volta che il codice è completamente attendibile.  
  
 È possibile utilizzare `Type.InvokeMember` per impostare un campo a un determinato valore specificando <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Ad esempio, se si desidera impostare un campo di istanza pubblica denominato F sulla classe C e F è un `String`, è possibile usare codice, ad esempio:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 Se F è un `String[]`, è possibile usare codice, ad esempio:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 in modo da inizializzare il campo F su questa nuova matrice. È inoltre possibile utilizzare `Type.InvokeMember` per impostare una posizione in una matrice fornendo l'indice del valore e quindi il valore successivo utilizzando codice simile al seguente:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 Stringa "z" nella matrice che contiene F alla stringa "b" verrà modificato.  
  
 Quando si richiama un `IDispatch` membro, è possibile specificare il DispID anziché il nome di membro, utilizzando il formato della stringa "[DispID = # #]". Ad esempio, se il DispID di MyComMethod è 3, è possibile specificare la stringa "[DispID = 3]" anziché "MyComMethod". Richiamare un membro da DispID è più veloce rispetto alla ricerca del membro in base al nome. In scenari complessi di aggregazione, talvolta il DispID è l'unico modo per richiamare il membro desiderato.  
  
> [!NOTE]
>  A partire dal [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a membri pubblici, se il chiamante è stato concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag e se il set di concessioni dei membri non pubblici è limitato al chiamante o a un sottoinsieme Questi due elementi. (Vedere [considerazioni sulla sicurezza per la Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 L'esempio seguente usa `InvokeMember` per accedere ai membri di un tipo.  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> non contiene <see langword="CreateInstance" /> e <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" /> non è un attributo valido di <see cref="T:System.Reflection.BindingFlags" />.  
  
 oppure  
  
 <paramref name="invokeAttr" /> non contiene uno dei flag di binding seguenti: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.  
  
 oppure  
  
 <paramref name="invokeAttr" /> contiene <see langword="CreateInstance" /> in combinazione con <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.  
  
 oppure  
  
 <paramref name="invokeAttr" /> contiene sia <see langword="GetField" /> che <see langword="SetField" />.  
  
 oppure  
  
 <paramref name="invokeAttr" /> contiene sia <see langword="GetProperty" /> che <see langword="SetProperty" />.  
  
 oppure  
  
 <paramref name="invokeAttr" /> contiene <see langword="InvokeMethod" /> in combinazione con <see langword="SetField" /> o <see langword="SetProperty" />.  
  
 oppure  
  
 <paramref name="invokeAttr" /> contiene <see langword="SetField" /> e <paramref name="args" /> include più elementi.  
  
 oppure  
  
 Questo metodo è stato chiamato su un oggetto COM e uno dei flag di binding seguenti non è stato passato: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> o <see langword="BindingFlags.PutRefDispProperty" />.  
  
 oppure  
  
 Una delle matrici di parametri denominati contiene una stringa <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">Il membro specificato è un inizializzatore di classi.</exception>
        <exception cref="T:System.MissingFieldException">Non è possibile trovare il campo o la proprietà.</exception>
        <exception cref="T:System.MissingMethodException">Non è possibile trovare metodi corrispondenti agli argomenti in <paramref name="args" />.  
  
 oppure  
  
 L'oggetto <see cref="T:System.Type" /> corrente rappresenta un tipo che contiene parametri di tipo open, ovvero <see cref="P:System.Type.ContainsGenericParameters" /> restituisce <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">Non è possibile richiamare il metodo specificato su <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Più di un metodo corrisponde ai criteri di binding.</exception>
        <exception cref="T:System.NotSupportedException">Questo metodo non è attualmente supportato in .NET Compact Framework.</exception>
        <exception cref="T:System.InvalidOperationException">Il metodo rappresentato da <paramref name="name" /> include uno o più parametri di tipo generico non specificati. In altri termini, la proprietà <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> del metodo restituisce <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per l'accesso a membri non pubblici indipendentemente dalle autorizzazioni impostate. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome del costruttore, del metodo, della proprietà o del membro del campo da richiamare.  
  
 oppure  
  
 Stringa vuota ("") per richiamare il membro predefinito.  
  
 oppure  
  
 Per i membri <see langword="IDispatch" />, stringa che rappresenta DispID, ad esempio "[DispID=3]".</param>
        <param name="invokeAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca. L'accesso può essere uno dei <see langword="BindingFlags" />, ad esempio <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> e così via. Il tipo di ricerca non deve essere specificato. Se il tipo di ricerca viene omesso, vengono usati <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />.</param>
        <param name="binder">Oggetto che definisce una serie di proprietà e permette il binding, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.  
  
 oppure  
  
 Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />. Si noti che potrebbe essere necessario definire in modo esplicito un oggetto <see cref="T:System.Reflection.Binder" /> per richiamare correttamente overload di metodo con argomenti variabili.</param>
        <param name="target">Oggetto su cui richiamare il membro specificato.</param>
        <param name="args">Matrice che contiene gli argomenti da passare al membro da richiamare.</param>
        <param name="culture">Oggetto che rappresenta le impostazioni locali di globalizzazione da usare, che possono essere necessarie per conversioni specifiche delle impostazioni locali, ad esempio la conversione di un oggetto <see cref="T:System.String" /> numerico in <see cref="T:System.Double" />.  
  
 oppure  
  
 Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso dell'oggetto <see cref="T:System.Globalization.CultureInfo" /> del thread corrente.</param>
        <summary>Chiama il membro specificato, usando i vincoli di binding specificati e associando l'elenco di argomenti specificati e le impostazioni cultura.</summary>
        <returns>Oggetto che rappresenta il valore restituito di un membro richiamato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anche se il binder predefinito elabora <xref:System.Globalization.CultureInfo> (il `culture` parametro), è possibile utilizzare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per la scrittura di un gestore di associazione personalizzato che elaborano `culture`.  
  
> [!NOTE]
>  Non è possibile utilizzare <xref:System.Type.InvokeMember%2A> per richiamare un metodo generico.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire i membri da includere nella ricerca:  
  
-   Specificare `BindingFlags.Public` per includere i membri pubblici nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere i membri non pubblici (ovvero, i membri privati, interni e protetti) nella ricerca.  
  
-   Specificare `BindingFlags.FlattenHierarchy` per includere i membri statici nella gerarchia.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare le modalità di ricerca:  
  
-   `BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.  
  
-   `BindingFlags.DeclaredOnly` Per cercare solo i membri dichiarati nel <xref:System.Type>, non i membri sono stati ereditati.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di chiamata può essere utilizzato per indicare l'azione da intraprendere con il membro:  
  
-   `CreateInstance` per richiamare un costruttore. `name` viene ignorato. Non è valido con altri flag di chiamata.  
  
-   `InvokeMethod` per richiamare un metodo, ma non un costruttore o un inizializzatore di tipo. Non è valido con `SetField` o `SetProperty`. Se `InvokeMethod` è specificato da solo, `BindingFlags.Public`, `BindingFlags.Instance`, e `BindingFlags.Static` vengono inclusi automaticamente.  
  
-   `GetField` Per ottenere il valore di un campo. Non è valido con `SetField`.  
  
-   `SetField` Per impostare il valore di un campo. Non è valido con `GetField`.  
  
-   `GetProperty` Per ottenere una proprietà. Non è valido con `SetProperty`.  
  
-   `SetProperty` Per impostare una proprietà. Non è valido con `GetProperty`.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Verrà richiamato un metodo se si verificano entrambe le condizioni seguenti:  
  
-   Il numero di parametri della dichiarazione del metodo è uguale al numero di argomenti in di `args` matrice (a meno che gli argomenti predefiniti vengono definiti sul membro e `BindingFlags.OptionalParamBinding` è specificato).  
  
-   Il tipo di ciascun argomento può essere convertito dal gestore di associazione per il tipo del parametro.  
  
 Lo strumento di associazione troverà tutti i metodi di corrispondenza. Questi metodi vengono rilevati in base al tipo di associazione richiesta (<xref:System.Reflection.BindingFlags> valori `InvokeMethod`, `GetProperty`e così via). Il set di metodi verrà filtrato per il nome, numero di argomenti e un set di modificatori di ricerca definiti nel gestore di associazione.  
  
 Dopo aver selezionato il metodo, viene richiamato. A questo punto viene controllato l'accesso facilitato. È possibile specificare quale set di metodi vengono ricercati in base all'attributo di accessibilità associato al metodo. Il <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> metodo il <xref:System.Reflection.Binder> è responsabile della selezione del metodo da richiamare. Il binder predefinito consente di selezionare la corrispondenza più specifica.  
  
 Restrizioni di accesso vengono ignorate per il codice completamente attendibile. vale a dire, proprietà, metodi, campi e costruttori privati accessibili e richiamate tramite Reflection, ogni volta che il codice è completamente attendibile.  
  
 È possibile utilizzare `Type.InvokeMember` per impostare un campo a un determinato valore specificando <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Ad esempio, se si desidera impostare un campo di istanza pubblica denominato F sulla classe C e F è un `String` è possibile usare codice, ad esempio:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 Se F è un `String[]`, è possibile usare codice, ad esempio:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 in modo da inizializzare il campo F su questa nuova matrice. È inoltre possibile utilizzare `Type.InvokeMember` per impostare una posizione in una matrice fornendo l'indice del valore e quindi il valore successivo utilizzando codice simile al seguente:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 Stringa "z" nella matrice che contiene F alla stringa "b" verrà modificato.  
  
 Quando si richiama un `IDispatch` membro è possibile specificare il DispID anziché il nome di membro, utilizzando il formato della stringa "[DispID = # #]". Ad esempio, se il DispID di MyComMethod è 3, è possibile specificare la stringa "[DispID = 3]" anziché "MyComMethod". Richiamare un membro da DispID è più veloce rispetto alla ricerca del membro in base al nome. In scenari complessi di aggregazione, talvolta il DispID è l'unico modo per richiamare il membro desiderato.  
  
> [!NOTE]
>  A partire dal [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a membri pubblici, se il chiamante è stato concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag e se il set di concessioni dei membri non pubblici è limitato al chiamante o a un sottoinsieme Questi due elementi. (Vedere [considerazioni sulla sicurezza per la Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> non contiene <see langword="CreateInstance" /> e <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" /> non è un attributo valido di <see cref="T:System.Reflection.BindingFlags" />.  
  
 oppure  
  
 <paramref name="invokeAttr" /> non contiene uno dei flag di binding seguenti: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.  
  
 oppure  
  
 <paramref name="invokeAttr" /> contiene <see langword="CreateInstance" /> in combinazione con <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.  
  
 oppure  
  
 <paramref name="invokeAttr" /> contiene sia <see langword="GetField" /> che <see langword="SetField" />.  
  
 oppure  
  
 <paramref name="invokeAttr" /> contiene sia <see langword="GetProperty" /> che <see langword="SetProperty" />.  
  
 oppure  
  
 <paramref name="invokeAttr" /> contiene <see langword="InvokeMethod" /> in combinazione con <see langword="SetField" /> o <see langword="SetProperty" />.  
  
 oppure  
  
 <paramref name="invokeAttr" /> contiene <see langword="SetField" /> e <paramref name="args" /> include più elementi.  
  
 oppure  
  
 Questo metodo è stato chiamato su un oggetto COM e uno dei flag di binding seguenti non è stato passato: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> o <see langword="BindingFlags.PutRefDispProperty" />.  
  
 oppure  
  
 Una delle matrici di parametri denominati contiene una stringa <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">Il membro specificato è un inizializzatore di classi.</exception>
        <exception cref="T:System.MissingFieldException">Non è possibile trovare il campo o la proprietà.</exception>
        <exception cref="T:System.MissingMethodException">Non è possibile trovare metodi corrispondenti agli argomenti in <paramref name="args" />.  
  
 oppure  
  
 L'oggetto <see cref="T:System.Type" /> corrente rappresenta un tipo che contiene parametri di tipo open, ovvero <see cref="P:System.Type.ContainsGenericParameters" /> restituisce <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">Non è possibile richiamare il metodo specificato su <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Più di un metodo corrisponde ai criteri di binding.</exception>
        <exception cref="T:System.InvalidOperationException">Il metodo rappresentato da <paramref name="name" /> include uno o più parametri di tipo generico non specificati. In altri termini, la proprietà <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> del metodo restituisce <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per l'accesso a membri non pubblici indipendentemente dalle autorizzazioni impostate. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">Stringa che contiene il nome del costruttore, del metodo, della proprietà o del membro del campo da richiamare.  
  
 oppure  
  
 Stringa vuota ("") per richiamare il membro predefinito.  
  
 oppure  
  
 Per i membri <see langword="IDispatch" />, stringa che rappresenta DispID, ad esempio "[DispID=3]".</param>
        <param name="invokeAttr">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca. L'accesso può essere uno dei <see langword="BindingFlags" />, ad esempio <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> e così via. Il tipo di ricerca non deve essere specificato. Se il tipo di ricerca viene omesso, vengono usati <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />.</param>
        <param name="binder">Oggetto che definisce una serie di proprietà e permette il binding, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.  
  
 oppure  
  
 Riferimento Null (Nothing in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />. Si noti che potrebbe essere necessario definire in modo esplicito un oggetto <see cref="T:System.Reflection.Binder" /> per richiamare correttamente overload di metodo con argomenti variabili.</param>
        <param name="target">Oggetto su cui richiamare il membro specificato.</param>
        <param name="args">Matrice che contiene gli argomenti da passare al membro da richiamare.</param>
        <param name="modifiers">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresentano gli attributi associati all'elemento corrispondente nella matrice <c>args</c>. Gli attributi associati di un parametro sono archiviati nella firma digitale del membro.  
  
 Il binder predefinito elabora questo parametro solo quando si chiama un componente COM.</param>
        <param name="culture">Oggetto <see cref="T:System.Globalization.CultureInfo" /> che rappresenta le impostazioni locali da usare, che possono essere necessarie per conversioni specifiche delle impostazioni locali, ad esempio la conversione di un valore numerico da String a Double.  
  
 oppure  
  
 Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso dell'oggetto <see cref="T:System.Globalization.CultureInfo" /> del thread corrente.</param>
        <param name="namedParameters">Matrice contenente i nomi dei parametri a cui sono passati i valori della matrice <c>args</c>.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, richiama il membro specificato, usando i vincoli di binding specificati e associando l'elenco di argomenti, i modificatori e le impostazioni cultura specificati.</summary>
        <returns>Oggetto che rappresenta il valore restituito di un membro richiamato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember` chiama un membro di costruttore o un metodo, ottiene o imposta una proprietà del membro, ottiene o imposta un membro di campo di dati, o Ottiene o imposta un elemento di un membro di matrice.  
  
> [!NOTE]
>  Non è possibile utilizzare <xref:System.Type.InvokeMember%2A> per richiamare un metodo generico.  
  
 Quando si richiama un `IDispatch` membro è possibile specificare il DispID anziché il nome di membro, utilizzando il formato della stringa "[DispID = # #]". Ad esempio, se il DispID di MyComMethod è 3, è possibile specificare la stringa "[DispID = 3]" anziché "MyComMethod". Richiamare un membro da DispID è più veloce rispetto alla ricerca del membro in base al nome. In scenari complessi di aggregazione, talvolta il DispID è l'unico modo per richiamare il membro desiderato.  
  
 Anche se il binder predefinito elabora <xref:System.Reflection.ParameterModifier> o <xref:System.Globalization.CultureInfo> (il `modifiers` e `culture` parametri), è possibile utilizzare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per la scrittura di un gestore di associazione personalizzato che elaborano `modifiers` e `culture`. `ParameterModifier` viene utilizzato solo quando una chiamata tramite l'interoperabilità COM, e vengono gestiti solo i parametri che vengono passati per riferimento.  
  
 Tutti i parametri nella matrice `namedParameters` ottengono il valore nell'elemento corrispondente della matrice `args`. Se la lunghezza di `args` è superiore a quella di `namedParameters`, i valori degli argomenti rimanenti vengono passati in ordine.  
  
 Il `namedParameters` matrice può essere utilizzata per modificare l'ordine degli argomenti in una matrice di input. Ad esempio, poiché il metodo `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) e la matrice di input `{ 42, "x" }`, la matrice di input può essere passata invariata per `args` se la matrice `{ "b", "a" }` fornito per `namedParameters`.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire i membri da includere nella ricerca:  
  
-   Specificare `BindingFlags.Public` per includere i membri pubblici nella ricerca.  
  
-   Specificare `BindingFlags.NonPublic` per includere i membri non pubblici (ovvero, i membri privati, interni e protetti) nella ricerca.  
  
-   Specificare `BindingFlags.FlattenHierarchy` per includere i membri statici nella gerarchia.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare le modalità di ricerca:  
  
-   `BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.  
  
-   `BindingFlags.DeclaredOnly` Per cercare solo i membri dichiarati nel <xref:System.Type>, non i membri sono stati ereditati.  
  
 Le operazioni seguenti <xref:System.Reflection.BindingFlags> flag di chiamata può essere utilizzato per indicare l'azione da intraprendere con il membro:  
  
-   `CreateInstance` per richiamare un costruttore. `name` viene ignorato. Non è valido con altri flag di chiamata.  
  
-   `InvokeMethod` per richiamare un metodo, ma non un costruttore o un inizializzatore di tipo. Non è valido con `SetField` o `SetProperty`. Se `InvokeMethod` è specificato da solo, `BindingFlags.Public`, `BindingFlags.Instance`, e `BindingFlags.Static` vengono inclusi automaticamente.  
  
-   `GetField` Per ottenere il valore di un campo. Non è valido con `SetField`.  
  
-   `SetField` Per impostare il valore di un campo. Non è valido con `GetField`.  
  
-   `GetProperty` Per ottenere una proprietà. Non è valido con `SetProperty`.  
  
-   `SetProperty` Per impostare una proprietà. Non è valido con `GetProperty`.  
  
 Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Verrà richiamato un metodo se si verificano entrambe le condizioni seguenti:  
  
-   Il numero di parametri della dichiarazione del metodo è uguale al numero di argomenti in di `args` matrice (a meno che gli argomenti predefiniti vengono definiti sul membro e `BindingFlags.OptionalParamBinding` è specificato).  
  
-   Il tipo di ciascun argomento può essere convertito dal gestore di associazione per il tipo del parametro.  
  
 Lo strumento di associazione troverà tutti i metodi di corrispondenza. Questi metodi vengono rilevati in base al tipo di associazione richiesta (<xref:System.Reflection.BindingFlags> valori `InvokeMethod`, `GetProperty`e così via). Il set di metodi verrà filtrato per il nome, numero di argomenti e un set di modificatori di ricerca definiti nel gestore di associazione.  
  
 Dopo aver selezionato il metodo, viene richiamato. A questo punto viene controllato l'accesso facilitato. È possibile specificare quale set di metodi vengono ricercati in base all'attributo di accessibilità associato al metodo. Il <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> metodo il <xref:System.Reflection.Binder> è responsabile della selezione del metodo da richiamare. Il binder predefinito consente di selezionare la corrispondenza più specifica.  
  
 `InvokeMember` può essere utilizzato per richiamare metodi con parametri che hanno valori predefiniti. Per associare a questi metodi, la Reflection richiede <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> specificare. Per un parametro che ha un valore predefinito, è possibile specificare un valore diverso o fornire <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> per utilizzare il valore predefinito.  
  
 Si consideri ad esempio un metodo, ad esempio MyMethod (int x, y float = 2.0). Per richiamare questo metodo con il primo argomento come MyMethod (4), passare uno dei flag di associazione precedente e passare due argomenti, vale a dire, 4 per il primo argomento e `Missing.Value` per il secondo argomento. Se non si utilizza `Missing.Value`, non è possibile omettere i parametri facoltativi di `Invoke` metodo. Se necessario, utilizzare `InvokeMember` invece.  
  
 Restrizioni di accesso vengono ignorate per il codice completamente attendibile. ovvero costruttori privati, metodi, campi e proprietà accessibili e richiamate tramite <xref:System.Reflection> ogni volta che il codice è completamente attendibile.  
  
 È possibile utilizzare `Type.InvokeMember` per impostare un campo a un determinato valore specificando <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Ad esempio, se si desidera impostare un campo di istanza pubblica denominato F sulla classe C e F è un `String`, è possibile usare codice, ad esempio:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 Se F è un `String[]`, è possibile usare codice, ad esempio:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 in modo da inizializzare il campo F su questa nuova matrice. È inoltre possibile utilizzare `Type.InvokeMember` per impostare una posizione in una matrice fornendo l'indice del valore e quindi il valore successivo utilizzando codice simile al seguente:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 Stringa "z" nella matrice che contiene F alla stringa "b" verrà modificato.  
  
> [!NOTE]
>  A partire dal [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a membri pubblici, se il chiamante è stato concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag e se il set di concessioni dei membri non pubblici è limitato al chiamante o a un sottoinsieme Questi due elementi. (Vedere [considerazioni sulla sicurezza per la Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> non contiene <see langword="CreateInstance" /> e <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="args" /> e <paramref name="modifiers" /> non hanno la stessa lunghezza.  
  
 oppure  
  
 <paramref name="invokeAttr" /> non è un attributo valido di <see cref="T:System.Reflection.BindingFlags" />.  
  
 oppure  
  
 <paramref name="invokeAttr" /> non contiene uno dei flag di binding seguenti: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.  
  
 oppure  
  
 <paramref name="invokeAttr" /> contiene <see langword="CreateInstance" /> in combinazione con <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.  
  
 oppure  
  
 <paramref name="invokeAttr" /> contiene sia <see langword="GetField" /> che <see langword="SetField" />.  
  
 oppure  
  
 <paramref name="invokeAttr" /> contiene sia <see langword="GetProperty" /> che <see langword="SetProperty" />.  
  
 oppure  
  
 <paramref name="invokeAttr" /> contiene <see langword="InvokeMethod" /> in combinazione con <see langword="SetField" /> o <see langword="SetProperty" />.  
  
 oppure  
  
 <paramref name="invokeAttr" /> contiene <see langword="SetField" /> e <paramref name="args" /> include più elementi.  
  
 oppure  
  
 La matrice di parametri denominata è più grande della matrice di argomenti.  
  
 oppure  
  
 Questo metodo è stato chiamato su un oggetto COM e uno dei flag di binding seguenti non è stato passato: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> o <see langword="BindingFlags.PutRefDispProperty" />.  
  
 oppure  
  
 Una delle matrici di parametri denominati contiene una stringa <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">Il membro specificato è un inizializzatore di classi.</exception>
        <exception cref="T:System.MissingFieldException">Non è possibile trovare il campo o la proprietà.</exception>
        <exception cref="T:System.MissingMethodException">Non è possibile trovare metodi corrispondenti agli argomenti in <paramref name="args" />.  
  
 oppure  
  
 Non è possibile trovare membri con i nomi di argomento forniti in <paramref name="namedParameters" />.  
  
 oppure  
  
 L'oggetto <see cref="T:System.Type" /> corrente rappresenta un tipo che contiene parametri di tipo open, ovvero <see cref="P:System.Type.ContainsGenericParameters" /> restituisce <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">Non è possibile richiamare il metodo specificato su <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Più di un metodo corrisponde ai criteri di binding.</exception>
        <exception cref="T:System.InvalidOperationException">Il metodo rappresentato da <paramref name="name" /> include uno o più parametri di tipo generico non specificati. In altri termini, la proprietà <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> del metodo restituisce <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">per l'accesso a membri non pubblici indipendentemente dalle autorizzazioni impostate. Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Type" /> è astratto e se è necessario eseguirne l'override.</summary>
        <value>
          <see langword="true" /> se il <see cref="T:System.Type" /> è astratto. In caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.IsAbstract%2A> restituisce proprietà `true` nei casi seguenti:  
  
-   Il tipo corrente è astratto. ovvero, non è possibile creare un'istanza, ma può essere utilizzato solo come classe base per le classi derivate. In c#, classi astratte sono contrassegnate con il [astratta](~/docs/csharp/language-reference/keywords/abstract.md) (parola chiave); in Visual Basic vengono contrassegnati con il [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) (parola chiave).  
  
-   Il tipo corrente è un'interfaccia.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questa proprietà restituisce sempre `false`.  
  
   
  
## Examples  
 L'esempio seguente crea una matrice di <xref:System.Type> gli oggetti che rappresentano i seguenti tipi: tipo restituisce contiene `true` se l'oggetto specificato è `abstract`; in caso contrario, restituisce `false`.  
  
-   `AbstractClass`, una classe astratta (una classe contrassegnata come `abstract` in c# e `MustInherit` in Visual Basic).  
  
-   `DerivedClass`, una classe che eredita da `AbstractClass`.  
  
-   `SingleClass`, una classe NotInheritable. Viene definito come `sealed` in c# e `NotInheritable` in Visual Basic.  
  
-   `ITypeInfo`, un'interfaccia.  
  
-   `ImplementingClass`, una classe che implementa il `ITypeInfo` interfaccia.  
  
 Il metodo restituisce `true` solo per `AbstractClass`, la classe astratta, e `ITypeInfo`, l'interfaccia.  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'attributo di formato della stringa <see langword="AnsiClass" /> è selezionato per <see cref="T:System.Type" />.</summary>
        <value>
          <see langword="true" /> se l'attributo di formato della stringa <see langword="AnsiClass" /> è selezionato per <see cref="T:System.Type" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.TypeAttributes.StringFormatMask> consente di selezionare gli attributi di formato della stringa. Gli attributi del formato di stringa migliorano l'interoperabilità definendo come interpretare le stringhe.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico, questa proprietà si riferisce alla definizione di tipo generico da cui il tipo è stato costruito. Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato da `MyGenericType<T>`.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce sempre `false`.  
  
   
  
## Examples  
 Nell'esempio seguente ottiene le informazioni sui campi e verifica la presenza di `AnsiClass` attributo.  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il tipo è una matrice.</summary>
        <value>
          <see langword="true" /> se il tipo corrente è una matrice; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.IsArray%2A> restituisce proprietà `false` per la <xref:System.Array> classe. Restituisce inoltre `false` se l'istanza corrente è un <xref:System.Type> oggetto che rappresenta un tipo di raccolta o un'interfaccia progettato per funzionare con le raccolte, ad esempio <xref:System.Collections.IEnumerable> o <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Per verificare se una matrice, usare codice, ad esempio:  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 Se il tipo corrente rappresenta un tipo generico o un parametro di tipo nella definizione di un tipo o metodo generico, questa proprietà restituisce sempre `false`.  
  
 Questa proprietà è di sola lettura.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di <xref:System.Type.IsArray%2A> proprietà.  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, implementa la proprietà <see cref="P:System.Type.IsArray" /> e determina se l'oggetto <see cref="T:System.Type" /> è una matrice.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Type" /> è una matrice. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'istanza di <xref:System.Array> deve restituire classe `false` perché è un oggetto, non è una matrice.  
  
   
  
## Examples  
 Nell'esempio seguente esegue l'override di `IsArrayImpl` metodo il `MyTypeDelegator` classe controlla se una variabile è una matrice e viene visualizzato il risultato.  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Tipo da confrontare con il tipo corrente.</param>
        <summary>Determina se un'istanza di un tipo specificato può essere assegnata a un'istanza del tipo corrente.</summary>
        <returns>
          <see langword="true" /> se una o più delle condizioni seguenti sono vere:  
  
-   <paramref name="c" /> e l'istanza corrente rappresentano lo stesso tipo.  
  
-   <paramref name="c" /> deriva direttamente o indirettamente dall'istanza corrente. <paramref name="c" /> deriva direttamente dall'istanza corrente se eredita dall'istanza corrente. <paramref name="c" /> deriva indirettamente dall'istanza corrente se eredita da una successione di una o più classi che ereditano dall'istanza corrente.  
  
-   L'istanza corrente è un'interfaccia implementata da <paramref name="c" />.  
  
-   <paramref name="c" /> è un parametro di tipo generico e l'istanza corrente rappresenta uno dei vincoli di <paramref name="c" />.  
  
     Nell'esempio seguente, l'istanza corrente è un oggetto <see cref="T:System.Type" /> che rappresenta la classe <see cref="T:System.IO.Stream" />. <c>GenericWithConstraint</c> è un tipo generico il cui parametro di tipo generico deve essere di tipo <see cref="T:System.IO.Stream" />. Passando il parametro di tipo generico a <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> si indica che un'istanza del parametro di tipo generico può essere assegnata a un oggetto <see cref="T:System.IO.Stream" />.  
  
     [!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)]
     [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]  
  
-   <paramref name="c" /> rappresenta un tipo valore e l'istanza corrente rappresenta <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> in Visual Basic).  
  
 <see langword="false" /> se non viene soddisfatta nessuna di queste condizioni oppure se <paramref name="c" /> è <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.IsAssignableFrom%2A> metodo può essere utilizzato per determinare se un'istanza di `c` può essere assegnato a un'istanza del tipo corrente, il metodo è particolarmente utile quando si gestisce gli oggetti i cui tipi non sono noti in fase di progettazione e consente di condizionale assegnazione, come nell'esempio seguente viene illustrato come.  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 Questo metodo garantisce pertanto che una riga di codice, come nell'esempio verrà eseguito in fase di esecuzione senza generare un <xref:System.InvalidCastException> eccezione o un'eccezione simile:  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 Questo metodo può essere sottoposto a override da una classe derivata.  
  
> [!NOTE]
>  Una definizione di tipo generico non è assegnabile da un tipo costruito chiuso. Ovvero, non è possibile assegnare il tipo costruito chiuso `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) a una variabile di tipo `MyGenericList<T>`.  
  
 Se il `c` parametro è di tipo <xref:System.Reflection.Emit.TypeBuilder>, il risultato sarà basato sul tipo che deve essere compilato. Esempio di codice riportato di seguito viene illustrato questo utilizzando un tipo incorporato denominato `B`.  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il `IsAssignableFrom` metodo utilizzando le classi, matrici di valori integer e generics definiti.  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'attributo di formato della stringa <see langword="AutoClass" /> è selezionato per <see cref="T:System.Type" />.</summary>
        <value>
          <see langword="true" /> se l'attributo di formato della stringa <see langword="AutoClass" /> è selezionato per <see cref="T:System.Type" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.TypeAttributes.StringFormatMask> consente di selezionare gli attributi di formato della stringa. Gli attributi del formato di stringa migliorano l'interoperabilità definendo come interpretare le stringhe.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione di tipo generico da cui il tipo è stato costruito. Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato da `MyGenericType<T>`.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce sempre `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se i campi del tipo corrente sono disposti automaticamente dal Common Language Runtime.</summary>
        <value>
          <see langword="true" /> se la proprietà <see cref="P:System.Type.Attributes" /> del tipo corrente include <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà viene fornita per praticità. In alternativa, è possibile utilizzare il <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> il valore di enumerazione per selezionare tutti gli attributi di layout e quindi testare se <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> è impostata. Il <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, e <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valori dell'enumerazione indicano il modo in cui i campi del tipo vengono disposti nella memoria.  
  
 Per i tipi dinamici, è possibile specificare <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> quando si crea il tipo. Nel codice, applicare il <xref:System.Runtime.InteropServices.StructLayoutAttribute> attributo con il <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> il valore di enumerazione al tipo, per inviare al runtime di determinare il modo più appropriato per il layout della classe.  
  
> [!NOTE]
>  Non è possibile utilizzare il <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metodo per determinare se il <xref:System.Runtime.InteropServices.StructLayoutAttribute> è stato applicato a un tipo.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione di tipo generico da cui il tipo è stato costruito. Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato da `MyGenericType<T>.`  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questa proprietà restituisce sempre `false`.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata un'istanza del tipo e visualizza il <xref:System.Type.IsAutoLayout%2A> proprietà.  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Type" /> viene passato per riferimento.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Type" /> viene passato per riferimento. In caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ottenere il tipo effettivo, dereferenziare il tipo passato per riferimento e quindi chiamare <xref:System.Type.GetElementType%2A> su tale tipo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato un utilizzo del `IsByRef` proprietà per controllare se un tipo specificato viene passato per riferimento. Nell'esempio viene definita la classe `MyTypeDelegator`, che esegue l'override di `HasElementTypeImpl` metodo. La classe principale cerca di `HasElementType` proprietà e consente di visualizzare il tipo di elemento.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, implementa la proprietà <see cref="P:System.Type.IsByRef" /> e determina se l'oggetto <see cref="T:System.Type" /> viene passato per riferimento.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Type" /> viene passato per riferimento. In caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Type" /> è una classe o un delegato, ovvero se non è un tipo di valore o un'interfaccia.</summary>
        <value>
          <see langword="true" /> se il <see cref="T:System.Type" /> è una classe. In caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce `true` per classi, nonché i delegati. Restituisce `false` per i tipi di valore (per le strutture ed enumerazioni) anche se essi vengono sottoposti a boxing.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questa proprietà restituisce sempre `true`. Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà restituisce `true` se la definizione di tipo generico è una definizione di classe; ovvero, non definisce un'interfaccia o un tipo di valore.  
  
> [!NOTE]
>  Questa proprietà restituisce `true` per `Type` istanze che rappresentano il <xref:System.Enum> e <xref:System.ValueType> classi. Queste due classi sono rispettivamente i tipi di base per le enumerazioni e tipi di valore, ma non sono i tipi di valore o di enumerazioni. Per ulteriori informazioni, vedere il <xref:System.Type.IsValueType%2A> e <xref:System.Type.IsEnum%2A> proprietà.  
  
 Il <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> valore di enumerazione distingue una dichiarazione di tipo classe o interfaccia. Tuttavia, i tipi valore e classi sono contrassegnati con il <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> attributo. Se si recupera il valore della proprietà di attributi e utilizzare un tipo di <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> valore per determinare se un tipo è una classe anziché un tipo di valore, è necessario chiamare anche il <xref:System.Type.IsValueType%2A> proprietà. L'esempio per il <xref:System.Reflection.TypeAttributes> enumerazione contiene informazioni aggiuntive, nonché anexample.  
  
 Questa proprietà è di sola lettura.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata un'istanza di un tipo e indica se il tipo è una classe.  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Type" /> è un oggetto COM.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Type" /> è un oggetto COM; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce `false` per interfacce COM perché non sono oggetti. COM (interfacce) possono essere implementate da oggetti Microsoft .NET Framework.  
  
 È anche possibile caricare una classe COM e ottenere un `Type` oggetto per la classe COM utilizzando il [Tlbimp.exe (utilità di importazione di tipo libreria)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) strumento.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione di tipo generico da cui il tipo è stato costruito. Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int`> (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato da `MyGenericType<T>`.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questa proprietà restituisce sempre `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, implementa la proprietà <see cref="P:System.Type.IsCOMObject" /> e determina se <see cref="T:System.Type" /> è un oggetto COM.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Type" /> è un oggetto COM; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce `false` per interfacce COM perché non sono oggetti. COM (interfacce) possono essere implementate da oggetti Microsoft .NET Framework.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto rappresenta un tipo generico costruito. È possibile creare istanze di un tipo generico costruito.</summary>
        <value>
          <see langword="true" /> se questo oggetto rappresenta una definizione di tipo generico; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un tipo generico costruito ha tipi espliciti specificati per tutti i relativi parametri di tipo generico. E viene anche definito per un tipo generico chiuso.  
  
 Quando questa proprietà è `true`, è possibile creare istanze del tipo corrente, quando è `false`, non è possibile.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se è possibile includere <see cref="T:System.Type" /> in un contesto.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Type" /> può essere contenuto in un contesto; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un contesto intercetta le chiamate ai membri della classe e impone i criteri vengono applicati alla classe, ad esempio la sincronizzazione. Per ulteriori informazioni sui contesti remoti, vedere <xref:System.Runtime.Remoting.Contexts.Context>.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questa proprietà restituisce sempre `false`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, e <xref:System.Type.IsPrimitive%2A> proprietà la <xref:System.Type> classe. Controlla se il tipo specificato può essere contenuto nel contesto, se è possibile effettuare il marshalling per riferimento e, se il tipo è un tipo di dati primitivi.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementa la proprietà <see cref="P:System.Type.IsContextful" /> e determina se <see cref="T:System.Type" /> può essere contenuto in un contesto.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Type" /> può essere contenuto in un contesto; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere sottoposto a override da una classe derivata.  
  
 Un contesto intercetta le chiamate ai membri della classe e applicare i criteri che vengono applicati alla classe, ad esempio la sincronizzazione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato un utilizzo del `IsContextfulImpl` metodo.  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Type" /> è un'enumerazione.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Type" /> corrente è un'enumerazione; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà restituisce `true` per un'enumerazione, ma non per il <xref:System.Enum> tipo stesso.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione di tipo generico da cui il tipo è stato costruito. Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato da `MyGenericType<T>`.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questa proprietà restituisce sempre `false`.  
  
 Questa proprietà è di sola lettura.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il `IsEnum` proprietà.  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valore da verificare.</param>
        <summary>Restituisce un valore che indica se il valore specificato esiste nel tipo di enumerazione corrente.</summary>
        <returns>
          <see langword="true" /> se il valore specificato è un membro del tipo di enumerazione corrente; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Il tipo corrente non è un'enumerazione.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          Il tipo di <paramref name="value" /> non può essere il tipo sottostante di un'enumerazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">Tipo COM di cui si verifica l'equivalenza con il tipo corrente.</param>
        <summary>Determina se due tipi COM presentano la stessa identità e sono idonei per l'equivalenza di tipo.</summary>
        <returns>
          <see langword="true" /> se i tipi COM sono equivalenti; in caso contrario, <see langword="false" />. Questo metodo restituisce <see langword="false" /> anche se un tipo si trova in un assembly caricato per l'esecuzione e l'altro si trova in un assembly caricato nel contesto ReflectionOnly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], common language runtime supporta l'incorporamento di informazioni sui tipi COM direttamente negli assembly gestiti, anziché richiedere gli assembly gestiti ottenere informazioni sui tipi COM di interoperabilità assembly. Dato che le informazioni sui tipi incorporate includono solo i tipi e membri che vengono effettivamente usati da un assembly gestito, due assembly gestiti potrebbero avere viste diverse dello stesso tipo COM. Ogni assembly gestito a un oggetto <xref:System.Type> diverso per rappresentare la vista specifica del tipo COM. Common Language Runtime supporta l'equivalenza del tipo tra queste viste diverse per interfacce, strutture, enumerazioni e delegati.  
  
 Equivalenza del tipo significa che è possibile eseguire il cast di un oggetto COM passato da un assembly gestito a un altro sul tipo gestito appropriato nell'assembly ricevente. Il <xref:System.Type.IsEquivalentTo%2A> metodo consente a un assembly determinare che un oggetto COM ottenuto da un altro assembly ha la stessa identità COM come uno dei tipi di interoperabilità prima dell'assembly personalizzati incorporati e pertanto può eseguire il cast al tipo.  
  
 Per ulteriori informazioni, vedere [equivalenza del tipo e i tipi di interoperabilità incorporati](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se i campi del tipo corrente sono disposti a offset specificati in modo esplicito.</summary>
        <value>
          <see langword="true" /> se la proprietà <see cref="P:System.Type.Attributes" /> del tipo corrente include <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà viene fornita per praticità. In alternativa, è possibile utilizzare il <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> il valore di enumerazione per selezionare tutti gli attributi di layout e quindi testare se <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> è impostata. Il <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, e <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valori dell'enumerazione indicano il modo in cui i campi del tipo vengono disposti nella memoria.  
  
 Per i tipi dinamici, è possibile specificare <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> quando si crea il tipo. Nel codice, applicare il <xref:System.Runtime.InteropServices.StructLayoutAttribute> attributo con il <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> il valore di enumerazione al tipo, per specificare gli offset in corrispondenza del quale avviare i campi sono specificati in modo esplicito.  
  
> [!NOTE]
>  Non è possibile utilizzare il <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metodo per determinare se il <xref:System.Runtime.InteropServices.StructLayoutAttribute> è stato applicato a un tipo.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione di tipo generico da cui il tipo è stato costruito. Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato da `MyGenericType<T>`.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questa proprietà restituisce sempre `false`.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata un'istanza di un tipo e visualizza il valore della relativa <xref:System.Type.IsExplicitLayout%2A> proprietà. Usa il `MySystemTime` (classe), che è anche nell'esempio di codice per <xref:System.Runtime.InteropServices.StructLayoutAttribute>.  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Type" /> corrente rappresenta un parametro di tipo nella definizione di un tipo o metodo generico.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Type" /> rappresenta un parametro di tipo di una definizione di tipo o metodo generico. In caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> gli oggetti che rappresentano i parametri di tipo generico possono essere ottenuti chiamando il <xref:System.Type.GetGenericArguments%2A> metodo di un <xref:System.Type> oggetto che rappresenta una definizione di tipo generico, o <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> metodo di un <xref:System.Reflection.MethodInfo> oggetto che rappresenta un metodo generico definizione.  
  
-   Per un tipo generico o la definizione di metodo di <xref:System.Type.IsGenericParameter%2A> restituisce proprietà `true` per ogni elemento della matrice risultante.  
  
-   Per un tipo costruito chiuso o un metodo, il <xref:System.Type.IsGenericParameter%2A> restituisce proprietà `false` per ogni elemento della matrice restituita dal <xref:System.Type.GetGenericArguments%2A> metodo.  
  
-   Per un metodo o un tipo costruito aperto, alcuni elementi della matrice siano tipi specifici e così via potrebbero essere parametri di tipo. <xref:System.Type.IsGenericParameter%2A> Restituisce `false` per i tipi e `true` per i parametri di tipo. L'esempio di codice per il <xref:System.Type.ContainsGenericParameters%2A> proprietà illustra una classe generica con una combinazione di tipi e parametri di tipo.  
  
 Per un elenco delle condizioni invariabili relative ai termini usati dal processo di reflection generico, vedere i commenti sulla proprietà <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Type.IsGenericParameter%2A> proprietà per eseguire il test per i parametri di tipo generico in un tipo generico.  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il tipo corrente è un tipo generico.</summary>
        <value>
          <see langword="true" /> Se il tipo corrente è un tipo generico. in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Type.IsGenericType%2A> proprietà per determinare se un <xref:System.Type> oggetto rappresenta un tipo generico. Utilizzare il <xref:System.Type.ContainsGenericParameters%2A> proprietà per determinare se un <xref:System.Type> oggetto rappresenta un tipo costruito aperto o chiuso.  
  
> [!NOTE]
>  Il <xref:System.Type.IsGenericType%2A> restituisce proprietà `false` se il tipo di controllo immediato non è generico. Ad esempio, una matrice i cui elementi sono di tipo `A<int>` (`A(Of Integer)` in Visual Basic) non è un tipo generico.  
  
 Nella tabella seguente sono riepilogate le condizioni invariante per termini comuni usati nella reflection generica.  
  
|Termine|Invariante|  
|----------|---------------|  
|definizione di tipo generico|La proprietà <xref:System.Type.IsGenericTypeDefinition%2A> è `true`.<br /><br /> Definisce un tipo generico. Viene creato un tipo costruito chiamando il <xref:System.Type.MakeGenericType%2A> metodo su un <xref:System.Type> dell'oggetto che rappresenta una definizione di tipo generico e specificando una matrice di argomenti di tipo.<br /><br /> <xref:System.Type.MakeGenericType%2A> può essere chiamato solo in definizioni di tipo generico.<br /><br /> Qualsiasi definizione di tipo generico è un tipo generico (il <xref:System.Type.IsGenericType%2A> proprietà `true`), ma non è vero il contrario.|  
|tipo generico|La proprietà <xref:System.Type.IsGenericType%2A> è `true`.<br /><br /> Può essere una definizione di tipo generico, un tipo costruito aperto o un tipo costruito chiuso.<br /><br /> Si noti che una matrice di tipo il cui tipo di elemento sono di tipo generico non è un tipo generico. Lo stesso vale per un <xref:System.Type> oggetto che rappresenta un puntatore a un tipo generico.|  
|tipo costruito aperto|La proprietà <xref:System.Type.ContainsGenericParameters%2A> è `true`.<br /><br /> Esempi sono un tipo generico non assegnati parametri di tipo, un tipo annidato in una definizione di tipo generico o in un tipo costruito aperto o un tipo generico che dispone di un argomento di tipo per cui il <xref:System.Type.ContainsGenericParameters%2A> proprietà `true`.<br /><br /> Non è possibile creare un'istanza di un tipo costruito aperto.<br /><br /> Si noti che i tipi costruiti aperti non di tutti i generici. Ad esempio, una matrice il cui tipo di elemento è una definizione di tipo generico non è generica e un puntatore a un tipo costruito aperto non è generico.|  
|tipo costruito chiuso|La proprietà <xref:System.Type.ContainsGenericParameters%2A> è `false`.<br /><br /> Quando viene esaminato in modo ricorsivo, il tipo non dispone di alcun parametro generico non assegnati.|  
|parametro di tipo generico|La proprietà <xref:System.Type.IsGenericParameter%2A> è `true`.<br /><br /> La proprietà <xref:System.Type.ContainsGenericParameters%2A> è `true`.<br /><br /> In una definizione di tipo generico, un segnaposto per un tipo che verrà assegnato in un secondo momento.|  
|argomento di tipo generico|Può essere qualsiasi tipo, incluso un parametro di tipo generico.<br /><br /> Gli argomenti di tipo vengono specificati come una matrice di <xref:System.Type> gli oggetti passati al <xref:System.Type.MakeGenericType%2A> metodo durante la creazione di un tipo generico costruito. Se vengono create, le istanze del tipo risultante il <xref:System.Type.ContainsGenericParameters%2A> proprietà deve essere `false` per tutti gli argomenti di tipo.|  
  
 L'esempio di codice e la tabella seguenti illustrano alcune di queste condizioni e invarianti. La `Derived` classe è di particolare interesse, perché il tipo di base è un tipo costruito che dispone di una combinazione di tipi e parametri di tipo nell'elenco di argomenti tipo.  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 Nella tabella seguente vengono illustrati alcuni esempi che utilizzano e compilare per le classi `Base`, `Derived`, e `G`. Quando il codice C++ e c# è la stessa, viene visualizzata una sola voce.  
  
|Esempio|Invarianti|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|Per questo tipo:<br /><br /> <xref:System.Type.IsGenericType%2A> è `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> è `true`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> è `true`.|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|Per questo tipo:<br /><br /> <xref:System.Type.IsGenericType%2A> è `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> è `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> è `true`.|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|Per il tipo di variabile `d`:<br /><br /> <xref:System.Type.IsGenericType%2A> è `false` perché `d` è una matrice.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> è `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> è `false`.|  
|`T`, `U`, e `V` (everywhere vengono visualizzati)|<xref:System.Type.IsGenericParameter%2A> è `true`.<br /><br /> <xref:System.Type.IsGenericType%2A> è `false` perché non è possibile vincolare un parametro di tipo a tipi generici.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> è `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> è `true` perché `T`, `U`, e `V` sono a loro volta parametri di tipo generico. Ciò non implica necessariamente gli argomenti tipo che a loro assegnati in un secondo momento.|  
|Il tipo di campo `F`|<xref:System.Type.IsGenericType%2A> è `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> è `false` perché è stato assegnato un tipo per il parametro di tipo `G`. Si noti che questo è equivalente alla chiamata di <xref:System.Type.MakeGenericType%2A> metodo.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> è `true` perché il tipo di campo `F` è un argomento di tipo che è un tipo costruito aperto. Il tipo costruito è aperto perché il relativo argomento di tipo (vale a dire `Base`) è una definizione di tipo generico. Mostra la natura ricorsiva della <xref:System.Type.IsGenericType%2A> proprietà.|  
|La classe annidata `Nested`|<xref:System.Type.IsGenericType%2A> è `true`, anche se la `Nested` classe non dispone di alcun parametro di tipo generico di un proprio, perché è annidata in un tipo generico.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> è `true`. Ovvero, è possibile chiamare il <xref:System.Type.MakeGenericType%2A> metodo e fornire il parametro di tipo del tipo di inclusione, `Derived`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> è `true` poiché il tipo contenitore, `Derived`, dispone di parametri di tipo generico. Mostra la natura ricorsiva della <xref:System.Type.ContainsGenericParameters%2A> proprietà.|  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare il valore di <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, e <xref:System.Type.ContainsGenericParameters%2A> proprietà per i tipi descritti nella sezione Osservazioni. Per una spiegazione dei valori di proprietà, vedere la tabella nella sezione Osservazioni.  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se la classe <see cref="T:System.Type" /> corrente rappresenta una definizione di tipo generico, da cui è possibile costruire altri tipi generici.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Type" /> rappresenta una definizione di tipo generico. In caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una definizione di tipo generico è un modello da cui è possibile costruire altri tipi. Ad esempio, dalla definizione di tipo generico `G<T>` (espressi nella sintassi c#; `G(Of T)` in Visual Basic o `generic <typename T> ref class G` in C++) è possibile costruire e creare istanze del tipo `G<int>` (`G(Of Integer)` in Visual Basic), chiamando la <xref:System.Type.MakeGenericType%2A> metodo con un elenco di argomento generico che contiene il <xref:System.Int32> tipo. Dato un <xref:System.Type> oggetto che rappresenta questo tipo costruito, il <xref:System.Type.GetGenericTypeDefinition%2A> metodo ottiene la definizione di tipo generico nuovamente.  
  
 Utilizzare il <xref:System.Type.IsGenericTypeDefinition%2A> proprietà per determinare se è possibile creare nuovi tipi dal tipo corrente. Se il <xref:System.Type.IsGenericTypeDefinition%2A> restituisce proprietà `true`, è possibile chiamare il <xref:System.Type.MakeGenericType%2A> metodo per creare nuovi tipi generici.  
  
 Per un elenco delle condizioni invariabili relative ai termini usati dal processo di reflection generico, vedere i commenti sulla proprietà <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Nell'esempio seguente visualizza informazioni su un tipo, incluso o meno una definizione di tipo generico. Vengono visualizzate informazioni per un tipo costruito, la definizione di tipo generico e un tipo ordinario.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Type" /> dispone di un attributo <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> applicato, che ne indica l'importazione da una libreria di tipi COM.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Type" /> dispone di <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />. In caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione di tipo generico da cui il tipo è stato costruito. Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato da `MyGenericType<T>.`  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questa proprietà restituisce sempre `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Oggetto da confrontare con il tipo corrente.</param>
        <summary>Determina se l'oggetto specificato è un'istanza dell'oggetto <see cref="T:System.Type" /> corrente.</summary>
        <returns>
          <see langword="true" /> se l'oggetto <see langword="Type" /> corrente è incluso nella gerarchia di ereditarietà dell'oggetto rappresentato da <paramref name="o" /> oppure se l'oggetto <see langword="Type" /> corrente è un'interfaccia implementata da <paramref name="o" />. <see langword="false" /> se non viene soddisfatta nessuna di queste condizioni, se <paramref name="o" /> è <see langword="null" /> oppure se l'oggetto <see langword="Type" /> corrente è un tipo generico aperto, ovvero la proprietà <see cref="P:System.Type.ContainsGenericParameters" /> restituisce <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere sottoposto a override da una classe derivata.  
  
> [!NOTE]
>  Un tipo costruito non è un'istanza della relativa definizione di tipo generico. Vale a dire `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) non è un'istanza di `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'uso del metodo `IsInstanceOfType`.  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Type" /> è un'interfaccia, ovvero non è una classe né un tipo di valore.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Type" /> è un'interfaccia; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distingue una dichiarazione di tipo classe, interfaccia o tipo valore.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questa proprietà restituisce sempre `false`.  
  
 Questa proprietà è di sola lettura.  
  
   
  
## Examples  
 Nell'esempio seguente crea un'interfaccia, Cerca il tipo di interfaccia e indica se dispone di una classe di `IsInterface` set di proprietà.  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se i campi del tipo corrente sono disposti in sequenza, nell'ordine in cui sono stati definiti o rilasciati ai metadati.</summary>
        <value>
          <see langword="true" /> se la proprietà <see cref="P:System.Type.Attributes" /> del tipo corrente include <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà viene fornita per praticità. In alternativa, è possibile utilizzare il <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> il valore di enumerazione per selezionare tutti gli attributi di layout e quindi testare se <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> è impostata. Il <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, e <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valori dell'enumerazione indicano il modo in cui i campi del tipo vengono disposti nella memoria.  
  
 Per i tipi dinamici, è possibile specificare <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> quando si crea il tipo. Nel codice, applicare il <xref:System.Runtime.InteropServices.StructLayoutAttribute> attributo con il <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> il valore di enumerazione al tipo, per specificare che il layout è sequenza.  
  
> [!NOTE]
>  Non è possibile utilizzare il <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metodo per determinare se il <xref:System.Runtime.InteropServices.StructLayoutAttribute> è stato applicato a un tipo.  
  
 Per ulteriori informazioni, vedere la sezione 9.1.2 della specifica per la documentazione di Common Language Infrastructure (CLI), "Partizione II: metadati definizione e la semantica". La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione di tipo generico da cui il tipo è stato costruito. Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato da `MyGenericType<T>`.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questa proprietà restituisce sempre `false`.  
  
   
  
## Examples  
 Nell'esempio seguente crea un'istanza di una classe per cui il <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> valore di enumerazione nel <xref:System.Runtime.InteropServices.StructLayoutAttribute> classe è stata impostata, verifica la presenza del <xref:System.Type.IsLayoutSequential%2A> , proprietà e viene visualizzato il risultato.  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Type" /> viene sottoposto a marshalling per riferimento.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Type" /> viene sottoposto a marshalling per riferimento; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato il `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, e <xref:System.Type.IsPrimitive%2A> proprietà la <xref:System.Type> classe. Controlla se il tipo specificato può essere contenuto nel contesto, se è possibile effettuare il marshalling per riferimento e, se il tipo è un tipo di dati primitivi.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementa la proprietà <see cref="P:System.Type.IsMarshalByRef" /> e determina se l'oggetto <see cref="T:System.Type" /> viene sottoposto a marshalling per riferimento.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Type" /> viene sottoposto a marshalling per riferimento; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere sottoposto a override da una classe derivata.  
  
   
  
## Examples  
 Nell'esempio seguente determina se il tipo specificato viene sottoposto a marshalling per riferimento e viene visualizzato il risultato.  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Type" /> corrente rappresenta un tipo la cui definizione è annidata all'interno della definizione di un altro tipo.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Type" /> è annidato all'interno di un altro tipo; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.IsNested%2A> restituisce proprietà `true` per tutti i tipi annidati, indipendentemente dalla visibilità. Per testare l'annidamento e la visibilità nello stesso momento, utilizzare le proprietà correlate <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, o <xref:System.Type.IsNestedPublic%2A>.  
  
> [!NOTE]
>  Il <xref:System.Reflection.TypeAttributes.VisibilityMask> membro di enumerazione seleziona gli attributi di visibilità per un tipo.  
  
   
  
## Examples  
 L'esempio seguente crea una classe esterna con un numero di classi annidate che hanno tipi diversi di visibilità. Viene quindi recuperato il valore di un numero di correlate alla visibilità <xref:System.Type> le proprietà per il tipo padre e ciascuno dei relativi tipi annidati.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Type" /> è annidato e visibile soltanto all'interno dell'assembly.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Type" /> è annidato e visibile soltanto all'interno dell'assembly; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce sempre `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Consente di selezionare gli attributi di visibilità.  
  
   
  
## Examples  
 L'esempio seguente crea una classe esterna con un numero di classi annidate che hanno tipi diversi di visibilità. Viene quindi recuperato il valore di un numero di correlate alla visibilità <xref:System.Type> le proprietà per il tipo padre e ciascuno dei relativi tipi annidati.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Type" /> è annidato e visibile soltanto alle classi della stessa famiglia e dello stesso assembly.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Type" /> è annidato e visibile soltanto alle classi della stessa famiglia e dello stesso assembly. In caso contrario <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce sempre `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Consente di selezionare gli attributi di visibilità.  
  
> [!NOTE]
>  I linguaggi c# e Visual Basic non includono semantica che consentono di definire un tipo annidato è visibile solo per i tipi protetti nel proprio assembly. `protected internal` visibilità in c# e `Protected Friend` visibilità in Visual Basic definisce un tipo annidato è visibile per i tipi protetti e per i tipi nello stesso assembly.  
  
 Oggetto <xref:System.Type> famiglia dell'oggetto è definita come tutti gli oggetti dello stesso <xref:System.Type> e dei relativi sottotipi.  
  
   
  
## Examples  
 L'esempio seguente crea una classe esterna con un numero di classi annidate che hanno tipi diversi di visibilità. Viene quindi recuperato il valore di un numero di correlate alla visibilità <xref:System.Type> le proprietà per il tipo padre e ciascuno dei relativi tipi annidati.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Type" /> è annidato e visibile solo all'interno della famiglia.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Type" /> è annidato e visibile solo all'interno della famiglia; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce sempre `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Consente di selezionare gli attributi di visibilità.  
  
 Oggetto <xref:System.Type> famiglia dell'oggetto è definita come tutti gli oggetti di uno stesso <xref:System.Type> e dei relativi sottotipi.  
  
   
  
## Examples  
 L'esempio seguente crea una classe esterna con un numero di classi annidate che hanno tipi diversi di visibilità. Viene quindi recuperato il valore di un numero di correlate alla visibilità <xref:System.Type> le proprietà per il tipo padre e ciascuno dei relativi tipi annidati.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Type" /> è annidato e visibile solo alle classi della stessa famiglia o dello stesso assembly.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Type" /> è annidato e visibile solo alle classi della stessa famiglia o dello stesso assembly; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la visibilità di un tipo è `protected internal` in c# o `Protected Friend` in Visual Basic il <xref:System.Type.IsNestedFamORAssem%2A> restituisce proprietà `true`.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce sempre `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Consente di selezionare gli attributi di visibilità.  
  
 Oggetto <xref:System.Type> famiglia dell'oggetto è definita come tutti gli oggetti di uno stesso <xref:System.Type> e dei relativi sottotipi.  
  
   
  
## Examples  
 L'esempio seguente crea una classe esterna con un numero di classi annidate che hanno tipi diversi di visibilità. Viene quindi recuperato il valore di un numero di correlate alla visibilità <xref:System.Type> le proprietà per il tipo padre e ciascuno dei relativi tipi annidati.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Type" /> è annidato e dichiarato privato.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Type" /> è annidato e dichiarato privato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce sempre `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Consente di selezionare gli attributi di visibilità.  
  
   
  
## Examples  
 L'esempio seguente crea una classe esterna con un numero di classi annidate che hanno tipi diversi di visibilità. Viene quindi recuperato il valore di un numero di correlate alla visibilità <xref:System.Type> le proprietà per il tipo padre e ciascuno dei relativi tipi annidati.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se una classe è annidata e dichiarata pubblica.</summary>
        <value>
          <see langword="true" /> se la classe è annidata e dichiarata pubblica. In caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce sempre `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Consente di selezionare gli attributi di visibilità.  
  
   
  
## Examples  
 L'esempio seguente crea una classe esterna con un numero di classi annidate che hanno tipi diversi di visibilità. Viene quindi recuperato il valore di un numero di correlate alla visibilità <xref:System.Type> le proprietà per il tipo padre e ciascuno dei relativi tipi annidati.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Type" /> non è dichiarato pubblico.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Type" /> non è dichiarato pubblico e non è un tipo annidato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non utilizzare questa proprietà con i tipi annidati; Utilizzare il <xref:System.Type.IsNestedPublic%2A> proprietà invece.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce `false`.  
  
   
  
## Examples  
 Questo esempio usesthe `IsNotPublic` proprietà da ottenere la visibilità del tipo.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 Esempio di codice seguente viene illustrato perché non è possibile utilizzare `IsPublic` e `IsNotPublic` per le classi annidate.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 Per le classi annidate, ignorare i risultati di `IsPublic` e `IsNotPublic` e tenere in considerazione solo i risultati di `IsNestedPublic` e `IsNestedPrivate`. L'output di reflection per questo frammento di codice sarà come segue:  
  
|Classe|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|A|false|true|false|false|  
|B|false|false|true|false|  
|C|false|false|false|true|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Type" /> è un puntatore.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Type" /> è un puntatore. In caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico o un parametro di tipo nella definizione di un tipo generico o un metodo generico, questa proprietà restituisce sempre `false`.  
  
 Questa proprietà è di sola lettura.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato un utilizzo della `IsPointer` proprietà.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, implementa la proprietà <see cref="P:System.Type.IsPointer" /> e determina se l'oggetto <see cref="T:System.Type" /> è un puntatore.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Type" /> è un puntatore. In caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Type" /> è uno dei tipi primitivi.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Type" /> è uno dei tipi primitivi. In caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I tipi primitivi sono <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, e <xref:System.Single>.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico o un parametro di tipo nella definizione di un tipo generico o un metodo generico, questa proprietà restituisce sempre `false`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, e <xref:System.Type.IsPrimitive%2A> proprietà la <xref:System.Type> classe. Controlla se il tipo specificato può essere contenuto nel contesto, se è possibile effettuare il marshalling per riferimento e, se il tipo è un tipo di dati primitivi.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando ne viene eseguito l'override in una classe derivata, implementa la proprietà <see cref="P:System.Type.IsPrimitive" /> e determina se l'oggetto <see cref="T:System.Type" /> corrisponde a uno dei tipi primitivi.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Type" /> è uno dei tipi primitivi. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I tipi primitivi sono <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, e <xref:System.Single>.  
  
   
  
## Examples  
 Nell'esempio seguente determina se il tipo specificato è un tipo primitivo e viene visualizzato il risultato.  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'oggetto <see cref="T:System.Type" /> è dichiarato pubblico.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Type" /> è dichiarato pubblico e non è un tipo annidato; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non utilizzare con i tipi annidati; Utilizzare <xref:System.Type.IsNestedPublic%2A> invece.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce `true`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Consente di selezionare gli attributi di visibilità.  
  
   
  
## Examples  
 L'esempio seguente crea un'istanza di `MyTestClass`, verifica la presenza di `IsPublic` proprietà e viene visualizzato il risultato.  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 Per le classi annidate, ignorare i risultati di `IsPublic` e `IsNotPublic` e tenere in considerazione solo i risultati di <xref:System.Type.IsNestedPublic%2A> e <xref:System.Type.IsNestedPrivate%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Type" /> è dichiarato sealed.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Type" /> è dichiarato sealed; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce sempre `true`.  
  
   
  
## Examples  
 L'esempio seguente crea un'istanza di un `sealed` classe, Cerca il `IsSealed` , proprietà e viene visualizzato il risultato.  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il tipo corrente è SecurityCritical o SecuritySafeCritical al livello di attendibilità corrente e può pertanto eseguire operazioni critiche.</summary>
        <value>
          <see langword="true" /> se il tipo corrente è SecurityCritical o SecuritySafeCritical al livello di attendibilità corrente, <see langword="false" /> se è trasparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, e <xref:System.Type.IsSecurityTransparent%2A> riportano il livello di trasparenza del tipo al livello di attendibilità corrente, come determinato da common language runtime (CLR). Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:  
  
|Livello di sicurezza|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critico|`true`|`false`|`false`|  
|Critico per la sicurezza|`true`|`true`|`false`|  
|Trasparente|`false`|`false`|`true`|  
  
 Usare queste proprietà è molto più semplice che non esaminare le annotazioni di sicurezza di un assembly e dei suoi tipi, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.  
  
> [!IMPORTANT]
>  Per gli assembly parzialmente attendibile, il valore di questa proprietà dipende dal livello di attendibilità corrente dell'assembly. Se l'assembly viene caricato in un dominio di applicazione parzialmente attendibile (ad esempio, in un dominio applicazione creato mediante sandbox), il runtime ignora le annotazioni di sicurezza dell'assembly. L'assembly e tutti i relativi tipi vengono considerati come trasparente. Il runtime presta attenzione per le annotazioni di sicurezza di un assembly con attendibilità parziale solo quando l'assembly viene caricato in un dominio applicazione completamente attendibile (ad esempio, nel dominio applicazione predefinito di un'applicazione desktop). Al contrario, un assembly attendibile (vale a dire un assembly con nome sicuro che viene installato nella global assembly cache) è sempre caricato con attendibilità indipendentemente dal livello di trust del dominio dell'applicazione, pertanto il relativo livello di attendibilità corrente è sempre completamente attendibile. È possibile determinare i livelli di attendibilità corrente di domini applicazione e assembly utilizzando il <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> e <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> proprietà.  
  
 Per ulteriori informazioni sulla reflection e trasparenza, vedere [considerazioni sulla sicurezza per la Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Per informazioni su trasparenza, vedere [modifiche della sicurezza](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il tipo corrente è SecuritySafeCritical al livello di attendibilità corrente, vale a dire se può eseguire operazioni critiche e se è possibile accedervi tramite codice trasparente.</summary>
        <value>
          <see langword="true" /> se il tipo corrente è SecuritySafeCritical al livello di attendibilità corrente, <see langword="false" /> se è SecurityCritical o trasparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, e <xref:System.Type.IsSecurityTransparent%2A> riportano il livello di trasparenza del tipo al livello di attendibilità corrente, come determinato da common language runtime (CLR). Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:  
  
|Livello di sicurezza|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critico|`true`|`false`|`false`|  
|Critico per la sicurezza|`true`|`true`|`false`|  
|Trasparente|`false`|`false`|`true`|  
  
 Usare queste proprietà è molto più semplice che non esaminare le annotazioni di sicurezza di un assembly e dei suoi tipi, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.  
  
> [!IMPORTANT]
>  Per gli assembly parzialmente attendibile, il valore di questa proprietà dipende dal livello di attendibilità corrente dell'assembly. Se l'assembly viene caricato in un dominio di applicazione parzialmente attendibile (ad esempio, in un dominio applicazione creato mediante sandbox), il runtime ignora le annotazioni di sicurezza dell'assembly. L'assembly e tutti i relativi tipi vengono considerati come trasparente. Il runtime presta attenzione per le annotazioni di sicurezza di un assembly con attendibilità parziale solo quando l'assembly viene caricato in un dominio applicazione completamente attendibile (ad esempio, nel dominio applicazione predefinito di un'applicazione desktop). Al contrario, un assembly attendibile (vale a dire un assembly con nome sicuro che viene installato nella global assembly cache) è sempre caricato con attendibilità indipendentemente dal livello di trust del dominio dell'applicazione, pertanto il relativo livello di attendibilità corrente è sempre completamente attendibile. È possibile determinare i livelli di attendibilità corrente di domini applicazione e assembly utilizzando il <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> e <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> proprietà.  
  
 Per ulteriori informazioni sulla reflection e trasparenza, vedere [considerazioni sulla sicurezza per la Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Per informazioni su trasparenza, vedere [modifiche della sicurezza](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se il tipo corrente è trasparente al livello di attendibilità corrente e non può quindi eseguire operazioni critiche.</summary>
        <value>
          <see langword="true" /> se il tipo è SecurityTransparent al livello di attendibilità corrente; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questa proprietà restituisce `true`, <xref:System.Type.IsSecurityCritical%2A> e <xref:System.Type.IsSecuritySafeCritical%2A> restituiscono `false`.  
  
 Il <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, e <xref:System.Type.IsSecurityTransparent%2A> riportano il livello di trasparenza del tipo al livello di attendibilità corrente, come determinato da common language runtime (CLR). Usare queste proprietà è molto più semplice che non esaminare le annotazioni di sicurezza di un assembly e dei suoi tipi, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.  
  
> [!IMPORTANT]
>  Per gli assembly parzialmente attendibile, il valore di questa proprietà dipende dal livello di attendibilità corrente dell'assembly. Se l'assembly viene caricato in un dominio di applicazione parzialmente attendibile (ad esempio, in un dominio applicazione creato mediante sandbox), il runtime ignora le annotazioni di sicurezza dell'assembly. L'assembly e tutti i relativi tipi vengono considerati come trasparente. Il runtime presta attenzione per le annotazioni di sicurezza di un assembly con attendibilità parziale solo quando l'assembly viene caricato in un dominio applicazione completamente attendibile (ad esempio, nel dominio applicazione predefinito di un'applicazione desktop). Al contrario, un assembly attendibile (vale a dire un assembly con nome sicuro che viene installato nella global assembly cache) è sempre caricato con attendibilità indipendentemente dal livello di trust del dominio dell'applicazione, pertanto il relativo livello di attendibilità corrente è sempre completamente attendibile. È possibile determinare i livelli di attendibilità corrente di domini applicazione e assembly utilizzando il <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> e <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> proprietà.  
  
 Per ulteriori informazioni sulla reflection e trasparenza, vedere [considerazioni sulla sicurezza per la Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Per informazioni su trasparenza, vedere [modifiche della sicurezza](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Type" /> è serializzabile.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Type" /> è serializzabile; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Tipi definiti nello Standard .NET non contrassegnati con <xref:System.SerializableAttribute>. Ogni implementazione di .NET, invece, determina se un tipo è serializzabile. In fase di esecuzione, è possibile utilizzare il <xref:System.Type.IsSerializable%2A> proprietà per determinare se tale implementazione supporta la serializzazione di un'istanza del tipo. Per ulteriori informazioni e un esempio, vedere [come determinare se un oggetto .NET Standard è serializzabile](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione di tipo generico da cui il tipo è stato costruito. Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato da `MyGenericType<T>`.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questa proprietà restituisce sempre `false`.  
  
   
  
## Examples  
 L'esempio seguente crea un'istanza di `MyTestClass` (classe), imposta l'attributo [Serializable] e controlla il `IsSerializable` proprietà `true` o `false`.  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se per il nome del tipo richiede una gestione speciale.</summary>
        <value>
          <see langword="true" /> se il nome del tipo richiede una gestione speciale; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I nomi che iniziano con o contengono un carattere di sottolineatura (_), funzioni di accesso a proprietà e metodi di overload dell'operatore sono esempi di tipi che possono richiedere un trattamento speciale da alcuni compilatori.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione di tipo generico da cui il tipo è stato costruito. Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato da `MyGenericType<T>`.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questa proprietà restituisce sempre `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Tipo da confrontare con il tipo corrente.</param>
        <summary>Determina se l'oggetto <see cref="T:System.Type" /> corrente deriva dall'oggetto <see cref="T:System.Type" /> specificato.</summary>
        <returns>
          <see langword="true" /> se l'oggetto <see langword="Type" /> corrente deriva da <paramref name="c" />; in caso contrario, <see langword="false" />. Questo metodo restituisce anche <see langword="false" /> se <paramref name="c" /> e l'oggetto <see langword="Type" /> corrente sono uguali.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile chiamare il <xref:System.Type.IsSubclassOf%2A> metodo per determinare le seguenti operazioni:  
  
-   Una classe che deriva da un altro.  
  
-   Se un tipo deriva da <xref:System.ValueType>. Tuttavia, il <xref:System.Type.IsValueType%2A> è un modo più efficace per determinare se un tipo è un tipo di valore.  
  
-   Se un tipo deriva da <xref:System.Enum>. Tuttavia, il <xref:System.Type.IsEnum%2A> metodo è un modo più efficace per determinare se un tipo è un'enumerazione.  
  
-   Se un tipo è un delegato, ovvero se deriva da uno <xref:System.Delegate> o <xref:System.MulticastDelegate>.  
  
 Il <xref:System.Type.IsSubclassOf%2A> metodo non può essere utilizzato per determinare se un'interfaccia deriva da un'altra interfaccia, o se una classe implementa un'interfaccia. Utilizzare il <xref:System.Type.IsAssignableFrom%2A> metodo a tale scopo, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, deriva dal relativo vincolo di classe oppure da <xref:System.Object?displayProperty=nameWithType> se non sono presenti vincoli di classe.  
  
> [!NOTE]
>  Tranne quando è usato con le interfacce, <xref:System.Type.IsSubclassOf%2A> è il contrario di <xref:System.Type.IsAssignableFrom%2A>. Vale a dire se `t1.IsSubclassOf(t2)` è `true`, quindi `t2.IsAssignableFrom(t1)` anche `true`.  
  
 Questo metodo può essere sottoposto a override da una classe derivata.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una classe denominata `Class1` e una classe derivata denominata `DerivedC1`. Chiama il <xref:System.Type.IsSubclassOf%2A> metodo per verificare che `DerivedC1` è una sottoclasse di `Class1`.  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="c" /> è <see langword="null" />.</exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'attributo di formato della stringa <see langword="UnicodeClass" /> è selezionato per <see cref="T:System.Type" />.</summary>
        <value>
          <see langword="true" /> se l'attributo di formato della stringa <see langword="UnicodeClass" /> è selezionato per <see cref="T:System.Type" />; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.TypeAttributes.StringFormatMask> consente di selezionare gli attributi di formato della stringa. Gli attributi del formato di stringa migliorano l'interoperabilità definendo come interpretare le stringhe.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione di tipo generico da cui il tipo è stato costruito. Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato da `MyGenericType<T>`.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questa proprietà restituisce sempre `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se <see cref="T:System.Type" /> è un tipo di valore.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.Type" /> è un tipo di valore. In caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tipi di valore sono tipi che sono rappresentati come sequenze di bit; tipi di valore non sono classi o interfacce. Tipi di valore sono definiti come "struct" in alcuni linguaggi di programmazione. Le enumerazioni sono un tipo speciale di tipi di valore.  
  
 Questa proprietà restituisce `false` per il <xref:System.ValueType> classe, perché <xref:System.ValueType> non è un tipo di valore stesso. È la classe base per tutti i tipi di valore e, pertanto qualsiasi tipo di valore può essere assegnato a esso. Ciò non sarebbe possibile se <xref:System.ValueType> stesso stato di un tipo di valore. Tipi di valore sono boxed quando vengono assegnate a un campo di tipo <xref:System.ValueType>.  
  
 Questa proprietà restituisce `true` per le enumerazioni, ma non per il <xref:System.Enum> tipo stesso. Per un esempio che illustri questo comportamento, vedere <xref:System.Type.IsEnum%2A>.  
  
 Questa proprietà è di sola lettura.  
  
   
  
## Examples  
 Nell'esempio seguente viene creata una variabile di tipo `MyEnum`, verifica la presenza di `IsValueType` , proprietà e viene visualizzato il risultato.  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementa la proprietà <see cref="P:System.Type.IsValueType" /> e determina se l'oggetto <see cref="T:System.Type" /> è un tipo di valore, ovvero, non una classe o un'interfaccia.</summary>
        <returns>
          <see langword="true" /> se <see cref="T:System.Type" /> è un tipo di valore. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è fornito per abilitare l'implementazione di sistemi di tipi alternativo. Non è in genere utilizzato nel codice dell'applicazione.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se è possibile accedere a <see cref="T:System.Type" /> da codice esterno all'assembly.</summary>
        <value>
          <see langword="true" /> se l'oggetto <see cref="T:System.Type" /> corrente è un tipo pubblico o un tipo pubblico annidato in modo che tutti i tipi contenitore siano pubblici; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questa proprietà per determinare se un tipo fa parte dell'interfaccia pubblica di un assembly del componente.  
  
   
  
## Examples  
 Nell'esempio seguente verifica due classi, solo uno dei quali è visibile all'esterno dell'assembly.  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce un oggetto <see cref="T:System.Type" /> che rappresenta una matrice del tipo corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un oggetto <see cref="T:System.Type" /> che rappresenta una matrice unidimensionale del tipo corrente, con limite inferiore zero.</summary>
        <returns>Oggetto <see cref="T:System.Type" /> che rappresenta una matrice unidimensionale del tipo corrente, con limite inferiore zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.MakeArrayType%2A> metodo fornisce un modo per generare i tipi matrice i cui tipi di elemento vengono calcolati in fase di esecuzione.  
  
 **Nota** common language runtime viene fatta distinzione tra vettori (vale a dire matrici unidimensionali che sono sempre in base zero) e le matrici multidimensionali. Un vettore, che è sempre una sola dimensione, non corrisponde una matrice multidimensionale che dispone di una sola dimensione. Overload di questo metodo consente solo di creare tipi vettore, ed è l'unico modo per creare un tipo di vettore. Utilizzare il <xref:System.Type.MakeArrayType%28System.Int32%29> overload del metodo per creare tipi di matrici multidimensionali.  
  
   
  
## Examples  
 Esempio di codice seguente crea una matrice, `ref` (`ByRef` in Visual Basic) e i tipi di puntatore per il `Test` classe.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il metodo richiamato non è supportato nella classe base. Le classi derivate devono fornire un'implementazione.</exception>
        <exception cref="T:System.TypeLoadException">Il tipo corrente è <see cref="T:System.TypedReference" />.  
  
 oppure  
  
 Il tipo corrente è <see langword="ByRef" />, Ciò significa che <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">Numero di dimensioni della matrice. Il numero deve essere minore o uguale a 32.</param>
        <summary>Restituisce un oggetto <see cref="T:System.Type" /> che rappresenta una matrice del tipo corrente, con il numero specificato di dimensioni.</summary>
        <returns>Oggetto che rappresenta una matrice del tipo corrente, con il numero specificato di dimensioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.MakeArrayType%2A> metodo fornisce un modo per generare i tipi matrice i cui tipi di elemento vengono calcolati in fase di esecuzione.  
  
> [!NOTE]
>  Common language runtime viene fatta distinzione tra vettori (vale a dire matrici unidimensionali che sono sempre in base zero) e le matrici multidimensionali. Un vettore, che è sempre una sola dimensione, non corrisponde una matrice multidimensionale che dispone di una sola dimensione. È possibile utilizzare questo overload del metodo per creare un tipo di vettore. Se `rank` è 1, overload di questo metodo restituisce un tipo di matrice multidimensionale che dispone di una dimensione. Utilizzare il <xref:System.Type.MakeArrayType> overload del metodo per creare tipi di vettore.  
  
   
  
## Examples  
 Esempio di codice seguente crea una matrice, `ref` (`ByRef` in Visual Basic) e i tipi di puntatore per il `Test` classe.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="rank" /> non è valido. Ad esempio, 0 o negativo.</exception>
        <exception cref="T:System.NotSupportedException">Il metodo richiamato non è supportato nella classe base.</exception>
        <exception cref="T:System.TypeLoadException">Il tipo corrente è <see cref="T:System.TypedReference" />.  
  
 oppure  
  
 Il tipo corrente è <see langword="ByRef" />, Ciò significa che <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.  
  
 oppure  
  
 <paramref name="rank" /> è maggiore di 32.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un oggetto <see cref="T:System.Type" /> che rappresenta il tipo corrente quando viene passato come parametro <see langword="ref" /> (parametro <see langword="ByRef" /> in Visual Basic).</summary>
        <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo corrente quando viene passato come parametro <see langword="ref" /> (parametro <see langword="ByRef" /> in Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.MakeByRefType%2A> metodo fornisce un modo per generare `ref` tipi (`ByRef` in Visual Basic) per elenchi di parametri.  
  
 Utilizzando la sintassi di Microsoft intermediate language (MSIL), se l'oggetto corrente <xref:System.Type> oggetto <xref:System.Int32>, questo metodo restituisce un <xref:System.Type> che rappresenta l'oggetto `Int32&`.  
  
   
  
## Examples  
 Esempio di codice seguente crea una matrice, `ref` (`ByRef` in Visual Basic) e i tipi di puntatore per il `Test` classe.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il metodo richiamato non è supportato nella classe base.</exception>
        <exception cref="T:System.TypeLoadException">Il tipo corrente è <see cref="T:System.TypedReference" />.  
  
 oppure  
  
 Il tipo corrente è <see langword="ByRef" />, Ciò significa che <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Matrice di tipi con cui sostituire i parametri di tipo del tipo generico corrente.</param>
        <summary>Sostituisce gli elementi di una matrice di tipi ai parametri di tipo della definizione di tipo generico corrente e restituisce un oggetto <see cref="T:System.Type" /> che rappresenta il tipo costruito risultante.</summary>
        <returns>Oggetto <see cref="T:System.Type" /> che rappresenta il tipo costruito ottenuto sostituendo i parametri di tipo del tipo generico corrente con gli elementi di <paramref name="typeArguments" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.MakeGenericType%2A> metodo consente di scrivere codice per tipi specifici di assegnare ai parametri di tipo di una definizione di tipo generico, creando così un <xref:System.Type> oggetto che rappresenta un determinato tipo costruito. È possibile utilizzare questo <xref:System.Type> oggetto per creare istanze di runtime del tipo costruito.  
  
 Tipi costruiti con <xref:System.Type.MakeGenericType%2A> possono essere aperti, vale a dire alcuni dei relativi argomenti di tipo possono essere parametri di tipo di metodi generici o tipi di contenitore. È possibile utilizzare tali tipi costruiti aperti quando si generano assembly dinamici. Si consideri ad esempio le classi `Base` e `Derived` nel codice seguente.  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 Per generare `Derived` in un assembly dinamico, è necessario costruire il tipo di base. A tale scopo, chiamare il <xref:System.Type.MakeGenericType%2A> metodo su un <xref:System.Type> oggetto che rappresenta la classe `Base`, usando gli argomenti di tipo generico <xref:System.Int32> e il parametro di tipo `V` da `Derived`. Poiché i tipi e parametri di tipo generico sono rappresentati da <xref:System.Type> oggetti, è possibile passare una matrice contenente entrambi i <xref:System.Type.MakeGenericType%2A> metodo.  
  
> [!NOTE]
>  Un tipo costruito, ad esempio `Base<int, V>` è utile quando la creazione di codice, ma non è possibile chiamare il <xref:System.Type.MakeGenericType%2A> metodo su questo tipo perché non è una definizione di tipo generico. Per creare un tipo costruito chiuso che può essere creata un'istanza, chiamare innanzitutto il <xref:System.Type.GetGenericTypeDefinition%2A> metodo per ottenere un <xref:System.Type> dell'oggetto che rappresenta la definizione di tipo generico e quindi chiamare <xref:System.Type.MakeGenericType%2A> con gli argomenti di tipo desiderato.  
  
 Il <xref:System.Type> oggetto restituito da <xref:System.Type.MakeGenericType%2A> equivale il <xref:System.Type> ottenuto chiamando il <xref:System.Object.GetType%2A> metodo dell'oggetto risultante tipo costruito, o <xref:System.Object.GetType%2A> metodo di qualsiasi tipo è stato creato dalla stessa generico costruito definizione del tipo utilizzando gli stessi argomenti di tipo.  
  
> [!NOTE]
>  Una matrice di tipi generici non è un tipo generico. Non è possibile chiamare <xref:System.Type.MakeGenericType%2A> su un tipo matrice, ad esempio `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic). Per costruire un tipo generico chiuso da `C<T>[]`, chiamare <xref:System.Type.GetElementType%2A> per ottenere la definizione di tipo generico `C<T>`; chiamare <xref:System.Type.MakeGenericType%2A> sulla definizione di tipo generico per creare il tipo costruito; e infine chiamare il <xref:System.Type.MakeArrayType%2A> su (metodo) il tipo costruito per creare il tipo di matrice. Lo stesso vale per i tipi di puntatore e `ref` tipi (`ByRef` in Visual Basic).  
  
 Per un elenco delle condizioni invariabili relative ai termini usati dal processo di reflection generico, vedere i commenti sulla proprietà <xref:System.Type.IsGenericType%2A>.  
  
## <a name="nested-types"></a>Tipi annidati  
 Se un tipo generico è definito in c#, C++ o Visual Basic, i relativi tipi annidati sono tutti generici. Questo vale anche se non dispongono di alcun parametro di tipo i propri, perché tutti e tre i linguaggi includono i parametri di tipo dei tipi in inclusione negli elenchi di parametri di tipo per i tipi annidati. Prendere in considerazione le seguenti classi:  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 Elenco di parametri di tipo della classe annidata `Inner` presenta due parametri di tipo, `T` e `U`, il primo dei quali è il parametro di tipo della relativa classe che lo contiene. Analogamente, l'elenco di parametri di tipo della classe annidata `Innermost1` presenta tre parametri di tipo, `T`, `U`, e `V`, con `T` e `U` che provengono dalle relative classi. La classe annidata `Innermost2` presenta due parametri di tipo, `T` e `U`, provenienti da classi che la contengono.  
  
 Se l'elenco di parametri del tipo di inclusione ha più di un parametro di tipo, tutti i parametri di tipo nell'ordine vengono incluse nell'elenco di parametri di tipo del tipo annidato.  
  
 Per costruire un tipo generico dalla definizione del tipo generico per un tipo annidato, chiamare il <xref:System.Type.MakeGenericType%2A> (metodo) con la matrice formata concatenando le matrici di argomento del tipo di tutti i tipi in inclusione, che inizia con il tipo generico più esterno e terminando con il Digitare la matrice di argomenti di tipo annidato, se ha parametri di tipo propri. Per creare un'istanza di `Innermost1`, chiamare il <xref:System.Type.MakeGenericType%2A> (metodo) con una matrice contenente i tre tipi, per poter essere assegnati a T, U e V. Per creare un'istanza di `Innermost2`, chiamare il <xref:System.Type.MakeGenericType%2A> metodo con una matrice che contiene due tipi, per poter essere assegnati a T e U.  
  
 Le lingue propagano i parametri di tipo dei tipi in inclusione in questo modo, in modo è possibile utilizzare i parametri di tipo di un tipo di inclusione per definire i campi dei tipi annidati. In caso contrario, i parametri di tipo non sarebbe nell'ambito dei tipi annidati. È possibile definire i tipi annidati senza propagare i parametri di tipo tipi di inclusione, creazione di codice in un assembly dinamico o usando il [Ilasm.exe (Assembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md). Per l'assembler MSIL, esaminare il codice seguente:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 In questo esempio, non è possibile definire un campo di tipo `T` o `U` nella classe `Innermost`, in quanto tali parametri di tipo non sono presenti nell'ambito. Il codice assembler seguente definisce le classi annidate che presentano lo stesso comportamento che si verifica se è definito in C++, Visual Basic e c#:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 È possibile utilizzare il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare le classi annidate definite nei linguaggi di alto livello e osservare questo schema di denominazione.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Type.MakeGenericType%2A> metodo per creare un tipo costruito dalla definizione del tipo generico per il <xref:System.Collections.Generic.Dictionary%602> tipo. Rappresenta il tipo costruito un <xref:System.Collections.Generic.Dictionary%602> di `Test` oggetti con chiavi di stringa.  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il tipo corrente non rappresenta una definizione di tipo generico, Ciò significa che <see cref="P:System.Type.IsGenericTypeDefinition" /> restituisce <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArguments" /> è <see langword="null" />.  
  
 oppure  
  
 Qualsiasi elemento di <paramref name="typeArguments" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Il numero di elementi in <paramref name="typeArguments" /> non corrisponde al numero di parametri di tipo nella definizione di tipo generico corrente.  
  
 oppure  
  
 Nessun elemento di <paramref name="typeArguments" /> soddisfa i vincoli specificati per il parametro di tipo corrispondente del tipo generico corrente.  
  
 oppure  
  
 <paramref name="typeArguments" /> contiene un elemento che è un tipo di puntatore (<see cref="P:System.Type.IsPointer" /> restituisce <see langword="true" />), un tipo by-ref (<see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />) o <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.NotSupportedException">Il metodo richiamato non è supportato nella classe base. Le classi derivate devono fornire un'implementazione.</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un oggetto <see cref="T:System.Type" /> che rappresenta un puntatore al tipo corrente.</summary>
        <returns>Oggetto <see cref="T:System.Type" /> che rappresenta un puntatore al tipo corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Type.MakePointerType%2A> metodo fornisce un modo per generare i tipi di puntatore per elenchi di parametri.  
  
 Utilizzando la sintassi di Microsoft intermediate language (MSIL), se l'oggetto corrente <xref:System.Type> oggetto <xref:System.Int32>, questo metodo restituisce un <xref:System.Type> che rappresenta l'oggetto `Int32*`.  
  
   
  
## Examples  
 Esempio di codice seguente crea una matrice, `ref` (`ByRef` in Visual Basic) e i tipi di puntatore per il `Test` classe.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il metodo richiamato non è supportato nella classe base.</exception>
        <exception cref="T:System.TypeLoadException">Il tipo corrente è <see cref="T:System.TypedReference" />.  
  
 oppure  
  
 Il tipo corrente è <see langword="ByRef" />, Ciò significa che <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore <see cref="T:System.Reflection.MemberTypes" /> che indica che questo membro è un tipo o un tipo annidato.</summary>
        <value>Valore <see cref="T:System.Reflection.MemberTypes" /> che indica che questo membro è un tipo o un tipo annidato.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esegue l'override di questa proprietà <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>. Pertanto, quando si esamina un set di <xref:System.Reflection.MemberInfo> oggetti, ad esempio, la matrice restituita dal <xref:System.Type.GetMembers%2A>: il <xref:System.Reflection.MemberInfo.MemberType%2A> restituisce proprietà <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> quando un membro specificato è un tipo annidato.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione di tipo generico da cui il tipo è stato costruito. Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato da `MyGenericType<T>`.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questa proprietà restituisce sempre <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato il `MemberType` campo come parametro per il `GetMember` metodo:  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta un valore mancante nelle informazioni <see cref="T:System.Type" />. Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il `Missing` campo per la chiamata tramite la reflection per ottenere il valore predefinito di un parametro. Se il `Missing` campo viene passato un valore del parametro e vi è alcun valore predefinito per tale parametro, un <xref:System.ArgumentException> viene generata un'eccezione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del `Missing` campo per richiamare un metodo con gli argomenti predefiniti.  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 L'output del codice è il seguente:  
  
 a = 10 b = 55.3 c = 12  
  
 a = 10 b = 1.3 c = 1  
  
 un = 10 b = 1.2 c = 1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il modulo (DLL) in cui è definito l'oggetto <see cref="T:System.Type" /> corrente.</summary>
        <value>Modulo in cui è definito l'oggetto <see cref="T:System.Type" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà restituisce il modulo in cui è stata definita la definizione di tipo generico. Ad esempio, se si crea un'istanza di `MyGenericStack<int>`, <xref:System.Type.Module%2A> proprietà per il tipo costruito restituisce il modulo in cui `MyGenericStack<T>` è definito.  
  
 Analogamente, se l'oggetto corrente <xref:System.Type> rappresenta un parametro generico `T`, questa proprietà restituisce l'assembly che contiene il tipo generico che definisce `T`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato un utilizzo del <xref:System.Type.Namespace%2A> e `Module` proprietà e <xref:System.Type.ToString%2A> metodo <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene lo spazio dei nomi dell'oggetto <see cref="T:System.Type" />.</summary>
        <value>Spazio dei nomi di <see cref="T:System.Type" />; <see langword="null" /> se l'istanza corrente non dispone di alcuno spazio dei nomi o rappresenta un parametro generico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uno spazio dei nomi è una comodità denominazione, in fase di progettazione logica viene utilizzata principalmente per definire l'ambito in un'applicazione e organizzare le classi e altri tipi in una singola struttura gerarchica. Dal punto di vista del runtime, non ci sono spazi.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà restituisce lo spazio dei nomi che contiene la definizione di tipo generico. Analogamente, se l'oggetto corrente <xref:System.Type> rappresenta un parametro generico `T`, questa proprietà restituisce lo spazio dei nomi che contiene la definizione di tipo generico che definisce `T`.  
  
 Se l'oggetto corrente <xref:System.Type> oggetto rappresenta un parametro generico, questa proprietà restituisce `null`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato un utilizzo del `Namespace` e <xref:System.Type.Module%2A> proprietà e <xref:System.Type.ToString%2A> metodo <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">Primo oggetto da confrontare.</param>
        <param name="right">Secondo oggetto da confrontare.</param>
        <summary>Indica se due oggetti <see cref="T:System.Type" /> sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> è uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">Primo oggetto da confrontare.</param>
        <param name="right">Secondo oggetto da confrontare.</param>
        <summary>Indica se due oggetti <see cref="T:System.Type" /> non sono uguali.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> non è uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto classe usato per ottenere questo membro.</summary>
        <value>Oggetto <see langword="Type" /> tramite il quale è stato ottenuto questo oggetto <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per <xref:System.Type> oggetti, il valore di questa proprietà è sempre lo stesso valore di <xref:System.Type.DeclaringType%2A> proprietà.  
  
   
  
## Examples  
 Questo esempio visualizza il tipo riflesso di una classe annidata.  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nome completo di assembly dell'oggetto <see cref="T:System.Type" /> da ottenere.</param>
        <param name="throwIfNotFound">
          <see langword="true" /> per generare un'eccezione <see cref="T:System.TypeLoadException" /> se non è possibile trovare il tipo, <see langword="false" /> per restituire <see langword="null" /> se non è possibile trovare il tipo. Se si specifica <see langword="false" /> vengono eliminate alcune condizioni di eccezione, ma non tutte. Vedere la sezione relativa alle eccezioni.</param>
        <param name="ignoreCase">
          <see langword="true" /> per eseguire una ricerca di <c>typeName</c> senza distinzione tra maiuscole e minuscole, <see langword="false" /> per eseguire una ricerca di <c>typeName</c> con distinzione tra maiuscole e minuscole.</param>
        <summary>Ottiene l'oggetto <see cref="T:System.Type" /> con il nome specificato, indicando se eseguire una ricerca con distinzione tra maiuscole e minuscole e se generare un'eccezione in caso il tipo non venga trovato. Il tipo viene caricato a scopo di reflection, non per l'esecuzione.</summary>
        <returns>Tipo con il nome specificato, se presente; in caso contrario, <see langword="null" />. Se il tipo non viene trovato, il parametro <paramref name="throwIfNotFound" /> specifica se viene restituito <see langword="null" /> o se viene generata un'eccezione. In alcuni casi, viene generata un'eccezione indipendentemente dal valore di <paramref name="throwIfNotFound" />. Vedere la sezione relativa alle eccezioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'assembly contenente il tipo non è già caricato nel contesto reflection-only, utilizzando il <xref:System.Type.ReflectionOnlyGetType%2A> metodo è equivalente al primo caricamento dell'assembly ReflectionOnly, utilizzando il <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> (metodo) e quindi il caricamento del tipo chiamando il assembly <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> metodo. Per informazioni sui nomi completi di assembly, vedere il <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> proprietà. Per ulteriori informazioni su come specificare i nomi dei tipi, vedere il <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> overload del metodo.  
  
 Se l'assembly è già caricato per l'esecuzione, nel contesto reflection-only viene caricata la copia di un altro.  
  
 Il `throwIfNotFound` parametro specifica che cosa avviene quando non viene trovato, il tipo e vengono eliminate alcune condizioni di eccezione, come descritto nella sezione eccezioni. Alcune eccezioni vengono generate indipendentemente dal valore di `throwIfNotFound`. Se l'assembly non è valido, ad esempio un <xref:System.BadImageFormatException> viene generata anche se `throwIfNotFound` è `false`.  
  
 Per ulteriori informazioni sull'utilizzo del contesto reflection-only, vedere [procedura: caricamento di assembly nel contesto di only](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Viene richiamato un inizializzatore di classi e viene generata un'eccezione.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwIfNotFound" /> è <see langword="true" /> e il tipo non è stato trovato.  
  
 oppure  
  
 <paramref name="throwIfNotFound" /> è <see langword="true" /> e <paramref name="typeName" /> contiene caratteri non validi, ad esempio una scheda incorporata.  
  
 oppure  
  
 <paramref name="throwIfNotFound" /> è <see langword="true" /> e <paramref name="typeName" /> è una stringa vuota.  
  
 oppure  
  
 <paramref name="throwIfNotFound" /> è <see langword="true" /> e <paramref name="typeName" /> rappresenta un tipo di matrice con una dimensione non valida.  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta una matrice di oggetti <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> non include il nome dell'assembly.  
  
 oppure  
  
 <paramref name="throwIfNotFound" /> è <see langword="true" /> e <paramref name="typeName" /> contiene sintassi non valida, ad esempio "MyType[,*,]".  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta un tipo generico che ha un tipo di puntatore, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> tra i relativi argomenti di tipo.  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta un tipo generico che ha un numero errato di argomenti di tipo.  
  
 oppure  
  
 <paramref name="typeName" /> rappresenta un tipo generico e uno dei relativi argomenti di tipo non soddisfa i vincoli per il parametro di tipo corrispondente.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwIfNotFound" /> è <see langword="true" /> e l'assembly o una delle sue dipendenze non è stato trovato.</exception>
        <exception cref="T:System.IO.FileLoadException">L'assembly o una delle relative dipendenze è stato trovato, ma non può essere caricato.</exception>
        <exception cref="T:System.BadImageFormatException">L'assembly o una delle relative dipendenze non è valido.  
  
 oppure  
  
 L'assembly è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una classe <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> che descrive il layout del tipo corrente.</summary>
        <value>Ottiene una classe <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> che descrive le caratteristiche complessive di layout del tipo corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute> non viene restituito dal <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metodo. Utilizzare questa proprietà per ottenerlo.  
  
   
  
## Examples  
 L'esempio di codice seguente viene definita innanzitutto una classe, una struttura e una struttura con gli attributi di layout speciali (le strutture sono annidate all'interno della classe). Nell'esempio viene utilizzata la <xref:System.Type.StructLayoutAttribute%2A> proprietà per ottenere un <xref:System.Runtime.InteropServices.StructLayoutAttribute> per ogni tipo e vengono visualizzate le proprietà degli attributi.  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il metodo richiamato non è supportato nella classe base.</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Riservato per utilizzi futuri. Deve essere IID_NULL.</param>
        <param name="rgszNames">Matrice di nomi passata di cui eseguire il mapping.</param>
        <param name="cNames">Conteggio dei nomi di cui eseguire il mapping.</param>
        <param name="lcid">Contesto delle impostazioni locali in cui interpretare i nomi.</param>
        <param name="rgDispId">Matrice allocata dal chiamante che riceve gli ID corrispondenti ai nomi.</param>
        <summary>Esegue il mapping di un set di nomi a un set corrispondente di ID dispatch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::GetIDsOfNames`, vedere MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informazioni sul tipo da restituire.</param>
        <param name="lcid">Identificatore delle impostazioni locali per le informazioni sul tipo.</param>
        <param name="ppTInfo">Puntatore all'oggetto di informazioni sul tipo richiesto.</param>
        <summary>Recupera le informazioni sul tipo relative a un oggetto che può quindi essere usato per ottenere informazioni sul tipo relative a un'interfaccia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::GetTypeInfo`, vedere MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Punta a una posizione che riceve il numero di interfacce di informazioni sul tipo fornite dall'oggetto.</param>
        <summary>Recupera il numero delle interfacce di informazioni sul tipo fornite da un oggetto (0 o 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::GetTypeInfoCount`, vedere MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifica il membro.</param>
        <param name="riid">Riservato per utilizzi futuri. Deve essere IID_NULL.</param>
        <param name="lcid">Contesto di impostazioni locali all'interno del quale devono essere interpretati gli argomenti.</param>
        <param name="wFlags">Flag che descrivono il contesto della chiamata.</param>
        <param name="pDispParams">Puntatore a una struttura contenente una matrice di argomenti, una matrice di DISPID per argomenti denominati e i conteggi del numero di elementi nelle matrici.</param>
        <param name="pVarResult">Puntatore alla posizione in cui deve essere archiviato il risultato.</param>
        <param name="pExcepInfo">Puntatore a una struttura contenente informazioni sull'eccezione.</param>
        <param name="puArgErr">Indice del primo argomento che contiene un errore.</param>
        <summary>Fornisce l'accesso a proprietà e metodi esposti da un oggetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::Invoke`, vedere MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un valore <see langword="String" /> che rappresenta il nome del <see langword="Type" /> corrente.</summary>
        <returns>Oggetto <see cref="T:System.String" /> che rappresenta il nome dell'oggetto <see cref="T:System.Type" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo restituisce il nome completo common language runtime lo spazio dei nomi e il nome per tutti i tipi primitivi. Ad esempio, l'istruzione c#, `(long)0.Type().ToString()` restituisce "System. Int64" anziché semplicemente "Int64".  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico, il tipo e i relativi argomenti di tipo sono qualificati dallo spazio dei nomi e dal tipo annidato, ma non dall'assembly. Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questo metodo restituisce il nome non qualificato del parametro di tipo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato un utilizzo del <xref:System.Type.Namespace%2A> e <xref:System.Type.Module%2A> proprietà e `ToString` metodo <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 L'esempio seguente confronta le stringhe restituite dal <xref:System.Type.ToString%2A> (metodo) e `Name`, <xref:System.Type.FullName%2A>, e <xref:System.Type.AssemblyQualifiedName%2A> proprietà.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>che rappresenta il nome dell'oggetto <see cref="T:System.Type" /> corrente.</summary>
        <value>Handle per l'oggetto <see cref="T:System.Type" /> corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle` Incapsula un puntatore a una struttura dati interna che rappresenta il tipo. Questo handle è univoco nel corso della durata del processo. L'handle è valido solo nel dominio dell'applicazione in cui è stato ottenuto.  
  
   
  
## Examples  
 Nell'esempio seguente restituisce l'handle del tipo corrispondente e passa l'handle a un metodo che ottiene il tipo dall'handle e lo visualizza.  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Questa proprietà non è attualmente supportata in .NET Compact Framework.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'inizializzatore per il tipo.</summary>
        <value>Oggetto che contiene il nome del costruttore di classe per l'oggetto <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli inizializzatori di classi sono disponibili anche tramite il <xref:System.Type.FindMembers%2A> metodo, o tramite gli overload del <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, e <xref:System.Type.GetConstructors%2A> metodi che accettano <xref:System.Reflection.BindingFlags> come parametro.  
  
 Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o un metodo generico, questa proprietà restituisce `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica il tipo fornito da Common Language Runtime che rappresenta questo tipo.</summary>
        <value>Tipo di sistema sottostante per l'oggetto <see cref="T:System.Type" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>