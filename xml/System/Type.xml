<Type Name="Type" FullName="System.Type">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4c442b0e3855ad0206a02ff13f35e3b09a89b66f" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48621108" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="4ee8d-101">Rappresenta dichiarazioni di tipo: tipi classe, tipi interfaccia, tipi matrice, tipi di valore e di enumerazione, parametri di tipo, definizioni di tipo generico e tipi generici costruiti chiusi o aperti.</span>
      <span class="sxs-lookup">
        <span data-stu-id="4ee8d-101">Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-102">`Type` è la radice del <xref:System.Reflection> funzionalità ed è il modo principale per accedere ai metadati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-102">`Type` is the root of the <xref:System.Reflection> functionality and is the primary way to access metadata.</span></span> <span data-ttu-id="4ee8d-103">Usare i membri di <xref:System.Type> per ottenere informazioni su una dichiarazione del tipo, sui membri di un tipo (ad esempio i costruttori, metodi, campi, proprietà ed eventi di una classe), nonché il modulo e assembly in cui è distribuita la classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-103">Use the members of <xref:System.Type> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.</span></span>  
  
 <span data-ttu-id="4ee8d-104">Non sono necessarie autorizzazioni per il codice usare la reflection per ottenere informazioni sui tipi e i relativi membri, indipendentemente dalla loro i livelli di accesso.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-104">No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels.</span></span> <span data-ttu-id="4ee8d-105">Non sono necessarie autorizzazioni per il codice usare la reflection per accedere ai membri pubblici o su altri membri i cui livelli di accesso li renderebbero visibile durante la compilazione normale.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-105">No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation.</span></span> <span data-ttu-id="4ee8d-106">Tuttavia, in ordine per il codice usare la reflection per accedere ai membri che sarebbero normalmente inaccessibili, ad esempio metodi privati o interni o protetti i campi di un tipo di classe non eredita, il codice deve disporre <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-106">However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="4ee8d-107">Visualizzare [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-107">See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span>  
  
 <span data-ttu-id="4ee8d-108">`Type` è una classe base astratta che consente a più implementazioni.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-108">`Type` is an abstract base class that allows multiple implementations.</span></span> <span data-ttu-id="4ee8d-109">Il sistema offrirà sempre la classe derivata `RuntimeType`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-109">The system will always provide the derived class `RuntimeType`.</span></span> <span data-ttu-id="4ee8d-110">Nella reflection, tutte le classi che iniziano con la parola Runtime vengono create una sola volta per ogni oggetto nelle operazioni di confronto di sistema e supporto.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-110">In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-111">Negli scenari di multithreading, non bloccare <xref:System.Type> oggetti per sincronizzare l'accesso a `static` dati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-111">In multithreading scenarios, do not lock <xref:System.Type> objects in order to synchronize access to `static` data.</span></span> <span data-ttu-id="4ee8d-112">Altro codice, in cui si ha alcun controllo, potrebbe anche bloccare il tipo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-112">Other code, over which you have no control, might also lock your class type.</span></span> <span data-ttu-id="4ee8d-113">Ciò potrebbe comportare un deadlock.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-113">This might result in a deadlock.</span></span> <span data-ttu-id="4ee8d-114">Al contrario, sincronizzare l'accesso ai dati statici bloccando una privata `static` oggetto.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-114">Instead, synchronize access to static data by locking a private `static` object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-115">Una classe derivata può accedere ai membri protetti delle classi di base del codice chiamante.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-115">A derived class can access protected members of the calling code's base classes.</span></span> <span data-ttu-id="4ee8d-116">Inoltre, è consentito l'accesso ai membri di assembly dell'assembly del codice chiamante.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-116">Also, access is allowed to assembly members of the calling code's assembly.</span></span> <span data-ttu-id="4ee8d-117">Di norma, se è consentito l'accesso nel codice con associazione anticipata, è consentito anche al codice di associazione tardiva.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-117">As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-118">Le interfacce che estendono le altre interfacce non ereditano i metodi definiti nelle interfacce estese.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-118">Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.</span></span>  
  
 <span data-ttu-id="4ee8d-119">Contenuto della sezione:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-119">In this section:</span></span>  
  
 <span data-ttu-id="4ee8d-120">[I tipi rappresenta un oggetto di tipo?](#WhatTypes) </span><span class="sxs-lookup"><span data-stu-id="4ee8d-120">[What types does a Type object represent?](#WhatTypes) </span></span>  
 <span data-ttu-id="4ee8d-121">[Recupero di un oggetto di tipo](#Retrieve) </span><span class="sxs-lookup"><span data-stu-id="4ee8d-121">[Retrieving a Type object](#Retrieve) </span></span>  
 [<span data-ttu-id="4ee8d-122">Confronto tra gli oggetti di tipo per verificarne l'uguaglianza</span><span class="sxs-lookup"><span data-stu-id="4ee8d-122">Comparing type objects for equality</span></span>](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a><span data-ttu-id="4ee8d-123">I tipi rappresenta un oggetto di tipo?</span><span class="sxs-lookup"><span data-stu-id="4ee8d-123">What types does a Type object represent?</span></span>  
 <span data-ttu-id="4ee8d-124">Questa classe è thread-safe. più thread possono leggere simultaneamente da un'istanza di questo tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-124">This class is thread safe; multiple threads can concurrently read from an instance of this type.</span></span> <span data-ttu-id="4ee8d-125">Un'istanza di <xref:System.Type> classe può rappresentare uno qualsiasi dei tipi seguenti:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-125">An instance of the <xref:System.Type> class can represent any of the following types:</span></span>  
  
-   <span data-ttu-id="4ee8d-126">Classi</span><span class="sxs-lookup"><span data-stu-id="4ee8d-126">Classes</span></span>  
  
-   <span data-ttu-id="4ee8d-127">Tipi valore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-127">Value types</span></span>  
  
-   <span data-ttu-id="4ee8d-128">Matrici</span><span class="sxs-lookup"><span data-stu-id="4ee8d-128">Arrays</span></span>  
  
-   <span data-ttu-id="4ee8d-129">Interfacce</span><span class="sxs-lookup"><span data-stu-id="4ee8d-129">Interfaces</span></span>  
  
-   <span data-ttu-id="4ee8d-130">Enumerazioni</span><span class="sxs-lookup"><span data-stu-id="4ee8d-130">Enumerations</span></span>  
  
-   <span data-ttu-id="4ee8d-131">Delegati</span><span class="sxs-lookup"><span data-stu-id="4ee8d-131">Delegates</span></span>  
  
-   <span data-ttu-id="4ee8d-132">Tipi generici costruiti e definizioni di tipo generico</span><span class="sxs-lookup"><span data-stu-id="4ee8d-132">Constructed generic types and generic type definitions</span></span>  
  
-   <span data-ttu-id="4ee8d-133">Digitare gli argomenti e parametri di tipi generici costruiti, definizioni di tipi generici e definizioni di metodo generico di tipo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-133">Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</span></span>  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a><span data-ttu-id="4ee8d-134">Recupero di un oggetto di tipo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-134">Retrieving a Type object</span></span>  
 <span data-ttu-id="4ee8d-135">Il <xref:System.Type> oggetto associato a un determinato tipo può essere ottenuto nei modi seguenti:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-135">The <xref:System.Type> object associated with a particular type can be obtained in the following ways:</span></span>  
  
-   <span data-ttu-id="4ee8d-136">L'istanza <xref:System.Object.GetType%2A?displayProperty=nameWithType> metodo restituisce un <xref:System.Type> oggetto che rappresenta il tipo di un'istanza.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-136">The instance <xref:System.Object.GetType%2A?displayProperty=nameWithType> method returns a <xref:System.Type> object that represents the type of an instance.</span></span> <span data-ttu-id="4ee8d-137">Poiché tutti i tipi gestiti derivano dalle <xref:System.Object>, il <xref:System.Object.GetType%2A> metodo può essere chiamato in un'istanza di qualsiasi tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-137">Because all managed types derive from <xref:System.Object>, the <xref:System.Object.GetType%2A> method can be called on an instance of any type.</span></span>  
  
     <span data-ttu-id="4ee8d-138">L'esempio seguente chiama il <xref:System.Object.GetType%2A?displayProperty=nameWithType> metodo per determinare il tipo di runtime di ogni oggetto nella matrice di oggetti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-138">The following example calls the <xref:System.Object.GetType%2A?displayProperty=nameWithType> method to determine the runtime type of each object in an object array.</span></span>  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   <span data-ttu-id="4ee8d-139">Il metodo statico <xref:System.Type.GetType%2A?displayProperty=nameWithType> metodi restituiscono un <xref:System.Type> oggetto che rappresenta un tipo specificato dal relativo nome completo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-139">The static <xref:System.Type.GetType%2A?displayProperty=nameWithType> methods return a <xref:System.Type> object that represents a type specified by its fully qualified name.</span></span>  
  
-   <span data-ttu-id="4ee8d-140">Il <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, e <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> metodi restituiscono `Type` gli oggetti che rappresentano i tipi definiti in un modulo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-140">The <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> methods return `Type` objects that represent the types defined in a module.</span></span> <span data-ttu-id="4ee8d-141">Il primo metodo è utilizzabile per ottenere una matrice di <xref:System.Type> oggetti per tutti i tipi pubblici e privati definiti in un modulo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-141">The first method can be used to obtain an array of <xref:System.Type> objects for all the public and private types defined in a module.</span></span> <span data-ttu-id="4ee8d-142">(È possibile ottenere un'istanza di `Module` tramite il <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> oppure <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> metodo, o tramite il <xref:System.Type.Module%2A?displayProperty=nameWithType> proprietà.)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-142">(You can obtain an instance of `Module` through the <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> method, or through the <xref:System.Type.Module%2A?displayProperty=nameWithType> property.)</span></span>  
  
-   <span data-ttu-id="4ee8d-143">Il <xref:System.Reflection.Assembly?displayProperty=nameWithType> oggetto contiene un numero di metodi per recuperare le classi definite in un assembly, inclusa <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, e <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-143">The <xref:System.Reflection.Assembly?displayProperty=nameWithType> object contains a number of methods to retrieve the classes defined in an assembly, including <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="4ee8d-144">Il <xref:System.Type.FindInterfaces%2A> metodo restituisce un elenco filtrato dei tipi di interfaccia supportata da un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-144">The <xref:System.Type.FindInterfaces%2A> method returns a filtered list of interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="4ee8d-145">Il <xref:System.Type.GetElementType%2A> metodo restituisce un `Type` oggetto che rappresenta l'elemento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-145">The <xref:System.Type.GetElementType%2A> method returns a `Type` object that represents the element.</span></span>  
  
-   <span data-ttu-id="4ee8d-146">Il <xref:System.Type.GetInterfaces%2A> e <xref:System.Type.GetInterface%2A> metodi restituiscono <xref:System.Type> gli oggetti che rappresentano i tipi di interfaccia supportati da un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-146">The <xref:System.Type.GetInterfaces%2A> and <xref:System.Type.GetInterface%2A> methods return <xref:System.Type> objects representing the interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="4ee8d-147">Il <xref:System.Type.GetTypeArray%2A> metodo restituisce una matrice di <xref:System.Type> gli oggetti che rappresentano i tipi specificati da un set arbitrario di oggetti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-147">The <xref:System.Type.GetTypeArray%2A> method returns an array of <xref:System.Type> objects representing the types specified by an arbitrary set of objects.</span></span> <span data-ttu-id="4ee8d-148">Gli oggetti vengono specificati con una matrice di tipo <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-148">The objects are specified with an array of type <xref:System.Object>.</span></span>  
  
-   <span data-ttu-id="4ee8d-149">Il <xref:System.Type.GetTypeFromProgID%2A> e <xref:System.Type.GetTypeFromCLSID%2A> vengono forniti metodi per l'interoperabilità COM.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-149">The <xref:System.Type.GetTypeFromProgID%2A> and <xref:System.Type.GetTypeFromCLSID%2A> methods are provided for COM interoperability.</span></span> <span data-ttu-id="4ee8d-150">Restituiscono un <xref:System.Type> oggetto che rappresenta il tipo specificato da un `ProgID` o `CLSID`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-150">They return a <xref:System.Type> object that represents the type specified by a `ProgID` or `CLSID`.</span></span>  
  
-   <span data-ttu-id="4ee8d-151">Il <xref:System.Type.GetTypeFromHandle%2A> metodo è fornito per garantire l'interoperabilità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-151">The <xref:System.Type.GetTypeFromHandle%2A> method is provided for interoperability.</span></span> <span data-ttu-id="4ee8d-152">Restituisce un `Type` oggetto che rappresenta il tipo specificato da un handle di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-152">It returns a `Type` object that represents the type specified by a class handle.</span></span>  
  
-   <span data-ttu-id="4ee8d-153">Il codice c# `typeof` operatore C++ `typeid` operatore e Visual Basic `GetType` operatore ottenere il `Type` oggetto per un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-153">The C# `typeof` operator, the C++ `typeid` operator, and the Visual Basic `GetType` operator obtain the `Type` object for a type.</span></span>  
  
-   <span data-ttu-id="4ee8d-154">Il <xref:System.Type.MakeGenericType%2A> metodo restituisce un <xref:System.Type> oggetto che rappresenta un tipo generico costruito, che è un tipo costruito aperto se relativi <xref:System.Type.ContainsGenericParameters%2A> restituisce proprietà `true`, e un tipo costruito chiuso in caso contrario.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-154">The <xref:System.Type.MakeGenericType%2A> method returns a <xref:System.Type> object representing a constructed generic type, which is an open constructed type if its <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, and a closed constructed type otherwise.</span></span> <span data-ttu-id="4ee8d-155">Un tipo generico è possibile creare istanze solo se è chiuso.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-155">A generic type can be instantiated only if it is closed.</span></span>  
  
-   <span data-ttu-id="4ee8d-156">Il <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, e <xref:System.Type.MakeByRefType%2A> metodi restituiscono <xref:System.Type> gli oggetti che rappresentano, rispettivamente, una matrice di un tipo specificato, un puntatore a un tipo specificato e il tipo di un parametro di riferimento (`ref` in c# `ByRef`in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-156">The <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, and <xref:System.Type.MakeByRefType%2A> methods return <xref:System.Type> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (`ref` in C#, `ByRef` in Visual Basic).</span></span>  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a><span data-ttu-id="4ee8d-157">Confronto tra gli oggetti di tipo per verificarne l'uguaglianza</span><span class="sxs-lookup"><span data-stu-id="4ee8d-157">Comparing type objects for equality</span></span>  
 <span data-ttu-id="4ee8d-158">Oggetto <xref:System.Type> oggetto che rappresenta un tipo è univoco, vale a dire due <xref:System.Type> riferimenti ad oggetti puntano allo stesso oggetto solo se rappresentino lo stesso tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-158">A <xref:System.Type> object that represents a type is unique; that is, two <xref:System.Type> object references refer to the same object if and only if they represent the same type.</span></span> <span data-ttu-id="4ee8d-159">In questo modo per il confronto di <xref:System.Type> oggetti utilizzando l'uguaglianza dei riferimenti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-159">This allows for comparison of <xref:System.Type> objects using reference equality.</span></span> <span data-ttu-id="4ee8d-160">Nell'esempio seguente vengono confrontate le <xref:System.Type> gli oggetti che rappresentano un numero di valori interi per determinare se sono dello stesso tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-160">The following example compares the <xref:System.Type> objects that represent a number of integer values to determine whether they are of the same type.</span></span>  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-161">L'esempio seguente illustra alcune funzionalità rappresentative di <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-161">The following  example shows a few representative features of <xref:System.Type>.</span></span> <span data-ttu-id="4ee8d-162">Il codice c# `typeof` operatore (`GetType` operatore in Visual Basic `typeid` operatore in Visual C++) viene usato per ottenere una <xref:System.Type> che rappresenta l'oggetto <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-162">The C# `typeof` operator (`GetType` operator in Visual Basic, `typeid` operator in Visual C++) is used to get a <xref:System.Type> object representing <xref:System.String>.</span></span> <span data-ttu-id="4ee8d-163">Da questo <xref:System.Type> oggetti, il <xref:System.Type.GetMethod%2A> metodo viene utilizzato per ottenere un <xref:System.Reflection.MethodInfo> che rappresenta il <xref:System.String.Substring%2A> overload che accetta una posizione di inizio e una lunghezza.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-163">From this <xref:System.Type> object, the <xref:System.Type.GetMethod%2A> method is used to get a <xref:System.Reflection.MethodInfo> representing the <xref:System.String.Substring%2A> overload that takes a starting location and a length.</span></span>  
  
 <span data-ttu-id="4ee8d-164">Per identificare la firma di overload, l'esempio di codice crea una matrice temporanea contenente due <xref:System.Type> gli oggetti che rappresentano `int` (`Integer` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-164">To identify the overload signature, the code example creates a temporary array containing two <xref:System.Type> objects representing `int` (`Integer` in Visual Basic).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-165">Per essere precisi, la matrice contiene due riferimenti all'istanza di <xref:System.Type> che rappresenta `int` nel dominio dell'applicazione corrente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-165">To be precise, the array contains two references to the instance of <xref:System.Type> that represents `int` in the current application domain.</span></span> <span data-ttu-id="4ee8d-166">Per qualsiasi tipo, è disponibile solo un'istanza di <xref:System.Type> per ogni dominio dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-166">For any type, there is only one instance of <xref:System.Type> per application domain.</span></span>  
  
 <span data-ttu-id="4ee8d-167">L'esempio di codice Usa il <xref:System.Reflection.MethodInfo> per richiamare il <xref:System.String.Substring%2A> metodo sulla stringa "Hello, World!" e visualizza il risultato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-167">The code example uses the <xref:System.Reflection.MethodInfo> to invoke the <xref:System.String.Substring%2A> method on the string "Hello, World!", and displays the result.</span></span>  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="4ee8d-168">Questo tipo è thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="4ee8d-168">This type is thread safe.</span>
      </span>
    </threadsafe>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="4ee8d-169">Quando si eredita da <see langword="Type" />, è necessario eseguire l'override dei membri seguenti:</span>
        <span class="sxs-lookup">
          <span data-stu-id="4ee8d-169">When you inherit from <see langword="Type" />, you must override the following members:</span>
        </span> 
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" /><span data-ttu-id="4ee8d-170">
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,</span><span class="sxs-lookup"><span data-stu-id="4ee8d-170">
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,</span></span> 
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para>
    </block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="~/docs/framework/reflection-and-codedom/viewing-type-information.md">
      <span data-ttu-id="4ee8d-171">Visualizzazione delle informazioni sul tipo</span>
      <span class="sxs-lookup">
        <span data-stu-id="4ee8d-171">Viewing Type Information</span>
      </span>
    </related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-172">Inizializza una nuova istanza della classe <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-172">Initializes a new instance of the <see cref="T:System.Type" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-173">Questo costruttore viene richiamato da classi derivate durante la costruzione di oggetti di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-173">This constructor is invoked by derived classes during the construction of type objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-174">Ottiene la classe <see cref="T:System.Reflection.Assembly" /> in cui è dichiarato il tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-174">Gets the <see cref="T:System.Reflection.Assembly" /> in which the type is declared.</span>
          </span>
          <span data-ttu-id="4ee8d-175">Per i tipi generici, ottiene la classe <see cref="T:System.Reflection.Assembly" /> in cui è definito il tipo generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-175">For generic types, gets the <see cref="T:System.Reflection.Assembly" /> in which the generic type is defined.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-176">Istanza di <see cref="T:System.Reflection.Assembly" /> che descrive l'assembly contenente il tipo corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-176">An <see cref="T:System.Reflection.Assembly" /> instance that describes the assembly containing the current type.</span>
          </span>
          <span data-ttu-id="4ee8d-177">Per i tipi generici, l'istanza descrive l'assembly contenente la definizione di tipo generico, non l'assembly che crea e usa un determinato tipo costruito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-177">For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-178">Se l'oggetto corrente <xref:System.Type> oggetto rappresenta un tipo generico costruito, questa proprietà restituisce l'assembly che contiene la definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-178">If the current <xref:System.Type> object represents a constructed generic type, this property returns the assembly that contains the generic type definition.</span></span> <span data-ttu-id="4ee8d-179">Ad esempio, si supponga di crea un assembly denominato MyGenerics che contiene la definizione di tipo generico `MyGenericStack<T>` (`MyGenericStack(Of T)` in Visual Basic `generic<T> ref class MyGenericStack` in C++).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-179">For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition `MyGenericStack<T>` (`MyGenericStack(Of T)` in Visual Basic, `generic<T> ref class MyGenericStack` in C++).</span></span> <span data-ttu-id="4ee8d-180">Se si crea un'istanza di `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in un altro assembly, il <xref:System.Type.Assembly%2A> restituisce proprietà per il tipo costruito un <xref:System.Reflection.Assembly> oggetto che rappresenta MyGenerics.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-180">If you create an instance of `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in another assembly, the <xref:System.Type.Assembly%2A> property for the constructed type returns an <xref:System.Reflection.Assembly> object that represents MyGenerics.dll.</span></span>  
  
 <span data-ttu-id="4ee8d-181">Analogamente, se l'oggetto corrente <xref:System.Type> oggetto rappresenta un parametro generico non assegnato `T`, questa proprietà restituisce l'assembly che contiene il tipo generico che definisce `T`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-181">Similarly, if the current <xref:System.Type> object represents an unassigned generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
 <span data-ttu-id="4ee8d-182">Se il <xref:System.Type.Assembly%2A?displayProperty=nameWithType> proprietà non è disponibile in una particolare implementazione di .NET, ad esempio .NET Core o la piattaforma Windows universale, usare il <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> proprietà invece.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-182">If the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property is not available on a particular .NET implementation, such as .NET Core or the Universal Windows Platform, use the <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> property instead.</span></span>      
  
 <span data-ttu-id="4ee8d-183">Questa proprietà è di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-183">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-184">Nell'esempio seguente visualizza il nome dell'assembly associato alla classe e il nome completo del tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-184">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-185">Ottiene il nome qualificato dall'assembly del tipo, che include il nome dell'assembly da cui è stato caricato l'oggetto <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-185">Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <see cref="T:System.Type" /> object was loaded.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-186">Nome qualificato dall'assembly dell'oggetto <see cref="T:System.Type" />, che include il nome dell'assembly da cui è stato caricato <see cref="T:System.Type" /> oppure <see langword="null" /> se l'istanza corrente rappresenta un parametro di tipo generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-186">The assembly-qualified name of the <see cref="T:System.Type" />, which includes the name of the assembly from which the <see cref="T:System.Type" /> was loaded, or <see langword="null" /> if the current instance represents a generic type parameter.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-187">Il nome di un tipo qualificato dall'assembly è costituito il nome del tipo, incluso lo spazio dei nomi, seguito da una virgola, seguita dal nome visualizzato dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-187">The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly.</span></span> <span data-ttu-id="4ee8d-188">Il nome visualizzato di un assembly viene ottenuto usando la <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-188">The display name of an assembly is obtained using the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-189">In .NET Framework versione 2.0, architettura del processore viene aggiunta all'identità di assembly e può essere specificato come parte di stringhe di nomi di assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-189">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="4ee8d-190">Ad esempio, "ProcessorArchitecture = msil".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-190">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="4ee8d-191">Tuttavia, non è incluso nella stringa restituita dal <xref:System.Type.AssemblyQualifiedName%2A> proprietà, per motivi di compatibilità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-191">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="4ee8d-192">Vedere <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-192">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="4ee8d-193">Tutti i compilatori che supportano common language runtime creano il semplice nome di una classe annidata e un nome modificato quando si riceve una richiesta, in conformità con le seguenti convenzioni di costrutti di reflection.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-193">All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
|<span data-ttu-id="4ee8d-194">Delimitatore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-194">Delimiter</span></span>|<span data-ttu-id="4ee8d-195">Significato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-195">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="4ee8d-196">Barra rovesciata (\\)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-196">Backslash (\\)</span></span>|<span data-ttu-id="4ee8d-197">Carattere di escape.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-197">Escape character.</span></span>|  
|<span data-ttu-id="4ee8d-198">Virgola ()</span><span class="sxs-lookup"><span data-stu-id="4ee8d-198">Comma (,)</span></span>|<span data-ttu-id="4ee8d-199">Precede il nome dell'Assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-199">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="4ee8d-200">Segno più (+)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-200">Plus sign (+)</span></span>|<span data-ttu-id="4ee8d-201">Precede una classe annidata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-201">Precedes a nested class.</span></span>|  
|<span data-ttu-id="4ee8d-202">Punto (.)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-202">Period (.)</span></span>|<span data-ttu-id="4ee8d-203">Indica gli identificatori dello spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-203">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="4ee8d-204">Parentesi quadre ([])</span><span class="sxs-lookup"><span data-stu-id="4ee8d-204">Brackets ([])</span></span>|<span data-ttu-id="4ee8d-205">Dopo un nome di tipo, indica una matrice di quel tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-205">After a type name, denotes an array of that type.</span></span><br /><br /> <span data-ttu-id="4ee8d-206">oppure</span><span class="sxs-lookup"><span data-stu-id="4ee8d-206">-or-</span></span><br /><br /> <span data-ttu-id="4ee8d-207">Per un tipo generico, incluso l'elenco di argomenti tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-207">For a generic type, encloses the generic type argument list.</span></span><br /><br /> <span data-ttu-id="4ee8d-208">oppure</span><span class="sxs-lookup"><span data-stu-id="4ee8d-208">-or-</span></span><br /><br /> <span data-ttu-id="4ee8d-209">All'interno di un elenco di argomenti, include un tipo qualificato dall'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-209">Within a type argument list, encloses an assembly-qualified type.</span></span>|  
  
 <span data-ttu-id="4ee8d-210">Il nome qualificato dall'assembly per una classe, ad esempio, potrebbe essere simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-210">For example, the assembly-qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 <span data-ttu-id="4ee8d-211">Se lo spazio dei nomi contiene un segno più, ad esempio TopNamespace.Sub+Namespace, quindi il segno più (+) potrebbe essere preceduto da un carattere di escape (\\) per impedire che venga interpretato come separatore di annidamento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-211">If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="4ee8d-212">Questa stringa viene creata come indicato di seguito tramite reflection:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-212">Reflection would emit this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 <span data-ttu-id="4ee8d-213">Oggetto "+" diventa "\\+\\+" e un "\\"diventa"\\\\".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-213">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="4ee8d-214">Questo nome completo può essere persistente e successivamente utilizzato per caricare il <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-214">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="4ee8d-215">Per cercare e caricare un <xref:System.Type>, usare <xref:System.Type.GetType%2A> o con il tipo di nome solo oppure con il nome completo del tipo dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-215">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="4ee8d-216"><xref:System.Type.GetType%2A> con il tipo di nome solo cercherà il <xref:System.Type> nell'assembly del chiamante, quindi nell'assembly di sistema.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-216"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="4ee8d-217"><xref:System.Type.GetType%2A> con l'assembly avrà un aspetto completo del tipo il <xref:System.Type> nell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-217"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="4ee8d-218">I nomi dei tipi possono includere caratteri finali che indicano le informazioni aggiuntive sul tipo, ad esempio se il tipo è un tipo riferimento, un tipo di puntatore o un tipo di matrice.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-218">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="4ee8d-219">Per recuperare il nome del tipo senza caratteri finali, usare `t.GetElementType().ToString()`, dove `t` è il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-219">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="4ee8d-220">Gli spazi sono rilevanti in tutti i componenti di nome di tipo tranne il nome dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-220">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="4ee8d-221">Il nome di assembly e spazi che precedono il separatore ',' sono rilevanti, ma gli spazi dopo il separatore ',' vengono ignorati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-221">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="4ee8d-222">Gli argomenti generici di tipi generici sono qualificati dal nome dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-222">Generic arguments of generic types are themselves qualified by assembly name.</span></span> <span data-ttu-id="4ee8d-223">Ad esempio, nel nome del tipo qualificato dall'assembly per `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic), `int` viene espanso al nome del tipo qualificato dall'assembly per <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-223">For example, in the assembly-qualified type name for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic), `int` is expanded to the assembly-qualified type name for <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="4ee8d-224">Se l'oggetto corrente <xref:System.Type> oggetto rappresenta un parametro generico, questa proprietà restituisce `null`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-224">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-225">Nell'esempio seguente visualizza il nome dell'assembly associato alla classe e il nome completo del tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-225">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 <span data-ttu-id="4ee8d-226">Nell'esempio seguente vengono confrontate le stringhe restituite dal <xref:System.Type.ToString%2A> metodo e il `Name`, <xref:System.Type.FullName%2A>, e <xref:System.Type.AssemblyQualifiedName%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-226">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">
          <span data-ttu-id="4ee8d-227">Specifica di nomi di tipo completi</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-227">Specifying Fully Qualified Type Names</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-228">Ottiene gli attributi associati all'oggetto <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-228">Gets the attributes associated with the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-229">Oggetto <see cref="T:System.Reflection.TypeAttributes" /> che rappresenta il set di attributi di <see cref="T:System.Type" />, a meno che <see cref="T:System.Type" /> non rappresenti un parametro di tipo generico. In tal caso, il valore non è specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-229">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />, unless the <see cref="T:System.Type" /> represents a generic type parameter, in which case the value is unspecified.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-230">Alcuni membri del <xref:System.Reflection.TypeAttributes> enumerazione sono mask che rappresentano un gruppo di valori.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-230">Some members of the <xref:System.Reflection.TypeAttributes> enumeration are masks that represent a group of values.</span></span> <span data-ttu-id="4ee8d-231">Ogni gruppo include un membro il cui valore sottostante è uguale a zero.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-231">Each group includes one member whose underlying value is zero.</span></span> <span data-ttu-id="4ee8d-232">Ad esempio, il valore sottostante del <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> membro nel <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> gruppo è zero, come è la <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> membro nel <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> gruppo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-232">For example, the underlying value of the <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> group is zero, as is the <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> group.</span></span> <span data-ttu-id="4ee8d-233">Per questo motivo, è necessario utilizzare la maschera prima del test per tali valori.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-233">Because of this, you must use the mask before testing for those values.</span></span> <span data-ttu-id="4ee8d-234">Nell'esempio viene illustrata una situazione di questo tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-234">The example provides an illustration.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="4ee8d-235">Per la maggior parte degli scopi, le proprietà, ad esempio <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, e <xref:System.Type.IsSpecialName%2A> sono più facili da usare rispetto agli attributi di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-235">For most purposes, properties like <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, and <xref:System.Type.IsSpecialName%2A> are easier to use than type attributes.</span></span>  
  
 <span data-ttu-id="4ee8d-236">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà restituisce gli attributi della definizione del tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-236">If the current <xref:System.Type> represents a constructed generic type, this property returns the attributes of the generic type definition.</span></span> <span data-ttu-id="4ee8d-237">Ad esempio, gli attributi restituiti per `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) sono gli attributi del `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-237">For example, the attributes returned for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) are the attributes of `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="4ee8d-238">Se corrente <xref:System.Type> rappresenta un parametro di tipo generico, vale a dire, se il <xref:System.Type.IsGenericParameter%2A> restituisce proprietà `true` , ovvero il <xref:System.Reflection.TypeAttributes> valore restituito da questa proprietà non è specificato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-238">If the current <xref:System.Type> represents a generic type parameter — that is, if the <xref:System.Type.IsGenericParameter%2A> property returns `true` — the <xref:System.Reflection.TypeAttributes> value returned by this property is unspecified.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-239">Usa l'esempio seguente <xref:System.Type.Attributes%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-239">The following example usesthe <xref:System.Type.Attributes%2A> property.</span></span>  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-240">Ottiene il tipo da cui l'oggetto <see cref="T:System.Type" /> corrente eredita direttamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-240">Gets the type from which the current <see cref="T:System.Type" /> directly inherits.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-241">Oggetto <see cref="T:System.Type" /> da cui <see cref="T:System.Type" /> corrente eredita direttamente o <see langword="null" /> se <see langword="Type" /> rappresenta la classe <see cref="T:System.Object" /> o un'interfaccia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-241">The <see cref="T:System.Type" /> from which the current <see cref="T:System.Type" /> directly inherits, or <see langword="null" /> if the current <see langword="Type" /> represents the <see cref="T:System.Object" /> class or an interface.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-242">Il tipo di base è il tipo da cui il tipo corrente eredita direttamente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-242">The base type is the type from which the current type directly inherits.</span></span> <span data-ttu-id="4ee8d-243"><xref:System.Object> è l'unico tipo che non è un tipo di base, pertanto `null` viene restituito come tipo di base del <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-243"><xref:System.Object> is the only type that does not have a base type, therefore `null` is returned as the base type of <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="4ee8d-244">Interfacce di ereditano da zero o più interfacce di base. Pertanto, questa proprietà restituisce `null` se il `Type` oggetto rappresenta un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-244">Interfaces inherit from zero or more base interfaces; therefore, this property returns `null` if the `Type` object represents an interface.</span></span> <span data-ttu-id="4ee8d-245">Le interfacce di base possono essere determinate con <xref:System.Type.GetInterfaces%2A> o <xref:System.Type.FindInterfaces%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-245">The base interfaces can be determined with <xref:System.Type.GetInterfaces%2A> or <xref:System.Type.FindInterfaces%2A>.</span></span>  
  
 <span data-ttu-id="4ee8d-246">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, il tipo di base rifletta gli argomenti generici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-246">If the current <xref:System.Type> represents a constructed generic type, the base type reflects the generic arguments.</span></span> <span data-ttu-id="4ee8d-247">Si considerino ad esempio le dichiarazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-247">For example, consider the following declarations:</span></span>  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="4ee8d-248">Per il tipo costruito `C<int>` (`C(Of Integer)` in Visual Basic), il <xref:System.Type.BaseType%2A> restituisce proprietà `B<int>`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-248">For the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the <xref:System.Type.BaseType%2A> property returns `B<int>`.</span></span>  
  
 <span data-ttu-id="4ee8d-249">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di una definizione di tipo generico, <xref:System.Type.BaseType%2A> restituisce il vincolo di classe, vale a dire, la classe deve ereditare il parametro di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-249">If the current <xref:System.Type> represents a type parameter of a generic type definition, <xref:System.Type.BaseType%2A> returns the class constraint, that is, the class the type parameter must inherit.</span></span> <span data-ttu-id="4ee8d-250">Se è presente alcun vincolo di classe, <xref:System.Type.BaseType%2A> restituisce <xref:System.Object?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-250">If there is no class constraint, <xref:System.Type.BaseType%2A> returns <xref:System.Object?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="4ee8d-251">Questa proprietà è di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-251">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-252">Nell'esempio seguente viene illustrato l'utilizzo di <xref:System.Type.BaseType%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-252">The following example demonstrates using the <xref:System.Type.BaseType%2A> property.</span></span>  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 <span data-ttu-id="4ee8d-253">L'esempio seguente usa la ricorsione per elencare la gerarchia di ereditarietà completa di ogni classe trovato in un assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-253">The following example uses recursion to list the complete inheritance hierarchy of each class found in an assembly.</span></span> <span data-ttu-id="4ee8d-254">L'esempio definisce una classe denominata `C` che deriva da una classe denominata `B`che, a sua volta deriva da una classe denominata `A`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-254">The example defines a class named `C` that derives from a class named `B`, which, in turn, derives from a class named `A`.</span></span>  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="4ee8d-255">Reflection e tipi generici</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-255">Reflection and Generic Types</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-256">Ottiene un valore che indica se l'oggetto <see cref="T:System.Type" /> dispone di parametri di tipo che non sono stati sostituiti da tipi specifici.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-256">Gets a value indicating whether the current <see cref="T:System.Type" /> object has type parameters that have not been replaced by specific types.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-257">
            <see langword="true" /> se l'oggetto <see cref="T:System.Type" /> è a sua volta un parametro di tipo generico o possiede parametri di tipo per i quali non sono stati forniti tipi specifici; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-257">
              <see langword="true" /> if the <see cref="T:System.Type" /> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-258">Per creare un'istanza di un tipo, non deve essere presenti definizioni di tipo generico o tipi costruiti aperti negli argomenti di tipo del tipo stesso, in tutti i tipi generici o in tutti gli elementi del tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-258">In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type.</span></span> <span data-ttu-id="4ee8d-259">In altre parole, ciò è che quando viene esaminato in modo ricorsivo, il tipo non deve contenere alcun parametro di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-259">Another way of saying this is that when examined recursively, the type must contain no generic type parameters.</span></span>  
  
 <span data-ttu-id="4ee8d-260">Poiché i tipi possono essere arbitrariamente complessi, rendendo questo aspetto è difficile.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-260">Since types can be arbitrarily complex, making this determination is difficult.</span></span> <span data-ttu-id="4ee8d-261">Per motivi di praticità e a ridurre le probabilità di errore, il <xref:System.Type.ContainsGenericParameters%2A> proprietà fornisce un modo per distinguere tra tipi costruiti chiusi, che possono essere creata un'istanza, standard e tipi costruiti aperti, che non può essere.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-261">For convenience and to reduce the chance of error, the <xref:System.Type.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot.</span></span> <span data-ttu-id="4ee8d-262">Se il <xref:System.Type.ContainsGenericParameters%2A> restituisce proprietà `true`, il tipo non è possibile creare un'istanza.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-262">If the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, the type cannot be instantiated.</span></span>  
  
 <span data-ttu-id="4ee8d-263">Il <xref:System.Type.ContainsGenericParameters%2A> proprietà ricerca in modo ricorsivo per i parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-263">The <xref:System.Type.ContainsGenericParameters%2A> property searches recursively for type parameters.</span></span> <span data-ttu-id="4ee8d-264">Ad esempio, viene restituito `true` per una matrice i cui elementi sono tipo `A<T>` (`A(Of T)` in Visual Basic), anche se la matrice non è a sua volta generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-264">For example, it returns `true` for an array whose elements are type `A<T>` (`A(Of T)` in Visual Basic), even though the array is not itself generic.</span></span> <span data-ttu-id="4ee8d-265">Ciò si differenzia il comportamento dei <xref:System.Type.IsGenericType%2A> proprietà, che restituisce `false` per le matrici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-265">Contrast this with the behavior of the <xref:System.Type.IsGenericType%2A> property, which returns `false` for arrays.</span></span>  
  
 <span data-ttu-id="4ee8d-266">Per un set di classi di esempio e una tabella che mostra i valori del <xref:System.Type.ContainsGenericParameters%2A> proprietà, vedere <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-266">For a set of example classes and a table showing the values of the <xref:System.Type.ContainsGenericParameters%2A> property, see <xref:System.Type.IsGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-267">Nell'esempio seguente definisce una classe generica con due parametri di tipo e definisce quindi una seconda classe generica da cui deriva la prima classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-267">The following example defines a generic class with two type parameters and then defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="4ee8d-268">Classe di base della classe derivata dispone di due argomenti di tipo: il primo è <xref:System.Int32> e il secondo è un parametro di tipo del tipo derivato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-268">The derived class's base class has two type arguments: the first is <xref:System.Int32> and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="4ee8d-269">Nell'esempio vengono visualizzate informazioni su queste classi generiche, incluse le posizioni segnalati dal <xref:System.Type.GenericParameterPosition%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-269">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="4ee8d-270">Reflection e tipi generici</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-270">Reflection and Generic Types</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="4ee8d-271">Procedura: esaminare e creare istanze di tipi generici tramite reflection</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-271">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-272">Ottiene una classe <see cref="T:System.Reflection.MethodBase" /> che rappresenta il metodo dichiarante se la classe <see cref="T:System.Type" /> corrente rappresenta un parametro di tipo di un metodo generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-272">Gets a <see cref="T:System.Reflection.MethodBase" /> that represents the declaring method, if the current <see cref="T:System.Type" /> represents a type parameter of a generic method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-273">Se l'oggetto <see cref="T:System.Type" /> corrente rappresenta un parametro di tipo di un metodo generico, una classe <see cref="T:System.Reflection.MethodBase" /> che rappresenta il metodo dichiarante; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-273">If the current <see cref="T:System.Type" /> represents a type parameter of a generic method, a <see cref="T:System.Reflection.MethodBase" /> that represents declaring method; otherwise, <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-274">Il metodo dichiarante è una definizione di metodo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-274">The declaring method is a generic method definition.</span></span> <span data-ttu-id="4ee8d-275">Vale a dire, se <xref:System.Type.DeclaringMethod%2A> non restituisce `null`, quindi `DeclaringMethod.IsGenericMethodDefinition` restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-275">That is, if <xref:System.Type.DeclaringMethod%2A> does not return `null`, then `DeclaringMethod.IsGenericMethodDefinition` returns `true`.</span></span>  
  
 <span data-ttu-id="4ee8d-276">Il <xref:System.Type.DeclaringType%2A> e <xref:System.Type.DeclaringMethod%2A> identificano la definizione di tipo generico o una definizione di metodo generico in cui è stato originariamente definito il parametro di tipo generico:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-276">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="4ee8d-277">Se il <xref:System.Type.DeclaringMethod%2A> proprietà restituisce un <xref:System.Reflection.MethodInfo>, tale <xref:System.Reflection.MethodInfo> rappresenta una definizione di metodo generico e corrente <xref:System.Type> oggetto rappresenta un parametro di tipo della definizione di metodo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-277">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="4ee8d-278">Se il <xref:System.Type.DeclaringMethod%2A> proprietà restituisce `null`, il <xref:System.Type.DeclaringType%2A> proprietà restituisce sempre un <xref:System.Type> oggetto che rappresenta una definizione di tipo generico e corrente <xref:System.Type> oggetto rappresenta un parametro di tipo di quel tipo generico definizione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-278">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="4ee8d-279">Recupero il <xref:System.Type.DeclaringMethod%2A> proprietà su un tipo la cui <xref:System.Type.IsGenericParameter%2A> proprietà è `false` genera un <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-279">Getting the <xref:System.Type.DeclaringMethod%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="4ee8d-280">Il <xref:System.Reflection.MethodBase> restituito dal <xref:System.Type.DeclaringMethod%2A> proprietà è un <xref:System.Reflection.MethodInfo> nel caso di un metodo generico, o un <xref:System.Reflection.ConstructorInfo> nel caso di un costruttore generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-280">The <xref:System.Reflection.MethodBase> that is returned by the <xref:System.Type.DeclaringMethod%2A> property is either a <xref:System.Reflection.MethodInfo> in the case of a generic method, or a <xref:System.Reflection.ConstructorInfo> in the case of a generic constructor.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-281">In .NET Framework versione 2.0, i costruttori generici non sono supportati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-281">In the .NET Framework version 2.0, generic constructors are not supported.</span></span>  
  
 <span data-ttu-id="4ee8d-282">Per un elenco delle condizioni invariabili relative ai termini usati dal processo di reflection generico, vedere i commenti sulla proprietà <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-282">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-283">Esempio di codice seguente definisce una classe che dispone di un metodo generico, viene assegnato un argomento di tipo al metodo e richiama il metodo generico costruito risulta.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-283">The following code example defines a class that has a generic method, assigns a type argument to the method, and invokes the resulting constructed generic method.</span></span> <span data-ttu-id="4ee8d-284">Visualizza anche informazioni sulla definizione di metodo generico e il metodo costruito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-284">It also displays information about the generic method definition and the constructed method.</span></span> <span data-ttu-id="4ee8d-285">Quando si visualizzano informazioni sui parametri di tipo della definizione di metodo generico, nelle `DisplayGenericMethodInfo` metodo, il codice di esempio mostra il valore della <xref:System.Type.DeclaringMethod%2A> proprietà per il parametro di tipo generico del metodo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-285">When displaying information about the type parameters of the generic method definition, in the `DisplayGenericMethodInfo` method, the example code shows the value of the <xref:System.Type.DeclaringMethod%2A> property for the method's generic type parameter.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="4ee8d-286">Reflection e tipi generici</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-286">Reflection and Generic Types</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="4ee8d-287">Procedura: esaminare e creare istanze di tipi generici tramite reflection</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-287">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-288">Ottiene il tipo che dichiara il parametro di tipo generico o di tipo annidato corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-288">Gets the type that declares the current nested type or generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-289">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo contenitore, se il tipo corrente è un tipo annidato, oppure la definizione di tipo generico, se il tipo corrente è un parametro di tipo di un tipo generico, oppure il tipo che dichiara il metodo generico, se il tipo corrente è un parametro di tipo di un metodo generico; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-289">A <see cref="T:System.Type" /> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-290">Se l'oggetto corrente <xref:System.Type> oggetto rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce la definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-290">If the current <xref:System.Type> object represents a type parameter of a generic type, this property returns the generic type definition.</span></span>  
  
 <span data-ttu-id="4ee8d-291">Se l'oggetto corrente <xref:System.Type> oggetto rappresenta un parametro di tipo di un metodo generico, questa proprietà restituisce il tipo che contiene la definizione di metodo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-291">If the current <xref:System.Type> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition.</span></span> <span data-ttu-id="4ee8d-292">Se il tipo è generico, viene restituita la definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-292">If the type is generic, the generic type definition is returned.</span></span> <span data-ttu-id="4ee8d-293">Vale a dire, il codice seguente restituisce la definizione di tipo generico del <xref:System.Collections.Generic.List%601> classe generica, che contiene il <xref:System.Collections.Generic.List%601.ConvertAll%2A> metodo generico:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-293">That is, the following code returns the generic type definition of the <xref:System.Collections.Generic.List%601> generic class, which contains the <xref:System.Collections.Generic.List%601.ConvertAll%2A> generic method:</span></span>  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="4ee8d-294">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, la <xref:System.Type.DeclaringType%2A> e <xref:System.Type.DeclaringMethod%2A> identificano la definizione di tipo generico o definizione di metodo generico in cui parametro di tipo generico è stato originariamente definito:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-294">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, the <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="4ee8d-295">Se il <xref:System.Type.DeclaringMethod%2A> proprietà restituisce un <xref:System.Reflection.MethodInfo>, tale <xref:System.Reflection.MethodInfo> rappresenta una definizione di metodo generico e corrente <xref:System.Type> oggetto rappresenta un parametro di tipo della definizione di metodo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-295">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="4ee8d-296">Se il <xref:System.Type.DeclaringMethod%2A> proprietà restituisce `null`, il <xref:System.Type.DeclaringType%2A> proprietà restituisce sempre un <xref:System.Type> oggetto che rappresenta una definizione di tipo generico e corrente <xref:System.Type> oggetto rappresenta un parametro di tipo di quel tipo generico definizione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-296">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="4ee8d-297">Recupero il <xref:System.Type.DeclaringType%2A> proprietà su un tipo la cui <xref:System.Type.IsGenericParameter%2A> proprietà è `false` genera un <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-297">Getting the <xref:System.Type.DeclaringType%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-298">In questo esempio visualizza il tipo dichiarante di un metodo in una classe derivata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-298">This example displays the declaring type of a method in a derived class.</span></span>  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-299">Ottiene un riferimento al binder predefinito, il quale implementa regole interne per la selezione dei membri appropriati che devono essere chiamati con il metodo <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-299">Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-300">Riferimento al binder predefinito usato dal sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-300">A reference to the default binder used by the system.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-301">Il binder predefinito fornito con common language runtime è applicabile in tutte le circostanze più specializzate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-301">The default binder provided with the common language runtime is applicable in all but the most specialized circumstances.</span></span> <span data-ttu-id="4ee8d-302">Se è necessario uno strumento di associazione che segue le regole diverse da quelle del binder predefinito fornito, definire un tipo derivato dal <xref:System.Reflection.Binder> classe e passare un'istanza di quel tipo usando il `binder` parametro di uno del <xref:System.Type.InvokeMember%2A> overload.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-302">If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <xref:System.Reflection.Binder> class and pass an instance of that type using the `binder` parameter of one of the <xref:System.Type.InvokeMember%2A> overloads.</span></span>  
  
 <span data-ttu-id="4ee8d-303">La reflection dei modelli di regole di accessibilità di common type system.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-303">Reflection models the accessibility rules of the common type system.</span></span> <span data-ttu-id="4ee8d-304">Ad esempio, se il chiamante è nello stesso assembly, il chiamante necessita di speciali autorizzazioni per membri interni.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-304">For example, if the caller is in the same assembly, the caller does not need special permissions for internal members.</span></span> <span data-ttu-id="4ee8d-305">In caso contrario, il chiamante deve avere <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-305">Otherwise, the caller needs <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="4ee8d-306">Ciò è coerente con ricerca di membri che sono protetti, privati e così via.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-306">This is consistent with lookup of members that are protected, private, and so on.</span></span>  
  
 <span data-ttu-id="4ee8d-307">Il principio generale è che <xref:System.Reflection.Binder.ChangeType%2A> deve eseguire una sola conversione di ampliamento, che non comportano la perdita dei dati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-307">The general principle is that <xref:System.Reflection.Binder.ChangeType%2A> should perform only widening conversions, which never lose data.</span></span> <span data-ttu-id="4ee8d-308">Un esempio di una conversione verso un consiste nel convertire un valore che è un intero con segno a 32 bit su un valore che è un intero con segno a 64 bit.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-308">An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer.</span></span> <span data-ttu-id="4ee8d-309">Questa operazione si differenzia da una conversione di narrowing, che potrebbe perdere dati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-309">This is distinguished from a narrowing conversion, which may lose data.</span></span> <span data-ttu-id="4ee8d-310">Un esempio di una conversione di narrowing converte un intero con segno a 64 bit in un intero con segno a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-310">An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.</span></span>  
  
 <span data-ttu-id="4ee8d-311">Nella tabella seguente sono elencate le conversioni supportate dal binder predefinito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-311">The following table lists the conversions supported by the default binder.</span></span>  
  
|<span data-ttu-id="4ee8d-312">Tipo di origine</span><span class="sxs-lookup"><span data-stu-id="4ee8d-312">Source Type</span></span>|<span data-ttu-id="4ee8d-313">Tipo di destinazione</span><span class="sxs-lookup"><span data-stu-id="4ee8d-313">Target Type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="4ee8d-314">Qualsiasi tipo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-314">Any type</span></span>|<span data-ttu-id="4ee8d-315">Il tipo di base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-315">Its base type.</span></span>|  
|<span data-ttu-id="4ee8d-316">Qualsiasi tipo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-316">Any type</span></span>|<span data-ttu-id="4ee8d-317">Implementa l'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-317">The interface it implements.</span></span>|  
|<span data-ttu-id="4ee8d-318">Char</span><span class="sxs-lookup"><span data-stu-id="4ee8d-318">Char</span></span>|<span data-ttu-id="4ee8d-319">Unt16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="4ee8d-319">Unt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="4ee8d-320">Byte</span><span class="sxs-lookup"><span data-stu-id="4ee8d-320">Byte</span></span>|<span data-ttu-id="4ee8d-321">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="4ee8d-321">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="4ee8d-322">SByte</span><span class="sxs-lookup"><span data-stu-id="4ee8d-322">SByte</span></span>|<span data-ttu-id="4ee8d-323">Int16, Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="4ee8d-323">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="4ee8d-324">UInt16</span><span class="sxs-lookup"><span data-stu-id="4ee8d-324">UInt16</span></span>|<span data-ttu-id="4ee8d-325">UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="4ee8d-325">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="4ee8d-326">Int16</span><span class="sxs-lookup"><span data-stu-id="4ee8d-326">Int16</span></span>|<span data-ttu-id="4ee8d-327">Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="4ee8d-327">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="4ee8d-328">UInt32</span><span class="sxs-lookup"><span data-stu-id="4ee8d-328">UInt32</span></span>|<span data-ttu-id="4ee8d-329">UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="4ee8d-329">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="4ee8d-330">Int32</span><span class="sxs-lookup"><span data-stu-id="4ee8d-330">Int32</span></span>|<span data-ttu-id="4ee8d-331">Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="4ee8d-331">Int64, Single, Double</span></span>|  
|<span data-ttu-id="4ee8d-332">UInt64</span><span class="sxs-lookup"><span data-stu-id="4ee8d-332">UInt64</span></span>|<span data-ttu-id="4ee8d-333">Single, Double</span><span class="sxs-lookup"><span data-stu-id="4ee8d-333">Single, Double</span></span>|  
|<span data-ttu-id="4ee8d-334">Int64</span><span class="sxs-lookup"><span data-stu-id="4ee8d-334">Int64</span></span>|<span data-ttu-id="4ee8d-335">Single, Double</span><span class="sxs-lookup"><span data-stu-id="4ee8d-335">Single, Double</span></span>|  
|<span data-ttu-id="4ee8d-336">Single</span><span class="sxs-lookup"><span data-stu-id="4ee8d-336">Single</span></span>|<span data-ttu-id="4ee8d-337">Double</span><span class="sxs-lookup"><span data-stu-id="4ee8d-337">Double</span></span>|  
|<span data-ttu-id="4ee8d-338">Non-reference</span><span class="sxs-lookup"><span data-stu-id="4ee8d-338">Non-reference</span></span>|<span data-ttu-id="4ee8d-339">Per riferimento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-339">By-reference.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-340">L'esempio seguente ottiene lo strumento di associazione predefinito dal `DefaultBinder` proprietà e richiama un membro di MyClass passando il `DefaultBinder` come parametro a un valore <xref:System.Type.InvokeMember%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-340">The following example gets the default binder from the `DefaultBinder` property, and invokes a member of MyClass by passing the `DefaultBinder` value as a parameter to <xref:System.Type.InvokeMember%2A>.</span></span>  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-341">Separa i nomi nello spazio dei nomi dell'oggetto <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-341">Separates names in the namespace of the <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="4ee8d-342">Questo campo è di sola lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-342">This field is read-only.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-343">Rappresenta una matrice vuota di tipo <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-343">Represents an empty array of type <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="4ee8d-344">Questo campo è di sola lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-344">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="4ee8d-345">Nell'esempio di codice riportato di seguito viene illustrato il `EmptyTypes` campo utilizzato in uno del `GetConstructor` metodi per ottenere un costruttore che non accetta parametri.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-345">The following code example shows the `EmptyTypes` field used in one of the `GetConstructor` methods to get a constructor that takes no parameters.</span></span>  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-346">Determina se il tipo di sistema sottostante dell'oggetto <see cref="T:System.Type" /> corrente coincide con il tipo di sistema sottostante di <see cref="T:System.Object" /> o dell'oggetto <see cref="T:System.Type" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-346">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Object" /> or <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="4ee8d-347">Oggetto il cui tipo di sistema sottostante deve essere confrontato con il tipo di sistema sottostante dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-347">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="4ee8d-348">Affinché il confronto abbia esito positivo, deve essere possibile eseguire il cast o la conversione di <c>o</c> in un oggetto di tipo <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-348">For the comparison to succeed, <c>o</c> must be able to be cast or converted to an object of type   <see cref="T:System.Type" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-349">Determina se il tipo di sistema sottostante dell'oggetto <see cref="T:System.Type" /> corrente coincide con il tipo di sistema sottostante dell'oggetto <see cref="T:System.Object" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-349">Determines if the underlying system type of the current <see cref="T:System.Type" /> object is the same as the underlying system type of the specified <see cref="T:System.Object" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-350">
            <see langword="true" /> se il tipo di sistema sottostante di <paramref name="o" /> coincide con il tipo di sistema sottostante del <see cref="T:System.Type" /> corrente. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-350">
              <see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="4ee8d-351">Questo metodo restituisce anche <see langword="false" /> se:</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-351">This method also returns <see langword="false" /> if: .</span>
          </span>
          <span data-ttu-id="4ee8d-352">
-   <paramref name="o" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-352">
-   <paramref name="o" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-353">
-   Impossibile eseguire il cast o la conversione di <paramref name="o" /> in un oggetto <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-353">
-   <paramref name="o" /> cannot be cast or converted to a <see cref="T:System.Type" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-354">Questo metodo esegue l'override del metodo <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-354">This method overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4ee8d-355">Viene eseguito il cast `o` a un oggetto di tipo <xref:System.Type> e chiama il <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-355">It casts `o` to an object of type <xref:System.Type> and calls the <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-356">L'esempio seguente usa <xref:System.Type.Equals%28System.Object%29> da confrontare vari <xref:System.Type> oggetto istanze con vari <xref:System.Object> istanze.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-356">The following example uses <xref:System.Type.Equals%28System.Object%29> to compare various <xref:System.Type> object instances with various <xref:System.Object> instances.</span></span>  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 <span data-ttu-id="4ee8d-357">In particolare la pena segnalare l'esempio sono due elementi:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-357">Two things are particularly worth noting about the example:</span></span>  
  
-   <span data-ttu-id="4ee8d-358">Il confronto di un <xref:System.Type> oggetto che rappresenta un intero con un <xref:System.Reflection.TypeInfo> che rappresenta un numero intero restituito `true` perché <xref:System.Reflection.TypeInfo> è derivato da <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-358">The comparison of a <xref:System.Type> object that represents an integer with a <xref:System.Reflection.TypeInfo> object that represents an integer return `true` because <xref:System.Reflection.TypeInfo> is derived from <xref:System.Type>.</span></span>  
  
-   <span data-ttu-id="4ee8d-359">Il confronto di un <xref:System.Type> oggetto che rappresenta un <xref:System.Collections.Generic.IList%601> oggetto (un tipo generico aperto) con un `List(Of String)` oggetto (un tipo generico chiuso) restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-359">The comparison of a  <xref:System.Type> object that represents a <xref:System.Collections.Generic.IList%601> object (an open generic type) with a `List(Of String)` object (a closed generic type) returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="4ee8d-360">Oggetto il cui tipo di sistema sottostante deve essere confrontato con il tipo di sistema sottostante dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-360">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-361">Determina se il tipo di sistema sottostante dell'oggetto <see cref="T:System.Type" /> corrente coincide con il tipo di sistema sottostante dell'oggetto <see cref="T:System.Type" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-361">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-362">
            <see langword="true" /> se il tipo di sistema sottostante di <paramref name="o" /> coincide con il tipo di sistema sottostante del <see cref="T:System.Type" /> corrente. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-362">
              <see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="4ee8d-363">L'esempio seguente usa `Equals` per confrontare due tipi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-363">The following example uses `Equals` to compare two types.</span></span>  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-364">Rappresenta il filtro membro usato sugli attributi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-364">Represents the member filter used on attributes.</span>
          </span>
          <span data-ttu-id="4ee8d-365">Questo campo è di sola lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-365">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-366">Questo campo contiene un riferimento al delegato usato dalla <xref:System.Type.FindMembers%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-366">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="4ee8d-367">Il metodo incapsulato da questo delegato accetta due parametri: il primo è un <xref:System.Reflection.MemberInfo> oggetto e il secondo è un `Object`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-367">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="4ee8d-368">Il metodo determina se il `MemberInfo` oggetto corrisponde ai criteri specificati per il `Object`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-368">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="4ee8d-369">Il `Object` può essere assegnato il valore di uno dei campi nelle classi <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, o <xref:System.Reflection.MethodImplAttributes>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-369">The `Object` may be assigned the value of any one of the fields on the classes <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, or <xref:System.Reflection.MethodImplAttributes>.</span></span>  
  
 <span data-ttu-id="4ee8d-370">Ad esempio, il `Object` può essere assegnato il valore di un campo da `FieldAttributes` come pubblico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-370">For example, the `Object` can be assigned the value of a field from `FieldAttributes` such as Public.</span></span> <span data-ttu-id="4ee8d-371">In tal caso, quando la `FilterAttribute` delegato viene richiamato, restituirà `true` solo se il metodo rappresentato dal `MemberInfo` oggetto è decorato con l'attributo di campo pubblico nei metadati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-371">In that case, when the `FilterAttribute` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object is decorated with the public field attribute in metadata.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-372">L'esempio seguente ottiene i `FilterAttribute` delegato, lo passa come parametro per il <xref:System.Type.FindMembers%2A> (metodo) e visualizza i membri specificati e i relativi attributi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-372">The following example gets the `FilterAttribute` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the specified members and their attributes.</span></span>  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-373">Rappresenta il filtro membro usato sui nomi, che fa distinzione tra maiuscole e minuscole.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-373">Represents the case-sensitive member filter used on names.</span>
          </span>
          <span data-ttu-id="4ee8d-374">Questo campo è di sola lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-374">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-375">Questo campo contiene un riferimento al delegato usato dalla <xref:System.Type.FindMembers%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-375">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="4ee8d-376">Il metodo incapsulato da questo delegato accetta due parametri: il primo è un <xref:System.Reflection.MemberInfo> oggetto e il secondo è un `Object`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-376">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="4ee8d-377">Il metodo determina se il `MemberInfo` oggetto corrisponde ai criteri specificati per il `Object`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-377">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="4ee8d-378">Il `Object` viene assegnato un valore stringa, che può includere una parentesi finale "\*" carattere jolly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-378">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="4ee8d-379">È supportato solo con caratteri jolly finali stringa corrispondente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-379">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="4ee8d-380">Ad esempio, il `Object` può essere assegnato il valore "Byte \*".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-380">For example, the `Object` may be assigned the value "Byte\*".</span></span> <span data-ttu-id="4ee8d-381">In tal caso, quando la `FilterName` delegato viene richiamato, restituirà `true` solo se il metodo rappresentato dal `MemberInfo` oggetto ha un nome che inizia con "Byte".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-381">In that case, when the `FilterName` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object has a name that begins with "Byte".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-382">Esempio di codice seguente ottiene i metodi associati definite dall'utente `Application` tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-382">The following code example gets the methods associated with the user-defined `Application` type.</span></span>  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-383">Rappresenta il filtro membro usato sui nomi che non fa distinzione tra maiuscole e minuscole.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-383">Represents the case-insensitive member filter used on names.</span>
          </span>
          <span data-ttu-id="4ee8d-384">Questo campo è di sola lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-384">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-385">Questo campo contiene un riferimento al delegato usato dalla <xref:System.Type.FindMembers%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-385">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="4ee8d-386">Il metodo incapsulato da questo delegato accetta due parametri: il primo è un <xref:System.Reflection.MemberInfo> oggetto e il secondo è un `Object`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-386">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="4ee8d-387">Il metodo determina se il `MemberInfo` oggetto corrisponde ai criteri specificati per il `Object`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-387">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="4ee8d-388">Il `Object` viene assegnato un valore stringa, che può includere una parentesi finale "\*" carattere jolly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-388">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="4ee8d-389">È supportato solo con caratteri jolly finali stringa corrispondente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-389">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="4ee8d-390">Ad esempio, il `Object` può essere assegnato il valore "ByTe \*".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-390">For example, the `Object` may be assigned the value "ByTe\*".</span></span> <span data-ttu-id="4ee8d-391">In tal caso, quando la `FilterName` delegato viene richiamato, viene restituito true solo se il metodo rappresentato dal `MemberInfo` oggetto ha un nome che inizia con "byte", ignorando i case.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-391">In that case, when the `FilterName` delegate is invoked, it will return true only if the method represented by the `MemberInfo` object has a name that begins with "byte", ignoring case.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-392">L'esempio seguente ottiene i `MemberFilter` delegato, lo passa come parametro per il <xref:System.Type.FindMembers%2A> metodo e visualizza i metodi e i relativi attributi del `String` classe che iniziano con la lettera "c", ignorando il caso.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-392">The following example gets the `MemberFilter` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the methods and their attributes of the `String` class that begin with the letter "c", disregarding the case.</span></span>  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">
          <span data-ttu-id="4ee8d-393">Delegato che confronta le interfacce con <c>filterCriteria</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-393">The delegate that compares the interfaces against <c>filterCriteria</c>.</span>
          </span>
        </param>
        <param name="filterCriteria">
          <span data-ttu-id="4ee8d-394">Criteri di ricerca che determinano se un'interfaccia deve essere inclusa nella matrice restituita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-394">The search criteria that determines whether an interface should be included in the returned array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-395">Restituisce una matrice di oggetti <see cref="T:System.Type" /> che rappresenta un elenco filtrato di interfacce implementate o ereditate dall'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-395">Returns an array of <see cref="T:System.Type" /> objects representing a filtered list of interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-396">Matrice di oggetti <see cref="T:System.Type" /> che rappresenta un elenco filtrato delle interfacce implementate o ereditate dall'oggetto <see cref="T:System.Type" /> corrente oppure matrice vuota di tipo <see cref="T:System.Type" /> se l'oggetto <see cref="T:System.Type" /> corrente non ha implementato né ereditato interfacce che corrispondono al filtro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-396">An array of <see cref="T:System.Type" /> objects representing a filtered list of the interfaces implemented or inherited by the current <see cref="T:System.Type" />, or an empty array of type <see cref="T:System.Type" /> if no interfaces matching the filter are implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-397">Questo metodo può essere sostituito da una classe derivata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-397">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="4ee8d-398">Il <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> e <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegati forniti dalle <xref:System.Reflection.Module?displayProperty=nameWithType> classe potrebbe anche essere usata, giurata del <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegare.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-398">The <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> and <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegates supplied by the <xref:System.Reflection.Module?displayProperty=nameWithType> class may also be used, in lieu of the <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegate.</span></span>  
  
 <span data-ttu-id="4ee8d-399">Tutte le interfacce implementate da questa classe sono considerate durante la ricerca, se dichiarati da questa stessa classe o una classe di base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-399">All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</span></span>  
  
 <span data-ttu-id="4ee8d-400">Questo metodo viene cercata nella gerarchia di classe di base, restituzione di ciascuna delle interfacce corrispondente ogni classe implementa, nonché tutte le corrispondenti ognuno di tali implementa le interfacce di interfacce (vale a dire, viene restituita la chiusura transitiva di interfacce corrispondenti).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-400">This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned).</span></span> <span data-ttu-id="4ee8d-401">Non vengono restituiti interfacce di duplicati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-401">No duplicate interfaces are returned.</span></span>  
  
 <span data-ttu-id="4ee8d-402">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, <xref:System.Type.FindInterfaces%2A> cercate tutte le interfacce dichiarate nei vincoli sul parametro di tipo e tutte le interfacce ereditate tramite le interfacce dichiarata in vincoli.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-402">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, <xref:System.Type.FindInterfaces%2A> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints.</span></span> <span data-ttu-id="4ee8d-403">Se l'oggetto corrente <xref:System.Type> rappresenta un argomento di un tipo generico, tipo <xref:System.Type.FindInterfaces%2A> Cerca tutte le interfacce implementate dal tipo, corrisponde ai vincoli o meno.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-403">If the current <xref:System.Type> represents a type argument of a generic type, <xref:System.Type.FindInterfaces%2A> searches all the interfaces implemented by the type, whether or not they match constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-404"><xref:System.Type.FindInterfaces%2A> può restituire le interfacce generiche, anche su tipi non generici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-404"><xref:System.Type.FindInterfaces%2A> can return generic interfaces, even on types that are not generic.</span></span> <span data-ttu-id="4ee8d-405">Ad esempio, un tipo non generico potrebbe implementare `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-405">For example, a nongeneric type might implement `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-406">Nell'esempio seguente trova l'interfaccia specificata implementata o ereditata dal tipo specificato e quindi Visualizza i nomi di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-406">The following example finds the specified interface implemented or inherited by the specified type, and then displays the interface names.</span></span>  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-407">
            <paramref name="filter" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-407">
              <paramref name="filter" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="4ee8d-408">Un inizializzatore statico viene richiamato e genera un'eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-408">A static initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">
          <span data-ttu-id="4ee8d-409">Oggetto che indica il tipo di membro da cercare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-409">An object that indicates the type of member to search for.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-410">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-410">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-411">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-411">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-412">Zero, per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-412">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="filter">
          <span data-ttu-id="4ee8d-413">Delegato che esegue il confronto e restituisce <see langword="true" /> se il membro in esame corrisponde a <c>filterCriteria</c>, in caso contrario <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-413">The delegate that does the comparisons, returning <see langword="true" /> if the member currently being inspected matches the <c>filterCriteria</c> and <see langword="false" /> otherwise.</span>
          </span>
          <span data-ttu-id="4ee8d-414">È possibile usare i delegati <see langword="FilterAttribute" />, <see langword="FilterName" /> e <see langword="FilterNameIgnoreCase" /> forniti da questa classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-414">You can use the <see langword="FilterAttribute" />, <see langword="FilterName" />, and <see langword="FilterNameIgnoreCase" /> delegates supplied by this class.</span>
          </span>
          <span data-ttu-id="4ee8d-415">Come criteri di ricerca, il primo usa i campi di <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> e <see langword="MethodImplAttributes" /> e gli altri due delegati usano gli oggetti <see langword="String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-415">The first uses the fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> as search criteria, and the other two delegates use <see langword="String" /> objects as the search criteria.</span>
          </span>
        </param>
        <param name="filterCriteria">
          <span data-ttu-id="4ee8d-416">Criteri di ricerca che determinano se un membro viene restituito nella matrice di oggetti <see langword="MemberInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-416">The search criteria that determines whether a member is returned in the array of <see langword="MemberInfo" /> objects.</span>
          </span>
          <span data-ttu-id="4ee8d-417">I campi di <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> e <see langword="MethodImplAttributes" /> possono essere usati assieme al delegato <see langword="FilterAttribute" /> fornito da questa classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-417">The fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> can be used in conjunction with the <see langword="FilterAttribute" /> delegate supplied by this class.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-418">Restituisce una matrice filtrata di oggetti <see cref="T:System.Reflection.MemberInfo" /> del tipo di membro specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-418">Returns a filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-419">Matrice filtrata di oggetti <see cref="T:System.Reflection.MemberInfo" /> del tipo di membro specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-419">A filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span>
          </span>
          <span data-ttu-id="4ee8d-420">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-420">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-421">Matrice vuota di tipo <see cref="T:System.Reflection.MemberInfo" />, se l'oggetto <see cref="T:System.Type" /> corrente non dispone di membri del tipo <paramref name="memberType" /> corrispondenti ai criteri del filtro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-421">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have members of type <paramref name="memberType" /> that match the filter criteria.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-422">Questo metodo può essere sostituito da una classe derivata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-422">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="4ee8d-423">I membri includono proprietà, metodi, campi, eventi e così via.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-423">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="4ee8d-424">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire quali membri includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-424">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-425">È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-425">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-426">Specificare `BindingFlags.Instance` per includere i membri di istanza nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-426">Specify `BindingFlags.Instance` to include instance members in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-427">Specificare `BindingFlags.Static` per includere i membri statici nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-427">Specify `BindingFlags.Static` to include static members in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-428">Specificare `BindingFlags.Public` per includere i membri pubblici nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-428">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-429">Specificare `BindingFlags.NonPublic` da includere nella ricerca i membri non pubblici (vale a dire, i membri privati, interni e protetti).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-429">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
 <span data-ttu-id="4ee8d-430">Nell'esempio <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare il comportamento della ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-430">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="4ee8d-431">`BindingFlags.DeclaredOnly` Per cercare solo i membri dichiarati nel <xref:System.Type>, non i membri ereditati sono semplicemente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-431">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="4ee8d-432">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-432">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="4ee8d-433">I valori validi per <xref:System.Type.MemberType%2A> sono definiti in <xref:System.Reflection.MemberInfo>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-433">Valid values for <xref:System.Type.MemberType%2A> are defined in <xref:System.Reflection.MemberInfo>.</span></span> <span data-ttu-id="4ee8d-434">Se non è stato trovato alcun membro, viene restituita una matrice vuota.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-434">If no such members are found, an empty array is returned.</span></span>  
  
 <span data-ttu-id="4ee8d-435">Per ottenere l'inizializzatore di classi (. cctor) utilizzando questo metodo, è necessario specificare <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-435">To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="4ee8d-436">È anche possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-436">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="4ee8d-437">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico o metodo generico, <xref:System.Type.FindMembers%2A> elabora tutti i membri dichiarati dal vincolo di classe e i vincoli di interfaccia del parametro di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-437">If the current <xref:System.Type> represents a type parameter of a generic type or generic method, <xref:System.Type.FindMembers%2A> processes any members declared by the class constraint and the interface constraints of the type parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-438">Nell'esempio seguente trova tutti i membri in una classe che soddisfano i criteri di ricerca specificato e quindi Visualizza i membri corrispondenti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-438">The following example finds all the members in a class that match the specified search criteria, and then displays the matched members.</span></span>  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-439">
            <paramref name="filter" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-439">
              <paramref name="filter" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-440">Ottiene il nome completo del tipo, comprendente il relativo spazio dei nomi ma non l'assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-440">Gets the fully qualified name of the type, including its namespace but not its assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-441">Nome completo del tipo, incluso il relativo lo spazio dei nomi ma non l'assembly; oppure <see langword="null" /> se l'istanza corrente rappresenta un parametro di tipo generico, un tipo matrice, un tipo puntatore o un tipo <see langword="byref" /> basato su un parametro di tipo, o un tipo generico che non è una definizione di tipo generico ma contiene parametri di tipo non risolto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-441">The fully qualified name of the type, including its namespace but not its assembly; or <see langword="null" /> if the current instance represents a generic type parameter, an array type, pointer type, or <see langword="byref" /> type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-442">Ad esempio, il nome completo del <xref:System.String> è di tipo `System.String`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-442">For example, the fully qualified name of the <xref:System.String> type is `System.String`.</span></span> <span data-ttu-id="4ee8d-443">Ciò si differenzia il nome qualificato dall'assembly restituito dal <xref:System.Type.AssemblyQualifiedName%2A> proprietà, che comprende il nome completo e nome completo dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-443">Contrast this with the assembly-qualified name returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, which consists of the full name plus the full assembly name.</span></span>  
  
 <span data-ttu-id="4ee8d-444">Se il tipo corrente rappresenta un tipo generico chiuso, gli argomenti di tipo nella stringa restituita dal <xref:System.Type.FullName%2A> proprietà sono qualificati dal nome completo dell'assembly, anche se la rappresentazione di stringa del tipo generico stesso non è qualificata dal relativo full nome dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-444">If the current type represents a closed generic type, the type arguments in the string returned by the <xref:System.Type.FullName%2A> property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name.</span></span> <span data-ttu-id="4ee8d-445">Nell'esempio seguente viene illustrata la differenza nella proprietà FullName per un tipo che rappresenta la definizione di tipo generico e uno che rappresenta un tipo generico chiuso.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-445">The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.</span></span>  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 <span data-ttu-id="4ee8d-446">Questa proprietà restituisce `null` se:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-446">This property returns `null` if:</span></span>  
  
-   <span data-ttu-id="4ee8d-447">Corrente <xref:System.Type> oggetto rappresenta un parametro di tipo di un tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-447">The current <xref:System.Type> object represents a type parameter of a generic type.</span></span>  
  
     <span data-ttu-id="4ee8d-448">Nell'esempio seguente recupera il parametro di tipo i <xref:System.Nullable%601> tipo e tenta di visualizzare il <xref:System.Type.FullName%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-448">The following example retrieves the type parameter of the <xref:System.Nullable%601> type and attempts to display its <xref:System.Type.FullName%2A> property.</span></span>  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   <span data-ttu-id="4ee8d-449">L'oggetto corrente <xref:System.Type> oggetto rappresenta un tipo di matrice, un tipo di puntatore, o un `byref` tipo basato su un parametro di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-449">The current <xref:System.Type> object represents an array type, a pointer  type, or a `byref` type that is based on a generic type parameter.</span></span>  
  
     <span data-ttu-id="4ee8d-450">L'esempio seguente definisce un tipo generico `Generictype1<T>`, con tre metodi: `Display(T[])`, che viene passata una matrice di tipo T. `HandleT(T)`, che viene passato un oggetto T; e `ChangeValue(ref T)`, che viene passato un oggetto T per riferimento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-450">The following example defines a generic type, `Generictype1<T>`, with three methods: `Display(T[])`, which is passed an array of type T; `HandleT(T)`, which is passed a T object; and `ChangeValue(ref T)`, which is passed a T object by reference.</span></span> <span data-ttu-id="4ee8d-451">Perché c# e Visual Basic non consentono di definire T come un puntatore nel `HandleT` metodo, è necessario chiamare il <xref:System.Type.MakePointerType%2A> metodo su di <xref:System.Type> oggetto che rappresenta il tipo di parametro del metodo per creare un puntatore a un tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-451">Because C# and Visual Basic do not allow us to define T as a pointer in the `HandleT` method, we have to call the <xref:System.Type.MakePointerType%2A> method on the <xref:System.Type> object that represents the method's parameter type to create a pointer to a generic type.</span></span> <span data-ttu-id="4ee8d-452">L'output dell'esempio mostra che in tutti i tre casi, il <xref:System.Type.FullName%2A> è di proprietà `null`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-452">The output from the example shows that in all three cases, the <xref:System.Type.FullName%2A> property is `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   <span data-ttu-id="4ee8d-453">Il tipo corrente contiene parametri di tipo generico che non sono stati sostituiti da tipi specifici (vale a dire, il <xref:System.Type.ContainsGenericParameters%2A> restituisce proprietà `true`), ma il tipo non è una definizione di tipo generico (vale a dire, il <xref:System.Type.IsGenericTypeDefinition%2A> restituisce proprietà `false`</span><span class="sxs-lookup"><span data-stu-id="4ee8d-453">The current type contains generic type parameters that have not been replaced by specific types (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`), but the type is not a generic type definition (that is, the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `false`</span></span>  
  
     <span data-ttu-id="4ee8d-454">Nell'esempio riportato di seguito `Derived<T>` eredita da `Base<T>`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-454">In the following example, `Derived<T>` inherits from `Base<T>`.</span></span> <span data-ttu-id="4ee8d-455">Il <xref:System.Type.BaseType%2A> proprietà ottiene il <xref:System.Type> oggetto che rappresenta il tipo di base `Derived<T>`e la relativa <xref:System.Type.FullName%2A> restituisce proprietà `null`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-455">The <xref:System.Type.BaseType%2A> property obtains the  <xref:System.Type> object that represents the base type of `Derived<T>`, and its <xref:System.Type.FullName%2A> property returns `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     <span data-ttu-id="4ee8d-456">Per ottenere un <xref:System.Type.FullName%2A> che non è `null`, è possibile usare il <xref:System.Type.GetGenericTypeDefinition%2A> metodo per ottenere la definizione di tipo generico, come illustrato nell'esempio.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-456">To get a <xref:System.Type.FullName%2A> that is not `null`, you can use the <xref:System.Type.GetGenericTypeDefinition%2A> method to get the generic type definition, as the example illustrates.</span></span>  
  
 <span data-ttu-id="4ee8d-457">Questa proprietà è di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-457">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-458">Nell'esempio seguente visualizza il nome completo del tipo specificato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-458">The following example displays the full name of the specified type.</span></span>  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 <span data-ttu-id="4ee8d-459">Nell'esempio seguente vengono confrontate le stringhe restituite dal <xref:System.Type.ToString%2A> metodo e il `Name`, <xref:System.Type.FullName%2A>, e <xref:System.Type.AssemblyQualifiedName%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-459">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">
          <span data-ttu-id="4ee8d-460">Specifica di nomi di tipo completi</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-460">Specifying Fully Qualified Type Names</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-461">Ottiene una combinazione di flag <see cref="T:System.Reflection.GenericParameterAttributes" /> che descrivono la covariante e i vincoli speciali del parametro di tipo generico corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-461">Gets a combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> flags that describe the covariance and special constraints of the current generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-462">Combinazione bit per bit di valori <see cref="T:System.Reflection.GenericParameterAttributes" /> che descrive la covariante e i vincoli speciali del parametro di tipo generico corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-462">A bitwise combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> values that describes the covariance and special constraints of the current generic type parameter.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-463">Il valore di questa proprietà contiene i flag che descrivono se il parametro di tipo generico corrente è covariante e i flag che descrivono i vincoli speciali.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-463">The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints.</span></span> <span data-ttu-id="4ee8d-464">Usare la <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> valore per selezionare i flag di covarianza e usare il <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> valore per selezionare i flag di vincolo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-464">Use the <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> value to select the covariance flags, and use the <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> value to select the constraint flags.</span></span>  
  
 <span data-ttu-id="4ee8d-465">Per un elenco delle condizioni invariabili relative ai termini usati dal processo di reflection generico, vedere i commenti sulla proprietà <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-465">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-466">Esempio di codice seguente definisce un tipo generico `Test` con due parametri di tipo con vincoli diversi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-466">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="4ee8d-467">Quando viene eseguito il programma, i vincoli vengono esaminati tramite il <xref:System.Type.GenericParameterAttributes%2A> proprietà e il <xref:System.Type.GetGenericParameterConstraints%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-467">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4ee8d-468">L'oggetto <see cref="T:System.Type" /> corrente non è un parametro di tipo generico,</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-468">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span>
          </span>
          <span data-ttu-id="4ee8d-469">Quindi la proprietà <see cref="P:System.Type.IsGenericParameter" /> restituisce <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-469">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="4ee8d-470">Il metodo richiamato non è supportato nella classe base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-470">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="4ee8d-471">Reflection e tipi generici</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-471">Reflection and Generic Types</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="4ee8d-472">Procedura: esaminare e creare istanze di tipi generici tramite reflection</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-472">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-473">Ottiene la posizione del parametro di tipo nell'elenco di parametri di tipo del tipo o del metodo generico che ha dichiarato il parametro, quando l'oggetto <see cref="T:System.Type" /> rappresenta un parametro di tipo di un tipo o un metodo generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-473">Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <see cref="T:System.Type" /> object represents a type parameter of a generic type or a generic method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-474">Posizione del parametro di tipo nell'elenco dei parametri di tipo del tipo o del metodo generico che definisce il parametro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-474">The position of a type parameter in the type parameter list of the generic type or method that defines the parameter.</span>
          </span>
          <span data-ttu-id="4ee8d-475">I numeri di posizione iniziano da 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-475">Position numbers begin at 0.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-476">Il <xref:System.Type.GenericParameterPosition%2A> proprietà restituisce la posizione di un parametro di tipo nell'elenco dei parametri della definizione di tipo generico o definizione di metodo generico in cui è stato originariamente definito il parametro di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-476">The <xref:System.Type.GenericParameterPosition%2A> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined.</span></span> <span data-ttu-id="4ee8d-477">Il <xref:System.Type.DeclaringType%2A> e <xref:System.Type.DeclaringMethod%2A> identificano la definizione di tipo o metodo generica:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-477">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type or method definition:</span></span>  
  
-   <span data-ttu-id="4ee8d-478">Se il <xref:System.Type.DeclaringMethod%2A> proprietà restituisce un <xref:System.Reflection.MethodInfo>, tale <xref:System.Reflection.MethodInfo> rappresenta una definizione di metodo generico e corrente <xref:System.Type> oggetto rappresenta un parametro di tipo della definizione di metodo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-478">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="4ee8d-479">Se il <xref:System.Type.DeclaringMethod%2A> proprietà restituisce `null`, il <xref:System.Type.DeclaringType%2A> proprietà restituisce sempre un <xref:System.Type> oggetto che rappresenta una definizione di tipo generico e corrente <xref:System.Type> oggetto rappresenta un parametro di tipo di quel tipo generico definizione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-479">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
 <span data-ttu-id="4ee8d-480">Per fornire il contesto corretto per il valore della <xref:System.Type.GenericParameterPosition%2A> proprietà, è necessario identificare il tipo o metodo generico un parametro di tipo appartiene.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-480">To provide the correct context for the value of the <xref:System.Type.GenericParameterPosition%2A> property, it is necessary to identify the generic type or method a type parameter belongs to.</span></span> <span data-ttu-id="4ee8d-481">Si consideri ad esempio il valore restituito del metodo generico `GetSomething` nel codice seguente:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-481">For example, consider the return value of the generic method `GetSomething` in the following code:</span></span>  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 <span data-ttu-id="4ee8d-482">Il tipo restituito da `GetSomething` dipende dagli argomenti di tipo specificati alla classe `A` e a `GetSomething` stesso.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-482">The type returned by `GetSomething` depends on the type arguments supplied to class `A` and to `GetSomething` itself.</span></span> <span data-ttu-id="4ee8d-483">È possibile ottenere un <xref:System.Reflection.MethodInfo> per `GetSomething`, e da cui è possibile ottenere il tipo restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-483">You can obtain a <xref:System.Reflection.MethodInfo> for `GetSomething`, and from that you can obtain the return type.</span></span> <span data-ttu-id="4ee8d-484">Quando si esaminano i parametri di tipo del tipo restituito, <xref:System.Type.GenericParameterPosition%2A> restituisce 0 per entrambi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-484">When you examine the type parameters of the return type, <xref:System.Type.GenericParameterPosition%2A> returns 0 for both.</span></span> <span data-ttu-id="4ee8d-485">La posizione della `V` è 0 perché `V` è il primo parametro di tipo nell'elenco di parametri di tipo per la classe `A`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-485">The position of `V` is 0 because `V` is the first type parameter in the type parameter list for class `A`.</span></span> <span data-ttu-id="4ee8d-486">La posizione della `X` è 0 perché `X` è il primo parametro di tipo nell'elenco di parametri di tipo per `GetSomething`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-486">The position of `X` is 0 because `X` is the first type parameter in the type parameter list for `GetSomething`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-487">Chiama il <xref:System.Type.GenericParameterPosition%2A> proprietà genera un'eccezione se l'oggetto corrente <xref:System.Type> non rappresenta un parametro di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-487">Calling the <xref:System.Type.GenericParameterPosition%2A> property causes an exception if the current <xref:System.Type> does not represent a type parameter.</span></span> <span data-ttu-id="4ee8d-488">Quando si esaminano gli argomenti tipo di un tipo costruito aperto, usare il <xref:System.Type.IsGenericParameter%2A> proprietà in modo che i parametri di tipo e i tipi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-488">When you examine the type arguments of an open constructed type, use the <xref:System.Type.IsGenericParameter%2A> property to tell which are type parameters and which are types.</span></span> <span data-ttu-id="4ee8d-489">Il <xref:System.Type.IsGenericParameter%2A> proprietà restituisce `true` per un parametro di tipo; è quindi possibile usare il <xref:System.Type.GenericParameterPosition%2A> metodo per ottenere la posizione e il <xref:System.Type.DeclaringMethod%2A> e <xref:System.Type.DeclaringType%2A> le proprietà per determinare il metodo generico o tipo di definizione che lo definisce .</span><span class="sxs-lookup"><span data-stu-id="4ee8d-489">The <xref:System.Type.IsGenericParameter%2A> property returns `true` for a type parameter; you can then use the <xref:System.Type.GenericParameterPosition%2A> method to obtain its position and use the <xref:System.Type.DeclaringMethod%2A> and <xref:System.Type.DeclaringType%2A> properties to determine the generic method or type definition that defines it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-490">Nell'esempio seguente definisce una classe generica con due parametri di tipo e una seconda classe generica da cui deriva la prima classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-490">The following example defines a generic class with two type parameters and defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="4ee8d-491">Classe di base della classe derivata dispone di due argomenti di tipo: il primo è <xref:System.Int32>, e il secondo è un parametro di tipo del tipo derivato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-491">The derived class's base class has two type arguments: the first is <xref:System.Int32>, and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="4ee8d-492">Nell'esempio vengono visualizzate informazioni su queste classi generiche, incluse le posizioni segnalati dal <xref:System.Type.GenericParameterPosition%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-492">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4ee8d-493">Il tipo corrente non rappresenta un parametro di tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-493">The current type does not represent a type parameter.</span>
          </span>
          <span data-ttu-id="4ee8d-494">Ciò significa che <see cref="P:System.Type.IsGenericParameter" /> restituisce <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-494">That is, <see cref="P:System.Type.IsGenericParameter" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="4ee8d-495">Reflection e tipi generici</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-495">Reflection and Generic Types</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="4ee8d-496">Procedura: esaminare e creare istanze di tipi generici tramite reflection</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-496">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-497">Ottiene una matrice di argomenti tipo generico per questo tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-497">Gets an array of the generic type arguments for this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-498">Matrice di argomenti tipo generico per questo tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-498">An array of the generic type arguments for this type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-499">Questa proprietà ottiene solo gli argomenti di tipo generico; vale a dire, i tipi che sono stati specificati per i parametri di tipo generico del tipo corrente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-499">This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type.</span></span> <span data-ttu-id="4ee8d-500">Se il tipo corrente è una definizione di tipo generico, questa proprietà restituisce una matrice vuota.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-500">If the current type is a generic type definition, this property returns an empty array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-501">Se un tipo generico viene usato in un metodo generico o in un altro tipo generico, alcuni dei relativi argomenti di tipo generico potrebbe essere parametri di tipo generico del metodo o del tipo di inclusione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-501">If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.</span></span>  
  
 <span data-ttu-id="4ee8d-502">Per ottenere i parametri di tipo generico di un tipo che rappresenta una definizione di tipo generico, usare il <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-502">To get the generic type parameters of a type that represents a generic type definition, use the <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="4ee8d-503">Per ottenere un <xref:System.Reflection.TypeInfo> oggetto corrente <xref:System.Type> dell'oggetto, usare il <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> metodo di estensione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-503">To get a <xref:System.Reflection.TypeInfo> object for the current <xref:System.Type> object, use the <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> extension method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-504">Ottiene il numero di dimensioni in una matrice.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-504">Gets the number of dimensions in an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-505">Intero che contiene il numero di dimensioni del tipo corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-505">An integer that contains the number of dimensions in the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="4ee8d-506">Nell'esempio seguente visualizza il numero di dimensioni nella matrice.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-506">The following example displays the number of dimensions in an array.</span></span>  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="4ee8d-507">La funzionalità di questo metodo non è supportata nella classe base e deve invece essere implementata in una classe derivata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-507">The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-508">Il tipo corrente non è una matrice.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-508">The current type is not an array.</span>
          </span>
        </exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-509">Quando ne viene eseguito l'override in una classe derivata, implementa la proprietà <see cref="P:System.Type.Attributes" /> e ottiene una maschera di bit che indica gli attributi associati a <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-509">When overridden in a derived class, implements the <see cref="P:System.Type.Attributes" /> property and gets a bitmask indicating the attributes associated with the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-510">Oggetto <see cref="T:System.Reflection.TypeAttributes" /> che rappresenta il gruppo di attributi di <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-510">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-511">Ottiene un costruttore specifico dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-511">Gets a specific constructor of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">
          <span data-ttu-id="4ee8d-512">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano il numero, l'ordine e il tipo dei parametri per il costruttore desiderato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-512">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the desired constructor.</span>
          </span>
          <span data-ttu-id="4ee8d-513">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-513">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-514">Matrice vuota di oggetti <see cref="T:System.Type" /> per ottenere un costruttore che non accetta parametri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-514">An empty array of <see cref="T:System.Type" /> objects, to get a constructor that takes no parameters.</span>
          </span>
          <span data-ttu-id="4ee8d-515">Tale matrice vuota viene fornita dal campo <see langword="static" /><see cref="F:System.Type.EmptyTypes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-515">Such an empty array is provided by the <see langword="static" /> field <see cref="F:System.Type.EmptyTypes" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-516">Cerca un costruttore di istanza pubblica i cui parametri corrispondono ai tipi nella matrice specificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-516">Searches for a public instance constructor whose parameters match the types in the specified array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-517">Oggetto che rappresenta il costruttore dell'istanza pubblica i cui parametri corrispondono ai tipi nella matrice del tipo di parametro, se presente; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-517">An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-518">Questo overload del metodo esegue la ricerca di costruttori di istanza pubblici e non può essere usato per ottenere un inizializzatore di classi (. cctor).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-518">This method overload looks for public instance constructors and cannot be used to obtain a class initializer (.cctor).</span></span> <span data-ttu-id="4ee8d-519">Per ottenere un inizializzatore di classi, usare un overload che accetta <xref:System.Reflection.BindingFlags>e specificare <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-519">To get a class initializer, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="4ee8d-520">È anche possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-520">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="4ee8d-521">Se il costruttore richiesto non è pubblica, questo metodo restituisce `null`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-521">If the requested constructor is non-public, this method returns `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-522">Non è possibile omettere i parametri durante la ricerca di costruttori e metodi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-522">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="4ee8d-523">È possibile omettere i parametri solo quando viene richiamato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-523">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="4ee8d-524">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.ConstructorInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-524">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="4ee8d-525">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo restituisce sempre `null`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-525">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-526">L'esempio seguente ottiene il tipo della `MyClass`, ottiene il <xref:System.Reflection.ConstructorInfo> dell'oggetto e consente di visualizzare la firma del costruttore.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-526">The following example obtains the type of `MyClass`, gets the <xref:System.Reflection.ConstructorInfo> object, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-527">
            <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-527">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-528">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-528">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-529">Uno degli elementi in <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-529">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-530">
            <paramref name="types" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-530">
              <paramref name="types" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-531">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-531">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-532">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-532">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-533">Zero, per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-533">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="4ee8d-534">Oggetto che definisce una serie di proprietà e permette il binding, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-534">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="4ee8d-535">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-535">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-536">Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-536">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="4ee8d-537">Matrice di oggetti <see cref="T:System.Type" /> che rappresenta numero, ordine e tipo dei parametri relativi al costruttore da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-537">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span>
          </span>
          <span data-ttu-id="4ee8d-538">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-538">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-539">Matrice vuota di tipo <see cref="T:System.Type" /> (ovvero Type[] types = new Type[0]) per ottenere un costruttore che non accetta parametri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-539">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span>
          </span>
          <span data-ttu-id="4ee8d-540">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-540">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-541">
            <see cref="F:System.Type.EmptyTypes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-541">
              <see cref="F:System.Type.EmptyTypes" />.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="4ee8d-542">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresentano gli attributi associati all'elemento corrispondente nella matrice del tipo di parametro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-542">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the parameter type array.</span>
          </span>
          <span data-ttu-id="4ee8d-543">Questo parametro non viene elaborato dal binder predefinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-543">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-544">Cerca un costruttore i cui parametri corrispondono ai tipi e ai modificatori dell'argomento specificato, usando i vincoli di associazione specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-544">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-545">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> che rappresenta il costruttore corrispondente ai requisiti specificati, se presente; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-545">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-546">Se non esiste una corrispondenza esatta, la `binder` tenterà di assegnare i tipi di parametro specificati nel `types` matrice per selezionare una corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-546">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="4ee8d-547">Se il `binder` non è in grado di selezionare una corrispondenza, quindi `null` viene restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-547">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="4ee8d-548">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro può essere utilizzato per definire i costruttori da includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-548">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-549">È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-549">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-550">Specificare `BindingFlags.Public` da includere nella ricerca i costruttori pubblici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-550">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-551">Specificare `BindingFlags.NonPublic` da includere nella ricerca i costruttori non pubblici (vale a dire, i costruttori privati, interni e protetti).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-551">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="4ee8d-552">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-552">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="4ee8d-553">Per ottenere l'inizializzatore di classi (. cctor) usando questo overload del metodo, è necessario specificare <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-553">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="4ee8d-554">È anche possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-554">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-555">Non è possibile omettere i parametri durante la ricerca di costruttori e metodi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-555">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="4ee8d-556">È possibile omettere i parametri solo quando viene richiamato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-556">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="4ee8d-557">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.ConstructorInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-557">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="4ee8d-558">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo restituisce sempre `null`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-558">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-559">Il programma seguente ottiene il tipo della `MyClass1` classe, ottiene il <xref:System.Reflection.ConstructorInfo> corrispondenza il flag di associazione specificati e Visualizza la firma del costruttore.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-559">The following program obtains the type of `MyClass1` class, gets the <xref:System.Reflection.ConstructorInfo> object matching the specified binding flags, and displays the signature of the constructor.</span></span>  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-560">
            <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-560">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-561">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-561">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-562">Uno degli elementi in <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-562">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-563">
            <paramref name="types" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-563">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="4ee8d-564">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-564">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-565">
            <paramref name="modifiers" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-565">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="4ee8d-566">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-566">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-567">
            <paramref name="types" /> e <paramref name="modifiers" /> non hanno la stessa lunghezza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-567">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-568">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-568">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-569">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-569">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-570">Zero, per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-570">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="4ee8d-571">Oggetto che definisce una serie di proprietà e permette il binding, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-571">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="4ee8d-572">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-572">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-573">Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-573">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="4ee8d-574">Oggetto che specifica il set di regole da usare per l'ordine e il layout degli argomenti, la modalità di passaggio del valore restituito, i Registri di sistema usati per gli argomenti e la pulizia dello stack.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-574">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="4ee8d-575">Matrice di oggetti <see cref="T:System.Type" /> che rappresenta numero, ordine e tipo dei parametri relativi al costruttore da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-575">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span>
          </span>
          <span data-ttu-id="4ee8d-576">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-576">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-577">Matrice vuota di tipo <see cref="T:System.Type" /> (ovvero Type[] types = new Type[0]) per ottenere un costruttore che non accetta parametri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-577">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="4ee8d-578">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresenta gli attributi associati all'elemento corrispondente nella matrice <c>types</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-578">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="4ee8d-579">Questo parametro non viene elaborato dal binder predefinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-579">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-580">Cerca il costruttore i cui parametri corrispondono ai tipi di argomenti e ai modificatori specificati, usando i vincoli di associazione e la convenzione di chiamata specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-580">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-581">Oggetto che rappresenta il costruttore corrispondente ai requisiti specificati, se è stato trovato; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-581">An object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-582">Anche se il binder predefinito elabora <xref:System.Reflection.ParameterModifier> (la `modifiers` parametro), è possibile usare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per scrivere un binder personalizzato che elaborano `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-582">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="4ee8d-583">`ParameterModifier` viene usato solo quando si chiama tramite l'interoperabilità COM, e vengono gestiti solo i parametri che vengono passati per riferimento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-583">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="4ee8d-584">Se non esiste una corrispondenza esatta, la `binder` tenterà di assegnare i tipi di parametro specificati nel `types` matrice per selezionare una corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-584">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="4ee8d-585">Se il `binder` non è in grado di selezionare una corrispondenza, quindi `null` viene restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-585">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="4ee8d-586">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro può essere utilizzato per definire i costruttori da includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-586">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-587">È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-587">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-588">Specificare `BindingFlags.Public` da includere nella ricerca i costruttori pubblici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-588">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-589">Specificare `BindingFlags.NonPublic` da includere nella ricerca i costruttori non pubblici (vale a dire, i costruttori privati, interni e protetti).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-589">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="4ee8d-590">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-590">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="4ee8d-591">Per ottenere l'inizializzatore di classi (. cctor) utilizzando questo metodo, è necessario specificare <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-591">To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="4ee8d-592">È anche possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-592">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="4ee8d-593">La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-593">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="4ee8d-594">Tipo di membro</span><span class="sxs-lookup"><span data-stu-id="4ee8d-594">Member Type</span></span>|<span data-ttu-id="4ee8d-595">Static</span><span class="sxs-lookup"><span data-stu-id="4ee8d-595">Static</span></span>|<span data-ttu-id="4ee8d-596">Non statici</span><span class="sxs-lookup"><span data-stu-id="4ee8d-596">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="4ee8d-597">Costruttore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-597">Constructor</span></span>|<span data-ttu-id="4ee8d-598">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-598">No</span></span>|<span data-ttu-id="4ee8d-599">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-599">No</span></span>|  
|<span data-ttu-id="4ee8d-600">Campo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-600">Field</span></span>|<span data-ttu-id="4ee8d-601">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-601">No</span></span>|<span data-ttu-id="4ee8d-602">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-602">Yes.</span></span> <span data-ttu-id="4ee8d-603">Un campo viene sempre hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-603">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-604">event</span><span class="sxs-lookup"><span data-stu-id="4ee8d-604">Event</span></span>|<span data-ttu-id="4ee8d-605">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-605">Not applicable</span></span>|<span data-ttu-id="4ee8d-606">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-606">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-607">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-607">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-608">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-608">See note 2 below.</span></span>|  
|<span data-ttu-id="4ee8d-609">Metodo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-609">Method</span></span>|<span data-ttu-id="4ee8d-610">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-610">No</span></span>|<span data-ttu-id="4ee8d-611">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-611">Yes.</span></span> <span data-ttu-id="4ee8d-612">Un metodo (virtuale e non virtuale) può essere hide-by-name o hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-612">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-613">Tipo annidato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-613">Nested Type</span></span>|<span data-ttu-id="4ee8d-614">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-614">No</span></span>|<span data-ttu-id="4ee8d-615">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-615">No</span></span>|  
|<span data-ttu-id="4ee8d-616">Proprietà</span><span class="sxs-lookup"><span data-stu-id="4ee8d-616">Property</span></span>|<span data-ttu-id="4ee8d-617">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-617">Not applicable</span></span>|<span data-ttu-id="4ee8d-618">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-618">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-619">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-619">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-620">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-620">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="4ee8d-621">Hide-by-name-e-signature prende in considerazione tutte le parti della firma, inclusi i modificatori personalizzati, i tipi restituiti, i tipi di parametri, elementi sentinel e le convenzioni di chiamata non gestite.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-621">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="4ee8d-622">Si tratta di un confronto binario.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-622">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="4ee8d-623">Per la reflection, proprietà ed eventi sono hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-623">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-624">Se si dispone di una proprietà con una richiesta get e una funzione di accesso set nella classe di base, ma la classe derivata ha solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter della classe base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-624">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="4ee8d-625">Gli attributi personalizzati non fanno parte di common type system.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-625">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-626">Non è possibile omettere i parametri durante la ricerca di costruttori e metodi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-626">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="4ee8d-627">È possibile omettere i parametri solo quando viene richiamato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-627">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="4ee8d-628">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.ConstructorInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-628">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="4ee8d-629">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo restituisce sempre `null`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-629">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-630">L'esempio seguente ottiene il tipo della `MyClass1`, ottiene il <xref:System.Reflection.ConstructorInfo> oggetto che corrisponde al flag di associazione specificati e Visualizza la firma del costruttore.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-630">The following example obtains the type of `MyClass1`, gets the <xref:System.Reflection.ConstructorInfo> object that matches the specified binding flags, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-631">
            <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-631">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-632">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-632">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-633">Uno degli elementi in <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-633">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-634">
            <paramref name="types" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-634">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="4ee8d-635">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-635">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-636">
            <paramref name="modifiers" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-636">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="4ee8d-637">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-637">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-638">
            <paramref name="types" /> e <paramref name="modifiers" /> non hanno la stessa lunghezza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-638">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-639">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-639">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-640">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-640">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-641">Zero, per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-641">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="4ee8d-642">Oggetto che definisce una serie di proprietà e permette il binding, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-642">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="4ee8d-643">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-643">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-644">Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-644">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="4ee8d-645">Oggetto che specifica il set di regole da usare per l'ordine e il layout degli argomenti, la modalità di passaggio del valore restituito, i Registri di sistema usati per gli argomenti e la pulizia dello stack.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-645">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="4ee8d-646">Matrice di oggetti <see cref="T:System.Type" /> che rappresenta numero, ordine e tipo dei parametri relativi al costruttore da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-646">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span>
          </span>
          <span data-ttu-id="4ee8d-647">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-647">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-648">Matrice vuota di tipo <see cref="T:System.Type" /> (ovvero Type[] types = new Type[0]) per ottenere un costruttore che non accetta parametri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-648">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="4ee8d-649">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresenta gli attributi associati all'elemento corrispondente nella matrice <c>types</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-649">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="4ee8d-650">Questo parametro non viene elaborato dal binder predefinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-650">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-651">Quando ne viene eseguito l'override in una classe derivata, cerca un costruttore i cui parametri corrispondono ai modificatori e ai tipi di argomento specificati, usando i vincoli di associazione e la convenzione di denominazione specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-651">When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-652">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> che rappresenta il costruttore corrispondente ai requisiti specificati, se presente; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-652">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-653">Anche se il binder predefinito elabora <xref:System.Reflection.ParameterModifier> (la `modifiers` parametro), è possibile usare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per scrivere un binder personalizzato che elaborano `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-653">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="4ee8d-654">`ParameterModifier` viene usato solo quando si chiama tramite l'interoperabilità COM, e vengono gestiti solo i parametri che vengono passati per riferimento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-654">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="4ee8d-655">Se non esiste una corrispondenza esatta, la `binder` tenterà di assegnare i tipi di parametro specificati nel `types` matrice per selezionare una corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-655">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="4ee8d-656">Se il `binder` non è in grado di selezionare una corrispondenza, quindi `null` viene restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-656">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="4ee8d-657">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro può essere utilizzato per definire i costruttori da includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-657">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-658">È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-658">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-659">Specificare `BindingFlags.Public` da includere nella ricerca i costruttori pubblici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-659">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-660">Specificare `BindingFlags.NonPublic` da includere nella ricerca i costruttori non pubblici (vale a dire, i costruttori privati, interni e protetti).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-660">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="4ee8d-661">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-661">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="4ee8d-662">Questo metodo implementa <xref:System.Type.GetConstructor%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-662">This method implements <xref:System.Type.GetConstructor%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-663">
            <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-663">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-664">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-664">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-665">Uno degli elementi in <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-665">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-666">
            <paramref name="types" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-666">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="4ee8d-667">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-667">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-668">
            <paramref name="modifiers" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-668">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="4ee8d-669">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-669">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-670">
            <paramref name="types" /> e <paramref name="modifiers" /> non hanno la stessa lunghezza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-670">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="4ee8d-671">Il tipo corrente è un oggetto <see cref="T:System.Reflection.Emit.TypeBuilder" /> o <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-671">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-672">Ottiene i costruttori dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-672">Gets the constructors of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-673">Restituisce tutti i costruttori di tipo pubblico definiti per l'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-673">Returns all the public constructors defined for the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-674">Matrice di oggetti <see cref="T:System.Reflection.ConstructorInfo" /> che rappresentano tutti i costruttori di istanza pubblici definiti per l'oggetto <see cref="T:System.Type" /> corrente, senza l'inizializzatore di tipo (costruttore statico).</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-674">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all the public instance constructors defined for the current <see cref="T:System.Type" />, but not including the type initializer (static constructor).</span>
          </span>
          <span data-ttu-id="4ee8d-675">Se per l'oggetto <see cref="T:System.Type" /> corrente non sono definiti costruttori di istanza pubblici o se l'oggetto <see cref="T:System.Type" /> corrente rappresenta un parametro di tipo nella definizione di un tipo o di un metodo generico, viene restituita una matrice vuota di tipo <see cref="T:System.Reflection.ConstructorInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-675">If no public instance constructors are defined for the current <see cref="T:System.Type" />, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-676">Il <xref:System.Type.GetConstructors%2A> metodo non restituisce i costruttori in un determinato ordine, ad esempio ordine di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-676">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="4ee8d-677">Il codice non deve dipendere dall'ordine in cui vengono restituiti i costruttori, perché che varia in base di order.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-677">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="4ee8d-678">La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-678">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="4ee8d-679">Tipo di membro</span><span class="sxs-lookup"><span data-stu-id="4ee8d-679">Member Type</span></span>|<span data-ttu-id="4ee8d-680">Static</span><span class="sxs-lookup"><span data-stu-id="4ee8d-680">Static</span></span>|<span data-ttu-id="4ee8d-681">Non statici</span><span class="sxs-lookup"><span data-stu-id="4ee8d-681">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="4ee8d-682">Costruttore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-682">Constructor</span></span>|<span data-ttu-id="4ee8d-683">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-683">No</span></span>|<span data-ttu-id="4ee8d-684">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-684">No</span></span>|  
|<span data-ttu-id="4ee8d-685">Campo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-685">Field</span></span>|<span data-ttu-id="4ee8d-686">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-686">No</span></span>|<span data-ttu-id="4ee8d-687">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-687">Yes.</span></span> <span data-ttu-id="4ee8d-688">Un campo viene sempre hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-688">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-689">event</span><span class="sxs-lookup"><span data-stu-id="4ee8d-689">Event</span></span>|<span data-ttu-id="4ee8d-690">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-690">Not applicable</span></span>|<span data-ttu-id="4ee8d-691">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-691">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-692">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-692">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-693">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-693">See note 2 below.</span></span>|  
|<span data-ttu-id="4ee8d-694">Metodo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-694">Method</span></span>|<span data-ttu-id="4ee8d-695">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-695">No</span></span>|<span data-ttu-id="4ee8d-696">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-696">Yes.</span></span> <span data-ttu-id="4ee8d-697">Un metodo (virtuale e non virtuale) può essere hide-by-name o hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-697">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-698">Tipo annidato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-698">Nested Type</span></span>|<span data-ttu-id="4ee8d-699">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-699">No</span></span>|<span data-ttu-id="4ee8d-700">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-700">No</span></span>|  
|<span data-ttu-id="4ee8d-701">Proprietà</span><span class="sxs-lookup"><span data-stu-id="4ee8d-701">Property</span></span>|<span data-ttu-id="4ee8d-702">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-702">Not applicable</span></span>|<span data-ttu-id="4ee8d-703">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-703">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-704">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-704">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-705">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-705">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="4ee8d-706">Hide-by-name-e-signature prende in considerazione tutte le parti della firma, inclusi i modificatori personalizzati, i tipi restituiti, i tipi di parametri, elementi sentinel e le convenzioni di chiamata non gestite.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-706">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="4ee8d-707">Si tratta di un confronto binario.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-707">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="4ee8d-708">Per la reflection, proprietà ed eventi sono hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-708">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-709">Se si dispone di una proprietà con una richiesta get e una funzione di accesso set nella classe di base, ma la classe derivata ha solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter della classe base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-709">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="4ee8d-710">Gli attributi personalizzati non fanno parte di common type system.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-710">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="4ee8d-711">Questo overload del metodo chiama il <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> overload del metodo, con <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-711">This method overload calls the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="4ee8d-712">Non si troverà gli inizializzatori di classi (. cctor).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-712">It will not find class initializers (.cctor).</span></span> <span data-ttu-id="4ee8d-713">Per trovare gli inizializzatori di classi, usare un overload che accetta <xref:System.Reflection.BindingFlags>e specificare <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-713">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="4ee8d-714">È anche possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-714">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="4ee8d-715">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.ConstructorInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-715">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="4ee8d-716">Ad esempio, se classe `C<T>` ha un costruttore `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), la chiamata <xref:System.Type.GetConstructors%2A> sul `C<int>` restituisce un <xref:System.Reflection.ConstructorInfo> che rappresenta `C(int t1)` nel linguaggio c# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-716">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="4ee8d-717">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo generico, la <xref:System.Type.GetConstructors%2A> metodo restituisce una matrice vuota.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-717">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-718">In questo esempio mostra l'output del <xref:System.Type.GetConstructors%2A> overload da una classe che dispone di due costruttori di istanza e un costruttore statico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-718">This example shows the output of the <xref:System.Type.GetConstructors%2A> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="4ee8d-719">L'output di questo codice è:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-719">The output of this code is:</span></span>  
  
 <span data-ttu-id="4ee8d-720">2</span><span class="sxs-lookup"><span data-stu-id="4ee8d-720">2</span></span>  
  
 <span data-ttu-id="4ee8d-721">False</span><span class="sxs-lookup"><span data-stu-id="4ee8d-721">False</span></span>  
  
 <span data-ttu-id="4ee8d-722">False</span><span class="sxs-lookup"><span data-stu-id="4ee8d-722">False</span></span>  
  
 <span data-ttu-id="4ee8d-723">Perché il <xref:System.Type.GetConstructors> overload viene utilizzato solo <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> e <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, il costruttore statico non viene conteggiato per il `for` espressione né valutato da `IsStatic`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-723">Because the <xref:System.Type.GetConstructors> overload uses only <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="4ee8d-724">Per trovare i costruttori statici, usare il <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> rapporto di overload, quindi passare la combinazione (logiche `OR`) della <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, come illustrato nell'esempio di codice seguente:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-724">To find static constructors, use the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> overload, and pass the combination (logical `OR`) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="4ee8d-725">A questo punto l'output è:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-725">Now the output is:</span></span>  
  
 <span data-ttu-id="4ee8d-726">3</span><span class="sxs-lookup"><span data-stu-id="4ee8d-726">3</span></span>  
  
 <span data-ttu-id="4ee8d-727">False</span><span class="sxs-lookup"><span data-stu-id="4ee8d-727">False</span></span>  
  
 <span data-ttu-id="4ee8d-728">True</span><span class="sxs-lookup"><span data-stu-id="4ee8d-728">True</span></span>  
  
 <span data-ttu-id="4ee8d-729">False</span><span class="sxs-lookup"><span data-stu-id="4ee8d-729">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-730">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-730">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-731">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-731">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-732">Zero, per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-732">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-733">Quando ne viene eseguito l'override in una classe derivata, cerca i costruttori definiti per l'oggetto <see cref="T:System.Type" /> corrente, usando i <see langword="BindingFlags" /> specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-733">When overridden in a derived class, searches for the constructors defined for the current <see cref="T:System.Type" />, using the specified <see langword="BindingFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-734">Matrice di oggetti <see cref="T:System.Reflection.ConstructorInfo" /> che rappresentano tutti i costruttori definiti per l'oggetto <see cref="T:System.Type" /> corrente corrispondente ai vincoli di binding specificati, compreso l'inizializzatore di tipo, se definito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-734">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all constructors defined for the current <see cref="T:System.Type" /> that match the specified binding constraints, including the type initializer if it is defined.</span>
          </span>
          <span data-ttu-id="4ee8d-735">Restituisce una matrice vuota di tipo <see cref="T:System.Reflection.ConstructorInfo" /> se per l'oggetto <see cref="T:System.Type" /> corrente non sono definiti costruttori, se nessuno dei costruttori definiti corrisponde ai vincoli di binding o se l'oggetto <see cref="T:System.Type" /> corrente rappresenta un parametro di tipo nella definizione di un tipo o di un metodo generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-735">Returns an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> if no constructors are defined for the current <see cref="T:System.Type" />, if none of the defined constructors match the binding constraints, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-736">Il <xref:System.Type.GetConstructors%2A> metodo non restituisce i costruttori in un determinato ordine, ad esempio ordine di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-736">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="4ee8d-737">Il codice non deve dipendere dall'ordine in cui vengono restituiti i costruttori, perché che varia in base di order.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-737">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="4ee8d-738">`bindingAttr` Consente di specificare se restituire solo i costruttori pubblici o i costruttori pubblici e non pubblici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-738">`bindingAttr` can be used to specify whether to return only public constructors or both public and non-public constructors.</span></span>  
  
 <span data-ttu-id="4ee8d-739">Se non esiste una corrispondenza esatta, la `binder` tenterà di assegnare i tipi di parametro specificati nel `types` matrice per selezionare una corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-739">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="4ee8d-740">Se il `binder` non è in grado di selezionare una corrispondenza, quindi `null` viene restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-740">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="4ee8d-741">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro può essere utilizzato per definire i costruttori da includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-741">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-742">È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-742">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-743">Specificare `BindingFlags.Public` da includere nella ricerca i costruttori pubblici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-743">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-744">Specificare `BindingFlags.NonPublic` da includere nella ricerca i costruttori non pubblici (vale a dire, i costruttori privati, interni e protetti).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-744">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span> <span data-ttu-id="4ee8d-745">I costruttori delle classi base non vengono restituiti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-745">Constructors of base classes are not returned.</span></span>  
  
 <span data-ttu-id="4ee8d-746">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-746">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="4ee8d-747">Per ottenere l'inizializzatore di classi (. cctor) usando questo overload del metodo, è necessario specificare <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-747">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="4ee8d-748">È anche possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-748">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="4ee8d-749">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.ConstructorInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-749">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="4ee8d-750">Ad esempio, se classe `C<T>` ha un costruttore `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), la chiamata <xref:System.Type.GetConstructors%2A> sul `C<int>` restituisce un <xref:System.Reflection.ConstructorInfo> che rappresenta `C(int t1)` nel linguaggio c# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-750">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="4ee8d-751">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo generico, la <xref:System.Type.GetConstructors%2A> metodo restituisce una matrice vuota.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-751">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-752">In questo esempio mostra l'output del <xref:System.Type.GetConstructors> overload da una classe che dispone di due costruttori di istanza e un costruttore statico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-752">This example shows the output of the <xref:System.Type.GetConstructors> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="4ee8d-753">L'output di questo codice è:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-753">The output of this code is:</span></span>  
  
 <span data-ttu-id="4ee8d-754">2</span><span class="sxs-lookup"><span data-stu-id="4ee8d-754">2</span></span>  
  
 <span data-ttu-id="4ee8d-755">False</span><span class="sxs-lookup"><span data-stu-id="4ee8d-755">False</span></span>  
  
 <span data-ttu-id="4ee8d-756">False</span><span class="sxs-lookup"><span data-stu-id="4ee8d-756">False</span></span>  
  
 <span data-ttu-id="4ee8d-757">Perché il <xref:System.Type.GetConstructors%2A> overload viene utilizzato solo <xref:System.Reflection.BindingFlags.Public> e <xref:System.Reflection.BindingFlags.Instance>, il costruttore statico non viene conteggiato per il `for` espressione né valutato da `IsStatic`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-757">Because the <xref:System.Type.GetConstructors%2A> overload uses only <xref:System.Reflection.BindingFlags.Public> and <xref:System.Reflection.BindingFlags.Instance>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="4ee8d-758">Per trovare i costruttori statici, usare il <xref:System.Type.GetConstructors%2A> rapporto di overload e passarlo di combinazione (OR logico) di <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, come illustrato nell'esempio di codice seguente:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-758">To find static constructors, use the <xref:System.Type.GetConstructors%2A> overload, and pass it the combination (logical OR) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="4ee8d-759">A questo punto l'output è:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-759">Now the output is:</span></span>  
  
 <span data-ttu-id="4ee8d-760">3</span><span class="sxs-lookup"><span data-stu-id="4ee8d-760">3</span></span>  
  
 <span data-ttu-id="4ee8d-761">False</span><span class="sxs-lookup"><span data-stu-id="4ee8d-761">False</span></span>  
  
 <span data-ttu-id="4ee8d-762">True</span><span class="sxs-lookup"><span data-stu-id="4ee8d-762">True</span></span>  
  
 <span data-ttu-id="4ee8d-763">False</span><span class="sxs-lookup"><span data-stu-id="4ee8d-763">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-764">Cerca i membri definiti per l'oggetto <see cref="T:System.Type" /> corrente per cui è impostato il <see cref="T:System.Reflection.DefaultMemberAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-764">Searches for the members defined for the current <see cref="T:System.Type" /> whose <see cref="T:System.Reflection.DefaultMemberAttribute" /> is set.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-765">Matrice di oggetti <see cref="T:System.Reflection.MemberInfo" /> che rappresentano tutti i membri predefiniti dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-765">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all default members of the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="4ee8d-766">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-766">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-767">Matrice vuota di tipo <see cref="T:System.Reflection.MemberInfo" />, se per l'oggetto <see cref="T:System.Type" /> corrente non esistono membri predefiniti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-767">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have default members.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-768">Il <xref:System.Type.GetDefaultMembers%2A> metodo non restituisce i membri in un ordine specifico, ad esempio in ordine alfabetico o un ordine di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-768">The <xref:System.Type.GetDefaultMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="4ee8d-769">Il codice non deve dipendere dall'ordine in cui vengono restituiti i membri, perché che varia in base di order.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-769">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="4ee8d-770">Questo metodo può essere sostituito da una classe derivata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-770">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="4ee8d-771">I membri includono proprietà, metodi, campi, eventi e così via.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-771">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="4ee8d-772">La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-772">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="4ee8d-773">Tipo di membro</span><span class="sxs-lookup"><span data-stu-id="4ee8d-773">Member Type</span></span>|<span data-ttu-id="4ee8d-774">Static</span><span class="sxs-lookup"><span data-stu-id="4ee8d-774">Static</span></span>|<span data-ttu-id="4ee8d-775">Non statici</span><span class="sxs-lookup"><span data-stu-id="4ee8d-775">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="4ee8d-776">Costruttore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-776">Constructor</span></span>|<span data-ttu-id="4ee8d-777">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-777">No</span></span>|<span data-ttu-id="4ee8d-778">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-778">No</span></span>|  
|<span data-ttu-id="4ee8d-779">Campo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-779">Field</span></span>|<span data-ttu-id="4ee8d-780">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-780">No</span></span>|<span data-ttu-id="4ee8d-781">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-781">Yes.</span></span> <span data-ttu-id="4ee8d-782">Un campo viene sempre hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-782">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-783">event</span><span class="sxs-lookup"><span data-stu-id="4ee8d-783">Event</span></span>|<span data-ttu-id="4ee8d-784">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-784">Not applicable</span></span>|<span data-ttu-id="4ee8d-785">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-785">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-786">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-786">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-787">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-787">See note 2 below.</span></span>|  
|<span data-ttu-id="4ee8d-788">Metodo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-788">Method</span></span>|<span data-ttu-id="4ee8d-789">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-789">No</span></span>|<span data-ttu-id="4ee8d-790">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-790">Yes.</span></span> <span data-ttu-id="4ee8d-791">Un metodo (virtuale e non virtuale) può essere hide-by-name o hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-791">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-792">Tipo annidato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-792">Nested Type</span></span>|<span data-ttu-id="4ee8d-793">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-793">No</span></span>|<span data-ttu-id="4ee8d-794">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-794">No</span></span>|  
|<span data-ttu-id="4ee8d-795">Proprietà</span><span class="sxs-lookup"><span data-stu-id="4ee8d-795">Property</span></span>|<span data-ttu-id="4ee8d-796">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-796">Not applicable</span></span>|<span data-ttu-id="4ee8d-797">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-797">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-798">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-798">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-799">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-799">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="4ee8d-800">Hide-by-name-e-signature prende in considerazione tutte le parti della firma, inclusi i modificatori personalizzati, i tipi restituiti, i tipi di parametri, elementi sentinel e le convenzioni di chiamata non gestite.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-800">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="4ee8d-801">Si tratta di un confronto binario.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-801">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="4ee8d-802">Per la reflection, proprietà ed eventi sono hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-802">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-803">Se si dispone di una proprietà con una richiesta get e una funzione di accesso set nella classe di base, ma la classe derivata ha solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter della classe base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-803">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="4ee8d-804">Gli attributi personalizzati non fanno parte di common type system.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-804">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="4ee8d-805">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MemberInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-805">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="4ee8d-806">Ad esempio, se classe `C<T>` dispone di una proprietà `P` che restituisce `T`, la chiamata <xref:System.Type.GetDefaultMembers%2A> sul `C<int>` restituisce `int P` in c# (`Property P As Integer` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-806">For example, if class `C<T>` has a property `P` that returns `T`, calling <xref:System.Type.GetDefaultMembers%2A> on `C<int>` returns `int P` in C# (`Property P As Integer` in Visual Basic).</span></span>  
  
 <span data-ttu-id="4ee8d-807">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o metodo generico, questo metodo cerca i membri del vincolo di classe o i membri di <xref:System.Object> se è presente alcun vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-807">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-808">L'esempio seguente ottiene le informazioni sui membri predefiniti di `MyClass` e visualizza i membri predefiniti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-808">The following example obtains the default member information of `MyClass` and displays the default members.</span></span>  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-809">Quando ne viene eseguito l'override in una classe derivata, restituisce l'oggetto <see cref="T:System.Type" /> dell'oggetto incluso in modo diretto o mediante riferimento tramite matrice, puntatore o tipo di riferimento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-809">When overridden in a derived class, returns the <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer or reference type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-810">Oggetto <see cref="T:System.Type" /> dell'oggetto incluso o a cui fa riferimento la matrice, il puntatore o il tipo di riferimento corrente oppure <see langword="null" /> se l'oggetto <see cref="T:System.Type" /> corrente non è una matrice né un puntatore, non viene passato per riferimento oppure rappresenta un tipo generico o un parametro di tipo nella definizione di un tipo o di un metodo generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-810">The <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer, or reference type, or <see langword="null" /> if the current <see cref="T:System.Type" /> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-811">Questo metodo restituisce `null` per il <xref:System.Array> classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-811">This method returns `null` for the <xref:System.Array> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-812">Nell'esempio seguente viene illustrato l'utilizzo di `GetElementType` (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-812">The following example demonstrates using the `GetElementType` method.</span></span>  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="4ee8d-813">Valore di cui recuperare il nome.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-813">The value whose name is to be retrieved.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-814">Restituisce il nome della costante avente il valore specificato, per il tipo di enumerazione corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-814">Returns the name of the constant that has the specified value, for the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-815">Nome del membro del tipo di enumerazione corrente avente il valore specificato oppure <see langword="null" /> se tale costante non viene rilevata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-815">The name of the member of the current enumeration type that has the specified value, or <see langword="null" /> if no such constant is found.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-816">Il tipo corrente non è un'enumerazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-816">The current type is not an enumeration.</span>
          </span>
          <span data-ttu-id="4ee8d-817">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-817">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-818">Il tipo di <paramref name="value" /> non corrisponde al tipo corrente. Inoltre, il relativo tipo sottostante non corrisponde a quello del tipo corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-818">
              <paramref name="value" /> is neither of the current type nor does it have the same underlying type as the current type.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-819">
            <paramref name="value" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-819">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-820">Restituisce i nomi dei membri del tipo di enumerazione corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-820">Returns the names of the members of the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-821">Matrice contenente i nomi dei membri dell'enumerazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-821">An array that contains the names of the members of the enumeration.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-822">Gli elementi della matrice di valori restituiti vengono ordinati i valori binari (vale a dire, i valori senza segno) delle costanti enumerate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-822">The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants.</span></span> <span data-ttu-id="4ee8d-823">Se la matrice contiene costanti enumerate con lo stesso valore, non è specificato l'ordine dei nomi corrispondenti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-823">If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-824">Il tipo corrente non è un'enumerazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-824">The current type is not an enumeration.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-825">Restituisce il tipo sottostante del tipo di enumerazione corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-825">Returns the underlying type of the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-826">Tipo sottostante dell'enumerazione corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-826">The underlying type of the current enumeration.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-827">Per impostazione predefinita, il tipo sottostante di un'enumerazione in c# e Visual Basic è <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-827">By default, the underlying type of an enumeration in C# and Visual Basic is <xref:System.Int32>.</span></span> <span data-ttu-id="4ee8d-828">È possibile specificare altri tipi di integer.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-828">Other integer types can be specified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-829">Il tipo corrente non è un'enumerazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-829">The current type is not an enumeration.</span>
          </span>
          <span data-ttu-id="4ee8d-830">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-830">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-831">Il tipo di enumerazione non è valido perché contiene più di un campo di istanza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-831">The enumeration type is not valid, because it contains more than one instance field.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-832">Restituisce una matrice dei valori delle costanti nel tipo di enumerazione corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-832">Returns an array of the values of the constants in the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-833">Matrice contenente i valori.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-833">An array that contains the values.</span>
          </span>
          <span data-ttu-id="4ee8d-834">Gli elementi della matrice sono ordinati in base ai valori binari (ad esempio, i valori senza segno) delle costanti dell'enumerazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-834">The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-835">Il tipo corrente non è un'enumerazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-835">The current type is not an enumeration.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-836">Ottiene un evento specifico dichiarato o ereditato dall'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-836">Gets a specific event declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-837">Stringa contenente il nome di un evento dichiarato o ereditato dall'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-837">The string containing the name of an event that is declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-838">Restituisce l'oggetto <see cref="T:System.Reflection.EventInfo" /> che rappresenta l'evento pubblico specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-838">Returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified public event.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-839">Oggetto che rappresenta l'evento pubblico specificato dichiarato o ereditato dall'oggetto <see cref="T:System.Type" /> corrente, se disponibile; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-839">The object representing the specified public event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-840">Un evento è considerato pubblico per la reflection se dispone di almeno un metodo o funzione di accesso pubblico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-840">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="4ee8d-841">In caso contrario, l'evento viene considerato privato ed è necessario usare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerla.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-841">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="4ee8d-842">La ricerca di `name` tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-842">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="4ee8d-843">La ricerca include gli eventi di istanza pubblici statici e pubblici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-843">The search includes public static and public instance events.</span></span>  
  
 <span data-ttu-id="4ee8d-844">La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-844">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="4ee8d-845">Tipo di membro</span><span class="sxs-lookup"><span data-stu-id="4ee8d-845">Member Type</span></span>|<span data-ttu-id="4ee8d-846">Static</span><span class="sxs-lookup"><span data-stu-id="4ee8d-846">Static</span></span>|<span data-ttu-id="4ee8d-847">Non statici</span><span class="sxs-lookup"><span data-stu-id="4ee8d-847">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="4ee8d-848">Costruttore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-848">Constructor</span></span>|<span data-ttu-id="4ee8d-849">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-849">No</span></span>|<span data-ttu-id="4ee8d-850">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-850">No</span></span>|  
|<span data-ttu-id="4ee8d-851">Campo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-851">Field</span></span>|<span data-ttu-id="4ee8d-852">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-852">No</span></span>|<span data-ttu-id="4ee8d-853">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-853">Yes.</span></span> <span data-ttu-id="4ee8d-854">Un campo viene sempre hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-854">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-855">event</span><span class="sxs-lookup"><span data-stu-id="4ee8d-855">Event</span></span>|<span data-ttu-id="4ee8d-856">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-856">Not applicable</span></span>|<span data-ttu-id="4ee8d-857">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-857">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-858">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-858">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-859">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-859">See note 2 below.</span></span>|  
|<span data-ttu-id="4ee8d-860">Metodo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-860">Method</span></span>|<span data-ttu-id="4ee8d-861">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-861">No</span></span>|<span data-ttu-id="4ee8d-862">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-862">Yes.</span></span> <span data-ttu-id="4ee8d-863">Un metodo (virtuale e non virtuale) può essere hide-by-name o hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-863">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-864">Tipo annidato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-864">Nested Type</span></span>|<span data-ttu-id="4ee8d-865">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-865">No</span></span>|<span data-ttu-id="4ee8d-866">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-866">No</span></span>|  
|<span data-ttu-id="4ee8d-867">Proprietà</span><span class="sxs-lookup"><span data-stu-id="4ee8d-867">Property</span></span>|<span data-ttu-id="4ee8d-868">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-868">Not applicable</span></span>|<span data-ttu-id="4ee8d-869">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-869">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-870">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-870">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-871">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-871">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="4ee8d-872">Hide-by-name-e-signature prende in considerazione tutte le parti della firma, inclusi i modificatori personalizzati, i tipi restituiti, i tipi di parametri, elementi sentinel e le convenzioni di chiamata non gestite.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-872">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="4ee8d-873">Si tratta di un confronto binario.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-873">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="4ee8d-874">Per la reflection, proprietà ed eventi sono hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-874">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-875">Se si dispone di una proprietà con una richiesta get e una funzione di accesso set nella classe di base, ma la classe derivata ha solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter della classe base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-875">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="4ee8d-876">Gli attributi personalizzati non fanno parte di common type system.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-876">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="4ee8d-877">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.EventInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-877">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-878">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cercherà gli eventi del vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-878">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-879">L'esempio seguente crea un <xref:System.Reflection.EventInfo> dell'oggetto e ottiene l'evento per una classe di pulsanti per l'evento specificato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-879">The following example creates an <xref:System.Reflection.EventInfo> object and gets the event for a button class for the specified event.</span></span>  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-880">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-880">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-881">Stringa contenente il nome di un evento dichiarato o ereditato dall'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-881">The string containing the name of an event which is declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-882">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-882">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-883">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-883">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-884">Zero, per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-884">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-885">Quando ne viene eseguito l'override in una classe derivata, restituisce l'oggetto <see cref="T:System.Reflection.EventInfo" /> che rappresenta l'evento specificato, usando i vincoli di binding specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-885">When overridden in a derived class, returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified event, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-886">Oggetto che rappresenta l'evento specificato dichiarato o ereditato dall'oggetto <see cref="T:System.Type" /> corrente, se disponibile; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-886">The object representing the specified event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-887">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire gli eventi da includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-887">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-888">È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-888">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-889">Specificare `BindingFlags.Public` per includere gli eventi pubblici nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-889">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-890">Specificare `BindingFlags.NonPublic` da includere non pubblica gli eventi (vale a dire, privati, interni e protetto) nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-890">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-891">Specificare `BindingFlags.FlattenHierarchy` da includere `public` e `protected` membri statici nella gerarchia; `private` non sono inclusi i membri statici nelle classi ereditate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-891">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="4ee8d-892">Nell'esempio <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare il comportamento della ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-892">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="4ee8d-893">`BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-893">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="4ee8d-894">`BindingFlags.DeclaredOnly` eseguire la ricerca solo gli eventi dichiarati nel <xref:System.Type>, non gli eventi che sono stati semplicemente ereditati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-894">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="4ee8d-895">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-895">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="4ee8d-896">Un evento è considerato pubblico per la reflection se dispone di almeno un metodo o funzione di accesso pubblico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-896">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="4ee8d-897">In caso contrario, l'evento viene considerato privato ed è necessario usare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerla.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-897">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="4ee8d-898">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.EventInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-898">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-899">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cercherà gli eventi del vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-899">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-900">Il codice seguente viene illustrato come utilizzare il <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> per cercare un tipo di un evento pubblico o non pubblica denominato "Fare clic su" che non è `static` (`Shared` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-900">The following code example uses the <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> method to search a type for a public or non-public event named "Click" that is not `static` (`Shared` in Visual Basic).</span></span>  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-901">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-901">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-902">Ottiene gli eventi dichiarati o ereditati dall'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-902">Gets the events that are declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-903">Restituisce tutti gli eventi pubblici dichiarati o ereditati dall'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-903">Returns all the public events that are declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-904">Matrice di oggetti <see cref="T:System.Reflection.EventInfo" /> che rappresentano tutti gli eventi pubblici dichiarati o ereditati dall'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-904">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all the public events which are declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="4ee8d-905">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-905">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-906">Matrice vuota di tipo <see cref="T:System.Reflection.EventInfo" />, se per l'oggetto <see cref="T:System.Type" /> corrente non esistono eventi pubblici.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-906">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have public events.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-907">Un evento è considerato pubblico per la reflection se dispone di almeno un metodo o funzione di accesso pubblico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-907">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="4ee8d-908">In caso contrario, l'evento viene considerato privato ed è necessario usare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerla.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-908">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="4ee8d-909">Il <xref:System.Type.GetEvents%2A> metodo non restituisce gli eventi in un ordine specifico, ad esempio in ordine alfabetico o un ordine di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-909">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="4ee8d-910">Il codice non deve dipendere dall'ordine in cui vengono restituiti gli eventi, perché che varia in base di order.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-910">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="4ee8d-911">Questo metodo può essere sostituito da una classe derivata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-911">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="4ee8d-912">La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-912">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="4ee8d-913">Tipo di membro</span><span class="sxs-lookup"><span data-stu-id="4ee8d-913">Member Type</span></span>|<span data-ttu-id="4ee8d-914">Static</span><span class="sxs-lookup"><span data-stu-id="4ee8d-914">Static</span></span>|<span data-ttu-id="4ee8d-915">Non statici</span><span class="sxs-lookup"><span data-stu-id="4ee8d-915">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="4ee8d-916">Costruttore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-916">Constructor</span></span>|<span data-ttu-id="4ee8d-917">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-917">No</span></span>|<span data-ttu-id="4ee8d-918">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-918">No</span></span>|  
|<span data-ttu-id="4ee8d-919">Campo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-919">Field</span></span>|<span data-ttu-id="4ee8d-920">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-920">No</span></span>|<span data-ttu-id="4ee8d-921">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-921">Yes.</span></span> <span data-ttu-id="4ee8d-922">Un campo viene sempre hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-922">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-923">event</span><span class="sxs-lookup"><span data-stu-id="4ee8d-923">Event</span></span>|<span data-ttu-id="4ee8d-924">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-924">Not applicable</span></span>|<span data-ttu-id="4ee8d-925">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-925">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-926">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-926">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-927">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-927">See note 2 below.</span></span>|  
|<span data-ttu-id="4ee8d-928">Metodo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-928">Method</span></span>|<span data-ttu-id="4ee8d-929">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-929">No</span></span>|<span data-ttu-id="4ee8d-930">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-930">Yes.</span></span> <span data-ttu-id="4ee8d-931">Un metodo (virtuale e non virtuale) può essere hide-by-name o hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-931">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-932">Tipo annidato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-932">Nested Type</span></span>|<span data-ttu-id="4ee8d-933">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-933">No</span></span>|<span data-ttu-id="4ee8d-934">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-934">No</span></span>|  
|<span data-ttu-id="4ee8d-935">Proprietà</span><span class="sxs-lookup"><span data-stu-id="4ee8d-935">Property</span></span>|<span data-ttu-id="4ee8d-936">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-936">Not applicable</span></span>|<span data-ttu-id="4ee8d-937">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-937">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-938">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-938">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-939">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-939">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="4ee8d-940">Hide-by-name-e-signature prende in considerazione tutte le parti della firma, inclusi i modificatori personalizzati, i tipi restituiti, i tipi di parametri, elementi sentinel e le convenzioni di chiamata non gestite.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-940">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="4ee8d-941">Si tratta di un confronto binario.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-941">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="4ee8d-942">Per la reflection, proprietà ed eventi sono hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-942">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-943">Se si dispone di una proprietà con una richiesta get e una funzione di accesso set nella classe di base, ma la classe derivata ha solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter della classe base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-943">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="4ee8d-944">Gli attributi personalizzati non fanno parte di common type system.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-944">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="4ee8d-945">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.EventInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-945">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-946">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cercherà gli eventi del vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-946">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-947">L'esempio seguente ottiene una matrice di <xref:System.Reflection.EventInfo> gli oggetti, ottiene tutti gli eventi per un `Button` classe e visualizza i nomi degli eventi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-947">The following example obtains an array of <xref:System.Reflection.EventInfo> objects, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="4ee8d-948">Per compilare l'esempio di Visual Basic, usare la riga di comando seguente:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-948">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-949">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-949">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-950">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-950">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-951">Zero, per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-951">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-952">Quando ne viene eseguito l'override in una classe derivata, cerca gli eventi dichiarati o ereditati dall'oggetto <see cref="T:System.Type" /> corrente, usando i vincoli di binding specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-952">When overridden in a derived class, searches for events that are declared or inherited by the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-953">Matrice di oggetti <see cref="T:System.Reflection.EventInfo" /> che rappresentano tutti gli eventi dichiarati o ereditati dalla classe <see cref="T:System.Type" /> corrente e che corrispondono ai vincoli di binding specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-953">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all events that are declared or inherited by the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="4ee8d-954">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-954">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-955">Matrice vuota di tipo <see cref="T:System.Reflection.EventInfo" />, se l'oggetto <see cref="T:System.Type" /> corrente non dispone di eventi oppure se nessuno degli eventi corrisponde ai vincoli di binding.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-955">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have events, or if none of the events match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-956">Il <xref:System.Type.GetEvents%2A> metodo non restituisce gli eventi in un ordine specifico, ad esempio in ordine alfabetico o un ordine di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-956">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="4ee8d-957">Il codice non deve dipendere dall'ordine in cui vengono restituiti gli eventi, perché che varia in base di order.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-957">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="4ee8d-958">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire gli eventi da includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-958">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-959">È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-959">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-960">Specificare `BindingFlags.Public` per includere gli eventi pubblici nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-960">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-961">Specificare `BindingFlags.NonPublic` da includere non pubblica gli eventi (vale a dire, privati, interni e protetto) nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-961">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span> <span data-ttu-id="4ee8d-962">Solo protetti e vengono restituiti gli eventi interni sulle classi di base; eventi privati in classi di base non vengono restituiti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-962">Only protected and internal events on base classes are returned; private events on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="4ee8d-963">Specificare `BindingFlags.FlattenHierarchy` da includere `public` e `protected` membri statici nella gerarchia; `private` non sono inclusi i membri statici nelle classi ereditate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-963">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="4ee8d-964">Nell'esempio <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare il comportamento della ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-964">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="4ee8d-965">`BindingFlags.DeclaredOnly` eseguire la ricerca solo gli eventi dichiarati nel <xref:System.Type>, non gli eventi che sono stati semplicemente ereditati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-965">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="4ee8d-966">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-966">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="4ee8d-967">Un evento è considerato pubblico per la reflection se dispone di almeno un metodo o funzione di accesso pubblico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-967">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="4ee8d-968">In caso contrario, l'evento viene considerato privato ed è necessario usare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerla.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-968">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="4ee8d-969">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.EventInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-969">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-970">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cercherà gli eventi del vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-970">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-971">L'esempio seguente ottiene una matrice di <xref:System.Reflection.EventInfo> gli oggetti che corrispondono ai flag di binding specificati, ottiene tutti gli eventi per un `Button` classe e visualizza i nomi degli eventi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-971">The following example obtains an array of <xref:System.Reflection.EventInfo> objects that match the specified binding flags, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="4ee8d-972">Per compilare l'esempio di Visual Basic, usare la riga di comando seguente:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-972">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-973">Ottiene un campo specifico dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-973">Gets a specific field of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-974">Stringa che contiene il nome del campo dati da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-974">The string containing the name of the data field to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-975">Cerca il campo pubblico con il nome specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-975">Searches for the public field with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-976">Oggetto che rappresenta il campo pubblico con il nome specificato, se disponibile; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-976">An object representing the public field with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-977">La ricerca di `name` tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-977">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="4ee8d-978">La ricerca include i campi di istanza pubblici statici e pubblici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-978">The search includes public static and public instance fields.</span></span>  
  
 <span data-ttu-id="4ee8d-979">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.FieldInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-979">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-980">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cercherà i campi del vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-980">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-981">L'esempio seguente ottiene i `Type` dell'oggetto per la classe specificata, ottiene il <xref:System.Reflection.FieldInfo> oggetto per il campo e viene visualizzato il valore del campo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-981">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-982">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-982">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="4ee8d-983">Questo oggetto <see cref="T:System.Type" /> è un oggetto <see cref="T:System.Reflection.Emit.TypeBuilder" /> il cui metodo <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> non è stato ancora chiamato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-983">This <see cref="T:System.Type" /> object is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> whose <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method has not yet been called.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-984">Stringa che contiene il nome del campo dati da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-984">The string containing the name of the data field to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-985">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-985">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-986">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-986">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-987">Zero, per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-987">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-988">Cerca il campo specificato, usando i vincoli di associazione specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-988">Searches for the specified field, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-989">Oggetto che rappresenta il campo corrispondente ai requisiti specificati, se è stato trovato; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-989">An object representing the field that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-990">La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-990">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="4ee8d-991">Tipo di membro</span><span class="sxs-lookup"><span data-stu-id="4ee8d-991">Member Type</span></span>|<span data-ttu-id="4ee8d-992">Static</span><span class="sxs-lookup"><span data-stu-id="4ee8d-992">Static</span></span>|<span data-ttu-id="4ee8d-993">Non statici</span><span class="sxs-lookup"><span data-stu-id="4ee8d-993">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="4ee8d-994">Costruttore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-994">Constructor</span></span>|<span data-ttu-id="4ee8d-995">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-995">No</span></span>|<span data-ttu-id="4ee8d-996">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-996">No</span></span>|  
|<span data-ttu-id="4ee8d-997">Campo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-997">Field</span></span>|<span data-ttu-id="4ee8d-998">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-998">No</span></span>|<span data-ttu-id="4ee8d-999">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-999">Yes.</span></span> <span data-ttu-id="4ee8d-1000">Un campo viene sempre hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1000">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-1001">event</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1001">Event</span></span>|<span data-ttu-id="4ee8d-1002">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1002">Not applicable</span></span>|<span data-ttu-id="4ee8d-1003">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1003">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-1004">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1004">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1005">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1005">See note 2 below.</span></span>|  
|<span data-ttu-id="4ee8d-1006">Metodo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1006">Method</span></span>|<span data-ttu-id="4ee8d-1007">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1007">No</span></span>|<span data-ttu-id="4ee8d-1008">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1008">Yes.</span></span> <span data-ttu-id="4ee8d-1009">Un metodo (virtuale e non virtuale) può essere hide-by-name o hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1009">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-1010">Tipo annidato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1010">Nested Type</span></span>|<span data-ttu-id="4ee8d-1011">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1011">No</span></span>|<span data-ttu-id="4ee8d-1012">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1012">No</span></span>|  
|<span data-ttu-id="4ee8d-1013">Proprietà</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1013">Property</span></span>|<span data-ttu-id="4ee8d-1014">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1014">Not applicable</span></span>|<span data-ttu-id="4ee8d-1015">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1015">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-1016">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1016">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1017">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1017">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="4ee8d-1018">Hide-by-name-e-signature prende in considerazione tutte le parti della firma, inclusi i modificatori personalizzati, i tipi restituiti, i tipi di parametri, elementi sentinel e le convenzioni di chiamata non gestite.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1018">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="4ee8d-1019">Si tratta di un confronto binario.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1019">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="4ee8d-1020">Per la reflection, proprietà ed eventi sono hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1020">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1021">Se si dispone di una proprietà con una richiesta get e una funzione di accesso set nella classe di base, ma la classe derivata ha solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter della classe base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1021">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="4ee8d-1022">Gli attributi personalizzati non fanno parte di common type system.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1022">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="4ee8d-1023">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire i campi da includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1023">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-1024">È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1024">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-1025">Specificare `BindingFlags.Public` per includere i campi pubblici nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1025">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1026">Specificare `BindingFlags.NonPublic` da includere campi non pubblici (vale a dire, i campi privati, interni e protetti) nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1026">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1027">Specificare `BindingFlags.FlattenHierarchy` da includere `public` e `protected` membri statici nella gerarchia; `private` non sono inclusi i membri statici nelle classi ereditate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1027">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="4ee8d-1028">Nell'esempio <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare il comportamento della ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1028">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="4ee8d-1029">`BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1029">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="4ee8d-1030">`BindingFlags.DeclaredOnly` Per cercare solo i campi dichiarati nel <xref:System.Type>, non da campi quelli ereditati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1030">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
 <span data-ttu-id="4ee8d-1031">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1031">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="4ee8d-1032">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.FieldInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1032">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1033">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cercherà i campi del vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1033">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1034">L'esempio seguente ottiene i `Type` dell'oggetto per la classe specificata, ottiene il <xref:System.Reflection.FieldInfo> oggetto per il campo che corrisponde al flag di associazione specificati e viene visualizzato il valore del campo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1034">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field that matches the specified binding flags, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-1035">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1035">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-1036">Ottiene i campi dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1036">Gets the fields of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-1037">Restituisce tutti i campi pubblici dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1037">Returns all the public fields of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1038">Matrice di oggetti <see cref="T:System.Reflection.FieldInfo" /> che rappresentano tutti i campi pubblici definiti per l'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1038">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all the public fields defined for the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="4ee8d-1039">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1039">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1040">Matrice vuota di tipo <see cref="T:System.Reflection.FieldInfo" />, se non è definito alcun campo pubblico per l'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1040">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no public fields are defined for the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1041">Il <xref:System.Type.GetFields%2A> metodo non restituisce i campi in un ordine specifico, ad esempio in ordine alfabetico o un ordine di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1041">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="4ee8d-1042">Il codice non deve dipendere dall'ordine in cui vengono restituiti i campi, perché che varia in base di order.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1042">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="4ee8d-1043">La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1043">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="4ee8d-1044">Tipo di membro</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1044">Member Type</span></span>|<span data-ttu-id="4ee8d-1045">Static</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1045">Static</span></span>|<span data-ttu-id="4ee8d-1046">Non statici</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1046">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="4ee8d-1047">Costruttore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1047">Constructor</span></span>|<span data-ttu-id="4ee8d-1048">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1048">No</span></span>|<span data-ttu-id="4ee8d-1049">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1049">No</span></span>|  
|<span data-ttu-id="4ee8d-1050">Campo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1050">Field</span></span>|<span data-ttu-id="4ee8d-1051">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1051">No</span></span>|<span data-ttu-id="4ee8d-1052">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1052">Yes.</span></span> <span data-ttu-id="4ee8d-1053">Un campo viene sempre hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1053">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-1054">event</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1054">Event</span></span>|<span data-ttu-id="4ee8d-1055">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1055">Not applicable</span></span>|<span data-ttu-id="4ee8d-1056">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1056">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-1057">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1057">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1058">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1058">See note 2 below.</span></span>|  
|<span data-ttu-id="4ee8d-1059">Metodo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1059">Method</span></span>|<span data-ttu-id="4ee8d-1060">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1060">No</span></span>|<span data-ttu-id="4ee8d-1061">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1061">Yes.</span></span> <span data-ttu-id="4ee8d-1062">Un metodo (virtuale e non virtuale) può essere hide-by-name o hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1062">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-1063">Tipo annidato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1063">Nested Type</span></span>|<span data-ttu-id="4ee8d-1064">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1064">No</span></span>|<span data-ttu-id="4ee8d-1065">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1065">No</span></span>|  
|<span data-ttu-id="4ee8d-1066">Proprietà</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1066">Property</span></span>|<span data-ttu-id="4ee8d-1067">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1067">Not applicable</span></span>|<span data-ttu-id="4ee8d-1068">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1068">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-1069">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1069">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1070">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1070">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="4ee8d-1071">Hide-by-name-e-signature prende in considerazione tutte le parti della firma, inclusi i modificatori personalizzati, i tipi restituiti, i tipi di parametri, elementi sentinel e le convenzioni di chiamata non gestite.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1071">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="4ee8d-1072">Si tratta di un confronto binario.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1072">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="4ee8d-1073">Per la reflection, proprietà ed eventi sono hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1073">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1074">Se si dispone di una proprietà con una richiesta get e una funzione di accesso set nella classe di base, ma la classe derivata ha solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter della classe base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1074">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="4ee8d-1075">Gli attributi personalizzati non fanno parte di common type system.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1075">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="4ee8d-1076">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.FieldInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1076">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1077">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cercherà i campi pubblici del vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1077">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1078">L'esempio seguente illustra un uso di `GetFields()` (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1078">The following example shows a use of the `GetFields()` method.</span></span>  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-1079">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1079">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-1080">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1080">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1081">Zero, per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1081">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1082">Quando ne viene eseguito l'override in una classe derivata, cerca i campi definiti per l'oggetto <see cref="T:System.Type" /> corrente, usando i vincoli di binding specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1082">When overridden in a derived class, searches for the fields defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1083">Matrice di oggetti <see cref="T:System.Reflection.FieldInfo" /> che rappresentano tutti i campi definiti per l'oggetto <see cref="T:System.Type" /> corrente corrispondente ai vincoli di binding specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1083">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all fields defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="4ee8d-1084">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1084">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1085">Matrice vuota di tipo <see cref="T:System.Reflection.FieldInfo" />, se non è definito alcun campo per l'oggetto <see cref="T:System.Type" /> corrente oppure se nessuno dei campi definiti corrisponde ai vincoli di binding.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1085">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no fields are defined for the current <see cref="T:System.Type" />, or if none of the defined fields match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1086">Il <xref:System.Type.GetFields%2A> metodo non restituisce i campi in un ordine specifico, ad esempio in ordine alfabetico o un ordine di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1086">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="4ee8d-1087">Il codice non deve dipendere dall'ordine in cui vengono restituiti i campi, perché che varia in base di order.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1087">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="4ee8d-1088">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire i campi da includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1088">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-1089">È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1089">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-1090">Specificare `BindingFlags.Public` per includere i campi pubblici nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1090">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1091">Specificare `BindingFlags.NonPublic` da includere campi non pubblici (vale a dire, i campi privati, interni e protetti) nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1091">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span> <span data-ttu-id="4ee8d-1092">Solo protetti e vengono restituiti i campi interni sulle classi di base; i campi privati delle classi di base non vengono restituiti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1092">Only protected and internal fields on base classes are returned; private fields on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="4ee8d-1093">Specificare `BindingFlags.FlattenHierarchy` da includere `public` e `protected` membri statici nella gerarchia; `private` non sono inclusi i membri statici nelle classi ereditate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1093">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="4ee8d-1094">Nell'esempio <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare il comportamento della ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1094">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="4ee8d-1095">`BindingFlags.DeclaredOnly` Per cercare solo i campi dichiarati nel <xref:System.Type>, non da campi quelli ereditati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1095">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
 <span data-ttu-id="4ee8d-1096">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1096">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="4ee8d-1097">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.FieldInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1097">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1098">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cercherà i campi pubblici del vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1098">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1099">L'esempio seguente illustra un uso di `GetFields(BindingFlags)` (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1099">The following example shows a use of the `GetFields(BindingFlags)` method.</span></span>  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-1100">Restituisce una matrice di oggetti <see cref="T:System.Type" /> che rappresentano gli argomenti di tipo di un tipo generico chiuso o i parametri di tipo di una definizione di tipo generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1100">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1101">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano gli argomenti di tipo di un tipo generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1101">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic type.</span>
          </span>
          <span data-ttu-id="4ee8d-1102">Restituisce una matrice vuota se il tipo corrente non è un tipo generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1102">Returns an empty array if the current type is not a generic type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1103">Gli elementi della matrice vengono restituiti nell'ordine in cui vengono visualizzati nell'elenco di argomenti tipo per il tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1103">The array elements are returned in the order in which they appear in the list of type arguments for the generic type.</span></span>  
  
-   <span data-ttu-id="4ee8d-1104">Se il tipo corrente è un tipo costruito chiuso (vale a dire il <xref:System.Type.ContainsGenericParameters%2A> proprietà restituisce `false`), la matrice restituita dal <xref:System.Type.GetGenericArguments%2A> metodo contiene i tipi che sono stati assegnati ai parametri di tipo generico della definizione del tipo generico .</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1104">If the current type is a closed constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Type.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic type definition.</span></span>  
  
-   <span data-ttu-id="4ee8d-1105">Se il tipo corrente è una definizione di tipo generico, la matrice contiene i parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1105">If the current type is a generic type definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="4ee8d-1106">Se il tipo corrente è un tipo costruito aperto (vale a dire il <xref:System.Type.ContainsGenericParameters%2A> restituisce proprietà `true`) in tipi specifici non sono stati assegnati a tutti i parametri di tipo e i parametri di tipo di inclusione tipi o metodi generici, contiene la matrice tipi e i parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1106">If the current type is an open constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters.</span></span> <span data-ttu-id="4ee8d-1107">Usare il <xref:System.Type.IsGenericParameter%2A> proprietà per distinguerli.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1107">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="4ee8d-1108">Per una dimostrazione di questo scenario, vedere l'esempio di codice per il <xref:System.Type.ContainsGenericParameters%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1108">For a demonstration of this scenario, see the code example for the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="4ee8d-1109">Per un elenco delle condizioni invariabili relative ai termini usati dal processo di reflection generico, vedere i commenti sulla proprietà <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1109">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1110">Il codice seguente viene illustrato come utilizzare il <xref:System.Type.GetGenericArguments%2A> metodo per visualizzare gli argomenti di tipo di un tipo costruito e i parametri di tipo della relativa definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1110">The following code example uses the <xref:System.Type.GetGenericArguments%2A> method to display the type arguments of a constructed type and the type parameters of its generic type definition.</span></span>  
  
 <span data-ttu-id="4ee8d-1111">Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Type.IsGenericTypeDefinition%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1111">This code example is part of a larger example provided for the <xref:System.Type.IsGenericTypeDefinition%2A> property.</span></span> <span data-ttu-id="4ee8d-1112">Vedere l'esempio più esaustivo per l'output di esempio.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1112">See the larger example for sample output.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="4ee8d-1113">Il metodo richiamato non è supportato nella classe base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1113">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="4ee8d-1114">Le classi derivate devono fornire un'implementazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1114">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="4ee8d-1115">Reflection e tipi generici</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1115">Reflection and Generic Types</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="4ee8d-1116">Procedura: esaminare e creare istanze di tipi generici tramite reflection</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1116">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-1117">Restituisce una matrice di oggetti <see cref="T:System.Type" /> che rappresentano i vincoli sul parametro di tipo generico corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1117">Returns an array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1118">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano i vincoli sul parametro di tipo generico corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1118">An array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1119">Ogni vincolo su un parametro di tipo generico è espressa come un <xref:System.Type> oggetto.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1119">Each constraint on a generic type parameter is expressed as a <xref:System.Type> object.</span></span> <span data-ttu-id="4ee8d-1120">Usare la <xref:System.Type.IsClass%2A> proprietà per determinare se un vincolo è il vincolo di classe di base; se la proprietà restituisce `false`, il vincolo è un vincolo di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1120">Use the <xref:System.Type.IsClass%2A> property to determine whether a constraint is the base class constraint; if the property returns `false`, the constraint is an interface constraint.</span></span> <span data-ttu-id="4ee8d-1121">Se dispone di un parametro di tipo senza vincoli di classe e senza vincoli di interfaccia, viene restituita una matrice vuota.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1121">If a type parameter has no class constraint and no interface constraints, an empty array is returned.</span></span>  
  
 <span data-ttu-id="4ee8d-1122">Per un elenco delle condizioni invariabili relative ai termini usati dal processo di reflection generico, vedere i commenti sulla proprietà <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1122">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1123">Esempio di codice seguente definisce un tipo generico `Test` con due parametri di tipo con vincoli diversi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1123">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="4ee8d-1124">Quando viene eseguito il programma, i vincoli vengono esaminati tramite il <xref:System.Type.GenericParameterAttributes%2A> proprietà e il <xref:System.Type.GetGenericParameterConstraints%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1124">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4ee8d-1125">L'oggetto <see cref="T:System.Type" /> corrente non è un parametro di tipo generico,</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1125">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span>
          </span>
          <span data-ttu-id="4ee8d-1126">Quindi la proprietà <see cref="P:System.Type.IsGenericParameter" /> restituisce <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1126">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="4ee8d-1127">Procedura: esaminare e creare istanze di tipi generici tramite reflection</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1127">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-1128">Restituisce un oggetto <see cref="T:System.Type" /> che rappresenta una definizione di tipo generico da cui è possibile costruire il tipo generico corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1128">Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current generic type can be constructed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1129">Oggetto <see cref="T:System.Type" /> che rappresenta un tipo generico da cui è possibile costruire il tipo corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1129">A <see cref="T:System.Type" /> object representing a generic type from which the current type can be constructed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1130">Una definizione di tipo generico è un modello da cui è possibile costruire altri tipi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1130">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="4ee8d-1131">Ad esempio, dalla definizione di tipo generico `G<T>` (espressi nella sintassi c#; `G(Of T)` in Visual Basic o `generic <typename T> ref class G` in C++) è possibile costruire e creare un'istanza di tipo `G<int>` (`G(Of Integer)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1131">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic).</span></span> <span data-ttu-id="4ee8d-1132">Dato un <xref:System.Type> oggetto che rappresenta questo tipo, costruito il <xref:System.Type.GetGenericTypeDefinition%2A> metodo restituisce la definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1132">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the generic type definition.</span></span>  
  
 <span data-ttu-id="4ee8d-1133">Se vengono creati due tipi costruiti dalla stessa definizione di tipo generico, con gli stessi argomenti di tipo, il <xref:System.Type.GetGenericTypeDefinition%2A> metodo viene restituito lo stesso <xref:System.Type> per entrambi i tipi di oggetto.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1133">If two constructed types are created from the same generic type definition, using the same type arguments, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the same <xref:System.Type> object for both types.</span></span>  
  
 <span data-ttu-id="4ee8d-1134">Se si chiama il <xref:System.Type.GetGenericTypeDefinition%2A> metodo su un <xref:System.Type> oggetto che rappresenta già una definizione di tipo generico, restituisce l'attuale <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1134">If you call the <xref:System.Type.GetGenericTypeDefinition%2A> method on a <xref:System.Type> object that already represents a generic type definition, it returns the current <xref:System.Type>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4ee8d-1135">Una matrice di tipi generici non è a sua volta generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1135">An array of generic types is not itself generic.</span></span> <span data-ttu-id="4ee8d-1136">Nel codice c# `A<int>[] v;` o il codice Visual Basic `Dim v() As A(Of Integer)`, il tipo di variabile `v` non generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1136">In the C# code `A<int>[] v;` or the Visual Basic code `Dim v() As A(Of Integer)`, the type of variable `v` is not generic.</span></span> <span data-ttu-id="4ee8d-1137">Uso <xref:System.Type.IsGenericType%2A> per determinare se un tipo è generico prima di chiamare <xref:System.Type.GetGenericTypeDefinition%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1137">Use <xref:System.Type.IsGenericType%2A> to determine whether a type is generic before calling <xref:System.Type.GetGenericTypeDefinition%2A>.</span></span>  
  
 <span data-ttu-id="4ee8d-1138">Per un elenco delle condizioni invariabili relative ai termini usati dal processo di reflection generico, vedere i commenti sulla proprietà <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1138">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1139">Esempio di codice seguente crea un'istanza di un tipo costruito utilizzando la creazione di istanza comune e quindi Usa il <xref:System.Type.GetType%2A> e <xref:System.Type.GetGenericTypeDefinition%2A> metodi per recuperare il tipo costruito e la definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1139">The following code example creates an instance of a constructed type by using ordinary instance creation and then uses the <xref:System.Type.GetType%2A> and <xref:System.Type.GetGenericTypeDefinition%2A> methods to retrieve the constructed type and the generic type definition.</span></span> <span data-ttu-id="4ee8d-1140">Questo esempio viene usato il tipo generico <xref:System.Collections.Generic.Dictionary%602> tipo; rappresenta il tipo costruito un <xref:System.Collections.Generic.Dictionary%602> di `Test` oggetti con chiavi di stringa.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1140">This example uses the generic <xref:System.Collections.Generic.Dictionary%602> type; the constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4ee8d-1141">Il tipo corrente non è generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1141">The current type is not a generic type.</span>
          </span>
          <span data-ttu-id="4ee8d-1142">Ciò significa che <see cref="P:System.Type.IsGenericType" /> restituisce <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1142">That is, <see cref="P:System.Type.IsGenericType" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="4ee8d-1143">Il metodo richiamato non è supportato nella classe base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1143">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="4ee8d-1144">Le classi derivate devono fornire un'implementazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1144">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="4ee8d-1145">Reflection e tipi generici</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1145">Reflection and Generic Types</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="4ee8d-1146">Procedura: esaminare e creare istanze di tipi generici tramite reflection</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1146">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-1147">Restituisce il codice hash per l'istanza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1147">Returns the hash code for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1148">Codice hash per l'istanza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1148">The hash code for this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1149">Questo metodo esegue l'override del metodo <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1149">This method overrides <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1150">L'esempio seguente mostra il codice hash del `System.Windows.Forms.Button` classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1150">The following example displays the hash code of the `System.Windows.Forms.Button` class.</span></span>  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-1151">Ottiene un'interfaccia specifica implementata o ereditata dall'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1151">Gets a specific interface implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-1152">Stringa che contiene il nome dell'interfaccia da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1152">The string containing the name of the interface to get.</span>
          </span>
          <span data-ttu-id="4ee8d-1153">Per le interfacce generiche, si tratta del nome alterato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1153">For generic interfaces, this is the mangled name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1154">Cerca l'interfaccia con il nome specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1154">Searches for the interface with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1155">Oggetto che rappresenta l'interfaccia con il nome specificato, implementata o ereditata dall'oggetto <see cref="T:System.Type" /> corrente, se presente; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1155">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1156">La ricerca di `name` tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1156">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="4ee8d-1157">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Type> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1157">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1158">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o metodo generico, questo metodo vengono cercati i vincoli di interfaccia e tutte le interfacce ereditate dai vincoli di classe o interfaccia.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1158">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1159">Per le interfacce generiche, la `name` parametro è il nome modificato, che termina con un accento grave (\`) e il numero di parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1159">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="4ee8d-1160">Questo vale per le definizioni di interfaccia generica e interfacce generiche costruite.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1160">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="4ee8d-1161">Ad esempio, per trovare `IExample<T>` (`IExample(Of T)` in Visual Basic) o `IExample<string>` (`IExample(Of String)` in Visual Basic), cercare ``"IExample`1"``.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1161">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for ``"IExample`1"``.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1162">Il codice seguente viene illustrato come utilizzare il <xref:System.Type.GetInterface%28System.String%29> per cercare la <xref:System.Collections.Hashtable> classe per il <xref:System.Runtime.Serialization.IDeserializationCallback> interfaccia ed elenca i metodi dell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1162">The following code example uses the <xref:System.Type.GetInterface%28System.String%29> method to search the <xref:System.Collections.Hashtable> class for the <xref:System.Runtime.Serialization.IDeserializationCallback> interface, and lists the methods of the interface.</span></span>  
  
 <span data-ttu-id="4ee8d-1163">L'esempio di codice dimostra anche il <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> overload del metodo e il <xref:System.Type.GetInterfaceMap%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1163">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-1164">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1164">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="4ee8d-1165">L'oggetto <see cref="T:System.Type" /> corrente rappresenta un tipo che implementa la stessa interfaccia generica con argomenti di tipo differenti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1165">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-1166">Stringa che contiene il nome dell'interfaccia da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1166">The string containing the name of the interface to get.</span>
          </span>
          <span data-ttu-id="4ee8d-1167">Per le interfacce generiche, si tratta del nome alterato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1167">For generic interfaces, this is the mangled name.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="4ee8d-1168">
            <see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole nella parte di <c> name</c> che specifica il nome semplice dell'interfaccia. Nella parte in cui viene specificato lo spazio dei nomi è necessario fare distinzione tra maiuscole e minuscole.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1168">
              <see langword="true" /> to ignore the case of that part of <c>name</c> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).</span>
          </span>
          <span data-ttu-id="4ee8d-1169">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1169">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1170">
            <see langword="false" /> per eseguire una ricerca di tutte le parti di <c>name</c> facendo distinzione tra maiuscole e minuscole.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1170">
              <see langword="false" /> to perform a case-sensitive search for all parts of <c>name</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1171">Quando è sottoposto a override in una classe derivata, cerca l'interfaccia specificata, indicando se la ricerca del nome dell'interfaccia viene eseguita senza fare distinzione tra maiuscole e minuscole.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1171">When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1172">Oggetto che rappresenta l'interfaccia con il nome specificato, implementata o ereditata dall'oggetto <see cref="T:System.Type" /> corrente, se presente; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1172">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1173">Il `ignoreCase` parametro si applica solo al nome semplice dell'interfaccia, non allo spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1173">The `ignoreCase` parameter applies only to the simple interface name, not to the namespace.</span></span> <span data-ttu-id="4ee8d-1174">La parte di `name` che specifica lo spazio dei nomi deve avere formato caratteri corretto o l'interfaccia non verrà trovato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1174">The portion of `name` that specifies the namespace must have the correct case, or the interface will not be found.</span></span> <span data-ttu-id="4ee8d-1175">Ad esempio, la stringa "System. IComparable" trova il <xref:System.IComparable> interfaccia, ma la stringa "System. IComparable" non esiste.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1175">For example, the string "System.icomparable" finds the <xref:System.IComparable> interface, but the string "system.icomparable" does not.</span></span>  
  
 <span data-ttu-id="4ee8d-1176">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Type> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1176">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1177">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o metodo generico, questo metodo vengono cercati i vincoli di interfaccia e tutte le interfacce ereditate dai vincoli di classe o interfaccia.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1177">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1178">Per le interfacce generiche, la `name` parametro è il nome modificato, che termina con un accento grave (\`) e il numero di parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1178">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="4ee8d-1179">Questo vale per le definizioni di interfaccia generica e interfacce generiche costruite.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1179">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="4ee8d-1180">Ad esempio, per trovare `IExample<T>` (`IExample(Of T)` in Visual Basic) o `IExample<string>` (`IExample(Of String)` in Visual Basic), cercare `"IExample`1"'.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1180">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for `"IExample`1"\`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1181">Il codice seguente viene illustrato come utilizzare il <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> metodo per eseguire una ricerca tra maiuscole e minuscole del <xref:System.Collections.Hashtable> classe per il <xref:System.Collections.IEnumerable> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1181">The following code example uses the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method to perform a case-insensitive search of the <xref:System.Collections.Hashtable> class for the <xref:System.Collections.IEnumerable> interface.</span></span>  
  
 <span data-ttu-id="4ee8d-1182">L'esempio di codice dimostra anche il <xref:System.Type.GetInterface%28System.String%29> overload del metodo e il <xref:System.Type.GetInterfaceMap%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1182">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-1183">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1183">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="4ee8d-1184">L'oggetto <see cref="T:System.Type" /> corrente rappresenta un tipo che implementa la stessa interfaccia generica con argomenti di tipo differenti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1184">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">
          <span data-ttu-id="4ee8d-1185">Tipo dell'interfaccia per cui recuperare un mapping.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1185">The interface type to retrieve a mapping for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1186">Restituisce un mapping di interfaccia per il tipo di interfaccia specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1186">Returns an interface mapping for the specified interface type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1187">Oggetto che rappresenta il mapping dell'interfaccia per il parametro <paramref name="interfaceType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1187">An object that represents the interface mapping for <paramref name="interfaceType" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1188">La mappa dell'interfaccia indica la modalità di mapping di un'interfaccia ai membri effettivi in una classe che implementa tale interfaccia.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1188">The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.</span></span>  
  
 <span data-ttu-id="4ee8d-1189">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, i parametri vengono sostituiti dagli argomenti di tipo appropriato negli elementi del tipo di <xref:System.Reflection.InterfaceMapping> restituito da questo metodo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1189">If the current <xref:System.Type> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <xref:System.Reflection.InterfaceMapping> returned by this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1190">L'esempio seguente chiama il <xref:System.Type.GetInterfaceMap%2A> metodo per determinare come il <xref:System.IFormatProvider> esegue il mapping dell'interfaccia a <xref:System.Globalization.CultureInfo> metodi e il comportamento della <xref:System.IAppDomainSetup> esegue il mapping dell'interfaccia a <xref:System.AppDomainSetup> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1190">The following example calls the <xref:System.Type.GetInterfaceMap%2A> method to determine how the <xref:System.IFormatProvider> interface maps to <xref:System.Globalization.CultureInfo> methods, and how the <xref:System.IAppDomainSetup> interface maps to <xref:System.AppDomainSetup> properties.</span></span> <span data-ttu-id="4ee8d-1191">Si noti che, in quanto il <xref:System.IAppDomainSetup> interfaccia definisce un set di proprietà, l'oggetto restituito <xref:System.Reflection.InterfaceMapping> oggetto include separato <xref:System.Reflection.MethodInfo> oggetti per get una proprietà e set di funzioni di accesso.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1191">Note that, because the <xref:System.IAppDomainSetup> interface defines a set of properties, the returned <xref:System.Reflection.InterfaceMapping> object includes separate <xref:System.Reflection.MethodInfo> objects for a property's get and set accessors.</span></span>  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-1192">
            <paramref name="interfaceType" /> non è implementato dal tipo corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1192">
              <paramref name="interfaceType" /> is not implemented by the current type.</span>
          </span>
          <span data-ttu-id="4ee8d-1193">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1193">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1194">Il parametro <paramref name="interfaceType" /> non contiene riferimenti a un'interfaccia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1194">The <paramref name="interfaceType" /> parameter does not refer to an interface.</span>
          </span>
          <span data-ttu-id="4ee8d-1195">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1195">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1196">
            <paramref name="interfaceType" /> è un'interfaccia generica e il tipo corrente è un tipo di matrice.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1196">
              <paramref name="interfaceType" /> is a generic interface, and the current type is an array type.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-1197">
            <paramref name="interfaceType" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1197">
              <paramref name="interfaceType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4ee8d-1198">L'oggetto <see cref="T:System.Type" /> corrente rappresenta un parametro di tipo generico; ovvero la proprietà <see cref="P:System.Type.IsGenericParameter" /> è <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1198">The current <see cref="T:System.Type" /> represents a generic type parameter; that is, <see cref="P:System.Type.IsGenericParameter" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="4ee8d-1199">Il metodo richiamato non è supportato nella classe base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1199">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="4ee8d-1200">Le classi derivate devono fornire un'implementazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1200">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-1201">Quando ne viene eseguito l'override in una classe derivata, ottiene tutte le interfacce implementate o ereditate dall'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1201">When overridden in a derived class, gets all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1202">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano tutte le interfacce implementate o ereditate dall'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1202">An array of <see cref="T:System.Type" /> objects representing all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="4ee8d-1203">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1203">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1204">Matrice vuota di tipo <see cref="T:System.Type" />, se non vengono implementate o ereditate interfacce dall'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1204">An empty array of type <see cref="T:System.Type" />, if no interfaces are implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1205">Il <xref:System.Type.GetInterfaces%2A> metodo non restituisce le interfacce in un ordine specifico, ad esempio in ordine alfabetico o un ordine di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1205">The <xref:System.Type.GetInterfaces%2A> method does not return interfaces in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="4ee8d-1206">Il codice non deve dipendere dall'ordine in cui vengono restituite le interfacce, perché che varia in base di order.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1206">Your code must not depend on the order in which interfaces are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="4ee8d-1207">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Type> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1207">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1208">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o metodo generico, questo metodo vengono cercati i vincoli di interfaccia e tutte le interfacce ereditate dai vincoli di classe o interfaccia.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1208">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1209">Nell'esempio seguente ottiene il tipo della classe specificata e consente di visualizzare tutte le interfacce che il tipo implementa o eredita.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1209">The following example gets the type of the specified class and displays all the interfaces that the type implements or inherits.</span></span> <span data-ttu-id="4ee8d-1210">Per compilare l'esempio di Visual Basic, usare i comandi del compilatore seguenti:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1210">To compile the Visual Basic example, use the following compiler commands:</span></span>  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="4ee8d-1211">Un inizializzatore statico viene richiamato e genera un'eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1211">A static initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-1212">Ottiene i membri specificati dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1212">Gets the specified members of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-1213">Stringa che contiene il nome dei membri pubblici da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1213">The string containing the name of the public members to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1214">Cerca i membri pubblici con il nome specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1214">Searches for the public members with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1215">Matrice di oggetti <see cref="T:System.Reflection.MemberInfo" /> che rappresentano i membri pubblici con il nome specificato, se presenti; in caso contrario, matrice vuota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1215">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1216">La ricerca di `name` tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1216">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="4ee8d-1217">La ricerca include i membri di istanza pubblici statici e pubblici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1217">The search includes public static and public instance members.</span></span>  
  
 <span data-ttu-id="4ee8d-1218">I membri includono proprietà, metodi, campi, eventi e così via.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1218">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="4ee8d-1219">Il <xref:System.Type.GetMember%2A> metodo non restituisce i membri in un ordine specifico, ad esempio in ordine alfabetico o un ordine di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1219">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="4ee8d-1220">Il codice non deve dipendere dall'ordine in cui vengono restituiti i membri, perché che varia in base di order.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1220">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="4ee8d-1221">Questo overload del metodo non sarà possibile trovare gli inizializzatori di classi (. cctor).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1221">This method overload will not find class initializers (.cctor).</span></span> <span data-ttu-id="4ee8d-1222">Per trovare gli inizializzatori di classi, usare un overload che accetta <xref:System.Reflection.BindingFlags>e specificare <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1222">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="4ee8d-1223">È anche possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1223">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="4ee8d-1224">La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1224">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="4ee8d-1225">Tipo di membro</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1225">Member Type</span></span>|<span data-ttu-id="4ee8d-1226">Static</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1226">Static</span></span>|<span data-ttu-id="4ee8d-1227">Non statici</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1227">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="4ee8d-1228">Costruttore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1228">Constructor</span></span>|<span data-ttu-id="4ee8d-1229">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1229">No</span></span>|<span data-ttu-id="4ee8d-1230">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1230">No</span></span>|  
|<span data-ttu-id="4ee8d-1231">Campo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1231">Field</span></span>|<span data-ttu-id="4ee8d-1232">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1232">No</span></span>|<span data-ttu-id="4ee8d-1233">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1233">Yes.</span></span> <span data-ttu-id="4ee8d-1234">Un campo viene sempre hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1234">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-1235">event</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1235">Event</span></span>|<span data-ttu-id="4ee8d-1236">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1236">Not applicable</span></span>|<span data-ttu-id="4ee8d-1237">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1237">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-1238">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1238">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1239">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1239">See note 2 below.</span></span>|  
|<span data-ttu-id="4ee8d-1240">Metodo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1240">Method</span></span>|<span data-ttu-id="4ee8d-1241">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1241">No</span></span>|<span data-ttu-id="4ee8d-1242">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1242">Yes.</span></span> <span data-ttu-id="4ee8d-1243">Un metodo (virtuale e non virtuale) può essere hide-by-name o hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1243">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-1244">Tipo annidato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1244">Nested Type</span></span>|<span data-ttu-id="4ee8d-1245">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1245">No</span></span>|<span data-ttu-id="4ee8d-1246">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1246">No</span></span>|  
|<span data-ttu-id="4ee8d-1247">Proprietà</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1247">Property</span></span>|<span data-ttu-id="4ee8d-1248">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1248">Not applicable</span></span>|<span data-ttu-id="4ee8d-1249">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1249">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-1250">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1250">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1251">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1251">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="4ee8d-1252">Hide-by-name-e-signature prende in considerazione tutte le parti della firma, inclusi i modificatori personalizzati, i tipi restituiti, i tipi di parametri, elementi sentinel e le convenzioni di chiamata non gestite.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1252">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="4ee8d-1253">Si tratta di un confronto binario.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1253">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="4ee8d-1254">Per la reflection, proprietà ed eventi sono hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1254">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1255">Se si dispone di una proprietà con una richiesta get e una funzione di accesso set nella classe di base, ma la classe derivata ha solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter della classe base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1255">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="4ee8d-1256">Gli attributi personalizzati non fanno parte di common type system.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1256">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="4ee8d-1257">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MemberInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1257">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1258">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o metodo generico, questo metodo cerca i membri del vincolo di classe o i membri di <xref:System.Object> se è presente alcun vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1258">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1259">Per i metodi generici, non includere gli argomenti di tipo in `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1259">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="4ee8d-1260">Ad esempio, il codice c# `GetMember("MyMethod<int>")` esegue la ricerca di un membro con il nome di testo "`MyMethod<int>`", anziché per un metodo denominato `MyMethod` che dispone di un argomento generico di tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1260">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1261">L'esempio seguente mostra tutti i membri del `String` classe che iniziano con la lettera C.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1261">The following example displays all the members of the `String` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-1262">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1262">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-1263">Stringa che contiene il nome dei membri da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1263">The string containing the name of the members to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-1264">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1264">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-1265">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1265">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1266">Zero, per restituire una matrice vuota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1266">Zero, to return an empty array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1267">Cerca i membri specificati, usando i vincoli di associazione specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1267">Searches for the specified members, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1268">Matrice di oggetti <see cref="T:System.Reflection.MemberInfo" /> che rappresentano i membri pubblici con il nome specificato, se presenti; in caso contrario, matrice vuota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1268">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1269">Questo metodo può essere sostituito da una classe derivata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1269">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="4ee8d-1270">I membri includono proprietà, metodi, campi, eventi e così via.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1270">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="4ee8d-1271">Il <xref:System.Type.GetMember%2A> metodo non restituisce i membri in un ordine specifico, ad esempio in ordine alfabetico o un ordine di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1271">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="4ee8d-1272">Il codice non deve dipendere dall'ordine in cui vengono restituiti i membri, perché che varia in base di order.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1272">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="4ee8d-1273">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire quali membri includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1273">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-1274">È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1274">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-1275">Specificare `BindingFlags.Public` per includere i membri pubblici nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1275">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1276">Specificare `BindingFlags.NonPublic` da includere nella ricerca i membri non pubblici (vale a dire, i membri privati, interni e protetti).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1276">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1277">Specificare `BindingFlags.FlattenHierarchy` da includere `public` e `protected` membri statici nella gerarchia; `private` non sono inclusi i membri statici nelle classi ereditate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1277">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="4ee8d-1278">Nell'esempio <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare il comportamento della ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1278">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="4ee8d-1279">`BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1279">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="4ee8d-1280">`BindingFlags.DeclaredOnly` Per cercare solo i membri dichiarati nel <xref:System.Type>, non i membri ereditati sono semplicemente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1280">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="4ee8d-1281">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1281">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="4ee8d-1282">Per ottenere l'inizializzatore di classi (. cctor) usando questo overload del metodo, è necessario specificare ". cctor" per `name`, e <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) per `bindingAttr`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1282">To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for `name`, and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="4ee8d-1283">È anche possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1283">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="4ee8d-1284">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MemberInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1284">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1285">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o metodo generico, questo metodo cerca i membri del vincolo di classe o i membri di <xref:System.Object> se è presente alcun vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1285">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1286">Per i metodi generici, non includere gli argomenti di tipo in `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1286">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="4ee8d-1287">Ad esempio, il codice c# `GetMember("MyMethod<int>")` esegue la ricerca di un membro con il nome di testo "`MyMethod<int>`", anziché per un metodo denominato `MyMethod` che dispone di un argomento generico di tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1287">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1288">Nell'esempio seguente consente di visualizzare tutti i membri statici pubblici del `myString` classe che iniziano con la lettera C.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1288">The following example displays all the public static members of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-1289">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1289">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-1290">Stringa che contiene il nome dei membri da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1290">The string containing the name of the members to get.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="4ee8d-1291">Valore da cercare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1291">The value to search for.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-1292">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1292">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-1293">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1293">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1294">Zero, per restituire una matrice vuota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1294">Zero, to return an empty array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1295">Cerca i membri specificati del tipo di membro specificato usando i vincoli di associazione specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1295">Searches for the specified members of the specified member type, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1296">Matrice di oggetti <see cref="T:System.Reflection.MemberInfo" /> che rappresentano i membri pubblici con il nome specificato, se presenti; in caso contrario, matrice vuota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1296">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1297">I membri includono proprietà, metodi, campi, eventi e così via.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1297">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="4ee8d-1298">Il <xref:System.Type.GetMember%2A> metodo non restituisce i membri in un ordine specifico, ad esempio in ordine alfabetico o un ordine di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1298">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="4ee8d-1299">Il codice non deve dipendere dall'ordine in cui vengono restituiti i membri, perché che varia in base di order.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1299">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="4ee8d-1300">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire quali membri includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1300">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-1301">È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1301">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-1302">Specificare `BindingFlags.Public` per includere i membri pubblici nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1302">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1303">Specificare `BindingFlags.NonPublic` da includere nella ricerca i membri non pubblici (vale a dire, i membri privati, interni e protetti).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1303">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1304">Specificare `BindingFlags.FlattenHierarchy` da includere `public` e `protected` membri statici nella gerarchia; `private` non sono inclusi i membri statici nelle classi ereditate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1304">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="4ee8d-1305">Nell'esempio <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare il comportamento della ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1305">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="4ee8d-1306">`BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1306">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="4ee8d-1307">`BindingFlags.DeclaredOnly` Per cercare solo i membri dichiarati nel <xref:System.Type>, non i membri ereditati sono semplicemente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1307">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="4ee8d-1308">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1308">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="4ee8d-1309">Per ottenere l'inizializzatore di classi (. cctor) usando questo overload del metodo, è necessario specificare ". cctor" per `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> per `type`, e <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) per `bindingAttr`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1309">To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> for `type`, and  <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="4ee8d-1310">È anche possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1310">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="4ee8d-1311">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MemberInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1311">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1312">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o metodo generico, questo metodo cerca i membri del vincolo di classe o i membri di <xref:System.Object> se è presente alcun vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1312">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1313">Per i metodi generici, non includere gli argomenti di tipo in `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1313">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="4ee8d-1314">Ad esempio, il codice c# `GetMember("MyMethod<int>")` esegue la ricerca di un membro con il nome di testo "`MyMethod<int>`", anziché per un metodo denominato `MyMethod` che dispone di un argomento generico di tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1314">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1315">L'esempio seguente mostra tutti i metodi del `myString` classe che iniziano con la lettera C.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1315">The following example displays all the methods of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-1316">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1316">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="4ee8d-1317">Una classe derivata deve fornire un'implementazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1317">A derived class must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-1318">Ottiene i membri (proprietà, metodi, campi, eventi e così via) dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1318">Gets the members (properties, methods, fields, events, and so on) of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-1319">Restituisce tutti i membri pubblici dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1319">Returns all the public members of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1320">Matrice di oggetti <see cref="T:System.Reflection.MemberInfo" /> che rappresentano tutti i membri pubblici dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1320">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all the public members of the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="4ee8d-1321">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1321">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1322">Matrice vuota di tipo <see cref="T:System.Reflection.MemberInfo" />, se per l'oggetto <see cref="T:System.Type" /> corrente non esistono membri pubblici.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1322">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have public members.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1323">I membri includono proprietà, metodi, campi, eventi e così via.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1323">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="4ee8d-1324">Il <xref:System.Type.GetMembers%2A> metodo non restituisce i membri in un ordine specifico, ad esempio in ordine alfabetico o un ordine di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1324">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="4ee8d-1325">Il codice non deve dipendere dall'ordine in cui vengono restituiti i membri, perché che varia in base di order.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1325">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="4ee8d-1326">Questo overload del metodo chiama il <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> overload del metodo, con <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1326">This method overload calls the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="4ee8d-1327">Non si troverà gli inizializzatori di classi (. cctor).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1327">It will not find class initializers (.cctor).</span></span> <span data-ttu-id="4ee8d-1328">Per trovare gli inizializzatori di classi, usare un overload che accetta <xref:System.Reflection.BindingFlags>e specificare <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1328">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="4ee8d-1329">È anche possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1329">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="4ee8d-1330">La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1330">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="4ee8d-1331">Tipo di membro</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1331">Member Type</span></span>|<span data-ttu-id="4ee8d-1332">Static</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1332">Static</span></span>|<span data-ttu-id="4ee8d-1333">Non statici</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1333">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="4ee8d-1334">Costruttore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1334">Constructor</span></span>|<span data-ttu-id="4ee8d-1335">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1335">No</span></span>|<span data-ttu-id="4ee8d-1336">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1336">No</span></span>|  
|<span data-ttu-id="4ee8d-1337">Campo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1337">Field</span></span>|<span data-ttu-id="4ee8d-1338">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1338">No</span></span>|<span data-ttu-id="4ee8d-1339">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1339">Yes.</span></span> <span data-ttu-id="4ee8d-1340">Un campo viene sempre hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1340">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-1341">event</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1341">Event</span></span>|<span data-ttu-id="4ee8d-1342">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1342">Not applicable</span></span>|<span data-ttu-id="4ee8d-1343">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1343">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-1344">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1344">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1345">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1345">See note 2 below.</span></span>|  
|<span data-ttu-id="4ee8d-1346">Metodo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1346">Method</span></span>|<span data-ttu-id="4ee8d-1347">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1347">No</span></span>|<span data-ttu-id="4ee8d-1348">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1348">Yes.</span></span> <span data-ttu-id="4ee8d-1349">Un metodo (virtuale e non virtuale) può essere hide-by-name o hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1349">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-1350">Tipo annidato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1350">Nested Type</span></span>|<span data-ttu-id="4ee8d-1351">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1351">No</span></span>|<span data-ttu-id="4ee8d-1352">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1352">No</span></span>|  
|<span data-ttu-id="4ee8d-1353">Proprietà</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1353">Property</span></span>|<span data-ttu-id="4ee8d-1354">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1354">Not applicable</span></span>|<span data-ttu-id="4ee8d-1355">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1355">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-1356">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1356">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1357">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1357">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="4ee8d-1358">Hide-by-name-e-signature prende in considerazione tutte le parti della firma, inclusi i modificatori personalizzati, i tipi restituiti, i tipi di parametri, elementi sentinel e le convenzioni di chiamata non gestite.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1358">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="4ee8d-1359">Si tratta di un confronto binario.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1359">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="4ee8d-1360">Per la reflection, proprietà ed eventi sono hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1360">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1361">Se si dispone di una proprietà con una richiesta get e una funzione di accesso set nella classe di base, ma la classe derivata ha solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter della classe base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1361">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="4ee8d-1362">Gli attributi personalizzati non fanno parte di common type system.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1362">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="4ee8d-1363">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MemberInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1363">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1364">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o metodo generico, questo metodo cerca i membri del vincolo di classe o i membri di <xref:System.Object> se è presente alcun vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1364">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1365">Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Type.GetMembers> overload del metodo per raccogliere informazioni su tutti i membri pubblici di una classe specificata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1365">The following code example demonstrates how to use the <xref:System.Type.GetMembers> method overload to collect information about all public members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-1366">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1366">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-1367">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1367">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1368">Zero (<see cref="F:System.Reflection.BindingFlags.Default" />), per restituire una matrice vuota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1368">Zero (<see cref="F:System.Reflection.BindingFlags.Default" />), to return an empty array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1369">Quando ne viene eseguito l'override in una classe derivata, cerca i membri definiti per l'oggetto <see cref="T:System.Type" /> corrente, usando i vincoli di binding specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1369">When overridden in a derived class, searches for the members defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1370">Matrice di oggetti <see cref="T:System.Reflection.MemberInfo" /> che rappresentano tutti i membri definiti per l'oggetto <see cref="T:System.Type" /> corrente corrispondenti ai vincoli di binding specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1370">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all members defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="4ee8d-1371">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1371">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1372">Matrice vuota di tipo <see cref="T:System.Reflection.MemberInfo" />, se non vi sono membri definiti per l'oggetto <see cref="T:System.Type" /> corrente oppure se nessuno dei membri definiti corrisponde ai vincoli di binding.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1372">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if no members are defined for the current <see cref="T:System.Type" />, or if none of the defined members match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1373">I membri includono proprietà, metodi, campi, eventi e così via.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1373">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="4ee8d-1374">Il <xref:System.Type.GetMembers%2A> metodo non restituisce i membri in un ordine specifico, ad esempio in ordine alfabetico o un ordine di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1374">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="4ee8d-1375">Il codice non deve dipendere dall'ordine in cui vengono restituiti i membri, perché che varia in base di order.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1375">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="4ee8d-1376">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire quali membri includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1376">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-1377">È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1377">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-1378">Specificare `BindingFlags.Public` per includere i membri pubblici nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1378">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1379">Specificare `BindingFlags.NonPublic` da includere nella ricerca i membri non pubblici (vale a dire, i membri privati, interni e protetti).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1379">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span> <span data-ttu-id="4ee8d-1380">Solo protetti e interni come membri delle classi base vengono restituiti; membri privati nelle classi di base non vengono restituiti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1380">Only protected and internal members on base classes are returned; private members on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="4ee8d-1381">Specificare `BindingFlags.FlattenHierarchy` da includere `public` e `protected` membri statici nella gerarchia; `private` non sono inclusi i membri statici nelle classi ereditate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1381">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="4ee8d-1382">Nell'esempio <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare il comportamento della ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1382">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="4ee8d-1383">`BindingFlags.DeclaredOnly` Per cercare solo i membri dichiarati nel <xref:System.Type>, non i membri ereditati sono semplicemente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1383">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="4ee8d-1384">Chiamare questo metodo solo con il `Public` flag o solo il `NonPublic` flag restituirà i membri specificati e non richiede nessun altro flag.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1384">Calling this method with only the `Public` flag or only the `NonPublic` flag will return the specified members and does not require any other flags.</span></span>  
  
 <span data-ttu-id="4ee8d-1385">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1385">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="4ee8d-1386">Per ottenere l'inizializzatore di classi (. cctor) usando questo overload del metodo, è necessario specificare <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1386">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="4ee8d-1387">È anche possibile ottenere l'inizializzatore di classi tramite il <xref:System.Type.TypeInitializer%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1387">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="4ee8d-1388">Se l'oggetto T:System.Type corrente rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MemberInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1388">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1389">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o metodo generico, questo metodo cerca i membri del vincolo di classe o i membri di <xref:System.Object> se è presente alcun vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1389">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1390">Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> overload del metodo per raccogliere informazioni su tutti i membri di istanza pubblici di una classe specificata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1390">The following code example demonstrates how to use the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload to collect information about all public instance members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-1391">Ottiene un metodo specifico dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1391">Gets a specific method of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-1392">Stringa che contiene il nome del metodo pubblico da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1392">The string containing the name of the public method to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1393">Cerca il metodo pubblico con il nome specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1393">Searches for the public method with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1394">Oggetto che rappresenta il metodo pubblico con il nome specificato, se è stato trovato; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1394">An object that represents the public method with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1395">La ricerca di `name` tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1395">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="4ee8d-1396">La ricerca include i metodi di istanza pubblici statici e pubblici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1396">The search includes public static and public instance methods.</span></span>  
  
 <span data-ttu-id="4ee8d-1397">Se un metodo di overload e dispone di più di un metodo pubblico, il <xref:System.Type.GetMethod%28System.String%29> metodo genera un <xref:System.Reflection.AmbiguousMatchException> eccezione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1397">If a method is overloaded and has more than one public method, the <xref:System.Type.GetMethod%28System.String%29> method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="4ee8d-1398">Nell'esempio seguente, viene generata un'eccezione poiché non esiste più di un overload di pubblico del <xref:System.Int32.ToString%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1398">In the following example, an exception is thrown because there is more than one public overload of the <xref:System.Int32.ToString%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="4ee8d-1399">D'altra parte, poiché il `Person.ToString` override dei metodi <xref:System.Object.ToString%2A?displayProperty=nameWithType> e pertanto non sia sovraccarico, il <xref:System.Type.GetMethod%28System.String%29> metodo è in grado di recuperare il <xref:System.Reflection.MethodInfo> oggetto.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1399">On the other hand, because the `Person.ToString` method overrides  <xref:System.Object.ToString%2A?displayProperty=nameWithType> and therefore is not overloaded, the <xref:System.Type.GetMethod%28System.String%29> method is able to retrieve the <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 <span data-ttu-id="4ee8d-1400">È possibile eseguire una delle operazioni seguenti per recuperare un metodo specifico:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1400">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="4ee8d-1401">Chiamare il <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> metodo e specificare un `bindingAttr` argomento che identifica il metodo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1401">Call the <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> method and specify a `bindingAttr` argument that uniquely identifies the method.</span></span> <span data-ttu-id="4ee8d-1402">Ad esempio, se viene generata l'eccezione perché un tipo ha un valore statico e un overload di istanza, è possibile specificare una `bindingAttr` dell'argomento <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1402">For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  `bindingAttr` argument  of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="4ee8d-1403">Chiamare un overload del <xref:System.Type.GetMethod%2A> metodo che includa un `types` parametro che definisce i tipi di parametri del metodo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1403">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="4ee8d-1404">Chiamare il <xref:System.Type.GetMethods> metodo per recuperare una matrice contenente tutti i metodi pubblici che appartengono a un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1404">Call the <xref:System.Type.GetMethods> method to retrieve an array containing all of the public methods belonging to a type.</span></span> <span data-ttu-id="4ee8d-1405">È possibile quindi eseguire l'iterazione in modo da identificare i metodi duplicati denominati `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1405">You can then iterate it to identify the duplicate methods named `name`.</span></span>  
  
 <span data-ttu-id="4ee8d-1406">Se l'oggetto T:System.Type corrente rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MethodInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1406">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1407">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o metodo generico, questo metodo vengono cercati i metodi del vincolo di classe o i metodi di <xref:System.Object> se è presente alcun vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1407">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1408">Per i metodi generici, non includere gli argomenti di tipo in `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1408">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="4ee8d-1409">Ad esempio, il codice c# `GetMember("MyMethod<int>")` esegue la ricerca di un membro con il nome di testo "`MyMethod<int>`", anziché per un metodo denominato `MyMethod` che dispone di un argomento generico di tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1409">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1410">L'esempio seguente ottiene un metodo denominato `MethodA`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1410">The following example gets a method named `MethodA`.</span></span>  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="4ee8d-1411">È stato trovato più di un metodo con il nome specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1411">More than one method is found with the specified name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-1412">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1412">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-1413">Stringa che contiene il nome del metodo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1413">The string containing the name of the method to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-1414">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1414">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-1415">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1415">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1416">Zero, per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1416">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1417">Cerca il metodo specificato, usando i vincoli di binding specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1417">Searches for the specified method, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1418">Oggetto che rappresenta il metodo corrispondente ai requisiti specificati, se presente; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1418">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1419">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire i metodi da includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1419">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-1420">È necessario specificare <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> o <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> per ottenere un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1420">You must specify either <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in order to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-1421">Specificare <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> da includere nella ricerca i metodi pubblici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1421">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1422">Specificare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> da includere nella ricerca i metodi non pubblici (vale a dire metodi privati, interni e protetti).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1422">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1423">Specificare <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> da includere `public` e `protected` membri statici nella gerarchia; `private` non sono inclusi i membri statici nelle classi ereditate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1423">Specify <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="4ee8d-1424">Nell'esempio <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare il comportamento della ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1424">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="4ee8d-1425"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> per ignorare la distinzione di `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1425"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="4ee8d-1426"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> Per cercare solo i metodi dichiarati nel <xref:System.Type>, non i metodi ereditati sono semplicemente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1426"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="4ee8d-1427">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1427">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="4ee8d-1428">Se un metodo viene sottoposto a overload e più di un overload soddisfa i vincoli specificati per il `bindingAttr` argomento, il metodo genera un <xref:System.Reflection.AmbiguousMatchException> eccezione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1428">If a method is overloaded and more than one overload meets the constraints specified by the `bindingAttr` argument, the method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="4ee8d-1429">Nell'esempio seguente, perché viene generata un'eccezione:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1429">In the following example, an exception is thrown because:</span></span>  
  
-   <span data-ttu-id="4ee8d-1430">Il `TestClass` tipo ha due overload di istanza pubblici del `DisplayValue` metodo `DisplayValue(String)` e `DisplayValue(String, Object[])`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1430">The `TestClass` type has two public instance overloads of the `DisplayValue` method, `DisplayValue(String)` and `DisplayValue(String, Object[])`.</span></span>  
  
-   <span data-ttu-id="4ee8d-1431">Il `TestClass` tipo ha due overload di istanza pubblici del `Equals` metodo, una delle quali viene ereditata dal <xref:System.Object>: `Equals(TestClass)` e `Equals(Object)`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1431">The `TestClass` type has two public instance overloads of the `Equals` method,  one of which is inherited from <xref:System.Object>: `Equals(TestClass)` and `Equals(Object)`.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 <span data-ttu-id="4ee8d-1432">È possibile eseguire una delle operazioni seguenti per recuperare un metodo specifico:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1432">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="4ee8d-1433">Modificare i vincoli di binding.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1433">Change the binding constraints.</span></span> <span data-ttu-id="4ee8d-1434">Nell'esempio precedente, si prova a recuperare un'istanza pubblica `Equals` metodo che viene dichiarata dal tipo e non è stato ereditato recupera `Equals(TestClass)`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1434">In the previous example, attempting to retrieve a public instance `Equals` method that is declared by the type and not inherited successfully retrieves `Equals(TestClass)`.</span></span>  
  
-   <span data-ttu-id="4ee8d-1435">Chiamare un overload del <xref:System.Type.GetMethod%2A> metodo che includa un `types` parametro che definisce i tipi di parametri del metodo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1435">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="4ee8d-1436">Chiamare il <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> metodo per recuperare una matrice contenente tutti i metodi appartenenti a un tipo che hanno gli attributi di binding specificati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1436">Call the <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes.</span></span> <span data-ttu-id="4ee8d-1437">È possibile quindi eseguire l'iterazione in modo da identificare i metodi duplicati denominati `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1437">You can then iterate it to identify the duplicate methods named `name`.</span></span> <span data-ttu-id="4ee8d-1438">Questo approccio è illustrato nel gestore dell'esempio precedente per il <xref:System.Reflection.AmbiguousMatchException> eccezione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1438">This approach is illustrated in the previous example's handler for the <xref:System.Reflection.AmbiguousMatchException> exception.</span></span>  
  
 <span data-ttu-id="4ee8d-1439">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MethodInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1439">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1440">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o metodo generico, questo metodo vengono cercati i metodi del vincolo di classe o i metodi di <xref:System.Object> se è presente alcun vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1440">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1441">Per i metodi generici, non includere gli argomenti di tipo in `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1441">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="4ee8d-1442">Ad esempio, il codice c# `GetMember("MyMethod<int>")` esegue la ricerca di un membro con il nome di testo "`MyMethod<int>`", anziché per un metodo denominato `MyMethod` che dispone di un argomento generico di tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1442">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1443">Nell'esempio seguente ottiene il metodo che corrisponde al flag di associazione specificati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1443">The following example gets the method that matches the specified binding flags.</span></span>  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="4ee8d-1444">È stato trovato più di un metodo con il nome specificato e corrispondente ai vincoli di associazione specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1444">More than one method is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-1445">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1445">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-1446">Stringa che contiene il nome del metodo pubblico da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1446">The string containing the name of the public method to get.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="4ee8d-1447">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano numero, ordine e tipo dei parametri relativi al metodo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1447">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="4ee8d-1448">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1448">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1449">Matrice vuota di oggetti <see cref="T:System.Type" /> (come fornita dal campo <see cref="F:System.Type.EmptyTypes" />) per ottenere un metodo che non accetta parametri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1449">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1450">Cerca il metodo pubblico specificato i cui parametri corrispondono ai tipi di argomenti specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1450">Searches for the specified public method whose parameters match the specified argument types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1451">Oggetto che rappresenta il metodo pubblico i cui parametri corrispondono ai tipi di argomenti specificati, se è stato trovato; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1451">An object representing the public method whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1452">La ricerca di `name` tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1452">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="4ee8d-1453">La ricerca include i metodi di istanza pubblici statici e pubblici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1453">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1454">Non è possibile omettere i parametri durante la ricerca di costruttori e metodi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1454">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="4ee8d-1455">È possibile omettere i parametri solo quando viene richiamato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1455">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="4ee8d-1456">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MethodInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1456">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1457">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o metodo generico, questo metodo vengono cercati i metodi del vincolo di classe o i metodi di <xref:System.Object> se è presente alcun vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1457">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1458">Il `name` parametro non può includere gli argomenti di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1458">The `name` parameter cannot include type arguments.</span></span> <span data-ttu-id="4ee8d-1459">Ad esempio, il codice c# `GetMethod("MyGenericMethod<int>")` Cerca un metodo con il nome di testo "`MyGenericMethod<int>`", anziché per un metodo denominato `MyGenericMethod` che dispone di un argomento generico di tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1459">For example, the C# code `GetMethod("MyGenericMethod<int>")` searches for a method with the text name "`MyGenericMethod<int>`", rather than for a method named `MyGenericMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="4ee8d-1460">Usare invece `GetMethod("MyGenericMethod")` con il parametro appropriato nel `types` matrice.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1460">Instead, use `GetMethod("MyGenericMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1461">Nell'esempio seguente consente di trovare un overload specifico di `MethodA`, specificando un'ampia gamma di tipi di argomento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1461">The following example finds specific overloads of `MethodA`, specifying a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1462">Il [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] presuppone il `/unsafe` opzione del compilatore.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1462">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 <span data-ttu-id="4ee8d-1463">Nell'esempio seguente vengono recuperati <xref:System.Reflection.MethodInfo> gli oggetti che rappresentano le `Add` metodi di un tipo non generico (il <xref:System.Collections.ArrayList> classe), un tipo generico aperto (il <xref:System.Collections.Generic.List%601> classe) e un tipo generico chiuso (il `List(Of String)` tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1463">The following example retrieves <xref:System.Reflection.MethodInfo> objects that represent the `Add` methods  of a non-generic type (the <xref:System.Collections.ArrayList> class), an open generic type (the <xref:System.Collections.Generic.List%601> class), and a closed generic type (the `List(Of String)` type.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 <span data-ttu-id="4ee8d-1464">L'esempio definisce una `GetAddMethod` metodo che recupera l'oggetto appropriato <xref:System.Reflection.MethodInfo> oggetto.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1464">The example defines a `GetAddMethod` method that retrieves the appropriate <xref:System.Reflection.MethodInfo> object.</span></span> <span data-ttu-id="4ee8d-1465">Per fornire il `types` argomento per un tipo generico aperto, chiama il <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1465">To provide the `types` argument for an open generic type, it calls the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4ee8d-1466">Per fornire il `types` argomento per un tipo generico chiuso, viene recuperato il valore della <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1466">To provide the `types` argument for a closed generic type, it retrieves the value of the <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="4ee8d-1467">Sono stati trovati più metodi con il nome e i parametri specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1467">More than one method is found with the specified name and specified parameters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-1468">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1468">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-1469">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1469">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1470">
            <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1470">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-1471">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1471">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1472">Uno degli elementi in <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1472">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-1473">
            <paramref name="types" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1473">
              <paramref name="types" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-1474">Stringa che contiene il nome del metodo pubblico da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1474">The string containing the name of the public method to get.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="4ee8d-1475">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano numero, ordine e tipo dei parametri relativi al metodo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1475">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="4ee8d-1476">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1476">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1477">Matrice vuota di oggetti <see cref="T:System.Type" /> (come fornita dal campo <see cref="F:System.Type.EmptyTypes" />) per ottenere un metodo che non accetta parametri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1477">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="4ee8d-1478">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresenta gli attributi associati all'elemento corrispondente nella matrice <c>types</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1478">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="4ee8d-1479">Da usare solo quando si effettuano chiamate tramite l'interoperabilità COM e vengono gestiti solo i parametri passati per riferimento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1479">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span>
          </span>
          <span data-ttu-id="4ee8d-1480">Questo parametro non viene elaborato dal binder predefinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1480">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1481">Cerca il metodo pubblico specificato i cui parametri corrispondono ai modificatori e ai tipi di argomenti specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1481">Searches for the specified public method whose parameters match the specified argument types and modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1482">Oggetto che rappresenta il metodo pubblico corrispondente ai requisiti specificati, se è stato trovato; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1482">An object representing the public method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1483">Anche se il binder predefinito elabora <xref:System.Reflection.ParameterModifier> (la `modifiers` parametro), è possibile usare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per scrivere un binder personalizzato che elaborano `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1483">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="4ee8d-1484">`ParameterModifier` viene usato solo quando si chiama tramite l'interoperabilità COM, e vengono gestiti solo i parametri che vengono passati per riferimento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1484">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="4ee8d-1485">La ricerca di `name` tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1485">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="4ee8d-1486">La ricerca include i metodi di istanza pubblici statici e pubblici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1486">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1487">Non è possibile omettere i parametri durante la ricerca di costruttori e metodi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1487">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="4ee8d-1488">È possibile omettere i parametri solo quando viene richiamato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1488">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="4ee8d-1489">Se l'oggetto T:System.Type corrente rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MethodInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1489">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1490">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o metodo generico, questo metodo vengono cercati i metodi del vincolo di classe o i metodi di <xref:System.Object> se è presente alcun vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1490">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1491">Per i metodi generici, non includere gli argomenti di tipo in `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1491">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="4ee8d-1492">Ad esempio, il codice c# `GetMethod("MyMethod<int>")` esegue la ricerca di un membro con il nome di testo "`MyMethod<int>`", anziché per un metodo denominato `MyMethod` che dispone di un argomento generico di tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1492">For example, the C# code `GetMethod("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="4ee8d-1493">Usare invece `GetMethod("MyMethod")` con il parametro appropriato nel `types` matrice.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1493">Instead, use `GetMethod("MyMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="4ee8d-1494">Sono stati trovati più metodi con il nome e i parametri specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1494">More than one method is found with the specified name and specified parameters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-1495">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1495">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-1496">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1496">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1497">
            <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1497">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-1498">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1498">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1499">Uno degli elementi in <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1499">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-1500">
            <paramref name="types" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1500">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="4ee8d-1501">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1501">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1502">
            <paramref name="modifiers" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1502">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-1503">Stringa che contiene il nome del metodo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1503">The string containing the name of the method to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-1504">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1504">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-1505">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1505">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1506">Zero, per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1506">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="4ee8d-1507">Oggetto che definisce una serie di proprietà e permette il binding, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1507">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="4ee8d-1508">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1508">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1509">Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1509">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="4ee8d-1510">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano numero, ordine e tipo dei parametri relativi al metodo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1510">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="4ee8d-1511">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1511">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1512">Matrice vuota di oggetti <see cref="T:System.Type" /> (come fornita dal campo <see cref="F:System.Type.EmptyTypes" />) per ottenere un metodo che non accetta parametri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1512">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="4ee8d-1513">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresenta gli attributi associati all'elemento corrispondente nella matrice <c>types</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1513">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="4ee8d-1514">Da usare solo quando si effettuano chiamate tramite l'interoperabilità COM e vengono gestiti solo i parametri passati per riferimento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1514">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span>
          </span>
          <span data-ttu-id="4ee8d-1515">Questo parametro non viene elaborato dal binder predefinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1515">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1516">Cerca il metodo specificato i cui parametri corrispondono ai tipi di argomenti e ai modificatori specificati, usando i vincoli di associazione specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1516">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1517">Oggetto che rappresenta il metodo corrispondente ai requisiti specificati, se presente; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1517">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1518">Anche se il binder predefinito elabora <xref:System.Reflection.ParameterModifier> (la `modifiers` parametro), è possibile usare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per scrivere un binder personalizzato che elaborano `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1518">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="4ee8d-1519">`ParameterModifier` viene usato solo quando si chiama tramite l'interoperabilità COM, e vengono gestiti solo i parametri che vengono passati per riferimento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1519">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="4ee8d-1520">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire i metodi da includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1520">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-1521">È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1521">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-1522">Specificare `BindingFlags.Public` da includere nella ricerca i metodi pubblici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1522">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1523">Specificare `BindingFlags.NonPublic` per includere i metodi non pubblici (vale a dire metodi privati, interni e protetti) nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1523">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1524">Specificare `BindingFlags.FlattenHierarchy` da includere `public` e `protected` membri statici nella gerarchia; `private` non sono inclusi i membri statici nelle classi ereditate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1524">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="4ee8d-1525">Nell'esempio <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare il comportamento della ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1525">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="4ee8d-1526">`BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1526">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="4ee8d-1527">`BindingFlags.DeclaredOnly` Per cercare solo i metodi dichiarati nel <xref:System.Type>, non i metodi ereditati sono semplicemente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1527">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="4ee8d-1528">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1528">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1529">Non è possibile omettere i parametri durante la ricerca di costruttori e metodi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1529">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="4ee8d-1530">È possibile omettere i parametri solo quando viene richiamato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1530">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="4ee8d-1531">Se l'oggetto T:System.Type corrente rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MethodInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1531">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1532">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o metodo generico, questo metodo vengono cercati i metodi del vincolo di classe o i metodi di <xref:System.Object> se è presente alcun vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1532">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1533">Per i metodi generici, non includere gli argomenti di tipo in `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1533">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="4ee8d-1534">Ad esempio, il codice c# `GetMember("MyMethod<int>")` esegue la ricerca di un membro con il nome di testo "`MyMethod<int>`", anziché per un metodo denominato `MyMethod` che dispone di un argomento generico di tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1534">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1535">Nell'esempio seguente consente di trovare un overload specifico di `MethodA`, che specifica i vincoli di binding e una varietà di tipi di argomento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1535">The following example finds specific overloads of `MethodA`, specifying binding constraints and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1536">Il [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] presuppone il `/unsafe` opzione del compilatore.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1536">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="4ee8d-1537">È stato trovato più di un metodo con il nome specificato e corrispondente ai vincoli di associazione specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1537">More than one method is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-1538">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1538">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-1539">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1539">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1540">
            <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1540">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-1541">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1541">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1542">Uno degli elementi in <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1542">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-1543">
            <paramref name="types" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1543">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="4ee8d-1544">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1544">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1545">
            <paramref name="modifiers" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1545">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-1546">Stringa che contiene il nome del metodo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1546">The string containing the name of the method to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-1547">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1547">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-1548">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1548">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1549">Zero, per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1549">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="4ee8d-1550">Oggetto che definisce una serie di proprietà e permette il binding, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1550">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="4ee8d-1551">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1551">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1552">Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1552">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="4ee8d-1553">Oggetto che specifica il set di regole da usare per la disposizione e il layout degli argomenti, la modalità di passaggio del valore restituito, i registri usati per gli argomenti e la pulizia dello stack.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1553">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="4ee8d-1554">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano numero, ordine e tipo dei parametri relativi al metodo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1554">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="4ee8d-1555">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1555">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1556">Matrice vuota di oggetti <see cref="T:System.Type" /> (come fornita dal campo <see cref="F:System.Type.EmptyTypes" />) per ottenere un metodo che non accetta parametri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1556">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="4ee8d-1557">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresenta gli attributi associati all'elemento corrispondente nella matrice <c>types</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1557">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="4ee8d-1558">Da usare solo quando si effettuano chiamate tramite l'interoperabilità COM e vengono gestiti solo i parametri passati per riferimento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1558">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span>
          </span>
          <span data-ttu-id="4ee8d-1559">Questo parametro non viene elaborato dal binder predefinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1559">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1560">Cerca il metodo specificato i cui parametri corrispondono ai tipi di argomenti e ai modificatori specificati, usando i vincoli di associazione e la convenzione di chiamata specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1560">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1561">Oggetto che rappresenta il metodo corrispondente ai requisiti specificati, se presente; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1561">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1562">Anche se il binder predefinito elabora <xref:System.Reflection.ParameterModifier> (la `modifiers` parametro), è possibile usare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per scrivere un binder personalizzato che elaborano `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1562">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="4ee8d-1563">`ParameterModifier` viene usato solo quando si chiama tramite l'interoperabilità COM, e vengono gestiti solo i parametri che vengono passati per riferimento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1563">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="4ee8d-1564">La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `GetXXX` metodi durante la reflection su un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1564">The following table shows what members of a base class are returned by the `GetXXX` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="4ee8d-1565">Tipo di membro</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1565">Member Type</span></span>|<span data-ttu-id="4ee8d-1566">Static</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1566">Static</span></span>|<span data-ttu-id="4ee8d-1567">Non statici</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1567">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="4ee8d-1568">Costruttore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1568">Constructor</span></span>|<span data-ttu-id="4ee8d-1569">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1569">No</span></span>|<span data-ttu-id="4ee8d-1570">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1570">No</span></span>|  
|<span data-ttu-id="4ee8d-1571">Campo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1571">Field</span></span>|<span data-ttu-id="4ee8d-1572">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1572">No</span></span>|<span data-ttu-id="4ee8d-1573">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1573">Yes.</span></span> <span data-ttu-id="4ee8d-1574">Un campo viene sempre hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1574">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-1575">event</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1575">Event</span></span>|<span data-ttu-id="4ee8d-1576">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1576">Not applicable</span></span>|<span data-ttu-id="4ee8d-1577">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1577">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-1578">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1578">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1579">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1579">See note 2 below.</span></span>|  
|<span data-ttu-id="4ee8d-1580">Metodo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1580">Method</span></span>|<span data-ttu-id="4ee8d-1581">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1581">No</span></span>|<span data-ttu-id="4ee8d-1582">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1582">Yes.</span></span> <span data-ttu-id="4ee8d-1583">Un metodo (virtuale e non virtuale) può essere hide-by-name o hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1583">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-1584">Tipo annidato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1584">Nested Type</span></span>|<span data-ttu-id="4ee8d-1585">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1585">No</span></span>|<span data-ttu-id="4ee8d-1586">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1586">No</span></span>|  
|<span data-ttu-id="4ee8d-1587">Proprietà</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1587">Property</span></span>|<span data-ttu-id="4ee8d-1588">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1588">Not applicable</span></span>|<span data-ttu-id="4ee8d-1589">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1589">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-1590">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1590">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1591">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1591">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="4ee8d-1592">Hide-by-name-e-signature prende in considerazione tutte le parti della firma, inclusi i modificatori personalizzati, i tipi restituiti, i tipi di parametri, elementi sentinel e le convenzioni di chiamata non gestite.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1592">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="4ee8d-1593">Si tratta di un confronto binario.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1593">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="4ee8d-1594">Per la reflection, proprietà ed eventi sono hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1594">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1595">Se si dispone di una proprietà con una richiesta get e una funzione di accesso set nella classe di base, ma la classe derivata ha solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter della classe base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1595">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="4ee8d-1596">Gli attributi personalizzati non fanno parte di common type system.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1596">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="4ee8d-1597">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire i metodi da includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1597">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-1598">È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1598">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-1599">Specificare `BindingFlags.Public` da includere nella ricerca i metodi pubblici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1599">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1600">Specificare `BindingFlags.NonPublic` per includere i metodi non pubblici (vale a dire metodi privati, interni e protetti) nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1600">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1601">Specificare `BindingFlags.FlattenHierarchy` da includere `public` e `protected` membri statici nella gerarchia; `private` non sono inclusi i membri statici nelle classi ereditate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1601">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="4ee8d-1602">Nell'esempio <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare il comportamento della ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1602">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="4ee8d-1603">`BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1603">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="4ee8d-1604">`BindingFlags.DeclaredOnly` Per cercare solo i metodi dichiarati nel <xref:System.Type>, non i metodi ereditati sono semplicemente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1604">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="4ee8d-1605">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1605">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1606">Non è possibile omettere i parametri durante la ricerca di costruttori e metodi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1606">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="4ee8d-1607">È possibile omettere i parametri solo quando viene richiamato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1607">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="4ee8d-1608">Se l'oggetto T:System.Type corrente rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MethodInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1608">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1609">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o metodo generico, questo metodo vengono cercati i metodi del vincolo di classe o i metodi di <xref:System.Object> se è presente alcun vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1609">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1610">Per i metodi generici, non includere gli argomenti di tipo in `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1610">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="4ee8d-1611">Ad esempio, il codice c# `GetMember("MyMethod<int>")` esegue la ricerca di un membro con il nome di testo "`MyMethod<int>`", anziché per un metodo denominato `MyMethod` che dispone di un argomento generico di tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1611">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1612">Nell'esempio seguente consente di trovare un overload specifico di `MethodA`, che specifica i vincoli di binding, convenzioni di chiamata e un'ampia gamma di tipi di argomento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1612">The following example finds specific overloads of `MethodA`, specifying binding constraints, calling conventions, and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1613">Il [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] presuppone il `/unsafe` opzione del compilatore.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1613">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="4ee8d-1614">È stato trovato più di un metodo con il nome specificato e corrispondente ai vincoli di associazione specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1614">More than one method is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-1615">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1615">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-1616">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1616">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1617">
            <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1617">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-1618">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1618">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1619">Uno degli elementi in <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1619">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-1620">
            <paramref name="types" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1620">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="4ee8d-1621">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1621">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1622">
            <paramref name="modifiers" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1622">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-1623">Stringa che contiene il nome del metodo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1623">The string containing the name of the method to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-1624">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1624">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-1625">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1625">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1626">Zero, per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1626">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="4ee8d-1627">Oggetto che definisce una serie di proprietà e permette il binding, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1627">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="4ee8d-1628">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1628">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1629">Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1629">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="4ee8d-1630">Oggetto che specifica il set di regole da usare per l'ordine e il layout degli argomenti, la modalità di passaggio del valore restituito, i registri usati per gli argomenti e il processo di pulizia dello stack.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1630">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="4ee8d-1631">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano numero, ordine e tipo dei parametri relativi al metodo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1631">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="4ee8d-1632">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1632">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1633">Matrice vuota di tipo <see cref="T:System.Type" /> (ovvero, Type[] types = new Type[0]) per ottenere un metodo che non accetta parametri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1633">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</span>
          </span>
          <span data-ttu-id="4ee8d-1634">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1634">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1635">
            <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1635">
              <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-1636">Se <c>types</c> è <see langword="null" />, gli argomenti non corrispondono.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1636">If <c>types</c> is <see langword="null" />, arguments are not matched.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="4ee8d-1637">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresenta gli attributi associati all'elemento corrispondente nella matrice <c>types</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1637">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="4ee8d-1638">Questo parametro non viene elaborato dal binder predefinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1638">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1639">Quando ne viene eseguito l'override in una classe derivata, cerca il metodo specificato i cui parametri corrispondono ai modificatori e ai tipi di argomento definiti, usando i vincoli di associazione e la convenzione di denominazione specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1639">When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1640">Oggetto che rappresenta il metodo corrispondente ai requisiti specificati, se presente; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1640">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1641">Anche se il binder predefinito elabora <xref:System.Reflection.ParameterModifier> (la `modifiers` parametro), è possibile usare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per scrivere un binder personalizzato che elaborano `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1641">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="4ee8d-1642">`ParameterModifier` viene usato solo quando si chiama tramite l'interoperabilità COM, e vengono gestiti solo i parametri che vengono passati per riferimento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1642">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="4ee8d-1643">Se `types` è `null`, gli argomenti non corrispondono.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1643">If `types` is `null`, arguments are not matched.</span></span>  
  
 <span data-ttu-id="4ee8d-1644">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire i metodi da includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1644">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-1645">È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1645">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-1646">Specificare `BindingFlags.Public` da includere nella ricerca i metodi pubblici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1646">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1647">Specificare `BindingFlags.NonPublic` da includere nella ricerca i metodi non pubblici (vale a dire metodi privati, interni e protetti).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1647">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1648">Specificare `BindingFlags.FlattenHierarchy` da includere `public` e `protected` membri statici nella gerarchia; `private` non sono inclusi i membri statici nelle classi ereditate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1648">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="4ee8d-1649">Nell'esempio <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare il comportamento della ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1649">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="4ee8d-1650">`BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1650">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="4ee8d-1651">`BindingFlags.DeclaredOnly` Per cercare solo i metodi dichiarati nel <xref:System.Type>, non i metodi ereditati sono semplicemente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1651">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="4ee8d-1652">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1652">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="4ee8d-1653">È stato trovato più di un metodo con il nome specificato e corrispondente ai vincoli di associazione specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1653">More than one method is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-1654">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1654">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-1655">
            <paramref name="types" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1655">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="4ee8d-1656">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1656">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1657">
            <paramref name="modifiers" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1657">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="4ee8d-1658">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1658">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1659">
            <paramref name="types" /> e <paramref name="modifiers" /> non hanno la stessa lunghezza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1659">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="4ee8d-1660">Il tipo corrente è un oggetto <see cref="T:System.Reflection.Emit.TypeBuilder" /> o <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1660">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-1661">Ottiene i metodi dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1661">Gets the methods of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-1662">Restituisce tutti i metodi pubblici dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1662">Returns all the public methods of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1663">Matrice di oggetti <see cref="T:System.Reflection.MethodInfo" /> che rappresentano tutti i metodi pubblici definiti per l'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1663">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the public methods defined for the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="4ee8d-1664">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1664">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1665">Matrice vuota di tipo <see cref="T:System.Reflection.MethodInfo" />, se non sono definiti metodi pubblici per l'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1665">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no public methods are defined for the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1666">Il <xref:System.Type.GetMethods%2A> metodo non restituisce i metodi in un ordine specifico, ad esempio in ordine alfabetico o un ordine di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1666">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="4ee8d-1667">Il codice non deve dipendere dall'ordine in cui vengono restituiti i metodi, perché che varia in base di order.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1667">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="4ee8d-1668">I costruttori non sono inclusi nella matrice di metodi restituiti da questa chiamata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1668">Constructors are not included in the array of methods returned by this call.</span></span> <span data-ttu-id="4ee8d-1669">Eseguire una chiamata separata a `GetConstructors()` per ottenere i metodi del costruttore.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1669">Make a separate call to `GetConstructors()` to get the constructor methods.</span></span>  
  
 <span data-ttu-id="4ee8d-1670">La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1670">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="4ee8d-1671">Tipo di membro</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1671">Member Type</span></span>|<span data-ttu-id="4ee8d-1672">Static</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1672">Static</span></span>|<span data-ttu-id="4ee8d-1673">Non statici</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1673">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="4ee8d-1674">Costruttore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1674">Constructor</span></span>|<span data-ttu-id="4ee8d-1675">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1675">No</span></span>|<span data-ttu-id="4ee8d-1676">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1676">No</span></span>|  
|<span data-ttu-id="4ee8d-1677">Campo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1677">Field</span></span>|<span data-ttu-id="4ee8d-1678">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1678">No</span></span>|<span data-ttu-id="4ee8d-1679">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1679">Yes.</span></span> <span data-ttu-id="4ee8d-1680">Un campo viene sempre hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1680">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-1681">event</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1681">Event</span></span>|<span data-ttu-id="4ee8d-1682">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1682">Not applicable</span></span>|<span data-ttu-id="4ee8d-1683">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1683">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-1684">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1684">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1685">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1685">See note 2 below.</span></span>|  
|<span data-ttu-id="4ee8d-1686">Metodo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1686">Method</span></span>|<span data-ttu-id="4ee8d-1687">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1687">No</span></span>|<span data-ttu-id="4ee8d-1688">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1688">Yes.</span></span> <span data-ttu-id="4ee8d-1689">Un metodo (virtuale e non virtuale) può essere hide-by-name o hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1689">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-1690">Tipo annidato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1690">Nested Type</span></span>|<span data-ttu-id="4ee8d-1691">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1691">No</span></span>|<span data-ttu-id="4ee8d-1692">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1692">No</span></span>|  
|<span data-ttu-id="4ee8d-1693">Proprietà</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1693">Property</span></span>|<span data-ttu-id="4ee8d-1694">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1694">Not applicable</span></span>|<span data-ttu-id="4ee8d-1695">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1695">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-1696">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1696">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1697">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1697">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="4ee8d-1698">Hide-by-name-e-signature prende in considerazione tutte le parti della firma, inclusi i modificatori personalizzati, i tipi restituiti, i tipi di parametri, elementi sentinel e le convenzioni di chiamata non gestite.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1698">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="4ee8d-1699">Si tratta di un confronto binario.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1699">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="4ee8d-1700">Per la reflection, proprietà ed eventi sono hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1700">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1701">Se si dispone di una proprietà con una richiesta get e una funzione di accesso set nella classe di base, ma la classe derivata ha solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter della classe base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1701">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="4ee8d-1702">Gli attributi personalizzati non fanno parte di common type system.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1702">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1703">Non è possibile omettere i parametri durante la ricerca di costruttori e metodi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1703">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="4ee8d-1704">È possibile omettere i parametri solo quando viene richiamato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1704">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="4ee8d-1705">Se l'oggetto T:System.Type corrente rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MethodInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1705">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1706">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o metodo generico, questo metodo vengono cercati i metodi del vincolo di classe o i metodi di <xref:System.Object> se è presente alcun vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1706">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-1707">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1707">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-1708">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1708">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1709">Zero, per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1709">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1710">Quando ne viene eseguito l'override in una classe derivata, cerca i metodi definiti per l'oggetto <see cref="T:System.Type" /> corrente, usando i vincoli di binding specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1710">When overridden in a derived class, searches for the methods defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1711">Matrice di oggetti <see cref="T:System.Reflection.MethodInfo" /> che rappresentano tutti i metodi definiti per l'oggetto <see cref="T:System.Type" /> corrente, corrispondente ai vincoli di binding specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1711">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all methods defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="4ee8d-1712">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1712">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1713">Matrice vuota di tipo <see cref="T:System.Reflection.MethodInfo" />, se non è definito alcun metodo per l'oggetto <see cref="T:System.Type" /> corrente oppure se nessuno dei metodi definiti corrisponde ai vincoli di binding.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1713">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no methods are defined for the current <see cref="T:System.Type" />, or if none of the defined methods match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1714">Il <xref:System.Type.GetMethods%2A> metodo non restituisce i metodi in un ordine specifico, ad esempio in ordine alfabetico o un ordine di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1714">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="4ee8d-1715">Il codice non deve dipendere dall'ordine in cui vengono restituiti i metodi, perché che varia in base di order.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1715">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="4ee8d-1716">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire i metodi da includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1716">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-1717">È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1717">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-1718">Specificare `BindingFlags.Public` da includere nella ricerca i metodi pubblici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1718">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1719">Specificare `BindingFlags.NonPublic` da includere nella ricerca i metodi non pubblici (vale a dire metodi privati, interni e protetti).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1719">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span> <span data-ttu-id="4ee8d-1720">Solo protetti e interni metodi delle classi base vengono restituiti; metodi privati nelle classi di base non vengono restituiti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1720">Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="4ee8d-1721">Specificare `BindingFlags.FlattenHierarchy` da includere `public` e `protected` membri statici nella gerarchia; `private` non sono inclusi i membri statici nelle classi ereditate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1721">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="4ee8d-1722">Nell'esempio <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare il comportamento della ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1722">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="4ee8d-1723">`BindingFlags.DeclaredOnly` Per cercare solo i metodi dichiarati nel <xref:System.Type>, non i metodi ereditati sono semplicemente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1723">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="4ee8d-1724">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1724">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1725">Non è possibile omettere i parametri durante la ricerca di costruttori e metodi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1725">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="4ee8d-1726">È possibile omettere i parametri solo quando viene richiamato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1726">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="4ee8d-1727">Se l'oggetto T:System.Type corrente rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.MethodInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1727">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1728">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o metodo generico, questo metodo vengono cercati i metodi del vincolo di classe o i metodi di <xref:System.Object> se è presente alcun vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1728">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1729">Nell'esempio seguente crea una classe con due metodi pubblici e un metodo protetto, crea una `Type` oggetto corrispondente a `MyTypeClass`Ottiene tutti i metodi non pubblici ed e consente di visualizzare i relativi nomi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1729">The following example creates a class with two public methods and one protected method, creates a `Type` object corresponding to `MyTypeClass`, gets all public and non-public methods, and displays their names.</span></span>  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-1730">Ottiene un tipo specifico annidato all'interno dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1730">Gets a specific type nested within the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-1731">Stringa che contiene il nome del tipo annidato da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1731">The string containing the name of the nested type to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1732">Cerca il tipo annidato pubblico con il nome specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1732">Searches for the public nested type with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1733">Oggetto che rappresenta il tipo annidato pubblico con il nome specificato, se disponibile; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1733">An object representing the public nested type with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1734">La ricerca di `name` tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1734">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="4ee8d-1735">Usare il nome semplice della classe annidata per `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1735">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="4ee8d-1736">Non sono idonee, con il nome della classe esterna.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1736">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="4ee8d-1737">Per una classe annidata di tipo generica, usare il nome modificato, vale a dire, aggiungere un accento grave e il numero di argomenti generici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1737">For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic arguments.</span></span> <span data-ttu-id="4ee8d-1738">Ad esempio, usare la stringa "interna\`1" per ottenere il tipo generico classe annidata `Inner<T>` (`Inner(Of T)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1738">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="4ee8d-1739">Non includere la sintassi specifica del linguaggio per i parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1739">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="4ee8d-1740">La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1740">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="4ee8d-1741">Tipo di membro</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1741">Member Type</span></span>|<span data-ttu-id="4ee8d-1742">Static</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1742">Static</span></span>|<span data-ttu-id="4ee8d-1743">Non statici</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1743">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="4ee8d-1744">Costruttore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1744">Constructor</span></span>|<span data-ttu-id="4ee8d-1745">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1745">No</span></span>|<span data-ttu-id="4ee8d-1746">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1746">No</span></span>|  
|<span data-ttu-id="4ee8d-1747">Campo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1747">Field</span></span>|<span data-ttu-id="4ee8d-1748">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1748">No</span></span>|<span data-ttu-id="4ee8d-1749">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1749">Yes.</span></span> <span data-ttu-id="4ee8d-1750">Un campo viene sempre hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1750">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-1751">event</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1751">Event</span></span>|<span data-ttu-id="4ee8d-1752">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1752">Not applicable</span></span>|<span data-ttu-id="4ee8d-1753">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1753">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-1754">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1754">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1755">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1755">See note 2 below.</span></span>|  
|<span data-ttu-id="4ee8d-1756">Metodo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1756">Method</span></span>|<span data-ttu-id="4ee8d-1757">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1757">No</span></span>|<span data-ttu-id="4ee8d-1758">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1758">Yes.</span></span> <span data-ttu-id="4ee8d-1759">Un metodo (virtuale e non virtuale) può essere hide-by-name o hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1759">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-1760">Tipo annidato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1760">Nested Type</span></span>|<span data-ttu-id="4ee8d-1761">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1761">No</span></span>|<span data-ttu-id="4ee8d-1762">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1762">No</span></span>|  
|<span data-ttu-id="4ee8d-1763">Proprietà</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1763">Property</span></span>|<span data-ttu-id="4ee8d-1764">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1764">Not applicable</span></span>|<span data-ttu-id="4ee8d-1765">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1765">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-1766">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1766">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1767">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1767">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="4ee8d-1768">Hide-by-name-e-signature prende in considerazione tutte le parti della firma, inclusi i modificatori personalizzati, i tipi restituiti, i tipi di parametri, elementi sentinel e le convenzioni di chiamata non gestite.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1768">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="4ee8d-1769">Si tratta di un confronto binario.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1769">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="4ee8d-1770">Per la reflection, proprietà ed eventi sono hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1770">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1771">Se si dispone di una proprietà con una richiesta get e una funzione di accesso set nella classe di base, ma la classe derivata ha solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter della classe base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1771">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="4ee8d-1772">Gli attributi personalizzati non fanno parte di common type system.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1772">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="4ee8d-1773">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cercherà i tipi annidati del vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1773">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="4ee8d-1774">Se un tipo annidato è generico, questo metodo restituisce la definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1774">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="4ee8d-1775">Questo vale anche se il tipo generico contenitore è un tipo costruito chiuso.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1775">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1776">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico definito in c#, Visual Basic o C++, relativi tipi annidati sono tutti generici anche se non dispongono i propri parametri generici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1776">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="4ee8d-1777">Questo non vale necessariamente per i tipi annidati definiti in assembly dinamici o compilati con il [Ilasm.exe (Assembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1777">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="4ee8d-1778">Per informazioni sui tipi generici annidati e sulla creazione di tipi generici annidati dalle relative definizioni di tipo generico, vedere <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1778">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-1779">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1779">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-1780">Stringa che contiene il nome del tipo annidato da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1780">The string containing the name of the nested type to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-1781">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1781">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-1782">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1782">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1783">Zero, per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1783">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1784">Quando ne viene eseguito l'override in una classe derivata, cerca il tipo annidato specificato, usando i vincoli di binding specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1784">When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1785">Oggetto che rappresenta il tipo annidato corrispondente ai requisiti specificati, se è stato trovato; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1785">An object representing the nested type that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1786">Usare il nome semplice della classe annidata per `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1786">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="4ee8d-1787">Non sono idonee, con il nome della classe esterna.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1787">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="4ee8d-1788">Per una classe annidata di tipo generica, usare il nome modificato, vale a dire, aggiungere un accento grave e il numero di parametri generici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1788">For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic parameters.</span></span> <span data-ttu-id="4ee8d-1789">Ad esempio, usare la stringa "interna\`1" per ottenere il tipo generico classe annidata `Inner<T>` (`Inner(Of T)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1789">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="4ee8d-1790">Non includere la sintassi specifica del linguaggio per i parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1790">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="4ee8d-1791">Nell'esempio <xref:System.Reflection.BindingFlags> filtro flag possono essere utilizzati per definire annidati di tipi da includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1791">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-1792">È necessario specificare <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> o <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> per ottenere un risultato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1792">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-1793">Specificare <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> includere tipi public annidati nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1793">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1794">Specificare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> da includere nella ricerca i tipi annidati pubblici (vale a dire, privati, interni e protetti i tipi annidati).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1794">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="4ee8d-1795">Questo metodo restituisce solo i tipi annidati del tipo corrente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1795">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="4ee8d-1796">Le classi di base del tipo corrente non vengono eseguite ricerche.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1796">It does not search the base classes of the current type.</span></span> <span data-ttu-id="4ee8d-1797">Per individuare i tipi annidati nelle classi di base, è necessario seguire la gerarchia di ereditarietà, la chiamata <xref:System.Type.GetNestedType%2A> a ogni livello.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1797">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedType%2A> at each level.</span></span>  
  
 <span data-ttu-id="4ee8d-1798"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> e <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> vengono ignorati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1798"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="4ee8d-1799">Chiamare questo metodo solo con il <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag o solo il <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag restituirà tipi annidati specificati e non richiede la eventuali altri flag.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1799">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="4ee8d-1800">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1800">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="4ee8d-1801">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cercherà i tipi annidati del vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1801">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="4ee8d-1802">Se un tipo annidato è generico, questo metodo restituisce la definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1802">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="4ee8d-1803">Questo vale anche se il tipo generico contenitore è un tipo costruito chiuso.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1803">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1804">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico definito in c#, Visual Basic o C++, relativi tipi annidati sono tutti generici anche se non dispongono i propri parametri generici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1804">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="4ee8d-1805">Questo non vale necessariamente per i tipi annidati definiti in assembly dinamici o compilati con il [Ilasm.exe (Assembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1805">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="4ee8d-1806">Per informazioni sui tipi generici annidati e sulla creazione di tipi generici annidati dalle relative definizioni di tipo generico, vedere <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1806">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-1807">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1807">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-1808">Ottiene i tipi annidati all'interno dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1808">Gets the types nested within the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-1809">Restituisce i tipi pubblici annidati all'interno dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1809">Returns the public types nested in the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1810">Matrice di oggetti <see cref="T:System.Type" /> che rappresenta i tipi pubblici annidati nell'oggetto <see cref="T:System.Type" /> corrente (la ricerca non è ricorsiva), oppure matrice vuota di tipo <see cref="T:System.Type" /> se nessun tipo pubblico è annidato nell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1810">An array of <see cref="T:System.Type" /> objects representing the public types nested in the current <see cref="T:System.Type" /> (the search is not recursive), or an empty array of type <see cref="T:System.Type" /> if no public types are nested in the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1811">Il <xref:System.Type.GetNestedTypes%2A> metodo non restituisce i tipi in un ordine specifico, ad esempio in ordine alfabetico o un ordine di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1811">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="4ee8d-1812">Il codice non deve dipendere dall'ordine in cui vengono restituiti tipi, perché che varia in base di order.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1812">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="4ee8d-1813">Vengono restituiti solo i tipi pubblici annidati immediatamente nel tipo corrente; la ricerca non è ricorsiva.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1813">Only the public types immediately nested in the current type are returned; the search is not recursive.</span></span>  
  
 <span data-ttu-id="4ee8d-1814">La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1814">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="4ee8d-1815">Tipo di membro</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1815">Member Type</span></span>|<span data-ttu-id="4ee8d-1816">Static</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1816">Static</span></span>|<span data-ttu-id="4ee8d-1817">Non statici</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1817">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="4ee8d-1818">Costruttore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1818">Constructor</span></span>|<span data-ttu-id="4ee8d-1819">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1819">No</span></span>|<span data-ttu-id="4ee8d-1820">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1820">No</span></span>|  
|<span data-ttu-id="4ee8d-1821">Campo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1821">Field</span></span>|<span data-ttu-id="4ee8d-1822">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1822">No</span></span>|<span data-ttu-id="4ee8d-1823">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1823">Yes.</span></span> <span data-ttu-id="4ee8d-1824">Un campo viene sempre hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1824">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-1825">event</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1825">Event</span></span>|<span data-ttu-id="4ee8d-1826">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1826">Not applicable</span></span>|<span data-ttu-id="4ee8d-1827">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1827">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-1828">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1828">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1829">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1829">See note 2 below.</span></span>|  
|<span data-ttu-id="4ee8d-1830">Metodo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1830">Method</span></span>|<span data-ttu-id="4ee8d-1831">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1831">No</span></span>|<span data-ttu-id="4ee8d-1832">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1832">Yes.</span></span> <span data-ttu-id="4ee8d-1833">Un metodo (virtuale e non virtuale) può essere hide-by-name o hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1833">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-1834">Tipo annidato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1834">Nested Type</span></span>|<span data-ttu-id="4ee8d-1835">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1835">No</span></span>|<span data-ttu-id="4ee8d-1836">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1836">No</span></span>|  
|<span data-ttu-id="4ee8d-1837">Proprietà</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1837">Property</span></span>|<span data-ttu-id="4ee8d-1838">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1838">Not applicable</span></span>|<span data-ttu-id="4ee8d-1839">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1839">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-1840">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1840">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1841">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1841">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="4ee8d-1842">Hide-by-name-e-signature prende in considerazione tutte le parti della firma, inclusi i modificatori personalizzati, i tipi restituiti, i tipi di parametri, elementi sentinel e le convenzioni di chiamata non gestite.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1842">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="4ee8d-1843">Si tratta di un confronto binario.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1843">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="4ee8d-1844">Per la reflection, proprietà ed eventi sono hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1844">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1845">Se si dispone di una proprietà con una richiesta get e una funzione di accesso set nella classe di base, ma la classe derivata ha solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter della classe base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1845">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="4ee8d-1846">Gli attributi personalizzati non fanno parte di common type system.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1846">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="4ee8d-1847">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cercherà i tipi annidati del vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1847">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="4ee8d-1848">Se un tipo annidato è generico, questo metodo restituisce la definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1848">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="4ee8d-1849">Questo vale anche se il tipo generico contenitore è un tipo costruito chiuso.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1849">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1850">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico definito in c#, Visual Basic o C++, relativi tipi annidati sono tutti generici anche se non dispongono i propri parametri generici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1850">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="4ee8d-1851">Questo non vale necessariamente per i tipi annidati definiti in assembly dinamici o compilati con il [Ilasm.exe (Assembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1851">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="4ee8d-1852">Per informazioni sui tipi generici annidati e sulla creazione di tipi generici annidati dalle relative definizioni di tipo generico, vedere <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1852">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1853">L'esempio seguente definisce una classe annidata e un `struct` nelle `MyClass`e quindi Ottiene gli oggetti di tipi annidati usando il tipo di `MyClass`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1853">The following example defines a nested class and a `struct` in `MyClass`, and then obtains objects of the nested types using the type of `MyClass`.</span></span>  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-1854">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1854">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-1855">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1855">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1856">Zero, per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1856">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1857">Quando ne viene eseguito l'override in una classe derivata, cerca i tipi annidati nell'oggetto <see cref="T:System.Type" /> corrente, usando i vincoli di binding specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1857">When overridden in a derived class, searches for the types nested in the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1858">Matrice di oggetti <see cref="T:System.Type" /> che rappresenta tutti i tipi annidati nell'oggetto <see cref="T:System.Type" /> corrente che corrispondono ai vincoli di binding specificati (la ricerca non è ricorsiva), oppure matrice vuota di tipo <see cref="T:System.Type" />, se non viene trovato alcun tipo annidato che corrisponde ai vincoli di binding.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1858">An array of <see cref="T:System.Type" /> objects representing all the types nested in the current <see cref="T:System.Type" /> that match the specified binding constraints (the search is not recursive), or an empty array of type <see cref="T:System.Type" />, if no nested types are found that match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1859">La ricerca per i tipi annidati non è ricorsiva.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1859">The search for nested types is not recursive.</span></span>  
  
 <span data-ttu-id="4ee8d-1860">Il <xref:System.Type.GetNestedTypes%2A> metodo non restituisce i tipi in un ordine specifico, ad esempio in ordine alfabetico o un ordine di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1860">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="4ee8d-1861">Il codice non deve dipendere dall'ordine in cui vengono restituiti tipi, perché che varia in base di order.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1861">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="4ee8d-1862">Nell'esempio <xref:System.Reflection.BindingFlags> filtro flag possono essere utilizzati per definire annidati di tipi da includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1862">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-1863">È necessario specificare <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> o <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> per ottenere un risultato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1863">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-1864">Specificare <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> includere tipi public annidati nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1864">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1865">Specificare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> da includere nella ricerca i tipi annidati pubblici (vale a dire, privati, interni e protetti i tipi annidati).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1865">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="4ee8d-1866">Questo metodo restituisce solo i tipi annidati del tipo corrente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1866">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="4ee8d-1867">Le classi di base del tipo corrente non vengono eseguite ricerche.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1867">It does not search the base classes of the current type.</span></span> <span data-ttu-id="4ee8d-1868">Per individuare i tipi annidati nelle classi di base, è necessario seguire la gerarchia di ereditarietà, la chiamata <xref:System.Type.GetNestedTypes%2A> a ogni livello.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1868">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedTypes%2A> at each level.</span></span>  
  
 <span data-ttu-id="4ee8d-1869"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> e <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> vengono ignorati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1869"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="4ee8d-1870">Chiamare questo metodo solo con il <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag o solo il <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag restituirà tipi annidati specificati e non richiede la eventuali altri flag.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1870">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="4ee8d-1871">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1871">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="4ee8d-1872">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cercherà i tipi annidati del vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1872">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="4ee8d-1873">Se un tipo annidato è generico, questo metodo restituisce la definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1873">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="4ee8d-1874">Questo vale anche se il tipo generico contenitore è un tipo costruito chiuso.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1874">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-1875">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico definito in c#, Visual Basic o C++, relativi tipi annidati sono tutti generici anche se non dispongono i propri parametri generici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1875">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="4ee8d-1876">Questo non vale necessariamente per i tipi annidati definiti in assembly dinamici o compilati con il [Ilasm.exe (Assembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1876">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="4ee8d-1877">Per informazioni sui tipi generici annidati e sulla creazione di tipi generici annidati dalle relative definizioni di tipo generico, vedere <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1877">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1878">Nell'esempio seguente crea due classi pubbliche annidate e due classi nidificate protette e visualizza le informazioni per le classi che corrisponde ai vincoli di binding specificati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1878">The following example creates two nested public classes and two nested protected classes, and displays information for classes that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-1879">Ottiene le proprietà dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1879">Gets the properties of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-1880">Restituisce tutte le proprietà pubbliche dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1880">Returns all the public properties of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1881">Matrice di oggetti <see cref="T:System.Reflection.PropertyInfo" /> che rappresentano tutte le proprietà pubbliche dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1881">An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all public properties of the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="4ee8d-1882">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1882">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1883">Matrice vuota di tipo <see cref="T:System.Reflection.PropertyInfo" />, se l'oggetto <see cref="T:System.Type" /> corrente non possiede delle proprietà pubbliche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1883">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have public properties.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1884">Chiamare questo overload equivale a chiamare il <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> rapporto di overload con un `bindingAttr` uguale all'argomento `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in c# e `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1884">Calling this overload is equivalent to calling the <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> overload with a `bindingAttr` argument equal to `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in C# and  `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic.</span></span> <span data-ttu-id="4ee8d-1885">Restituisce tutte le istanza pubblici e proprietà statiche, sia quelle definite dal tipo rappresentato dall'oggetto corrente <xref:System.Type> oggetto nonché quelle ereditate dai relativi tipi di base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1885">It returns all public instance and static properties, both those defined by the type represented by the current <xref:System.Type> object as well as those inherited from its base types.</span></span>  
  
 <span data-ttu-id="4ee8d-1886">Una proprietà è considerata pubblica per la reflection se dispone di almeno una funzione di accesso pubblico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1886">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="4ee8d-1887">In caso contrario, la proprietà viene considerata privata ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerla.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1887">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="4ee8d-1888">Il <xref:System.Type.GetProperties%2A> metodo non restituisce le proprietà in un ordine specifico, ad esempio in ordine alfabetico o un ordine di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1888">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="4ee8d-1889">Il codice non deve dipendere dall'ordine in cui vengono restituite le proprietà, perché che varia in base di order.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1889">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="4ee8d-1890">La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1890">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="4ee8d-1891">Tipo di membro</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1891">Member Type</span></span>|<span data-ttu-id="4ee8d-1892">Static</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1892">Static</span></span>|<span data-ttu-id="4ee8d-1893">Non statici</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1893">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="4ee8d-1894">Costruttore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1894">Constructor</span></span>|<span data-ttu-id="4ee8d-1895">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1895">No</span></span>|<span data-ttu-id="4ee8d-1896">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1896">No</span></span>|  
|<span data-ttu-id="4ee8d-1897">Campo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1897">Field</span></span>|<span data-ttu-id="4ee8d-1898">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1898">No</span></span>|<span data-ttu-id="4ee8d-1899">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1899">Yes.</span></span> <span data-ttu-id="4ee8d-1900">Un campo viene sempre hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1900">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-1901">event</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1901">Event</span></span>|<span data-ttu-id="4ee8d-1902">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1902">Not applicable</span></span>|<span data-ttu-id="4ee8d-1903">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1903">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-1904">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1904">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1905">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1905">See note 2 below.</span></span>|  
|<span data-ttu-id="4ee8d-1906">Metodo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1906">Method</span></span>|<span data-ttu-id="4ee8d-1907">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1907">No</span></span>|<span data-ttu-id="4ee8d-1908">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1908">Yes.</span></span> <span data-ttu-id="4ee8d-1909">Un metodo (virtuale e non virtuale) può essere hide-by-name o hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1909">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-1910">Tipo annidato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1910">Nested Type</span></span>|<span data-ttu-id="4ee8d-1911">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1911">No</span></span>|<span data-ttu-id="4ee8d-1912">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1912">No</span></span>|  
|<span data-ttu-id="4ee8d-1913">Proprietà</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1913">Property</span></span>|<span data-ttu-id="4ee8d-1914">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1914">Not applicable</span></span>|<span data-ttu-id="4ee8d-1915">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1915">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-1916">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1916">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1917">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1917">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="4ee8d-1918">Hide-by-name-e-signature prende in considerazione tutte le parti della firma, inclusi i modificatori personalizzati, i tipi restituiti, i tipi di parametri, elementi sentinel e le convenzioni di chiamata non gestite.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1918">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="4ee8d-1919">Si tratta di un confronto binario.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1919">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="4ee8d-1920">Per la reflection, proprietà ed eventi sono hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1920">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-1921">Se si dispone di una proprietà con una richiesta get e una funzione di accesso set nella classe di base, ma la classe derivata ha solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter della classe base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1921">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="4ee8d-1922">Gli attributi personalizzati non fanno parte di common type system.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1922">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="4ee8d-1923">Se l'oggetto T:System.Type corrente rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.PropertyInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1923">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1924">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cercherà le proprietà del vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1924">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1925">Nell'esempio seguente viene illustrato l'uso del metodo `GetProperties`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1925">The following example demonstrates the use of the `GetProperties` method.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-1926">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1926">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-1927">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1927">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1928">Zero, per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1928">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1929">Quando ne viene eseguito l'override in una classe derivata, cerca le proprietà dell'oggetto <see cref="T:System.Type" /> corrente, usando i vincoli di binding specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1929">When overridden in a derived class, searches for the properties of the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1930">Matrice di oggetti <see cref="T:System.Reflection.PropertyInfo" /> che rappresenta tutte le proprietà dell'oggetto <see cref="T:System.Type" /> corrente corrispondenti ai vincoli di binding specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1930">An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all properties of the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="4ee8d-1931">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1931">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1932">Matrice vuota di tipo <see cref="T:System.Reflection.PropertyInfo" />, se l'oggetto <see cref="T:System.Type" /> corrente non dispone di proprietà oppure se nessuna delle proprietà corrisponde ai vincoli di binding.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1932">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have properties, or if none of the properties match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1933">Una proprietà è considerata pubblica per la reflection se dispone di almeno una funzione di accesso pubblico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1933">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="4ee8d-1934">In caso contrario, la proprietà viene considerata privata ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerla.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1934">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="4ee8d-1935">Il <xref:System.Type.GetProperties%2A> metodo non restituisce le proprietà in un ordine specifico, ad esempio in ordine alfabetico o un ordine di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1935">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="4ee8d-1936">Il codice non deve dipendere dall'ordine in cui vengono restituite le proprietà, perché che varia in base di order.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1936">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="4ee8d-1937">Nell'esempio <xref:System.Reflection.BindingFlags> filtro flag possono essere utilizzati per definire annidati di tipi da includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1937">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-1938">È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1938">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-1939">Specificare `BindingFlags.Public` per includere le proprietà pubbliche nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1939">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1940">Specificare `BindingFlags.NonPublic` da includere non proprietà pubbliche (vale a dire, privati, interni e protetto) nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1940">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span> <span data-ttu-id="4ee8d-1941">Solo protetti e vengono restituite le proprietà interne sulle classi di base; proprietà private in classi di base non vengono restituite.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1941">Only protected and internal properties on base classes are returned; private properties on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="4ee8d-1942">Specificare `BindingFlags.FlattenHierarchy` da includere `public` e `protected` membri statici nella gerarchia; `private` non sono inclusi i membri statici nelle classi ereditate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1942">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="4ee8d-1943">Nell'esempio <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare il comportamento della ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1943">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="4ee8d-1944">`BindingFlags.DeclaredOnly` eseguire la ricerca solo le proprietà dichiarate nel <xref:System.Type>, non le proprietà che sono stati semplicemente ereditate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1944">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="4ee8d-1945">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1945">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="4ee8d-1946">Una proprietà è considerata pubblica per la reflection se dispone di almeno una funzione di accesso pubblico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1946">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="4ee8d-1947">In caso contrario, la proprietà viene considerata privata ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerla.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1947">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="4ee8d-1948">Se l'oggetto T:System.Type corrente rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.PropertyInfo> oggetti con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1948">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1949">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cercherà le proprietà del vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1949">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1950">L'esempio seguente definisce una classe denominata `PropertyClass` che include sei proprietà: due sono pubblici, uno è privato, una cartella risulta protetta, uno è interno (`Friend` in Visual Basic), e una cartella risulta protetta interna (`Protected Friend` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1950">The following example defines a class named `PropertyClass` that includes six properties: two are public, one is private, one is protected, one is internal (`Friend` in Visual Basic), and one is protected internal (`Protected Friend` in Visual Basic).</span></span> <span data-ttu-id="4ee8d-1951">Quindi visualizza alcune informazioni di base della proprietà (il nome della proprietà e il tipo, se si tratta di lettura/scrittura e la visibilità del relativo `get` e `set` funzioni di accesso) per le proprietà corrispondenti ai vincoli di binding specificati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1951">It then displays some basic property information (the property name and type, whether it is read/write, and the visibility of its `get` and `set` accessors) for the properties that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-1952">Ottiene una proprietà specifica dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1952">Gets a specific property of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-1953">Stringa che contiene il nome della proprietà pubblica da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1953">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1954">Cerca la proprietà pubblica con il nome specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1954">Searches for the public property with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1955">Oggetto che rappresenta la proprietà pubblica con il nome specificato, se presente; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1955">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1956">La ricerca di `name` tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1956">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="4ee8d-1957">La ricerca include le proprietà di istanza pubblici statici e pubblici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1957">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="4ee8d-1958">Una proprietà è considerata pubblica per la reflection se dispone di almeno una funzione di accesso pubblico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1958">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="4ee8d-1959">In caso contrario, la proprietà viene considerata privata ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerla.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1959">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="4ee8d-1960">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.PropertyInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1960">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-1961">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cercherà le proprietà del vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1961">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="4ee8d-1962">Situazioni in cui <xref:System.Reflection.AmbiguousMatchException> si verifica includono quanto segue:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1962">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="4ee8d-1963">Un tipo contiene due proprietà indicizzate con lo stesso nome ma diversi numeri di parametri.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1963">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="4ee8d-1964">Per risolvere l'ambiguità, usare un overload del <xref:System.Type.GetProperty%2A> metodo che specifica i tipi di parametro.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1964">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="4ee8d-1965">Un tipo derivato dichiara una proprietà che consente di nascondere una proprietà ereditata con lo stesso nome, usando il `new` modificatore (`Shadows` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1965">A derived type declares a property that hides an inherited property with the same name, by using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="4ee8d-1966">Per risolvere l'ambiguità, usare il <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> metodo di overload e aggiungere il <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> flag per limitare la ricerca di membri che non vengono ereditati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1966">To resolve the ambiguity, use the <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> method overload and add the <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> flag to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="4ee8d-1967">Gli indicizzatori e proprietà predefinite</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1967">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="4ee8d-1968">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] hanno la sintassi semplificata per l'accesso alle proprietà indicizzate e consentire una proprietà indicizzata essere un valore predefinito per il relativo tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1968">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="4ee8d-1969">Ad esempio, se la variabile `myList` fa riferimento a un <xref:System.Collections.ArrayList>, la sintassi `myList[3]` (`myList(3)` in Visual Basic) recupera l'elemento con indice 3.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1969">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="4ee8d-1970">È possibile eseguire l'overload della proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1970">You can overload the property.</span></span>  
  
 <span data-ttu-id="4ee8d-1971">In c#, questa funzionalità viene chiamata un indicizzatore e non è possibile farvi riferimento in base al nome.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1971">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="4ee8d-1972">Per impostazione predefinita, un indicizzatore c# viene visualizzato nei metadati come una proprietà indicizzata denominata "Item".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1972">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="4ee8d-1973">Tuttavia, uno sviluppatore di libreria di classi è possibile usare il <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attributo per modificare il nome dell'indicizzatore nei metadati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1973">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="4ee8d-1974">Ad esempio, il <xref:System.String> classe dispone di un indicizzatore denominato <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1974">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="4ee8d-1975">Proprietà indicizzate create con linguaggi diversi da c# possono avere nomi diversi da elementi, nonché.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1975">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="4ee8d-1976">Per determinare se un tipo ha una proprietà predefinita, usare il <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metodo per testare il <xref:System.Reflection.DefaultMemberAttribute> attributo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1976">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="4ee8d-1977">Se il tipo ha <xref:System.Reflection.DefaultMemberAttribute>, il <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> proprietà restituisce il nome della proprietà predefinita.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1977">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-1978">Nell'esempio seguente recupera il `Type` recupera una proprietà di tale classe, oggetto di una classe definita dall'utente e visualizza il nome della proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1978">The following example retrieves the `Type` object of a user-defined class, retrieves a property of that class, and displays the property name.</span></span>  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 <span data-ttu-id="4ee8d-1979">Internamente, questa proprietà viene definita nei metadati con il nome "Elemento".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1979">Internally, this property is referred to in the metadata by the name "Item."</span></span> <span data-ttu-id="4ee8d-1980">Qualsiasi tentativo di ottenere `PropertyInfo` usando la reflection è necessario specificare questo nome interno per non restituire correttamente il `PropertyInfo` proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1980">Any attempt to get `PropertyInfo` using reflection must specify this internal name in order to correctly return the `PropertyInfo` property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="4ee8d-1981">È stata trovata più di una proprietà con il nome specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1981">More than one property is found with the specified name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-1982">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1982">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-1983">Stringa che contiene il nome della proprietà da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1983">The string containing the name of the property to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-1984">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1984">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-1985">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1985">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-1986">Zero, per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1986">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-1987">Cerca la proprietà specificata, usando i vincoli di associazione specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1987">Searches for the specified property, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-1988">Oggetto che rappresenta la proprietà corrispondente ai requisiti specificati, se presente; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-1988">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-1989">Una proprietà è considerata pubblica per la reflection se dispone di almeno una funzione di accesso pubblico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1989">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="4ee8d-1990">In caso contrario, la proprietà viene considerata privata ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerla.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1990">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="4ee8d-1991">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire le proprietà da includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1991">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-1992">È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1992">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-1993">Specificare `BindingFlags.Public` per includere le proprietà pubbliche nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1993">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1994">Specificare `BindingFlags.NonPublic` da includere non proprietà pubbliche (vale a dire, privati, interni e protetto) nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1994">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-1995">Specificare `BindingFlags.FlattenHierarchy` da includere `public` e `protected` membri statici nella gerarchia; `private` non sono inclusi i membri statici nelle classi ereditate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1995">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="4ee8d-1996">Nell'esempio <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare il comportamento della ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1996">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="4ee8d-1997">`BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1997">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="4ee8d-1998">`BindingFlags.DeclaredOnly` eseguire la ricerca solo le proprietà dichiarate nel <xref:System.Type>, non le proprietà che sono stati semplicemente ereditate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1998">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="4ee8d-1999">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-1999">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="4ee8d-2000">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.PropertyInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2000">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-2001">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cercherà le proprietà del vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2001">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="4ee8d-2002">Situazioni in cui <xref:System.Reflection.AmbiguousMatchException> si verifica includono quanto segue:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2002">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="4ee8d-2003">Un tipo contiene due proprietà indicizzate con lo stesso nome ma diversi numeri di parametri.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2003">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="4ee8d-2004">Per risolvere l'ambiguità, usare un overload del <xref:System.Type.GetProperty%2A> metodo che specifica i tipi di parametro.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2004">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="4ee8d-2005">Un tipo derivato dichiara una proprietà che consente di nascondere una proprietà ereditata con lo stesso nome, usando il `new` modificatore (`Shadows` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2005">A derived type declares a property that hides an inherited property with the same name, using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="4ee8d-2006">Per risolvere l'ambiguità, includere <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> per limitare la ricerca di membri che non vengono ereditati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2006">To resolve the ambiguity, include <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="4ee8d-2007">Gli indicizzatori e proprietà predefinite</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2007">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="4ee8d-2008">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] hanno la sintassi semplificata per l'accesso alle proprietà indicizzate e consentire una proprietà indicizzata essere un valore predefinito per il relativo tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2008">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="4ee8d-2009">Ad esempio, se la variabile `myList` fa riferimento a un <xref:System.Collections.ArrayList>, la sintassi `myList[3]` (`myList(3)` in Visual Basic) recupera l'elemento con indice 3.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2009">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="4ee8d-2010">È possibile eseguire l'overload della proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2010">You can overload the property.</span></span>  
  
 <span data-ttu-id="4ee8d-2011">In c#, questa funzionalità viene chiamata un indicizzatore e non è possibile farvi riferimento in base al nome.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2011">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="4ee8d-2012">Per impostazione predefinita, un indicizzatore c# viene visualizzato nei metadati come una proprietà indicizzata denominata "Item".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2012">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="4ee8d-2013">Tuttavia, uno sviluppatore di libreria di classi è possibile usare il <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attributo per modificare il nome dell'indicizzatore nei metadati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2013">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="4ee8d-2014">Ad esempio, il <xref:System.String> classe dispone di un indicizzatore denominato <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2014">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="4ee8d-2015">Proprietà indicizzate create con linguaggi diversi da c# possono avere nomi diversi da elementi, nonché.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2015">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="4ee8d-2016">Per determinare se un tipo ha una proprietà predefinita, usare il <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metodo per testare il <xref:System.Reflection.DefaultMemberAttribute> attributo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2016">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="4ee8d-2017">Se il tipo ha <xref:System.Reflection.DefaultMemberAttribute>, il <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> proprietà restituisce il nome della proprietà predefinita.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2017">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-2018">Nell'esempio seguente recupera il tipo di una classe definita dall'utente, viene recuperata una proprietà di tale classe e visualizza il nome della proprietà in base ai vincoli di binding specificati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2018">The following example retrieves the type of a user-defined class, retrieves a property of that class and displays the property name in accordance with the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="4ee8d-2019">È stata trovata più di una proprietà con il nome specificato e corrispondente ai vincoli di associazione specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2019">More than one property is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-2020">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2020">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-2021">Stringa che contiene il nome della proprietà pubblica da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2021">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="4ee8d-2022">Tipo restituito della proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2022">The return type of the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-2023">Cerca la proprietà pubblica con il nome e il tipo restituito specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2023">Searches for the public property with the specified name and return type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-2024">Oggetto che rappresenta la proprietà pubblica con il nome specificato, se presente; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2024">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-2025">Una proprietà è considerata pubblica per la reflection se dispone di almeno una funzione di accesso pubblico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2025">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="4ee8d-2026">In caso contrario, la proprietà viene considerata privata ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerla.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2026">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="4ee8d-2027">La ricerca di `name` tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2027">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="4ee8d-2028">La ricerca include le proprietà di istanza pubblici statici e pubblici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2028">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="4ee8d-2029">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.PropertyInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2029">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-2030">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cercherà le proprietà del vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2030">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="4ee8d-2031">Gli indicizzatori e proprietà predefinite</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2031">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="4ee8d-2032">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] hanno la sintassi semplificata per l'accesso alle proprietà indicizzate e consentire una proprietà indicizzata essere un valore predefinito per il relativo tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2032">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="4ee8d-2033">Ad esempio, se la variabile `myList` fa riferimento a un <xref:System.Collections.ArrayList>, la sintassi `myList[3]` (`myList(3)` in Visual Basic) recupera l'elemento con indice 3.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2033">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="4ee8d-2034">È possibile eseguire l'overload della proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2034">You can overload the property.</span></span>  
  
 <span data-ttu-id="4ee8d-2035">In c#, questa funzionalità viene chiamata un indicizzatore e non è possibile farvi riferimento in base al nome.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2035">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="4ee8d-2036">Per impostazione predefinita, un indicizzatore c# viene visualizzato nei metadati come una proprietà indicizzata denominata "Item".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2036">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="4ee8d-2037">Tuttavia, uno sviluppatore di libreria di classi è possibile usare il <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attributo per modificare il nome dell'indicizzatore nei metadati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2037">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="4ee8d-2038">Ad esempio, il <xref:System.String> classe dispone di un indicizzatore denominato <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2038">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="4ee8d-2039">Proprietà indicizzate create con linguaggi diversi da c# possono avere nomi diversi da elementi, nonché.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2039">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="4ee8d-2040">Per determinare se un tipo ha una proprietà predefinita, usare il <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metodo per testare il <xref:System.Reflection.DefaultMemberAttribute> attributo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2040">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="4ee8d-2041">Se il tipo ha <xref:System.Reflection.DefaultMemberAttribute>, il <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> proprietà restituisce il nome della proprietà predefinita.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2041">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-2042">Nell'esempio seguente definisce una classe con una proprietà e recupera il nome e tipo della proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2042">The following example defines a class with one property and retrieves the name and type of the property.</span></span>  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="4ee8d-2043">È stata trovata più di una proprietà con il nome specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2043">More than one property is found with the specified name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-2044">
            <paramref name="name" /> è <see langword="null" /> o <paramref name="returnType" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2044">
              <paramref name="name" /> is <see langword="null" />, or <paramref name="returnType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-2045">Stringa che contiene il nome della proprietà pubblica da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2045">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="4ee8d-2046">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano numero, ordine e tipo dei parametri relativi alla proprietà indicizzata da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2046">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="4ee8d-2047">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2047">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2048">Matrice vuota di tipo <see cref="T:System.Type" /> (ovvero, Type[] types = new Type[0]) per ottenere una proprietà non indicizzata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2048">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-2049">Cerca la proprietà pubblica specificata i cui parametri corrispondono ai tipi di argomenti specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2049">Searches for the specified public property whose parameters match the specified argument types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-2050">Oggetto che rappresenta la proprietà pubblica i cui parametri corrispondono ai tipi di argomenti specificati, se presente; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2050">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-2051">Una proprietà è considerata pubblica per la reflection se dispone di almeno una funzione di accesso pubblico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2051">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="4ee8d-2052">In caso contrario, la proprietà viene considerata privata ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerla.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2052">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="4ee8d-2053">La ricerca di `name` tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2053">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="4ee8d-2054">La ricerca include le proprietà di istanza pubblici statici e pubblici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2054">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="4ee8d-2055">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.PropertyInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2055">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-2056">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cercherà le proprietà del vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2056">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="4ee8d-2057">Gli indicizzatori e proprietà predefinite</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2057">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="4ee8d-2058">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] hanno la sintassi semplificata per l'accesso alle proprietà indicizzate e consentire una proprietà indicizzata essere un valore predefinito per il relativo tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2058">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="4ee8d-2059">Ad esempio, se la variabile `myList` fa riferimento a un <xref:System.Collections.ArrayList>, la sintassi `myList[3]` (`myList(3)` in Visual Basic) recupera l'elemento con indice 3.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2059">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="4ee8d-2060">È possibile eseguire l'overload della proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2060">You can overload the property.</span></span>  
  
 <span data-ttu-id="4ee8d-2061">In c#, questa funzionalità viene chiamata un indicizzatore e non è possibile farvi riferimento in base al nome.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2061">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="4ee8d-2062">Per impostazione predefinita, un indicizzatore c# viene visualizzato nei metadati come una proprietà indicizzata denominata "Item".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2062">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="4ee8d-2063">Tuttavia, uno sviluppatore di libreria di classi è possibile usare il <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attributo per modificare il nome dell'indicizzatore nei metadati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2063">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="4ee8d-2064">Ad esempio, il <xref:System.String> classe dispone di un indicizzatore denominato <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2064">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="4ee8d-2065">Proprietà indicizzate create con linguaggi diversi da c# possono avere nomi diversi da elementi, nonché.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2065">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="4ee8d-2066">Per determinare se un tipo ha una proprietà predefinita, usare il <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metodo per testare il <xref:System.Reflection.DefaultMemberAttribute> attributo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2066">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="4ee8d-2067">Se il tipo ha <xref:System.Reflection.DefaultMemberAttribute>, il <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> proprietà restituisce il nome della proprietà predefinita.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2067">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-2068">Nell'esempio seguente recupera le `Type` oggetto di una classe definita dall'utente, viene recuperata la proprietà di tale classe e visualizza il nome della proprietà e il tipo della proprietà come specificato dagli argomenti passati al `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2068">The following example retrieves the `Type` object of a user-defined class, retrieves the property of that class, and displays the property name and type of the property as specified by the arguments passed to `GetProperty`.</span></span>  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="4ee8d-2069">È stata trovata più di una proprietà con il nome specificato e corrispondente ai tipi di argomento specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2069">More than one property is found with the specified name and matching the specified argument types.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-2070">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2070">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-2071">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2071">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2072">
            <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2072">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-2073">
            <paramref name="types" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2073">
              <paramref name="types" /> is multidimensional.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="4ee8d-2074">Un elemento di <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2074">An element of <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-2075">Stringa che contiene il nome della proprietà pubblica da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2075">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="4ee8d-2076">Tipo restituito della proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2076">The return type of the property.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="4ee8d-2077">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano numero, ordine e tipo dei parametri relativi alla proprietà indicizzata da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2077">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="4ee8d-2078">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2078">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2079">Matrice vuota di tipo <see cref="T:System.Type" /> (ovvero, Type[] types = new Type[0]) per ottenere una proprietà non indicizzata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2079">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-2080">Cerca la proprietà pubblica specificata i cui parametri corrispondono ai tipi di argomenti specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2080">Searches for the specified public property whose parameters match the specified argument types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-2081">Oggetto che rappresenta la proprietà pubblica i cui parametri corrispondono ai tipi di argomenti specificati, se presente; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2081">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-2082">Una proprietà è considerata pubblica per la reflection se dispone di almeno una funzione di accesso pubblico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2082">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="4ee8d-2083">In caso contrario, la proprietà viene considerata privata ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerla.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2083">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="4ee8d-2084">La ricerca di `name` tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2084">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="4ee8d-2085">La ricerca include le proprietà di istanza pubblici statici e pubblici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2085">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="4ee8d-2086">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.PropertyInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2086">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-2087">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cercherà le proprietà del vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2087">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="4ee8d-2088">Gli indicizzatori e proprietà predefinite</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2088">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="4ee8d-2089">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] hanno la sintassi semplificata per l'accesso alle proprietà indicizzate e consentire una proprietà indicizzata essere un valore predefinito per il relativo tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2089">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="4ee8d-2090">Ad esempio, se la variabile `myList` fa riferimento a un <xref:System.Collections.ArrayList>, la sintassi `myList[3]` (`myList(3)` in Visual Basic) recupera l'elemento con indice 3.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2090">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="4ee8d-2091">È possibile eseguire l'overload della proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2091">You can overload the property.</span></span>  
  
 <span data-ttu-id="4ee8d-2092">In c#, questa funzionalità viene chiamata un indicizzatore e non è possibile farvi riferimento in base al nome.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2092">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="4ee8d-2093">Per impostazione predefinita, un indicizzatore c# viene visualizzato nei metadati come una proprietà indicizzata denominata "Item".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2093">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="4ee8d-2094">Tuttavia, uno sviluppatore di libreria di classi è possibile usare il <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attributo per modificare il nome dell'indicizzatore nei metadati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2094">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="4ee8d-2095">Ad esempio, il <xref:System.String> classe dispone di un indicizzatore denominato <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2095">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="4ee8d-2096">Proprietà indicizzate create con linguaggi diversi da c# possono avere nomi diversi da elementi, nonché.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2096">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="4ee8d-2097">Per determinare se un tipo ha una proprietà predefinita, usare il <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metodo per testare il <xref:System.Reflection.DefaultMemberAttribute> attributo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2097">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="4ee8d-2098">Se il tipo ha <xref:System.Reflection.DefaultMemberAttribute>, il <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> proprietà restituisce il nome della proprietà predefinita.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2098">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="4ee8d-2099">È stata trovata più di una proprietà con il nome specificato e corrispondente ai tipi di argomento specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2099">More than one property is found with the specified name and matching the specified argument types.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-2100">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2100">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-2101">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2101">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2102">
            <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2102">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-2103">
            <paramref name="types" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2103">
              <paramref name="types" /> is multidimensional.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="4ee8d-2104">Un elemento di <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2104">An element of <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-2105">Stringa che contiene il nome della proprietà pubblica da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2105">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="4ee8d-2106">Tipo restituito della proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2106">The return type of the property.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="4ee8d-2107">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano numero, ordine e tipo dei parametri relativi alla proprietà indicizzata da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2107">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="4ee8d-2108">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2108">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2109">Matrice vuota di tipo <see cref="T:System.Type" /> (ovvero, Type[] types = new Type[0]) per ottenere una proprietà non indicizzata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2109">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="4ee8d-2110">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresenta gli attributi associati all'elemento corrispondente nella matrice <c>types</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2110">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="4ee8d-2111">Questo parametro non viene elaborato dal binder predefinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2111">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-2112">Cerca la proprietà pubblica specificata i cui parametri corrispondono ai tipi di argomenti e ai modificatori specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2112">Searches for the specified public property whose parameters match the specified argument types and modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-2113">Oggetto che rappresenta la proprietà pubblica corrispondente ai requisiti specificati, se è stato trovato; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2113">An object representing the public property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-2114">Una proprietà è considerata pubblica per la reflection se dispone di almeno una funzione di accesso pubblico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2114">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="4ee8d-2115">In caso contrario, la proprietà viene considerata privata ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerla.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2115">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="4ee8d-2116">Anche se il binder predefinito elabora <xref:System.Reflection.ParameterModifier> (la `modifiers` parametro), è possibile usare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per scrivere un binder personalizzato che elaborano `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2116">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="4ee8d-2117">`ParameterModifier` viene usato solo quando si chiama tramite l'interoperabilità COM, e vengono gestiti solo i parametri che vengono passati per riferimento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2117">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="4ee8d-2118">La ricerca di `name` tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2118">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="4ee8d-2119">La ricerca include le proprietà di istanza pubblici statici e pubblici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2119">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="4ee8d-2120">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.PropertyInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2120">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-2121">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cercherà le proprietà del vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2121">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="4ee8d-2122">Gli indicizzatori e proprietà predefinite</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2122">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="4ee8d-2123">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] hanno la sintassi semplificata per l'accesso alle proprietà indicizzate e consentire una proprietà indicizzata essere un valore predefinito per il relativo tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2123">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="4ee8d-2124">Ad esempio, se la variabile `myList` fa riferimento a un <xref:System.Collections.ArrayList>, la sintassi `myList[3]` (`myList(3)` in Visual Basic) recupera l'elemento con indice 3.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2124">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="4ee8d-2125">È possibile eseguire l'overload della proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2125">You can overload the property.</span></span>  
  
 <span data-ttu-id="4ee8d-2126">In c#, questa funzionalità viene chiamata un indicizzatore e non è possibile farvi riferimento in base al nome.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2126">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="4ee8d-2127">Per impostazione predefinita, un indicizzatore c# viene visualizzato nei metadati come una proprietà indicizzata denominata "Item".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2127">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="4ee8d-2128">Tuttavia, uno sviluppatore di libreria di classi è possibile usare il <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attributo per modificare il nome dell'indicizzatore nei metadati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2128">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="4ee8d-2129">Ad esempio, il <xref:System.String> classe dispone di un indicizzatore denominato <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2129">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="4ee8d-2130">Proprietà indicizzate create con linguaggi diversi da c# possono avere nomi diversi da elementi, nonché.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2130">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="4ee8d-2131">Per determinare se un tipo ha una proprietà predefinita, usare il <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metodo per testare il <xref:System.Reflection.DefaultMemberAttribute> attributo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2131">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="4ee8d-2132">Se il tipo ha <xref:System.Reflection.DefaultMemberAttribute>, il <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> proprietà restituisce il nome della proprietà predefinita.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2132">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-2133">L'esempio seguente ottiene una `Type` oggetto corrispondente `MyPropertyClass`, e la proprietà indicizzata di questa classe viene recuperata utilizzando gli argomenti passati al `GetProperty` (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2133">The following example obtains a `Type` object corresponding to `MyPropertyClass`, and the indexed property of this class is retrieved using the arguments passed to the `GetProperty` method.</span></span>  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="4ee8d-2134">È stata trovata più di una proprietà con il nome specificato e corrispondente ai tipi di argomento e modificatori specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2134">More than one property is found with the specified name and matching the specified argument types and modifiers.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-2135">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2135">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-2136">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2136">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2137">
            <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2137">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-2138">
            <paramref name="types" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2138">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="4ee8d-2139">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2139">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2140">
            <paramref name="modifiers" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2140">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="4ee8d-2141">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2141">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2142">
            <paramref name="types" /> e <paramref name="modifiers" /> non hanno la stessa lunghezza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2142">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="4ee8d-2143">Un elemento di <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2143">An element of <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-2144">Stringa che contiene il nome della proprietà da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2144">The string containing the name of the property to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-2145">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2145">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-2146">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2146">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2147">Zero, per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2147">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="4ee8d-2148">Oggetto che definisce una serie di proprietà e permette il binding, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2148">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="4ee8d-2149">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2149">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2150">Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2150">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="4ee8d-2151">Tipo restituito della proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2151">The return type of the property.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="4ee8d-2152">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano numero, ordine e tipo dei parametri relativi alla proprietà indicizzata da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2152">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="4ee8d-2153">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2153">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2154">Matrice vuota di tipo <see cref="T:System.Type" /> (ovvero, Type[] types = new Type[0]) per ottenere una proprietà non indicizzata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2154">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="4ee8d-2155">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresenta gli attributi associati all'elemento corrispondente nella matrice <c>types</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2155">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="4ee8d-2156">Questo parametro non viene elaborato dal binder predefinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2156">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-2157">Cerca la proprietà specificata i cui parametri corrispondono ai tipi di argomenti e ai modificatori specificati, usando i vincoli di associazione specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2157">Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-2158">Oggetto che rappresenta la proprietà corrispondente ai requisiti specificati, se presente; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2158">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-2159">Una proprietà è considerata pubblica per la reflection se dispone di almeno una funzione di accesso pubblico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2159">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="4ee8d-2160">In caso contrario, la proprietà viene considerata privata ed è necessario utilizzare <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combinare i valori utilizzando `Or`) per ottenerla.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2160">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="4ee8d-2161">Anche se il binder predefinito elabora <xref:System.Reflection.ParameterModifier> (la `modifiers` parametro), è possibile usare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per scrivere un binder personalizzato che elaborano `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2161">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="4ee8d-2162">`ParameterModifier` viene usato solo quando si chiama tramite l'interoperabilità COM, e vengono gestiti solo i parametri che vengono passati per riferimento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2162">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="4ee8d-2163">La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2163">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="4ee8d-2164">Tipo di membro</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2164">Member Type</span></span>|<span data-ttu-id="4ee8d-2165">Static</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2165">Static</span></span>|<span data-ttu-id="4ee8d-2166">Non statici</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2166">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="4ee8d-2167">Costruttore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2167">Constructor</span></span>|<span data-ttu-id="4ee8d-2168">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2168">No</span></span>|<span data-ttu-id="4ee8d-2169">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2169">No</span></span>|  
|<span data-ttu-id="4ee8d-2170">Campo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2170">Field</span></span>|<span data-ttu-id="4ee8d-2171">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2171">No</span></span>|<span data-ttu-id="4ee8d-2172">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2172">Yes.</span></span> <span data-ttu-id="4ee8d-2173">Un campo viene sempre hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2173">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-2174">event</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2174">Event</span></span>|<span data-ttu-id="4ee8d-2175">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2175">Not applicable</span></span>|<span data-ttu-id="4ee8d-2176">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2176">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-2177">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2177">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-2178">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2178">See note 2 below.</span></span>|  
|<span data-ttu-id="4ee8d-2179">Metodo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2179">Method</span></span>|<span data-ttu-id="4ee8d-2180">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2180">No</span></span>|<span data-ttu-id="4ee8d-2181">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2181">Yes.</span></span> <span data-ttu-id="4ee8d-2182">Un metodo (virtuale e non virtuale) può essere hide-by-name o hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2182">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-2183">Tipo annidato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2183">Nested Type</span></span>|<span data-ttu-id="4ee8d-2184">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2184">No</span></span>|<span data-ttu-id="4ee8d-2185">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2185">No</span></span>|  
|<span data-ttu-id="4ee8d-2186">Proprietà</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2186">Property</span></span>|<span data-ttu-id="4ee8d-2187">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2187">Not applicable</span></span>|<span data-ttu-id="4ee8d-2188">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2188">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-2189">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2189">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-2190">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2190">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="4ee8d-2191">Hide-by-name-e-signature prende in considerazione tutte le parti della firma, inclusi i modificatori personalizzati, i tipi restituiti, i tipi di parametri, elementi sentinel e le convenzioni di chiamata non gestite.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2191">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="4ee8d-2192">Si tratta di un confronto binario.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2192">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="4ee8d-2193">Per la reflection, proprietà ed eventi sono hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2193">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-2194">Se si dispone di una proprietà con una richiesta get e una funzione di accesso set nella classe di base, ma la classe derivata ha solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter della classe base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2194">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="4ee8d-2195">Gli attributi personalizzati non fanno parte di common type system.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2195">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="4ee8d-2196">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire le proprietà da includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2196">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-2197">È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2197">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-2198">Specificare `BindingFlags.Public` per includere le proprietà pubbliche nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2198">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-2199">Specificare `BindingFlags.NonPublic` da includere non proprietà pubbliche (vale a dire, privati, interni e protetto) nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2199">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-2200">Specificare `BindingFlags.FlattenHierarchy` da includere `public` e `protected` membri statici nella gerarchia; `private` non sono inclusi i membri statici nelle classi ereditate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2200">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="4ee8d-2201">Nell'esempio <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare il comportamento della ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2201">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="4ee8d-2202">`BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2202">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="4ee8d-2203">`BindingFlags.DeclaredOnly` eseguire la ricerca solo le proprietà dichiarate nel <xref:System.Type>, non le proprietà che sono stati semplicemente ereditate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2203">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="4ee8d-2204">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2204">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="4ee8d-2205">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questo metodo restituisce il <xref:System.Reflection.PropertyInfo> con i parametri di tipo sostituiti dagli argomenti di tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2205">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-2206">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questo metodo cercherà le proprietà del vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2206">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="4ee8d-2207">Gli indicizzatori e proprietà predefinite</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2207">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="4ee8d-2208">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] hanno la sintassi semplificata per l'accesso alle proprietà indicizzate e consentire una proprietà indicizzata essere un valore predefinito per il relativo tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2208">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="4ee8d-2209">Ad esempio, se la variabile `myList` fa riferimento a un <xref:System.Collections.ArrayList>, la sintassi `myList[3]` (`myList(3)` in Visual Basic) recupera l'elemento con indice 3.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2209">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="4ee8d-2210">È possibile eseguire l'overload della proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2210">You can overload the property.</span></span>  
  
 <span data-ttu-id="4ee8d-2211">In c#, questa funzionalità viene chiamata un indicizzatore e non è possibile farvi riferimento in base al nome.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2211">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="4ee8d-2212">Per impostazione predefinita, un indicizzatore c# viene visualizzato nei metadati come una proprietà indicizzata denominata "Item".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2212">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="4ee8d-2213">Tuttavia, uno sviluppatore di libreria di classi è possibile usare il <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attributo per modificare il nome dell'indicizzatore nei metadati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2213">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="4ee8d-2214">Ad esempio, il <xref:System.String> classe dispone di un indicizzatore denominato <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2214">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="4ee8d-2215">Proprietà indicizzate create con linguaggi diversi da c# possono avere nomi diversi da elementi, nonché.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2215">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="4ee8d-2216">Per determinare se un tipo ha una proprietà predefinita, usare il <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> metodo per testare il <xref:System.Reflection.DefaultMemberAttribute> attributo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2216">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="4ee8d-2217">Se il tipo ha <xref:System.Reflection.DefaultMemberAttribute>, il <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> proprietà restituisce il nome della proprietà predefinita.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2217">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="4ee8d-2218">È stata trovata più di una proprietà con il nome specificato e corrispondente ai vincoli di associazione specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2218">More than one property is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-2219">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2219">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-2220">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2220">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2221">
            <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2221">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-2222">
            <paramref name="types" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2222">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="4ee8d-2223">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2223">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2224">
            <paramref name="modifiers" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2224">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="4ee8d-2225">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2225">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2226">
            <paramref name="types" /> e <paramref name="modifiers" /> non hanno la stessa lunghezza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2226">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="4ee8d-2227">Un elemento di <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2227">An element of <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-2228">Stringa che contiene il nome della proprietà da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2228">The string containing the name of the property to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="4ee8d-2229">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2229">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-2230">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2230">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2231">Zero, per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2231">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="4ee8d-2232">Oggetto che definisce un set di proprietà e consente l'associazione, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2232">An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="4ee8d-2233">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2233">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2234">Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2234">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="4ee8d-2235">Tipo restituito della proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2235">The return type of the property.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="4ee8d-2236">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano numero, ordine e tipo dei parametri relativi alla proprietà indicizzata da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2236">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="4ee8d-2237">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2237">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2238">Matrice vuota di tipo <see cref="T:System.Type" /> (ovvero, Type[] types = new Type[0]) per ottenere una proprietà non indicizzata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2238">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="4ee8d-2239">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresenta gli attributi associati all'elemento corrispondente nella matrice <c>types</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2239">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="4ee8d-2240">Questo parametro non viene elaborato dal binder predefinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2240">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-2241">Quando ne viene eseguito l'override in una classe derivata, cerca la proprietà specificata i cui parametri corrispondono ai modificatori e ai tipi di argomenti definiti, usando i vincoli di associazione specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2241">When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-2242">Oggetto che rappresenta la proprietà corrispondente ai requisiti specificati, se presente; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2242">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-2243">Anche se il binder predefinito elabora <xref:System.Reflection.ParameterModifier> (la `modifiers` parametro), è possibile usare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per scrivere un binder personalizzato che elaborano `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2243">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="4ee8d-2244">`ParameterModifier` viene usato solo quando si chiama tramite l'interoperabilità COM, e vengono gestiti solo i parametri che vengono passati per riferimento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2244">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="4ee8d-2245">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire le proprietà da includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2245">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-2246">È necessario specificare `BindingFlags.Instance` o `BindingFlags.Static` per ottenere un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2246">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="4ee8d-2247">Specificare `BindingFlags.Public` per includere le proprietà pubbliche nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2247">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-2248">Specificare `BindingFlags.NonPublic` da includere non proprietà pubbliche (vale a dire, privati, interni e protetto) nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2248">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-2249">Specificare `BindingFlags.FlattenHierarchy` da includere `public` e `protected` membri statici nella gerarchia; `private` non sono inclusi i membri statici nelle classi ereditate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2249">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="4ee8d-2250">Nell'esempio <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare il comportamento della ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2250">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="4ee8d-2251">`BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2251">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="4ee8d-2252">`BindingFlags.DeclaredOnly` eseguire la ricerca solo le proprietà dichiarate nel <xref:System.Type>, non le proprietà che sono stati semplicemente ereditate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2252">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="4ee8d-2253">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2253">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="4ee8d-2254">È stata trovata più di una proprietà con il nome specificato e corrispondente ai vincoli di associazione specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2254">More than one property is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-2255">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2255">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-2256">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2256">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2257">
            <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2257">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-2258">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2258">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2259">Uno degli elementi in <paramref name="types" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2259">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-2260">
            <paramref name="types" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2260">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="4ee8d-2261">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2261">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2262">
            <paramref name="modifiers" /> è multidimensionale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2262">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="4ee8d-2263">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2263">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2264">
            <paramref name="types" /> e <paramref name="modifiers" /> non hanno la stessa lunghezza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2264">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="4ee8d-2265">Il tipo corrente è un oggetto <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" /> o <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2265">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" />, or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-2266">Ottiene un oggetto <see cref="T:System.Type" /> che rappresenta il tipo specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2266">Gets a <see cref="T:System.Type" /> object that represents the specified type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-2267">Ottiene l'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2267">Gets the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-2268">Oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2268">The current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="4ee8d-2269">Viene richiamato un inizializzatore di classi e viene generata un'eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2269">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">
          <span data-ttu-id="4ee8d-2270">Specifica di nomi di tipo completi</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2270">Specifying Fully Qualified Type Names</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="4ee8d-2271">Nome qualificato dall'assembly del tipo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2271">The assembly-qualified name of the type to get.</span>
          </span>
          <span data-ttu-id="4ee8d-2272">Vedere <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2272">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          </span>
          <span data-ttu-id="4ee8d-2273">Se il tipo è incluso nell'assembly attualmente in esecuzione o in Mscorlib.dll, è sufficiente specificare il nome del tipo qualificato in base al relativo spazio dei nomi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2273">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-2274">Ottiene l'oggetto <see cref="T:System.Type" /> con il nome specificato, eseguendo una ricerca con distinzione tra maiuscole e minuscole.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2274">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-2275">Tipo con il nome specificato, se presente; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2275">The type with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-2276">È possibile usare la <xref:System.Type.GetType%2A> metodo per ottenere un <xref:System.Type> dell'oggetto per un tipo in un altro assembly, se si conosce il nome qualificato dall'assembly che può essere ottenuto da <xref:System.Type.AssemblyQualifiedName>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2276">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if you know its assembly-qualified name which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="4ee8d-2277"><xref:System.Type.GetType%2A> causa il caricamento dell'assembly specificato nel `typeName`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2277"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="4ee8d-2278">È anche possibile caricare un assembly usando il <xref:System.Reflection.Assembly.Load%2A> (metodo) e quindi usare il <xref:System.Type.GetType%2A> o <xref:System.Reflection.Assembly.GetTypes%2A> metodi del <xref:System.Reflection.Assembly> classe per ottenere <xref:System.Type> oggetti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2278">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects.</span></span> <span data-ttu-id="4ee8d-2279">Se un tipo in un assembly è noto al programma in fase di compilazione, è più efficiente da usare nel linguaggio c#, <xref:System.Type.GetType%2A> in Visual Basic o c++.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2279">If a type is in an assembly known to your program at compile time, it is more efficient to use  in C#, <xref:System.Type.GetType%2A> in Visual Basic, or  in C++.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-2280">Se `typeName` non viene trovato, la chiamata per il <xref:System.Type.GetType%28System.String%29> restituzione del metodo `null`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2280">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%29> method returns `null`.</span></span> <span data-ttu-id="4ee8d-2281">Non genera un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2281">It does not throw an exception.</span></span> <span data-ttu-id="4ee8d-2282">Per controllare se viene generata un'eccezione, chiamare un overload del <xref:System.Type.GetType%2A> metodo che presenta un `throwOnError` parametro.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2282">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="4ee8d-2283"><xref:System.Type.GetType%2A> funziona solo su assembly caricati dal disco.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2283"><xref:System.Type.GetType%2A> only works on assemblies loaded from disk.</span></span> <span data-ttu-id="4ee8d-2284">Se si chiama <xref:System.Type.GetType%2A> per cercare un tipo definito in un assembly dinamico definito mediante il <xref:System.Reflection.Emit> servizi, si potrebbe ottenere un comportamento incoerente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2284">If you call <xref:System.Type.GetType%2A> to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="4ee8d-2285">Il comportamento dipende dal fatto che l'assembly dinamico è permanente, vale a dire, creato con il `RunAndSave` oppure `Save` della modalità di accesso di <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2285">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="4ee8d-2286">Se l'assembly dinamico è permanente ed è stato scritto su disco prima `GetType` viene chiamato, il caricatore individua l'assembly salvato su disco, carica l'assembly e recupera il tipo da tale assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2286">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="4ee8d-2287">Se l'assembly non è stato salvato su disco quando `GetType` viene chiamato il metodo restituisce `null`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2287">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="4ee8d-2288">`GetType` non riconosce gli assembly dinamici temporanei; Pertanto, la chiamata `GetType` recuperare un tipo in un temporaneo restituisce l'assembly dinamico `null`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2288">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="4ee8d-2289">Per utilizzare `GetType` su un modulo dinamico, sottoscrivere il <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> eventi e chiamate `GetType` prima del salvataggio.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2289">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="4ee8d-2290">In caso contrario, si otterrà due copie dell'assembly in memoria.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2290">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="4ee8d-2291">La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2291">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="4ee8d-2292">Tipo di membro</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2292">Member Type</span></span>|<span data-ttu-id="4ee8d-2293">Static</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2293">Static</span></span>|<span data-ttu-id="4ee8d-2294">Non statici</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2294">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="4ee8d-2295">Costruttore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2295">Constructor</span></span>|<span data-ttu-id="4ee8d-2296">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2296">No</span></span>|<span data-ttu-id="4ee8d-2297">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2297">No</span></span>|  
|<span data-ttu-id="4ee8d-2298">Campo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2298">Field</span></span>|<span data-ttu-id="4ee8d-2299">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2299">No</span></span>|<span data-ttu-id="4ee8d-2300">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2300">Yes.</span></span> <span data-ttu-id="4ee8d-2301">Un campo viene sempre hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2301">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-2302">event</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2302">Event</span></span>|<span data-ttu-id="4ee8d-2303">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2303">Not applicable</span></span>|<span data-ttu-id="4ee8d-2304">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2304">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-2305">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2305">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-2306">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2306">See note 2 below.</span></span>|  
|<span data-ttu-id="4ee8d-2307">Metodo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2307">Method</span></span>|<span data-ttu-id="4ee8d-2308">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2308">No</span></span>|<span data-ttu-id="4ee8d-2309">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2309">Yes.</span></span> <span data-ttu-id="4ee8d-2310">Un metodo (virtuale e non virtuale) può essere hide-by-name o hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2310">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-2311">Tipo annidato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2311">Nested Type</span></span>|<span data-ttu-id="4ee8d-2312">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2312">No</span></span>|<span data-ttu-id="4ee8d-2313">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2313">No</span></span>|  
|<span data-ttu-id="4ee8d-2314">Proprietà</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2314">Property</span></span>|<span data-ttu-id="4ee8d-2315">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2315">Not applicable</span></span>|<span data-ttu-id="4ee8d-2316">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2316">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-2317">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2317">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-2318">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2318">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="4ee8d-2319">Hide-by-name-e-signature prende in considerazione tutte le parti della firma, inclusi i modificatori personalizzati, i tipi restituiti, i tipi di parametri, elementi sentinel e le convenzioni di chiamata non gestite.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2319">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="4ee8d-2320">Si tratta di un confronto binario.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2320">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="4ee8d-2321">Per la reflection, proprietà ed eventi sono hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2321">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-2322">Se si dispone di una proprietà con una richiesta get e una funzione di accesso set nella classe di base, ma la classe derivata ha solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter della classe base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2322">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="4ee8d-2323">Gli attributi personalizzati non fanno parte di common type system.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2323">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="4ee8d-2324">Le matrici o tipi COM non vengono cercati a meno che non sono già stati caricati nella tabella delle classi disponibili.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2324">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="4ee8d-2325">`typeName` può essere il nome del tipo qualificato dal relativo spazio dei nomi o un nome qualificato dall'assembly che include una specifica di nome di assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2325">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="4ee8d-2326">Vedere <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2326">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="4ee8d-2327">Se `typeName` include lo spazio dei nomi ma non il nome dell'assembly, questo metodo cercherà solo assembly dell'oggetto chiamante a mscorlib. dll, in quest'ordine.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2327">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="4ee8d-2328">Se typeName è completo, con il nome dell'assembly completo o parziale, questo metodo cerca nell'assembly specificato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2328">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="4ee8d-2329">Se l'assembly ha un nome sicuro, è necessario un nome completo dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2329">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="4ee8d-2330">Il <xref:System.Type.AssemblyQualifiedName%2A> proprietà restituisce un nome completo del tipo, inclusi i tipi annidati, il nome dell'assembly e gli argomenti tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2330">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments.</span></span> <span data-ttu-id="4ee8d-2331">Tutti i compilatori che supportano common language runtime genererà il semplice nome di una classe annidata, e un nome modificato quando si riceve una richiesta, in conformità con le seguenti convenzioni di costrutti di reflection.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2331">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-2332">In .NET Framework versione 2.0, architettura del processore viene aggiunta all'identità di assembly e può essere specificato come parte di stringhe di nomi di assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2332">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="4ee8d-2333">Ad esempio, "ProcessorArchitecture = msil".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2333">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="4ee8d-2334">Tuttavia, non è incluso nella stringa restituita dal <xref:System.Type.AssemblyQualifiedName%2A> proprietà, per motivi di compatibilità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2334">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="4ee8d-2335">È anche possibile caricare i tipi creando un <xref:System.Reflection.AssemblyName> oggetto e passandolo a un overload appropriato del <xref:System.Reflection.Assembly.Load%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2335">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="4ee8d-2336">È quindi possibile usare il <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> per caricare i tipi dall'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2336">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="4ee8d-2337">Vedere anche <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2337">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="4ee8d-2338">Delimitatore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2338">Delimiter</span></span>|<span data-ttu-id="4ee8d-2339">Significato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2339">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="4ee8d-2340">Barra rovesciata (\\)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2340">Backslash (\\)</span></span>|<span data-ttu-id="4ee8d-2341">Carattere di escape.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2341">Escape character.</span></span>|  
|<span data-ttu-id="4ee8d-2342">Apice inverso (')</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2342">Backtick (\`)</span></span>|<span data-ttu-id="4ee8d-2343">Precede una o più cifre che rappresenta il numero di parametri di tipo, che si trova alla fine del nome di un tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2343">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="4ee8d-2344">Parentesi quadre ([])</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2344">Brackets ([])</span></span>|<span data-ttu-id="4ee8d-2345">Racchiudere un elenco di argomenti tipo generico, per un tipo generico costruito. all'interno di un elenco di argomenti, racchiudere un tipo qualificato dall'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2345">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="4ee8d-2346">Virgola ()</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2346">Comma (,)</span></span>|<span data-ttu-id="4ee8d-2347">Precede il nome dell'Assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2347">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="4ee8d-2348">Punto (.)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2348">Period (.)</span></span>|<span data-ttu-id="4ee8d-2349">Indica gli identificatori dello spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2349">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="4ee8d-2350">Segno più (+)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2350">Plus sign (+)</span></span>|<span data-ttu-id="4ee8d-2351">Precede una classe annidata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2351">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="4ee8d-2352">Ad esempio, il nome completo per una classe potrebbe essere simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2352">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="4ee8d-2353">Se lo spazio dei nomi sono stati TopNamespace.Sub+Namespace, quindi la stringa avrebbe in modo che preceda il segno più (+) con un carattere di escape (\\) per impedire che venga interpretato come separatore di annidamento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2353">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="4ee8d-2354">Reflection genera questa stringa come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2354">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="4ee8d-2355">Oggetto "+" diventa "\\+\\+" e un "\\"diventa"\\\\".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2355">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="4ee8d-2356">Questo nome completo può essere persistente e successivamente utilizzato per caricare il <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2356">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="4ee8d-2357">Per cercare e caricare un <xref:System.Type>, usare <xref:System.Type.GetType%2A> o con il tipo di nome solo oppure con il nome completo del tipo dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2357">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="4ee8d-2358"><xref:System.Type.GetType%2A> con il tipo di nome solo cercherà il <xref:System.Type> nell'assembly del chiamante, quindi nell'assembly di sistema.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2358"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="4ee8d-2359"><xref:System.Type.GetType%2A> con l'assembly avrà un aspetto completo del tipo il <xref:System.Type> nell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2359"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="4ee8d-2360">I nomi dei tipi possono includere caratteri finali che indicano le informazioni aggiuntive sul tipo, ad esempio se il tipo è un tipo riferimento, un tipo di puntatore o un tipo di matrice.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2360">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="4ee8d-2361">Per recuperare il nome del tipo senza caratteri finali, usare `t.GetElementType().ToString()`, dove `t` è il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2361">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="4ee8d-2362">Gli spazi sono rilevanti in tutti i componenti di nome di tipo tranne il nome dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2362">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="4ee8d-2363">Il nome di assembly e spazi che precedono il separatore ',' sono rilevanti, ma gli spazi dopo il separatore ',' vengono ignorati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2363">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="4ee8d-2364">Il nome di un tipo generico termina con un apice inverso (\`) seguito da cifre che rappresenta il numero di argomenti di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2364">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="4ee8d-2365">Lo scopo di questo tipo di alterazione dei nomi è consentire o meno i compilatori supportare i tipi generici con lo stesso nome ma con un numero diverso di parametri di tipo, che si verificano nello stesso ambito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2365">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="4ee8d-2366">Ad esempio, reflection vengono restituiti i nomi modificati `Tuple`1` and `tupla`2` da metodi generici `Tuple(Of T)` e `Tuple(Of T0, T1)` in Visual Basic oppure `Tuple<T>` tupla e`\<T0, T1>` in Visual c#.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2366">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="4ee8d-2367">Per i tipi generici, l'elenco di argomenti di tipo è racchiusa tra parentesi e gli argomenti di tipo sono separati da virgole.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2367">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="4ee8d-2368">Ad esempio, un oggetto generico <xref:System.Collections.Generic.Dictionary%602> ha due parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2368">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="4ee8d-2369">Oggetto <xref:System.Collections.Generic.Dictionary%602> dei `MyType` con le chiavi di tipo <xref:System.String> potrebbero essere rappresentati come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2369">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="4ee8d-2370">Per specificare un tipo qualificato dall'assembly all'interno di un elenco di argomenti, racchiudere il tipo qualificato dall'assembly racchiuso tra parentesi quadre.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2370">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="4ee8d-2371">In caso contrario, le virgole per separare le parti del nome qualificato dall'assembly vengono interpretate come argomenti di tipo aggiuntivi di delimitazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2371">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="4ee8d-2372">Ad esempio, un <xref:System.Collections.Generic.Dictionary%602> dei `MyType` fromMyAssembly.dll, con le chiavi di tipo <xref:System.String>, può essere specificata come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2372">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` fromMyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-2373">Un tipo qualificato dall'assembly può essere racchiuso tra parentesi quadre solo quando viene visualizzata all'interno di un elenco di parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2373">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="4ee8d-2374">Le regole per la ricerca degli assembly per i tipi completi e non qualificati negli elenchi di parametri di tipo sono le stesse delle regole per i tipi non generici completi e non qualificati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2374">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="4ee8d-2375">Tipi nullable rappresentano un caso speciale di tipi generici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2375">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="4ee8d-2376">Ad esempio, un valore nullable <xref:System.Int32> è rappresentato dalla stringa "System.Nullable'1[System.Int32]".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2376">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-2377">In c#, C++ e Visual Basic è anche possibile ottenere i tipi nullable utilizzando operatori di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2377">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="4ee8d-2378">Ad esempio, il valore nullable <xref:System.Boolean> tipo restituito da `typeof(Nullable<bool>)` in c#, da `Nullable<Boolean>::typeid` in C++ e da `GetType(Nullable(Of Boolean))` in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2378">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="4ee8d-2379">La tabella seguente illustra la sintassi da utilizzare con `GetType` per vari tipi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2379">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="4ee8d-2380">Per ottenere</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2380">To Get</span></span>|<span data-ttu-id="4ee8d-2381">Usa</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2381">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="4ee8d-2382">Un valore nullable <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="4ee8d-2382">A nullable <xref:System.Int32></span></span>|<span data-ttu-id="4ee8d-2383">`Type.GetType("System.Nullable`1[System.Int32]")\`</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2383">`Type.GetType("System.Nullable`1[System.Int32]")\`</span></span>|  
|<span data-ttu-id="4ee8d-2384">Un puntatore non gestito a `MyType`</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2384">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="4ee8d-2385">Un puntatore non gestito a un puntatore a `MyType`</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2385">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="4ee8d-2386">Un puntatore gestito o un riferimento a `MyType`</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2386">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="4ee8d-2387">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2387">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="4ee8d-2388">Si noti che, a differenza dei puntatori, i riferimenti sono limitati a un solo livello.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2388">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="4ee8d-2389">Una classe padre e una classe annidata</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2389">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="4ee8d-2390">Una matrice unidimensionale con limite inferiore pari a 0</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2390">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyType[]")`|  
|<span data-ttu-id="4ee8d-2391">Una matrice unidimensionale con limite inferiore sconosciuto</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2391">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyType[*]")`|  
|<span data-ttu-id="4ee8d-2392">Una matrice di n-dimensionale</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2392">An n-dimensional array</span></span>|<span data-ttu-id="4ee8d-2393">Una virgola (,) all'interno delle parentesi un totale di volte in cui n-1.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2393">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="4ee8d-2394">Ad esempio, `System.Object[,,]` rappresenta un oggetto tridimensionale `Object` matrice.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2394">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="4ee8d-2395">Matrice di matrici unidimensionali</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2395">An array of one-dimensional arrays</span></span>|`Type.GetType("MyType[][]")`|  
|<span data-ttu-id="4ee8d-2396">Una matrice rettangolare bidimensionale con limiti inferiori sconosciuti</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2396">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyType[,]")`|  
|<span data-ttu-id="4ee8d-2397">Un tipo generico con un argomento di tipo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2397">A generic type with one type argument</span></span>|<span data-ttu-id="4ee8d-2398">`Type.GetType("MyGenericType`1[MyType]")'</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2398">`Type.GetType("MyGenericType`1[MyType]")\`</span></span>|  
|<span data-ttu-id="4ee8d-2399">Un tipo generico con due argomenti tipo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2399">A generic type with two type arguments</span></span>|<span data-ttu-id="4ee8d-2400">`Type.GetType("MyGenericType`2[MyType,AnotherType]")'</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2400">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span></span>|  
|<span data-ttu-id="4ee8d-2401">Un tipo generico con due argomenti di tipo qualificato dall'assembly</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2401">A generic type with two assembly-qualified type arguments</span></span>|<span data-ttu-id="4ee8d-2402">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")'</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2402">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span></span>|  
|<span data-ttu-id="4ee8d-2403">Un tipo generico con un argomento di tipo qualificato dall'assembly completo di assembly</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2403">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|<span data-ttu-id="4ee8d-2404">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")'</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2404">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span></span>|  
|<span data-ttu-id="4ee8d-2405">Un tipo generico il cui argomento tipo è un tipo generico con due argomenti di tipo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2405">A generic type whose type argument is a generic type with two type arguments</span></span>|<span data-ttu-id="4ee8d-2406">`Type.GetType("MyGenericType`1 [AnotherGenericType`2[MyType,AnotherType]]")`</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2406">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-2407">Nell'esempio seguente recupera il tipo della `System.Int32` e Usa l'oggetto tipo per visualizzare il <xref:System.Type.FullName%2A> proprietà di `System.Int32`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2407">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-2408">
            <paramref name="typeName" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2408">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="4ee8d-2409">Viene richiamato un inizializzatore di classi e viene generata un'eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2409">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-2410">
            <paramref name="typeName" /> rappresenta un tipo generico che ha un tipo di puntatore, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> tra i relativi argomenti di tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2410">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="4ee8d-2411">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2411">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2412">
            <paramref name="typeName" /> rappresenta un tipo generico che ha un numero errato di argomenti di tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2412">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="4ee8d-2413">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2413">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2414">
            <paramref name="typeName" /> rappresenta un tipo generico e uno dei relativi argomenti di tipo non soddisfa i vincoli per il parametro di tipo corrispondente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2414">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="4ee8d-2415">
            <paramref name="typeName" /> rappresenta una matrice di <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2415">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="4ee8d-2416">In <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET per app di Windows Store</see> o nella <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">libreria di classi portabile</see> rilevare invece l'eccezione della classe di base, <see cref="T:System.IO.IOException" />.</span>
              <span class="sxs-lookup">
                <span data-stu-id="4ee8d-2416">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="4ee8d-2417">L'assembly o una delle relative dipendenze è stato trovato, ma non può essere caricato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2417">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="4ee8d-2418">L'assembly o una delle relative dipendenze non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2418">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="4ee8d-2419">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2419">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2420">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'assembly è stato compilato con una versione successiva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2420">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">
          <span data-ttu-id="4ee8d-2421">Specifica di nomi di tipo completi</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2421">Specifying Fully Qualified Type Names</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="4ee8d-2422">Nome qualificato dall'assembly del tipo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2422">The assembly-qualified name of the type to get.</span>
          </span>
          <span data-ttu-id="4ee8d-2423">Vedere <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2423">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          </span>
          <span data-ttu-id="4ee8d-2424">Se il tipo è incluso nell'assembly attualmente in esecuzione o in Mscorlib.dll, è sufficiente specificare il nome del tipo qualificato in base al relativo spazio dei nomi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2424">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="4ee8d-2425">
            <see langword="true" /> per generare un'eccezione se non è possibile trovare il tipo; <see langword="false" /> per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2425">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-2426">Se si specifica <see langword="false" /> vengono eliminate alcune condizioni di eccezione, ma non tutte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2426">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="4ee8d-2427">Vedere la sezione relativa alle eccezioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2427">See the Exceptions section.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-2428">Ottiene l'oggetto <see cref="T:System.Type" /> con il nome specificato, eseguendo una ricerca con distinzione tra maiuscole e minuscole e specificando se generare un'eccezione in caso il tipo non venga trovato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2428">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-2429">Tipo con il nome specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2429">The type with the specified name.</span>
          </span>
          <span data-ttu-id="4ee8d-2430">Se il tipo non viene trovato, il parametro <paramref name="throwOnError" /> specifica se viene restituito <see langword="null" /> o se viene generata un'eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2430">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="4ee8d-2431">In alcuni casi, viene generata un'eccezione indipendentemente dal valore di <paramref name="throwOnError" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2431">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span>
          </span>
          <span data-ttu-id="4ee8d-2432">Vedere la sezione relativa alle eccezioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2432">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-2433">È possibile usare la <xref:System.Type.GetType%2A> metodo per ottenere un <xref:System.Type> dell'oggetto per un tipo in un altro assembly, se si conosce il nome qualificato dall'assembly che può essere ottenuto da <xref:System.Type.AssemblyQualifiedName>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2433">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if you know its assembly-qualified name which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="4ee8d-2434"><xref:System.Type.GetType%2A> causa il caricamento dell'assembly specificato nel `typeName`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2434"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="4ee8d-2435">È anche possibile caricare un assembly usando il <xref:System.Reflection.Assembly.Load%2A> (metodo) e quindi usare il <xref:System.Type.GetType%2A> o <xref:System.Reflection.Assembly.GetTypes%2A> metodi del <xref:System.Reflection.Assembly> classe per ottenere <xref:System.Type> oggetti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2435">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects.</span></span> <span data-ttu-id="4ee8d-2436">Se un tipo in un assembly è noto al programma in fase di compilazione, è preferibile usare `typeof` in c# <xref:System.Type.GetType%2A> in Visual Basic o `typeid` in C++.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2436">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++.</span></span>  
  
 <span data-ttu-id="4ee8d-2437">`GetType` funziona solo su assembly caricati dal disco.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2437">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="4ee8d-2438">Se si chiama `GetType` per cercare un tipo definito in un assembly dinamico definito mediante il <xref:System.Reflection.Emit> servizi, si potrebbe ottenere un comportamento incoerente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2438">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="4ee8d-2439">Il comportamento dipende dal fatto che l'assembly dinamico è permanente, vale a dire, creato con il `RunAndSave` oppure `Save` della modalità di accesso di <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2439">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="4ee8d-2440">Se l'assembly dinamico è permanente ed è stato scritto su disco prima `GetType` viene chiamato, il caricatore individua l'assembly salvato su disco, carica l'assembly e recupera il tipo da tale assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2440">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="4ee8d-2441">Se l'assembly non è stato salvato su disco quando `GetType` viene chiamato il metodo restituisce `null`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2441">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="4ee8d-2442">`GetType` non riconosce gli assembly dinamici temporanei; Pertanto, la chiamata `GetType` recuperare un tipo in un temporaneo restituisce l'assembly dinamico `null`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2442">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="4ee8d-2443">Per utilizzare `GetType` su un modulo dinamico, sottoscrivere il <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> eventi e chiamate `GetType` prima del salvataggio.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2443">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="4ee8d-2444">In caso contrario, si otterrà due copie dell'assembly in memoria.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2444">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="4ee8d-2445">Il `throwOnError` parametro specifica che cosa avviene quando non viene trovato, il tipo e vengono eliminate alcune condizioni di eccezione, come descritto nella sezione delle eccezioni.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2445">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="4ee8d-2446">Alcune eccezioni vengono generate indipendentemente dal valore di `throwOnError`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2446">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="4ee8d-2447">Ad esempio, se il tipo è stato trovato ma non può essere caricato, un <xref:System.TypeLoadException> viene generata anche se `throwOnError` è `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2447">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="4ee8d-2448">La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2448">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="4ee8d-2449">Tipo di membro</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2449">Member Type</span></span>|<span data-ttu-id="4ee8d-2450">Static</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2450">Static</span></span>|<span data-ttu-id="4ee8d-2451">Non statici</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2451">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="4ee8d-2452">Costruttore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2452">Constructor</span></span>|<span data-ttu-id="4ee8d-2453">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2453">No</span></span>|<span data-ttu-id="4ee8d-2454">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2454">No</span></span>|  
|<span data-ttu-id="4ee8d-2455">Campo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2455">Field</span></span>|<span data-ttu-id="4ee8d-2456">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2456">No</span></span>|<span data-ttu-id="4ee8d-2457">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2457">Yes.</span></span> <span data-ttu-id="4ee8d-2458">Un campo viene sempre hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2458">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-2459">event</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2459">Event</span></span>|<span data-ttu-id="4ee8d-2460">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2460">Not applicable</span></span>|<span data-ttu-id="4ee8d-2461">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2461">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-2462">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2462">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-2463">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2463">See note 2 below.</span></span>|  
|<span data-ttu-id="4ee8d-2464">Metodo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2464">Method</span></span>|<span data-ttu-id="4ee8d-2465">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2465">No</span></span>|<span data-ttu-id="4ee8d-2466">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2466">Yes.</span></span> <span data-ttu-id="4ee8d-2467">Un metodo (virtuale e non virtuale) può essere hide-by-name o hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2467">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-2468">Tipo annidato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2468">Nested Type</span></span>|<span data-ttu-id="4ee8d-2469">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2469">No</span></span>|<span data-ttu-id="4ee8d-2470">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2470">No</span></span>|  
|<span data-ttu-id="4ee8d-2471">Proprietà</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2471">Property</span></span>|<span data-ttu-id="4ee8d-2472">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2472">Not applicable</span></span>|<span data-ttu-id="4ee8d-2473">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2473">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-2474">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2474">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-2475">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2475">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="4ee8d-2476">Hide-by-name-e-signature prende in considerazione tutte le parti della firma, inclusi i modificatori personalizzati, i tipi restituiti, i tipi di parametri, elementi sentinel e le convenzioni di chiamata non gestite.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2476">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="4ee8d-2477">Si tratta di un confronto binario.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2477">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="4ee8d-2478">Per la reflection, proprietà ed eventi sono hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2478">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-2479">Se si dispone di una proprietà con una richiesta get e una funzione di accesso set nella classe di base, ma la classe derivata ha solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter della classe base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2479">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="4ee8d-2480">Gli attributi personalizzati non fanno parte di common type system.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2480">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="4ee8d-2481">Le matrici o tipi COM non vengono cercati a meno che non sono già stati caricati nella tabella delle classi disponibili.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2481">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="4ee8d-2482">`typeName` può essere il nome del tipo qualificato dal relativo spazio dei nomi o un nome qualificato dall'assembly che include una specifica di nome di assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2482">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="4ee8d-2483">Vedere <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2483">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="4ee8d-2484">Se `typeName` include lo spazio dei nomi ma non il nome dell'assembly, questo metodo cercherà solo assembly dell'oggetto chiamante a mscorlib. dll, in quest'ordine.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2484">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="4ee8d-2485">Se typeName è completo, con il nome dell'assembly completo o parziale, questo metodo cerca nell'assembly specificato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2485">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="4ee8d-2486">Se l'assembly ha un nome sicuro, è necessario un nome completo dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2486">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="4ee8d-2487">Il <xref:System.Type.AssemblyQualifiedName%2A> proprietà restituisce un nome completo del tipo, inclusi i tipi annidati, il nome dell'assembly e gli argomenti generici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2487">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic arguments.</span></span> <span data-ttu-id="4ee8d-2488">Tutti i compilatori che supportano common language runtime genererà il semplice nome di una classe annidata, e un nome modificato quando si riceve una richiesta, in conformità con le seguenti convenzioni di costrutti di reflection.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2488">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-2489">In .NET Framework versione 2.0, architettura del processore viene aggiunta all'identità di assembly e può essere specificato come parte di stringhe di nomi di assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2489">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="4ee8d-2490">Ad esempio, "ProcessorArchitecture = msil".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2490">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="4ee8d-2491">Tuttavia, non è incluso nella stringa restituita dal <xref:System.Type.AssemblyQualifiedName%2A> proprietà, per motivi di compatibilità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2491">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="4ee8d-2492">È anche possibile caricare i tipi creando un <xref:System.Reflection.AssemblyName> oggetto e passandolo a un overload appropriato del <xref:System.Reflection.Assembly.Load%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2492">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="4ee8d-2493">È quindi possibile usare il <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> per caricare i tipi dall'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2493">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="4ee8d-2494">Vedere anche <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2494">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="4ee8d-2495">Delimitatore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2495">Delimiter</span></span>|<span data-ttu-id="4ee8d-2496">Significato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2496">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="4ee8d-2497">Barra rovesciata (\\)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2497">Backslash (\\)</span></span>|<span data-ttu-id="4ee8d-2498">Carattere di escape.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2498">Escape character.</span></span>|  
|<span data-ttu-id="4ee8d-2499">Apice inverso (')</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2499">Backtick (\`)</span></span>|<span data-ttu-id="4ee8d-2500">Precede una o più cifre che rappresenta il numero di parametri di tipo, che si trova alla fine del nome di un tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2500">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="4ee8d-2501">Parentesi quadre ([])</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2501">Brackets ([])</span></span>|<span data-ttu-id="4ee8d-2502">Racchiudere un elenco di argomenti tipo generico, per un tipo generico costruito. all'interno di un elenco di argomenti, racchiudere un tipo qualificato dall'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2502">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="4ee8d-2503">Virgola ()</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2503">Comma (,)</span></span>|<span data-ttu-id="4ee8d-2504">Precede il nome dell'Assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2504">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="4ee8d-2505">Punto (.)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2505">Period (.)</span></span>|<span data-ttu-id="4ee8d-2506">Indica gli identificatori dello spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2506">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="4ee8d-2507">Segno più (+)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2507">Plus sign (+)</span></span>|<span data-ttu-id="4ee8d-2508">Precede una classe annidata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2508">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="4ee8d-2509">Ad esempio, il nome completo per una classe potrebbe essere simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2509">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="4ee8d-2510">Se lo spazio dei nomi sono stati TopNamespace.Sub+Namespace, quindi la stringa avrebbe in modo che preceda il segno più (+) con un carattere di escape (\\) per impedire che venga interpretato come separatore di annidamento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2510">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="4ee8d-2511">Reflection genera questa stringa come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2511">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="4ee8d-2512">Oggetto "+" diventa "\\+\\+" e un "\\"diventa"\\\\".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2512">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="4ee8d-2513">Questo nome completo può essere persistente e successivamente utilizzato per caricare il <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2513">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="4ee8d-2514">Per cercare e caricare un <xref:System.Type>, usare <xref:System.Type.GetType%2A> o con il tipo di nome solo oppure con il nome completo del tipo dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2514">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="4ee8d-2515"><xref:System.Type.GetType%2A> con il tipo di nome solo cercherà il <xref:System.Type> nell'assembly del chiamante, quindi nell'assembly di sistema.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2515"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="4ee8d-2516"><xref:System.Type.GetType%2A> con l'assembly avrà un aspetto completo del tipo il <xref:System.Type> nell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2516"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="4ee8d-2517">I nomi dei tipi possono includere caratteri finali che indicano le informazioni aggiuntive sul tipo, ad esempio se il tipo è un tipo riferimento, un tipo di puntatore o un tipo di matrice.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2517">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="4ee8d-2518">Per recuperare il nome del tipo senza caratteri finali, usare `t.GetElementType().ToString()`, dove `t` è il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2518">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="4ee8d-2519">Gli spazi sono rilevanti in tutti i componenti di nome di tipo tranne il nome dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2519">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="4ee8d-2520">Il nome di assembly e spazi che precedono il separatore ',' sono rilevanti, ma gli spazi dopo il separatore ',' vengono ignorati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2520">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="4ee8d-2521">Il nome di un tipo generico termina con un apice inverso (\`) seguito da cifre che rappresenta il numero di argomenti di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2521">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="4ee8d-2522">Lo scopo di questo tipo di alterazione dei nomi è consentire o meno i compilatori supportare i tipi generici con lo stesso nome ma con un numero diverso di parametri di tipo, che si verificano nello stesso ambito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2522">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="4ee8d-2523">Ad esempio, reflection vengono restituiti i nomi modificati `Tuple`1` and `tupla`2` da metodi generici `Tuple(Of T)` e `Tuple(Of T0, T1)` in Visual Basic oppure `Tuple<T>` tupla e`\<T0, T1>` in Visual c#.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2523">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="4ee8d-2524">Per i tipi generici, l'elenco di argomenti di tipo è racchiusa tra parentesi e gli argomenti di tipo sono separati da virgole.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2524">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="4ee8d-2525">Ad esempio, un oggetto generico <xref:System.Collections.Generic.Dictionary%602> ha due parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2525">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="4ee8d-2526">Oggetto <xref:System.Collections.Generic.Dictionary%602> dei `MyType` con le chiavi di tipo <xref:System.String> potrebbero essere rappresentati come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2526">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="4ee8d-2527">Per specificare un tipo qualificato dall'assembly all'interno di un elenco di argomenti, racchiudere il tipo qualificato dall'assembly racchiuso tra parentesi quadre.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2527">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="4ee8d-2528">In caso contrario, le virgole per separare le parti del nome qualificato dall'assembly vengono interpretate come argomenti di tipo aggiuntivi di delimitazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2528">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="4ee8d-2529">Ad esempio, un <xref:System.Collections.Generic.Dictionary%602> dei `MyType` da MyAssembly. dll, con le chiavi di tipo <xref:System.String>, può essere specificata come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2529">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-2530">Un tipo qualificato dall'assembly può essere racchiuso tra parentesi quadre solo quando viene visualizzata all'interno di un elenco di parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2530">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="4ee8d-2531">Le regole per la ricerca degli assembly per i tipi completi e non qualificati negli elenchi di parametri di tipo sono le stesse delle regole per i tipi non generici completi e non qualificati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2531">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="4ee8d-2532">Tipi nullable rappresentano un caso speciale di tipi generici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2532">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="4ee8d-2533">Ad esempio, un valore nullable <xref:System.Int32> è rappresentato dalla stringa "System.Nullable'1[System.Int32]".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2533">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-2534">In c#, C++ e Visual Basic è anche possibile ottenere i tipi nullable utilizzando operatori di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2534">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="4ee8d-2535">Ad esempio, il valore nullable <xref:System.Boolean> tipo restituito da `typeof(Nullable<bool>)` in c#, da `Nullable<Boolean>::typeid` in C++ e da `GetType(Nullable(Of Boolean))` in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2535">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="4ee8d-2536">La tabella seguente illustra la sintassi da utilizzare con `GetType` per vari tipi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2536">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="4ee8d-2537">Per ottenere</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2537">To Get</span></span>|<span data-ttu-id="4ee8d-2538">Usa</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2538">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="4ee8d-2539">Un valore nullable <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="4ee8d-2539">A nullable <xref:System.Int32></span></span>|<span data-ttu-id="4ee8d-2540">`Type.GetType("System.Nullable`1[System.Int32]")\`</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2540">`Type.GetType("System.Nullable`1[System.Int32]")\`</span></span>|  
|<span data-ttu-id="4ee8d-2541">Un puntatore non gestito a `MyType`</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2541">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="4ee8d-2542">Un puntatore non gestito a un puntatore a `MyType`</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2542">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="4ee8d-2543">Un puntatore gestito o un riferimento a `MyType`</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2543">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="4ee8d-2544">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2544">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="4ee8d-2545">Si noti che, a differenza dei puntatori, i riferimenti sono limitati a un solo livello.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2545">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="4ee8d-2546">Una classe padre e una classe annidata</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2546">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="4ee8d-2547">Una matrice unidimensionale con limite inferiore pari a 0</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2547">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="4ee8d-2548">Una matrice unidimensionale con limite inferiore sconosciuto</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2548">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="4ee8d-2549">Una matrice di n-dimensionale</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2549">An n-dimensional array</span></span>|<span data-ttu-id="4ee8d-2550">Una virgola (,) all'interno delle parentesi un totale di volte in cui n-1.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2550">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="4ee8d-2551">Ad esempio, `System.Object[,,]` rappresenta un oggetto tridimensionale `Object` matrice.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2551">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="4ee8d-2552">Una matrice bidimensionale</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2552">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="4ee8d-2553">Una matrice rettangolare bidimensionale con limiti inferiori sconosciuti</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2553">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="4ee8d-2554">Un tipo generico con un argomento di tipo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2554">A generic type with one type argument</span></span>|<span data-ttu-id="4ee8d-2555">`Type.GetType("MyGenericType`1[MyType]")'</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2555">`Type.GetType("MyGenericType`1[MyType]")\`</span></span>|  
|<span data-ttu-id="4ee8d-2556">Un tipo generico con due argomenti tipo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2556">A generic type with two type arguments</span></span>|<span data-ttu-id="4ee8d-2557">`Type.GetType("MyGenericType`2[MyType,AnotherType]")'</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2557">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span></span>|  
|<span data-ttu-id="4ee8d-2558">Un tipo generico con due argomenti di tipo qualificato dall'assembly</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2558">A generic type with two assembly-qualified type arguments</span></span>|<span data-ttu-id="4ee8d-2559">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")'</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2559">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span></span>|  
|<span data-ttu-id="4ee8d-2560">Un tipo generico con un argomento di tipo qualificato dall'assembly completo di assembly</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2560">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|<span data-ttu-id="4ee8d-2561">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")'</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2561">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span></span>|  
|<span data-ttu-id="4ee8d-2562">Un tipo generico il cui argomento tipo è un tipo generico con due argomenti di tipo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2562">A generic type whose type argument is a generic type with two type arguments</span></span>|<span data-ttu-id="4ee8d-2563">`Type.GetType("MyGenericType`1 [AnotherGenericType`2[MyType,AnotherType]]")`</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2563">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-2564">Nell'esempio seguente recupera il tipo della `System.Int32` e Usa l'oggetto tipo per visualizzare il <xref:System.Type.FullName%2A> proprietà di `System.Int32`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2564">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span> <span data-ttu-id="4ee8d-2565">Se un oggetto di tipo fa riferimento a un assembly che non esiste, questo esempio genera un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2565">If a type object refers to an assembly that does not exist, this example throws an exception.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-2566">
            <paramref name="typeName" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2566">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="4ee8d-2567">Viene richiamato un inizializzatore di classi e viene generata un'eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2567">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="4ee8d-2568">
            <paramref name="throwOnError" /> è <see langword="true" /> e il tipo non è stato trovato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2568">
              <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="4ee8d-2569">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2569">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2570">
            <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> contiene caratteri non validi, ad esempio una scheda incorporata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2570">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="4ee8d-2571">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2571">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2572">
            <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> è una stringa vuota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2572">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="4ee8d-2573">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2573">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2574">
            <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> rappresenta un tipo di matrice con una dimensione non valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2574">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="4ee8d-2575">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2575">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2576">
            <paramref name="typeName" /> rappresenta una matrice di <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2576">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-2577">
            <paramref name="throwOnError" /> è <see langword="true" /> e la sintassi di <paramref name="typeName" /> non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2577">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span>
          </span>
          <span data-ttu-id="4ee8d-2578">Ad esempio: "MyType[,\*,]".</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2578">For example, "MyType[,\*,]".</span>
          </span>
          <span data-ttu-id="4ee8d-2579">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2579">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2580">
            <paramref name="typeName" /> rappresenta un tipo generico che ha un tipo di puntatore, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> tra i relativi argomenti di tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2580">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="4ee8d-2581">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2581">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2582">
            <paramref name="typeName" /> rappresenta un tipo generico che ha un numero errato di argomenti di tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2582">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="4ee8d-2583">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2583">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2584">
            <paramref name="typeName" /> rappresenta un tipo generico e uno dei relativi argomenti di tipo non soddisfa i vincoli per il parametro di tipo corrispondente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2584">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="4ee8d-2585">
            <paramref name="throwOnError" /> è <see langword="true" /> e l'assembly o una delle sue dipendenze non è stato trovato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2585">
              <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="4ee8d-2586">In <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET per app di Windows Store</see> o nella <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">libreria di classi portabile</see> rilevare invece l'eccezione della classe di base, <see cref="T:System.IO.IOException" />.</span>
              <span class="sxs-lookup">
                <span data-stu-id="4ee8d-2586">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="4ee8d-2587">L'assembly o una delle relative dipendenze è stato trovato, ma non può essere caricato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2587">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="4ee8d-2588">L'assembly o una delle relative dipendenze non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2588">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="4ee8d-2589">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2589">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2590">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'assembly è stato compilato con una versione successiva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2590">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">
          <span data-ttu-id="4ee8d-2591">Specifica di nomi di tipo completi</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2591">Specifying Fully Qualified Type Names</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="4ee8d-2592">Nome qualificato dall'assembly del tipo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2592">The assembly-qualified name of the type to get.</span>
          </span>
          <span data-ttu-id="4ee8d-2593">Vedere <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2593">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          </span>
          <span data-ttu-id="4ee8d-2594">Se il tipo è incluso nell'assembly attualmente in esecuzione o in Mscorlib.dll, è sufficiente specificare il nome del tipo qualificato in base al relativo spazio dei nomi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2594">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="4ee8d-2595">
            <see langword="true" /> per generare un'eccezione se il tipo non viene trovato; <see langword="false" /> per restituire <see langword="null" />. Specificando <see langword="false" /> inoltre si eliminano alcune condizioni dell'eccezione, ma non tutte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2595">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="4ee8d-2596">Vedere la sezione relativa alle eccezioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2596">See the Exceptions section.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="4ee8d-2597">
            <see langword="true" /> per eseguire una ricerca di <c>typeName</c> senza distinzione tra maiuscole e minuscole, <see langword="false" /> per eseguire una ricerca di <c>typeName</c> con distinzione tra maiuscole e minuscole.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2597">
              <see langword="true" /> to perform a case-insensitive search for <c>typeName</c>, <see langword="false" /> to perform a case-sensitive search for <c>typeName</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-2598">Ottiene l'oggetto <see cref="T:System.Type" /> con il nome specificato, che indica se generare un'eccezione quando viene trovato il tipo e se eseguire una ricerca con distinzione tra maiuscole e minuscole.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2598">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-2599">Tipo con il nome specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2599">The type with the specified name.</span>
          </span>
          <span data-ttu-id="4ee8d-2600">Se il tipo non viene trovato, il parametro <paramref name="throwOnError" /> specifica se viene restituito <see langword="null" /> o se viene generata un'eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2600">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="4ee8d-2601">In alcuni casi, viene generata un'eccezione indipendentemente dal valore di <paramref name="throwOnError" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2601">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span>
          </span>
          <span data-ttu-id="4ee8d-2602">Vedere la sezione relativa alle eccezioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2602">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-2603">È possibile usare la <xref:System.Type.GetType%2A> metodo per ottenere un <xref:System.Type> dell'oggetto per un tipo in un altro assembly, se si conosce il nome qualificato dall'assembly che può essere ottenuto da <xref:System.Type.AssemblyQualifiedName>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2603">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if you know its assembly-qualified name which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="4ee8d-2604"><xref:System.Type.GetType%2A> causa il caricamento dell'assembly specificato nel `typeName`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2604"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="4ee8d-2605">È anche possibile caricare un assembly usando il <xref:System.Reflection.Assembly.Load%2A> (metodo) e quindi usare il <xref:System.Type.GetType%2A> o <xref:System.Reflection.Assembly.GetTypes%2A> metodi del <xref:System.Reflection.Assembly> classe per ottenere <xref:System.Type> oggetti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2605">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects.</span></span> <span data-ttu-id="4ee8d-2606">Se un tipo in un assembly è noto al programma in fase di compilazione, è preferibile usare `typeof` in c# <xref:System.Type.GetType%2A> in Visual Basic o `typeid` in C++.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2606">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++.</span></span>  
  
 <span data-ttu-id="4ee8d-2607">`GetType` funziona solo su assembly caricati dal disco.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2607">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="4ee8d-2608">Se si chiama `GetType` per cercare un tipo definito in un assembly dinamico definito mediante il <xref:System.Reflection.Emit> servizi, si potrebbe ottenere un comportamento incoerente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2608">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="4ee8d-2609">Il comportamento dipende dal fatto che l'assembly dinamico è permanente, vale a dire, creato con il `RunAndSave` oppure `Save` della modalità di accesso di <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2609">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="4ee8d-2610">Se l'assembly dinamico è permanente ed è stato scritto su disco prima `GetType` viene chiamato, il caricatore individua l'assembly salvato su disco, carica l'assembly e recupera il tipo da tale assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2610">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="4ee8d-2611">Se l'assembly non è stato salvato su disco quando `GetType` viene chiamato il metodo restituisce `null`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2611">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="4ee8d-2612">`GetType` non riconosce gli assembly dinamici temporanei; Pertanto, la chiamata `GetType` recuperare un tipo in un temporaneo restituisce l'assembly dinamico `null`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2612">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="4ee8d-2613">Per utilizzare `GetType` su un modulo dinamico, sottoscrivere il <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> eventi e chiamate `GetType` prima del salvataggio.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2613">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="4ee8d-2614">In caso contrario, si otterrà due copie dell'assembly in memoria.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2614">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="4ee8d-2615">Il `throwOnError` parametro specifica che cosa avviene quando non viene trovato, il tipo e vengono eliminate alcune condizioni di eccezione, come descritto nella sezione delle eccezioni.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2615">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="4ee8d-2616">Alcune eccezioni vengono generate indipendentemente dal valore di `throwOnError`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2616">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="4ee8d-2617">Ad esempio, se il tipo è stato trovato ma non può essere caricato, un <xref:System.TypeLoadException> viene generata anche se `throwOnError` è `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2617">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="4ee8d-2618">La tabella seguente mostra quali vengono restituiti dai membri di una classe di base di `Get` metodi durante la reflection su un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2618">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="4ee8d-2619">Tipo di membro</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2619">Member Type</span></span>|<span data-ttu-id="4ee8d-2620">Static</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2620">Static</span></span>|<span data-ttu-id="4ee8d-2621">Non statici</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2621">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="4ee8d-2622">Costruttore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2622">Constructor</span></span>|<span data-ttu-id="4ee8d-2623">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2623">No</span></span>|<span data-ttu-id="4ee8d-2624">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2624">No</span></span>|  
|<span data-ttu-id="4ee8d-2625">Campo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2625">Field</span></span>|<span data-ttu-id="4ee8d-2626">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2626">No</span></span>|<span data-ttu-id="4ee8d-2627">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2627">Yes.</span></span> <span data-ttu-id="4ee8d-2628">Un campo viene sempre hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2628">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-2629">event</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2629">Event</span></span>|<span data-ttu-id="4ee8d-2630">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2630">Not applicable</span></span>|<span data-ttu-id="4ee8d-2631">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2631">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-2632">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2632">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-2633">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2633">See note 2 below.</span></span>|  
|<span data-ttu-id="4ee8d-2634">Metodo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2634">Method</span></span>|<span data-ttu-id="4ee8d-2635">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2635">No</span></span>|<span data-ttu-id="4ee8d-2636">Sì.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2636">Yes.</span></span> <span data-ttu-id="4ee8d-2637">Un metodo (virtuale e non virtuale) può essere hide-by-name o hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2637">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="4ee8d-2638">Tipo annidato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2638">Nested Type</span></span>|<span data-ttu-id="4ee8d-2639">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2639">No</span></span>|<span data-ttu-id="4ee8d-2640">No</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2640">No</span></span>|  
|<span data-ttu-id="4ee8d-2641">Proprietà</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2641">Property</span></span>|<span data-ttu-id="4ee8d-2642">Non applicabile</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2642">Not applicable</span></span>|<span data-ttu-id="4ee8d-2643">La regola di sistema di tipo comune è che l'ereditarietà è uguale a quello dei metodi che implementa la proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2643">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="4ee8d-2644">Reflection considerati proprietà hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2644">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-2645">Vedere la nota 2 riportato di seguito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2645">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="4ee8d-2646">Hide-by-name-e-signature prende in considerazione tutte le parti della firma, inclusi i modificatori personalizzati, i tipi restituiti, i tipi di parametri, elementi sentinel e le convenzioni di chiamata non gestite.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2646">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="4ee8d-2647">Si tratta di un confronto binario.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2647">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="4ee8d-2648">Per la reflection, proprietà ed eventi sono hide-by-name-e-signature.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2648">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="4ee8d-2649">Se si dispone di una proprietà con una richiesta get e una funzione di accesso set nella classe di base, ma la classe derivata ha solo una funzione di accesso get, la proprietà della classe derivata nasconde la proprietà di classe di base e non sarà in grado di accedere il setter della classe base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2649">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="4ee8d-2650">Gli attributi personalizzati non fanno parte di common type system.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2650">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="4ee8d-2651">Le matrici o tipi COM non vengono cercati a meno che non sono già stati caricati nella tabella delle classi disponibili.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2651">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="4ee8d-2652">`typeName` può essere il nome del tipo qualificato dal relativo spazio dei nomi o un nome qualificato dall'assembly che include una specifica di nome di assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2652">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="4ee8d-2653">Vedere <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2653">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="4ee8d-2654">Se `typeName` include lo spazio dei nomi ma non il nome dell'assembly, questo metodo cercherà solo assembly dell'oggetto chiamante a mscorlib. dll, in quest'ordine.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2654">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="4ee8d-2655">Se typeName è completo, con il nome dell'assembly completo o parziale, questo metodo cerca nell'assembly specificato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2655">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="4ee8d-2656">Se l'assembly ha un nome sicuro, è necessario un nome completo dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2656">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="4ee8d-2657">Il <xref:System.Type.AssemblyQualifiedName%2A> proprietà restituisce un nome completo del tipo, inclusi i tipi annidati, il nome dell'assembly e gli argomenti di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2657">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and type arguments.</span></span> <span data-ttu-id="4ee8d-2658">Tutti i compilatori che supportano common language runtime genererà il semplice nome di una classe annidata, e un nome modificato quando si riceve una richiesta, in conformità con le seguenti convenzioni di costrutti di reflection.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2658">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-2659">In .NET Framework versione 2.0, architettura del processore viene aggiunta all'identità di assembly e può essere specificato come parte di stringhe di nomi di assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2659">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="4ee8d-2660">Ad esempio, "ProcessorArchitecture = msil".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2660">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="4ee8d-2661">Tuttavia, non è incluso nella stringa restituita dal <xref:System.Type.AssemblyQualifiedName%2A> proprietà, per motivi di compatibilità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2661">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="4ee8d-2662">È anche possibile caricare i tipi creando un <xref:System.Reflection.AssemblyName> oggetto e passandolo a un overload appropriato del <xref:System.Reflection.Assembly.Load%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2662">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="4ee8d-2663">È quindi possibile usare il <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> per caricare i tipi dall'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2663">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="4ee8d-2664">Vedere anche <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2664">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="4ee8d-2665">Delimitatore</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2665">Delimiter</span></span>|<span data-ttu-id="4ee8d-2666">Significato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2666">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="4ee8d-2667">Barra rovesciata (\\)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2667">Backslash (\\)</span></span>|<span data-ttu-id="4ee8d-2668">Carattere di escape.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2668">Escape character.</span></span>|  
|<span data-ttu-id="4ee8d-2669">Apice inverso (')</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2669">Backtick (\`)</span></span>|<span data-ttu-id="4ee8d-2670">Precede una o più cifre che rappresenta il numero di parametri di tipo, che si trova alla fine del nome di un tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2670">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="4ee8d-2671">Parentesi quadre ([])</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2671">Brackets ([])</span></span>|<span data-ttu-id="4ee8d-2672">Racchiudere un elenco di argomenti tipo generico, per un tipo generico costruito. all'interno di un elenco di argomenti, racchiudere un tipo qualificato dall'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2672">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="4ee8d-2673">Virgola ()</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2673">Comma (,)</span></span>|<span data-ttu-id="4ee8d-2674">Precede il nome dell'Assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2674">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="4ee8d-2675">Punto (.)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2675">Period (.)</span></span>|<span data-ttu-id="4ee8d-2676">Indica gli identificatori dello spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2676">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="4ee8d-2677">Segno più (+)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2677">Plus sign (+)</span></span>|<span data-ttu-id="4ee8d-2678">Precede una classe annidata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2678">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="4ee8d-2679">Ad esempio, il nome completo per una classe potrebbe essere simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2679">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="4ee8d-2680">Se lo spazio dei nomi sono stati TopNamespace.Sub+Namespace, quindi la stringa avrebbe in modo che preceda il segno più (+) con un carattere di escape (\\) per impedire che venga interpretato come separatore di annidamento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2680">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="4ee8d-2681">Reflection genera questa stringa come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2681">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="4ee8d-2682">Oggetto "+" diventa "\\+\\+" e un "\\"diventa"\\\\".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2682">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="4ee8d-2683">Questo nome completo può essere persistente e successivamente utilizzato per caricare il <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2683">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="4ee8d-2684">Per cercare e caricare un <xref:System.Type>, usare <xref:System.Type.GetType%2A> o con il tipo di nome solo oppure con il nome completo del tipo dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2684">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="4ee8d-2685"><xref:System.Type.GetType%2A> con il tipo di nome solo cercherà il <xref:System.Type> nell'assembly del chiamante, quindi nell'assembly di sistema.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2685"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="4ee8d-2686"><xref:System.Type.GetType%2A> con l'assembly avrà un aspetto completo del tipo il <xref:System.Type> nell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2686"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="4ee8d-2687">I nomi dei tipi possono includere caratteri finali che indicano le informazioni aggiuntive sul tipo, ad esempio se il tipo è un tipo riferimento, un tipo di puntatore o un tipo di matrice.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2687">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="4ee8d-2688">Per recuperare il nome del tipo senza caratteri finali, usare `t.GetElementType().ToString()`, dove `t` è il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2688">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="4ee8d-2689">Gli spazi sono rilevanti in tutti i componenti di nome di tipo tranne il nome dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2689">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="4ee8d-2690">Il nome di assembly e spazi che precedono il separatore ',' sono rilevanti, ma gli spazi dopo il separatore ',' vengono ignorati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2690">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="4ee8d-2691">Il nome di un tipo generico termina con un apice inverso (\`) seguito da cifre che rappresenta il numero di argomenti di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2691">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="4ee8d-2692">Lo scopo di questo tipo di alterazione dei nomi è consentire o meno i compilatori supportare i tipi generici con lo stesso nome ma con un numero diverso di parametri di tipo, che si verificano nello stesso ambito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2692">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="4ee8d-2693">Ad esempio, reflection vengono restituiti i nomi modificati `Tuple`1` and `tupla`2` da metodi generici `Tuple(Of T)` e `Tuple(Of T0, T1)` in Visual Basic oppure `Tuple<T>` tupla e`\<T0, T1>` in Visual c#.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2693">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="4ee8d-2694">Per i tipi generici, l'elenco di argomenti di tipo è racchiusa tra parentesi e gli argomenti di tipo sono separati da virgole.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2694">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="4ee8d-2695">Ad esempio, un oggetto generico <xref:System.Collections.Generic.Dictionary%602> ha due parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2695">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="4ee8d-2696">Oggetto <xref:System.Collections.Generic.Dictionary%602> dei `MyType` con le chiavi di tipo <xref:System.String> potrebbero essere rappresentati come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2696">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="4ee8d-2697">Per specificare un tipo qualificato dall'assembly all'interno di un elenco di argomenti, racchiudere il tipo qualificato dall'assembly racchiuso tra parentesi quadre.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2697">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="4ee8d-2698">In caso contrario, le virgole per separare le parti del nome qualificato dall'assembly vengono interpretate come argomenti di tipo aggiuntivi di delimitazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2698">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="4ee8d-2699">Ad esempio, un <xref:System.Collections.Generic.Dictionary%602> dei `MyType` da MyAssembly. dll, con le chiavi di tipo <xref:System.String>, può essere specificata come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2699">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-2700">Un tipo qualificato dall'assembly può essere racchiuso tra parentesi quadre solo quando viene visualizzata all'interno di un elenco di parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2700">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="4ee8d-2701">Le regole per la ricerca degli assembly per i tipi completi e non qualificati negli elenchi di parametri di tipo sono le stesse delle regole per i tipi non generici completi e non qualificati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2701">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="4ee8d-2702">Tipi nullable rappresentano un caso speciale di tipi generici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2702">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="4ee8d-2703">Ad esempio, un valore nullable <xref:System.Int32> è rappresentato dalla stringa "System.Nullable'1[System.Int32]".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2703">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-2704">In c#, C++ e Visual Basic è anche possibile ottenere i tipi nullable utilizzando operatori di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2704">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="4ee8d-2705">Ad esempio, il valore nullable <xref:System.Boolean> tipo restituito da `typeof(Nullable<bool>)` in c#, da `Nullable<Boolean>::typeid` in C++ e da `GetType(Nullable(Of Boolean))` in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2705">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="4ee8d-2706">La tabella seguente illustra la sintassi da utilizzare con `GetType` per vari tipi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2706">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="4ee8d-2707">Per ottenere</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2707">To Get</span></span>|<span data-ttu-id="4ee8d-2708">Usa</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2708">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="4ee8d-2709">Un valore nullable <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="4ee8d-2709">A nullable <xref:System.Int32></span></span>|<span data-ttu-id="4ee8d-2710">`Type.GetType("System.Nullable`1[System.Int32]")\`</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2710">`Type.GetType("System.Nullable`1[System.Int32]")\`</span></span>|  
|<span data-ttu-id="4ee8d-2711">Un puntatore non gestito a `MyType`</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2711">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="4ee8d-2712">Un puntatore non gestito a un puntatore a `MyType`</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2712">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="4ee8d-2713">Un puntatore gestito o un riferimento a `MyType`</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2713">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="4ee8d-2714">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2714">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="4ee8d-2715">Si noti che, a differenza dei puntatori, i riferimenti sono limitati a un solo livello.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2715">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="4ee8d-2716">Una classe padre e una classe annidata</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2716">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="4ee8d-2717">Una matrice unidimensionale con limite inferiore pari a 0</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2717">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="4ee8d-2718">Una matrice unidimensionale con limite inferiore sconosciuto</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2718">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="4ee8d-2719">Una matrice di n-dimensionale</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2719">An n-dimensional array</span></span>|<span data-ttu-id="4ee8d-2720">Una virgola (,) all'interno delle parentesi un totale di volte in cui n-1.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2720">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="4ee8d-2721">Ad esempio, `System.Object[,,]` rappresenta un oggetto tridimensionale `Object` matrice.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2721">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="4ee8d-2722">Una matrice bidimensionale</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2722">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="4ee8d-2723">Una matrice rettangolare bidimensionale con limiti inferiori sconosciuti</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2723">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="4ee8d-2724">Un tipo generico con un argomento di tipo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2724">A generic type with one type argument</span></span>|<span data-ttu-id="4ee8d-2725">`Type.GetType("MyGenericType`1[MyType]")'</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2725">`Type.GetType("MyGenericType`1[MyType]")\`</span></span>|  
|<span data-ttu-id="4ee8d-2726">Un tipo generico con due argomenti tipo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2726">A generic type with two type arguments</span></span>|<span data-ttu-id="4ee8d-2727">`Type.GetType("MyGenericType`2[MyType,AnotherType]")'</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2727">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span></span>|  
|<span data-ttu-id="4ee8d-2728">Un tipo generico con due argomenti di tipo qualificato dall'assembly</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2728">A generic type with two assembly-qualified type arguments</span></span>|<span data-ttu-id="4ee8d-2729">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")'</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2729">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span></span>|  
|<span data-ttu-id="4ee8d-2730">Un tipo generico con un argomento di tipo qualificato dall'assembly completo di assembly</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2730">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|<span data-ttu-id="4ee8d-2731">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")'</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2731">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span></span>|  
|<span data-ttu-id="4ee8d-2732">Un tipo generico il cui argomento tipo è un tipo generico con due argomenti di tipo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2732">A generic type whose type argument is a generic type with two type arguments</span></span>|<span data-ttu-id="4ee8d-2733">`Type.GetType("MyGenericType`1 [AnotherGenericType`2[MyType,AnotherType]]")`</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2733">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-2734">
            <paramref name="typeName" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2734">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="4ee8d-2735">Viene richiamato un inizializzatore di classi e viene generata un'eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2735">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="4ee8d-2736">
            <paramref name="throwOnError" /> è <see langword="true" /> e il tipo non è stato trovato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2736">
              <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="4ee8d-2737">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2737">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2738">
            <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> contiene caratteri non validi, ad esempio una scheda incorporata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2738">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="4ee8d-2739">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2739">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2740">
            <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> è una stringa vuota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2740">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="4ee8d-2741">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2741">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2742">
            <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> rappresenta un tipo di matrice con una dimensione non valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2742">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="4ee8d-2743">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2743">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2744">
            <paramref name="typeName" /> rappresenta una matrice di <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2744">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-2745">
            <paramref name="throwOnError" /> è <see langword="true" /> e la sintassi di <paramref name="typeName" /> non è valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2745">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span>
          </span>
          <span data-ttu-id="4ee8d-2746">Ad esempio: "MyType[,\*,]".</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2746">For example, "MyType[,\*,]".</span>
          </span>
          <span data-ttu-id="4ee8d-2747">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2747">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2748">
            <paramref name="typeName" /> rappresenta un tipo generico che ha un tipo di puntatore, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> tra i relativi argomenti di tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2748">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="4ee8d-2749">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2749">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2750">
            <paramref name="typeName" /> rappresenta un tipo generico che ha un numero errato di argomenti di tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2750">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="4ee8d-2751">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2751">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2752">
            <paramref name="typeName" /> rappresenta un tipo generico e uno dei relativi argomenti di tipo non soddisfa i vincoli per il parametro di tipo corrispondente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2752">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="4ee8d-2753">
            <paramref name="throwOnError" /> è <see langword="true" /> e l'assembly o una delle sue dipendenze non è stato trovato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2753">
              <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="4ee8d-2754">L'assembly o una delle relative dipendenze è stato trovato, ma non può essere caricato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2754">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="4ee8d-2755">L'assembly o una delle relative dipendenze non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2755">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="4ee8d-2756">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2756">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2757">Attualmente è caricata la versione 2.0 o successiva di Common Language Runtime e l'assembly è stato compilato con una versione successiva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2757">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">
          <span data-ttu-id="4ee8d-2758">Specifica di nomi di tipo completi</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2758">Specifying Fully Qualified Type Names</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="4ee8d-2759">Nome del tipo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2759">The name of the type to get.</span>
          </span>
          <span data-ttu-id="4ee8d-2760">Se viene specificato il parametro <c>typeResolver</c>, il nome del tipo può essere qualsiasi stringa che <c>typeResolver</c> è in grado di risolvere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2760">If the <c>typeResolver</c> parameter is provided, the type name can be any string that <c>typeResolver</c> is capable of resolving.</span>
          </span>
          <span data-ttu-id="4ee8d-2761">Se viene specificato il parametro <c>assemblyResolver</c> o viene usata la risoluzione del tipo standard, <c>typeName</c> deve essere un nome qualificato dall'assembly (vedere <see cref="P:System.Type.AssemblyQualifiedName" />), a meno che il tipo non si trovi nell'assembly attualmente in esecuzione o in Mscorlib.dll, nel qual caso è sufficiente indicare il nome del tipo qualificato in base al relativo spazio dei nomi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2761">If the <c>assemblyResolver</c> parameter is provided or if standard type resolution is used, <c>typeName</c> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="assemblyResolver">
          <span data-ttu-id="4ee8d-2762">Metodo che individua e restituisce l'assembly specificato in <c>typeName</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2762">A method that locates and returns the assembly that is specified in <c>typeName</c>.</span>
          </span>
          <span data-ttu-id="4ee8d-2763">Il nome dell'assembly viene passato ad <c>assemblyResolver</c> come oggetto <see cref="T:System.Reflection.AssemblyName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2763">The assembly name is passed to <c>assemblyResolver</c> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span>
          </span>
          <span data-ttu-id="4ee8d-2764">Se <c>typeName</c> non contiene il nome di un assembly, <c>assemblyResolver</c> non viene chiamato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2764">If <c>typeName</c> does not contain the name of an assembly, <c>assemblyResolver</c> is not called.</span>
          </span>
          <span data-ttu-id="4ee8d-2765">Se non si specifica <c>assemblyResolver</c>, viene eseguita la risoluzione dell'assembly standard.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2765">If <c>assemblyResolver</c> is not supplied, standard assembly resolution is performed.</span>
          </span>
          <span data-ttu-id="4ee8d-2766">Attenzione   Non passare metodi da chiamanti non noti o non attendibili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2766">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
          <span data-ttu-id="4ee8d-2767">In caso contrario, potrebbe verificarsi un'elevazione di privilegi per codice dannoso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2767">Doing so could result in elevation of privilege for malicious code.</span>
          </span>
          <span data-ttu-id="4ee8d-2768">Usare solo i metodi forniti o con cui si ha dimestichezza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2768">Use only methods that you provide or that you are familiar with.</span>
          </span>
        </param>
        <param name="typeResolver">
          <span data-ttu-id="4ee8d-2769">Metodo che individua e restituisce il tipo specificato da <c>typeName</c> dall'assembly restituito da <c>assemblyResolver</c> o dalla risoluzione dell'assembly standard.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2769">A method that locates and returns the type that is specified by <c>typeName</c> from the assembly that is returned by <c>assemblyResolver</c> or by standard assembly resolution.</span>
          </span>
          <span data-ttu-id="4ee8d-2770">Se non viene indicato alcun assembly, il metodo <c>typeResolver</c> può specificarne uno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2770">If no assembly is provided, the <c>typeResolver</c> method can provide one.</span>
          </span>
          <span data-ttu-id="4ee8d-2771">Il metodo accetta inoltre un parametro che specifica se eseguire una ricerca senza fare distinzione tra maiuscole e minuscole. <see langword="false" /> viene passato al parametro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2771">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span>
          </span>
          <span data-ttu-id="4ee8d-2772">Attenzione   Non passare metodi da chiamanti non noti o non attendibili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2772">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-2773">Ottiene il tipo con il nome specificato, fornendo facoltativamente metodi personalizzati per risolvere l'assembly e il tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2773">Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-2774">Tipo con il nome specificato, oppure <see langword="null" /> se il tipo non viene trovato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2774">The type with the specified name, or <see langword="null" /> if the type is not found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-2775">Scenari di utilizzo per questo metodo e informazioni dettagliate sulle `assemblyResolver` e `typeResolver` i parametri sono reperibili nel <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2775">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-2776">Se `typeName` non viene trovato, la chiamata per il <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> restituzione del metodo `null`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2776">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> method returns `null`.</span></span> <span data-ttu-id="4ee8d-2777">Non genera un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2777">It does not throw an exception.</span></span> <span data-ttu-id="4ee8d-2778">Per controllare se viene generata un'eccezione, chiamare un overload del <xref:System.Type.GetType%2A> metodo che presenta un `throwOnError` parametro.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2778">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="4ee8d-2779">Chiamare questo overload del metodo è uguale alla chiamata al metodo il <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> overload del metodo e specificando `false` per il `throwOnError` e `ignoreCase` parametri.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2779">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `throwOnError` and `ignoreCase` parameters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-2780">
            <paramref name="typeName" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2780">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="4ee8d-2781">Viene richiamato un inizializzatore di classi e viene generata un'eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2781">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-2782">Si verifica un errore quando <paramref name="typeName" /> viene analizzato in un nome del tipo e un nome dell'assembly (ad esempio, quando il nome del tipo semplice include un carattere speciale senza codice di escape).</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2782">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span>
          </span>
          <span data-ttu-id="4ee8d-2783">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2783">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2784">
            <paramref name="typeName" /> rappresenta un tipo generico che ha un tipo di puntatore, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> tra i relativi argomenti di tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2784">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="4ee8d-2785">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2785">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2786">
            <paramref name="typeName" /> rappresenta un tipo generico che ha un numero errato di argomenti di tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2786">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="4ee8d-2787">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2787">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2788">
            <paramref name="typeName" /> rappresenta un tipo generico e uno dei relativi argomenti di tipo non soddisfa i vincoli per il parametro di tipo corrispondente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2788">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="4ee8d-2789">
            <paramref name="typeName" /> rappresenta una matrice di <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2789">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="4ee8d-2790">L'assembly o una delle relative dipendenze è stato trovato, ma non può essere caricato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2790">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
          <span data-ttu-id="4ee8d-2791">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2791">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2792">
            <paramref name="typeName" /> contiene un nome dell'assembly non valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2792">
              <paramref name="typeName" /> contains an invalid assembly name.</span>
          </span>
          <span data-ttu-id="4ee8d-2793">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2793">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2794">
            <paramref name="typeName" /> è un nome dell'assembly valido senza un nome di tipi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2794">
              <paramref name="typeName" /> is a valid assembly name without a type name.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="4ee8d-2795">L'assembly o una delle relative dipendenze non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2795">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="4ee8d-2796">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2796">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2797">L'assembly è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2797">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="4ee8d-2798">Nome del tipo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2798">The name of the type to get.</span>
          </span>
          <span data-ttu-id="4ee8d-2799">Se viene specificato il parametro <c>typeResolver</c>, il nome del tipo può essere qualsiasi stringa che <c>typeResolver</c> è in grado di risolvere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2799">If the <c>typeResolver</c> parameter is provided, the type name can be any string that <c>typeResolver</c> is capable of resolving.</span>
          </span>
          <span data-ttu-id="4ee8d-2800">Se viene specificato il parametro <c>assemblyResolver</c> o viene usata la risoluzione del tipo standard, <c>typeName</c> deve essere un nome qualificato dall'assembly (vedere <see cref="P:System.Type.AssemblyQualifiedName" />), a meno che il tipo non si trovi nell'assembly attualmente in esecuzione o in Mscorlib.dll, nel qual caso è sufficiente indicare il nome del tipo qualificato in base al relativo spazio dei nomi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2800">If the <c>assemblyResolver</c> parameter is provided or if standard type resolution is used, <c>typeName</c> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="assemblyResolver">
          <span data-ttu-id="4ee8d-2801">Metodo che individua e restituisce l'assembly specificato in <c>typeName</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2801">A method that locates and returns the assembly that is specified in <c>typeName</c>.</span>
          </span>
          <span data-ttu-id="4ee8d-2802">Il nome dell'assembly viene passato ad <c>assemblyResolver</c> come oggetto <see cref="T:System.Reflection.AssemblyName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2802">The assembly name is passed to <c>assemblyResolver</c> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span>
          </span>
          <span data-ttu-id="4ee8d-2803">Se <c>typeName</c> non contiene il nome di un assembly, <c>assemblyResolver</c> non viene chiamato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2803">If <c>typeName</c> does not contain the name of an assembly, <c>assemblyResolver</c> is not called.</span>
          </span>
          <span data-ttu-id="4ee8d-2804">Se non si specifica <c>assemblyResolver</c>, viene eseguita la risoluzione dell'assembly standard.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2804">If <c>assemblyResolver</c> is not supplied, standard assembly resolution is performed.</span>
          </span>
          <span data-ttu-id="4ee8d-2805">Attenzione   Non passare metodi da chiamanti non noti o non attendibili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2805">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
          <span data-ttu-id="4ee8d-2806">In caso contrario, potrebbe verificarsi un'elevazione di privilegi per codice dannoso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2806">Doing so could result in elevation of privilege for malicious code.</span>
          </span>
          <span data-ttu-id="4ee8d-2807">Usare solo i metodi forniti o con cui si ha dimestichezza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2807">Use only methods that you provide or that you are familiar with.</span>
          </span>
        </param>
        <param name="typeResolver">
          <span data-ttu-id="4ee8d-2808">Metodo che individua e restituisce il tipo specificato da <c>typeName</c> dall'assembly restituito da <c>assemblyResolver</c> o dalla risoluzione dell'assembly standard.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2808">A method that locates and returns the type that is specified by <c>typeName</c> from the assembly that is returned by <c>assemblyResolver</c> or by standard assembly resolution.</span>
          </span>
          <span data-ttu-id="4ee8d-2809">Se non viene fornito alcun assembly, il metodo può fornirne uno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2809">If no assembly is provided, the method can provide one.</span>
          </span>
          <span data-ttu-id="4ee8d-2810">Il metodo accetta inoltre un parametro che specifica se eseguire una ricerca senza fare distinzione tra maiuscole e minuscole. <see langword="false" /> viene passato al parametro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2810">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span>
          </span>
          <span data-ttu-id="4ee8d-2811">Attenzione   Non passare metodi da chiamanti non noti o non attendibili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2811">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="4ee8d-2812">
            <see langword="true" /> per generare un'eccezione se non è possibile trovare il tipo; <see langword="false" /> per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2812">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-2813">Se si specifica <see langword="false" /> vengono eliminate alcune condizioni di eccezione, ma non tutte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2813">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="4ee8d-2814">Vedere la sezione relativa alle eccezioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2814">See the Exceptions section.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-2815">Ottiene il tipo con il nome specificato, indicando se generare un'eccezione se il tipo non viene trovato e fornendo facoltativamente metodi personalizzati per risolvere l'assembly e il tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2815">Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-2816">Tipo con il nome specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2816">The type with the specified name.</span>
          </span>
          <span data-ttu-id="4ee8d-2817">Se il tipo non viene trovato, il parametro <paramref name="throwOnError" /> specifica se viene restituito <see langword="null" /> o se viene generata un'eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2817">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="4ee8d-2818">In alcuni casi, viene generata un'eccezione indipendentemente dal valore di <paramref name="throwOnError" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2818">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span>
          </span>
          <span data-ttu-id="4ee8d-2819">Vedere la sezione relativa alle eccezioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2819">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-2820">Scenari di utilizzo per questo metodo e informazioni dettagliate sulle `assemblyResolver` e `typeResolver` i parametri sono reperibili nel <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2820">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="4ee8d-2821">Chiamare questo overload del metodo è uguale alla chiamata al metodo il <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> overload del metodo e specificando `false` per il `ignoreCase` parametro.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2821">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `ignoreCase` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-2822">
            <paramref name="typeName" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2822">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="4ee8d-2823">Viene richiamato un inizializzatore di classi e viene generata un'eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2823">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="4ee8d-2824">
            <paramref name="throwOnError" /> è <see langword="true" /> e il tipo non è stato trovato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2824">
              <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="4ee8d-2825">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2825">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2826">
            <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> contiene caratteri non validi, ad esempio una scheda incorporata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2826">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="4ee8d-2827">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2827">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2828">
            <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> è una stringa vuota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2828">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="4ee8d-2829">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2829">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2830">
            <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> rappresenta un tipo di matrice con una dimensione non valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2830">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="4ee8d-2831">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2831">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2832">
            <paramref name="typeName" /> rappresenta una matrice di <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2832">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-2833">Si verifica un errore quando <paramref name="typeName" /> viene analizzato in un nome del tipo e un nome dell'assembly (ad esempio, quando il nome del tipo semplice include un carattere speciale senza codice di escape).</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2833">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span>
          </span>
          <span data-ttu-id="4ee8d-2834">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2834">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2835">
            <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> contiene sintassi non valida (ad esempio, "MyType [,\*,]").</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2835">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span>
          </span>
          <span data-ttu-id="4ee8d-2836">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2836">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2837">
            <paramref name="typeName" /> rappresenta un tipo generico che ha un tipo di puntatore, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> tra i relativi argomenti di tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2837">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="4ee8d-2838">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2838">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2839">
            <paramref name="typeName" /> rappresenta un tipo generico che ha un numero errato di argomenti di tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2839">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="4ee8d-2840">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2840">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2841">
            <paramref name="typeName" /> rappresenta un tipo generico e uno dei relativi argomenti di tipo non soddisfa i vincoli per il parametro di tipo corrispondente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2841">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="4ee8d-2842">
            <paramref name="throwOnError" /> è <see langword="true" /> e l'assembly o una delle sue dipendenze non è stato trovato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2842">
              <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
          <span data-ttu-id="4ee8d-2843">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2843">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2844">
            <paramref name="typeName" /> contiene un nome dell'assembly non valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2844">
              <paramref name="typeName" /> contains an invalid assembly name.</span>
          </span>
          <span data-ttu-id="4ee8d-2845">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2845">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2846">
            <paramref name="typeName" /> è un nome dell'assembly valido senza un nome di tipi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2846">
              <paramref name="typeName" /> is a valid assembly name without a type name.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="4ee8d-2847">L'assembly o una delle relative dipendenze è stato trovato, ma non può essere caricato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2847">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="4ee8d-2848">L'assembly o una delle relative dipendenze non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2848">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="4ee8d-2849">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2849">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-2850">L'assembly è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2850">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="4ee8d-2851">Nome del tipo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2851">The name of the type to get.</span>
          </span>
          <span data-ttu-id="4ee8d-2852">Se viene specificato il parametro <c>typeResolver</c>, il nome del tipo può essere qualsiasi stringa che <c>typeResolver</c> è in grado di risolvere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2852">If the <c>typeResolver</c> parameter is provided, the type name can be any string that <c>typeResolver</c> is capable of resolving.</span>
          </span>
          <span data-ttu-id="4ee8d-2853">Se viene specificato il parametro <c>assemblyResolver</c> o viene usata la risoluzione del tipo standard, <c>typeName</c> deve essere un nome qualificato dall'assembly (vedere <see cref="P:System.Type.AssemblyQualifiedName" />), a meno che il tipo non si trovi nell'assembly attualmente in esecuzione o in Mscorlib.dll, nel qual caso è sufficiente indicare il nome del tipo qualificato in base al relativo spazio dei nomi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2853">If the <c>assemblyResolver</c> parameter is provided or if standard type resolution is used, <c>typeName</c> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="assemblyResolver">
          <span data-ttu-id="4ee8d-2854">Metodo che individua e restituisce l'assembly specificato in <c>typeName</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2854">A method that locates and returns the assembly that is specified in <c>typeName</c>.</span>
          </span>
          <span data-ttu-id="4ee8d-2855">Il nome dell'assembly viene passato ad <c>assemblyResolver</c> come oggetto <see cref="T:System.Reflection.AssemblyName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2855">The assembly name is passed to <c>assemblyResolver</c> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span>
          </span>
          <span data-ttu-id="4ee8d-2856">Se <c>typeName</c> non contiene il nome di un assembly, <c>assemblyResolver</c> non viene chiamato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2856">If <c>typeName</c> does not contain the name of an assembly, <c>assemblyResolver</c> is not called.</span>
          </span>
          <span data-ttu-id="4ee8d-2857">Se non si specifica <c>assemblyResolver</c>, viene eseguita la risoluzione dell'assembly standard.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2857">If <c>assemblyResolver</c> is not supplied, standard assembly resolution is performed.</span>
          </span>
          <span data-ttu-id="4ee8d-2858">Attenzione   Non passare metodi da chiamanti non noti o non attendibili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2858">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
          <span data-ttu-id="4ee8d-2859">In caso contrario, potrebbe verificarsi un'elevazione di privilegi per codice dannoso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2859">Doing so could result in elevation of privilege for malicious code.</span>
          </span>
          <span data-ttu-id="4ee8d-2860">Usare solo i metodi forniti o con cui si ha dimestichezza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2860">Use only methods that you provide or that you are familiar with.</span>
          </span>
        </param>
        <param name="typeResolver">
          <span data-ttu-id="4ee8d-2861">Metodo che individua e restituisce il tipo specificato da <c>typeName</c> dall'assembly restituito da <c>assemblyResolver</c> o dalla risoluzione dell'assembly standard.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2861">A method that locates and returns the type that is specified by <c>typeName</c> from the assembly that is returned by <c>assemblyResolver</c> or by standard assembly resolution.</span>
          </span>
          <span data-ttu-id="4ee8d-2862">Se non viene fornito alcun assembly, il metodo può fornirne uno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2862">If no assembly is provided, the method can provide one.</span>
          </span>
          <span data-ttu-id="4ee8d-2863">Il metodo accetta inoltre un parametro che specifica se eseguire una ricerca senza fare distinzione tra maiuscole e minuscole. Il valore di <c>ignoreCase</c> viene passato a quel parametro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2863">The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <c>ignoreCase</c> is passed to that parameter.</span>
          </span>
          <span data-ttu-id="4ee8d-2864">Attenzione   Non passare metodi da chiamanti non noti o non attendibili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2864">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="4ee8d-2865">
            <see langword="true" /> per generare un'eccezione se non è possibile trovare il tipo; <see langword="false" /> per restituire <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2865">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-2866">Se si specifica <see langword="false" /> vengono eliminate alcune condizioni di eccezione, ma non tutte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2866">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="4ee8d-2867">Vedere la sezione relativa alle eccezioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2867">See the Exceptions section.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="4ee8d-2868">
            <see langword="true" /> per eseguire una ricerca di <c>typeName</c> senza distinzione tra maiuscole e minuscole, <see langword="false" /> per eseguire una ricerca di <c>typeName</c> con distinzione tra maiuscole e minuscole.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2868">
              <see langword="true" /> to perform a case-insensitive search for <c>typeName</c>, <see langword="false" /> to perform a case-sensitive search for <c>typeName</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-2869">Ottiene il tipo con il nome specificato, indicando se eseguire una ricerca facendo distinzione tra maiuscole e minuscole e se generare un'eccezione se il tipo non viene trovato e fornendo facoltativamente metodi personalizzati per risolvere l'assembly e il tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2869">Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-2870">Tipo con il nome specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2870">The type with the specified name.</span>
          </span>
          <span data-ttu-id="4ee8d-2871">Se il tipo non viene trovato, il parametro <paramref name="throwOnError" /> specifica se viene restituito <see langword="null" /> o se viene generata un'eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2871">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="4ee8d-2872">In alcuni casi, viene generata un'eccezione indipendentemente dal valore di <paramref name="throwOnError" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2872">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span>
          </span>
          <span data-ttu-id="4ee8d-2873">Vedere la sezione relativa alle eccezioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-2873">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-2874">Utilizzare questo overload del metodo e i rispettivi overload associati (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> e <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) per sostituire l'implementazione predefinita del <xref:System.Type.GetType%2A> metodo con le implementazioni più flessibile.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2874">Use this method overload and its associated overloads (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> and <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) to replace the default implementation of the <xref:System.Type.GetType%2A> method with more flexible implementations.</span></span> <span data-ttu-id="4ee8d-2875">Fornendo i propri metodi di risolvere i nomi dei tipi e i nomi degli assembly che li contengono, è possibile eseguire le operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2875">By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:</span></span>  
  
-   <span data-ttu-id="4ee8d-2876">Controllare quale versione di un assembly viene caricato da un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2876">Control which version of an assembly a type is loaded from.</span></span>  
  
-   <span data-ttu-id="4ee8d-2877">Specificare un altro elemento da esaminare per un nome di tipo che non include un nome di assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2877">Provide another place to look for a type name that does not include an assembly name.</span></span>  
  
-   <span data-ttu-id="4ee8d-2878">Caricare gli assembly con nomi di assembly parziali.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2878">Load assemblies using partial assembly names.</span></span>  
  
-   <span data-ttu-id="4ee8d-2879">Restituisce le sottoclassi di <xref:System.Type?displayProperty=nameWithType> che non vengono creati da common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2879">Return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the common language runtime (CLR).</span></span>  
  
 <span data-ttu-id="4ee8d-2880">Ad esempio, di serializzazione a tolleranza di versione questo metodo consente di cercare un assembly "best fit" usando un nome parziale.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2880">For example, in version-tolerant serialization this method enables you to search for a "best fit" assembly by using a partial name.</span></span> <span data-ttu-id="4ee8d-2881">Altri overload del <xref:System.Type.GetType%2A> metodo richiede un nome di tipo qualificato dall'assembly, che include il numero di versione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2881">Other overloads of the <xref:System.Type.GetType%2A> method require an assembly-qualified type name, which includes the version number.</span></span>  
  
 <span data-ttu-id="4ee8d-2882">Potrebbe essere necessario ripristinare le sottoclassi di implementazioni alternative del sistema di tipi <xref:System.Type?displayProperty=nameWithType> che non vengono create da CLR, tutti i tipi che vengono restituiti dagli altri overload del <xref:System.Type.GetType%2A> metodo sono tipi di runtime.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2882">Alternate implementations of the type system may need to return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the CLR; all types that are returned by other overloads of the <xref:System.Type.GetType%2A> method are runtime types.</span></span>  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a><span data-ttu-id="4ee8d-2883">Note sull'utilizzo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2883">Usage Notes</span></span>  
 <span data-ttu-id="4ee8d-2884">Questo overload del metodo e i rispettivi overload associati analizzare `typeName` nel nome di un tipo e il nome di un assembly e quindi la risoluzione dei nomi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2884">This method overload and its associated overloads parse `typeName` into the name of a type and the name of an assembly, and then resolve the names.</span></span> <span data-ttu-id="4ee8d-2885">Risoluzione del nome dell'assembly si verifica prima della risoluzione del nome del tipo, perché un nome di tipo deve essere risolto nel contesto di un assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2885">Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-2886">Se non si ha familiarità con il concetto di nomi di tipo qualificato dall'assembly, vedere il <xref:System.Type.AssemblyQualifiedName%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2886">If you are unfamiliar with the concept of assembly-qualified type names, see the <xref:System.Type.AssemblyQualifiedName%2A> property.</span></span>  
  
 <span data-ttu-id="4ee8d-2887">Se `typeName` non è un nome qualificato dall'assembly, la risoluzione dell'assembly viene ignorata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2887">If `typeName` is not an assembly-qualified name, assembly resolution is skipped.</span></span> <span data-ttu-id="4ee8d-2888">I nomi dei tipi non qualificati può essere risolto nel contesto di mscorlib. dll o assembly attualmente in esecuzione o, facoltativamente, è possibile fornire un assembly nel `typeResolver` parametro.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2888">Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the `typeResolver` parameter.</span></span> <span data-ttu-id="4ee8d-2889">Gli effetti dell'inclusione o omettendo il nome dell'assembly per diversi tipi di risoluzione dei nomi vengono visualizzati come una tabella nel [mista la risoluzione dei nomi](#mixed_name_resolution) sezione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2889">The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section.</span></span>  
  
 <span data-ttu-id="4ee8d-2890">Note generali sull'utilizzo:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2890">General usage notes:</span></span>  
  
-   <span data-ttu-id="4ee8d-2891">Non passare metodi da `assemblyResolver` o `typeResolver` se provengono da chiamanti non noti o non attendibili.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2891">Do not pass methods to `assemblyResolver` or `typeResolver` if they come from unknown or untrusted callers.</span></span> <span data-ttu-id="4ee8d-2892">Usare solo i metodi forniti o con cui si ha dimestichezza.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2892">Use only methods that you provide or that you are familiar with.</span></span>  
  
    > [!CAUTION]
    >  <span data-ttu-id="4ee8d-2893">Uso di metodi da chiamanti non noti o non attendibili potrebbe causare l'elevazione dei privilegi per codice dannoso.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2893">Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.</span></span>  
  
-   <span data-ttu-id="4ee8d-2894">Se si omette il `assemblyResolver` e/o `typeResolver` i parametri, il valore della `throwOnError` parametro viene passato ai metodi che eseguono la risoluzione predefinita.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2894">If you omit the `assemblyResolver` and/or `typeResolver` parameters, the value of the `throwOnError` parameter is passed to the methods that perform the default resolution.</span></span>  
  
-   <span data-ttu-id="4ee8d-2895">Se `throwOnError` viene `true`, questo metodo genera un' <xref:System.TypeLoadException> quando `typeResolver` restituisce `null`e una <xref:System.IO.FileNotFoundException> quando `assemblyResolver` restituisce `null`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2895">If `throwOnError` is `true`, this method throws a <xref:System.TypeLoadException> when `typeResolver` returns `null`, and a <xref:System.IO.FileNotFoundException> when `assemblyResolver` returns `null`.</span></span>  
  
-   <span data-ttu-id="4ee8d-2896">Questo metodo non intercetta le eccezioni generate dalle `assemblyResolver` e `typeResolver`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2896">This method does not catch exceptions thrown by `assemblyResolver` and `typeResolver`.</span></span> <span data-ttu-id="4ee8d-2897">Si è responsabili di eventuali eccezioni generate dai metodi di sistema di risoluzione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2897">You are responsible for any exceptions that are thrown by the resolver methods.</span></span>  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a><span data-ttu-id="4ee8d-2898">La risoluzione degli assembly</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2898">Resolving Assemblies</span></span>  
 <span data-ttu-id="4ee8d-2899">Il `assemblyResolver` metodo riceve un <xref:System.Reflection.AssemblyName> oggetto, che viene creato analizzando il nome dell'assembly stringa inclusa in `typeName`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2899">The `assemblyResolver` method receives an <xref:System.Reflection.AssemblyName> object, which is produced by parsing the string assembly name that is included in `typeName`.</span></span> <span data-ttu-id="4ee8d-2900">Se `typeName` non contiene un nome di assembly `assemblyResolver` non viene chiamato e `null` viene passato a `typeResolver`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2900">If `typeName` does not contain an assembly name, `assemblyResolver` is not called and `null` is passed to `typeResolver`.</span></span>  
  
 <span data-ttu-id="4ee8d-2901">Se `assemblyResolver` non è fornito, standard assembly individuazione tramite probe viene utilizzato per individuare l'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2901">If `assemblyResolver` is not supplied, standard assembly probing is used to locate the assembly.</span></span> <span data-ttu-id="4ee8d-2902">Se `assemblyResolver` viene specificato, il <xref:System.Type.GetType%2A> metodo non esegue una ricerca standard; in tal caso è necessario assicurarsi che il `assemblyResolver` può gestire tutti gli assembly passati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2902">If `assemblyResolver` is provided, the <xref:System.Type.GetType%2A> method does not do standard probing; in that case you must ensure that your `assemblyResolver` can handle all the assemblies you pass to it.</span></span>  
  
 <span data-ttu-id="4ee8d-2903">Il `assemblyResolver` metodo dovrebbe restituire `null` se l'assembly non può essere risolto.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2903">The `assemblyResolver` method should return `null` if the assembly cannot be resolved.</span></span> <span data-ttu-id="4ee8d-2904">Se `assemblyResolver` restituisce `null`, `typeResolver` non viene chiamato e non si verifica alcuna ulteriore elaborazione; inoltre, se `throwOnError` viene `true`, un <xref:System.IO.FileNotFoundException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2904">If `assemblyResolver` returns `null`, `typeResolver` is not called and no further processing occurs; additionally, if `throwOnError` is `true`, a <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="4ee8d-2905">Se il <xref:System.Reflection.AssemblyName> che viene passato `assemblyResolver` è un elemento parziale sono nome, uno o più delle relative parti `null`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2905">If the <xref:System.Reflection.AssemblyName> that is passed to `assemblyResolver` is a partial name, one or more of its parts are `null`.</span></span> <span data-ttu-id="4ee8d-2906">Ad esempio, se dispone di alcuna versione, il <xref:System.Reflection.AssemblyName.Version%2A> è di proprietà `null`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2906">For example, if it has no version, the <xref:System.Reflection.AssemblyName.Version%2A> property is `null`.</span></span> <span data-ttu-id="4ee8d-2907">Se il <xref:System.Reflection.AssemblyName.Version%2A> proprietà, il <xref:System.Reflection.AssemblyName.CultureInfo%2A> proprietà e il <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> metodo restituiscono tutti `null`, quindi solo il nome semplice dell'assembly è stato fornito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2907">If the <xref:System.Reflection.AssemblyName.Version%2A> property, the <xref:System.Reflection.AssemblyName.CultureInfo%2A> property, and the <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> method all return `null`, then only the simple name of the assembly was supplied.</span></span> <span data-ttu-id="4ee8d-2908">Il `assemblyResolver` metodo può usare o ignorare tutte le parti del nome dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2908">The `assemblyResolver` method can use or ignore all parts of the assembly name.</span></span>  
  
 <span data-ttu-id="4ee8d-2909">Gli effetti delle opzioni di risoluzione assembly diversi vengono visualizzati come una tabella di [mista la risoluzione dei nomi](#mixed_name_resolution) sezione, per i nomi di tipo semplice e completo di assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2909">The effects of different assembly resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a><span data-ttu-id="4ee8d-2910">La risoluzione dei tipi</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2910">Resolving Types</span></span>  
 <span data-ttu-id="4ee8d-2911">Se `typeName` non specifica un nome di assembly, `typeResolver` viene sempre chiamato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2911">If `typeName` does not specify an assembly name, `typeResolver` is always called.</span></span> <span data-ttu-id="4ee8d-2912">Se `typeName` specifica un nome di assembly, `typeResolver` viene chiamato solo quando il nome dell'assembly è stato risolto.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2912">If `typeName` specifies an assembly name, `typeResolver` is called only when the assembly name is successfully resolved.</span></span> <span data-ttu-id="4ee8d-2913">Se `assemblyResolver` o dell'assembly standard restituisce `null`, `typeResolver` non viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2913">If `assemblyResolver` or standard assembly probing returns `null`, `typeResolver` is not called.</span></span>  
  
 <span data-ttu-id="4ee8d-2914">Il `typeResolver` metodo riceve tre argomenti:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2914">The `typeResolver` method receives three arguments:</span></span>  
  
-   <span data-ttu-id="4ee8d-2915">L'assembly da cercare oppure `null` se `typeName` non contiene un nome di assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2915">The assembly to search or `null` if `typeName` does not contain an assembly name.</span></span>  
  
-   <span data-ttu-id="4ee8d-2916">Il nome semplice del tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2916">The simple name of the type.</span></span> <span data-ttu-id="4ee8d-2917">Nel caso di un tipo annidato, questo è il tipo che lo contiene più esterno.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2917">In the case of a nested type, this is the outermost containing type.</span></span> <span data-ttu-id="4ee8d-2918">Nel caso di un tipo generico, questo è il nome semplice del tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2918">In the case of a generic type, this is the simple name of the generic type.</span></span>  
  
-   <span data-ttu-id="4ee8d-2919">Valore booleano che è `true` se il caso di nomi di tipo deve essere ignorato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2919">A Boolean value that is `true` if the case of type names is to be ignored.</span></span>  
  
 <span data-ttu-id="4ee8d-2920">L'implementazione determina il modo in cui che vengono usati questi argomenti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2920">The implementation determines the way these arguments are used.</span></span> <span data-ttu-id="4ee8d-2921">Il `typeResolver` metodo dovrebbe restituire `null` se non è possibile risolvere il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2921">The `typeResolver` method should return `null` if it cannot resolve the type.</span></span> <span data-ttu-id="4ee8d-2922">Se `typeResolver` restituisce `null` e `throwOnError` viene `true`, questo overload del metodo <xref:System.Type.GetType%2A> genera un <xref:System.TypeLoadException>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2922">If `typeResolver` returns `null` and `throwOnError` is `true`, this overload of <xref:System.Type.GetType%2A> throws a <xref:System.TypeLoadException>.</span></span>  
  
 <span data-ttu-id="4ee8d-2923">Gli effetti delle opzioni di risoluzione di diverso tipo vengono visualizzati come una tabella di [mista la risoluzione dei nomi](#mixed_name_resolution) sezione, per i nomi di tipo semplice e completo di assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2923">The effects of different type resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
#### <a name="resolving-nested-types"></a><span data-ttu-id="4ee8d-2924">Risoluzione di tipi annidati</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2924">Resolving Nested Types</span></span>  
 <span data-ttu-id="4ee8d-2925">Se `typeName` è un tipo annidato, solo il nome di quello più esterno contenente il tipo viene passato a `typeResolver`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2925">If `typeName` is a nested type, only the name of the outermost containing type is passed to `typeResolver`.</span></span> <span data-ttu-id="4ee8d-2926">Quando `typeResolver` questo tipo, restituisce il <xref:System.Type.GetNestedType%2A> metodo viene chiamato in modo ricorsivo fino a quando non è stato risolto il tipo annidato più interno.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2926">When `typeResolver` returns this type, the <xref:System.Type.GetNestedType%2A> method is called recursively until the innermost nested type has been resolved.</span></span>  
  
#### <a name="resolving-generic-types"></a><span data-ttu-id="4ee8d-2927">La risoluzione dei tipi generici</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2927">Resolving Generic Types</span></span>  
 <span data-ttu-id="4ee8d-2928">Il <xref:System.Type.GetType%2A> viene chiamato in modo ricorsivo per risolvere i tipi generici: prima di tutto per risolvere il tipo generico stesso, quindi per risolvere i relativi argomenti di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2928">The <xref:System.Type.GetType%2A> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments.</span></span> <span data-ttu-id="4ee8d-2929">Se un argomento di tipo è generico, <xref:System.Type.GetType%2A> viene chiamato in modo ricorsivo per risolvere i relativi argomenti di tipo e così via.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2929">If a type argument is generic, <xref:System.Type.GetType%2A> is called recursively to resolve its type arguments, and so on.</span></span>  
  
 <span data-ttu-id="4ee8d-2930">La combinazione delle `assemblyResolver` e `typeResolver` forniti deve essere in grado di risolvere tutti i livelli di questo tipo di ricorsione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2930">The combination of `assemblyResolver` and `typeResolver` that you provide must be capable of resolving all levels of this recursion.</span></span> <span data-ttu-id="4ee8d-2931">Ad esempio, si supponga di fornire un' `assemblyResolver` che controlla il caricamento di `MyAssembly`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2931">For example, suppose you supply an `assemblyResolver` that controls the loading of `MyAssembly`.</span></span> <span data-ttu-id="4ee8d-2932">Si supponga che si desidera risolvere il tipo generico `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2932">Suppose you want to resolve the generic type `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic).</span></span> <span data-ttu-id="4ee8d-2933">È possibile passare il nome di tipo generico seguente:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2933">You might pass the following generic type name:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="4ee8d-2934">Si noti che `MyType` è costituito dall'argomento di tipo solo qualificato dall'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2934">Notice that `MyType` is the only assembly-qualified type argument.</span></span> <span data-ttu-id="4ee8d-2935">I nomi delle <xref:System.Collections.Generic.Dictionary%602> e <xref:System.String> classi non sono completi di assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2935">The names of the <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String> classes are not assembly-qualified.</span></span> <span data-ttu-id="4ee8d-2936">I `typeResolver` deve essere in grado di handle entrambi un assembly o `null`, perché possa ricevere `null` per <xref:System.Collections.Generic.Dictionary%602> e <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2936">Your `typeResolver` must be able handle either an assembly or `null`, because it will receive `null` for <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String>.</span></span> <span data-ttu-id="4ee8d-2937">È possibile gestire questo caso chiamando un overload del <xref:System.Type.GetType%2A> metodo che accetta una stringa, in quanto entrambi i nomi dei tipi non qualificati sono in mscorlib. dll:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2937">It can handle that case by calling an overload of the <xref:System.Type.GetType%2A> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 <span data-ttu-id="4ee8d-2938">Il `assemblyResolver` metodo non viene chiamato per il tipo di dizionario e il tipo di stringa, in quanto tali nomi non sono qualificato dall'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2938">The `assemblyResolver` method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.</span></span>  
  
 <span data-ttu-id="4ee8d-2939">Ora si supponga che al posto di `System.String`, è il primo tipo di argomento generico `YourType`, da `YourAssembly`:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2939">Now suppose that instead of `System.String`, the first generic argument type is `YourType`, from `YourAssembly`:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="4ee8d-2940">Trattandosi di questo assembly mscorlib. dll, né l'assembly attualmente in esecuzione, non è possibile risolvere `YourType` senza un nome qualificato dall'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2940">Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve `YourType` without an assembly-qualified name.</span></span> <span data-ttu-id="4ee8d-2941">Poiché il `assemblyResolve` sarà chiamato in modo ricorsivo, deve essere in grado di gestire questa situazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2941">Because your `assemblyResolve` will be called recursively, it must be able to handle this case.</span></span> <span data-ttu-id="4ee8d-2942">Anziché restituire `null` per gli assembly diverso da `MyAssembly`, esegue il caricamento di un assembly utilizzando l'interfaccia fornita <xref:System.Reflection.AssemblyName> oggetto.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2942">Instead of returning `null` for assemblies other than `MyAssembly`, it now performs an assembly load using the supplied <xref:System.Reflection.AssemblyName> object.</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 <span data-ttu-id="4ee8d-2943">Tornare a [note sull'utilizzo](#usage_notes).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2943">Back to [Usage Notes](#usage_notes).</span></span>  
  
#### <a name="resolving-type-names-with-special-characters"></a><span data-ttu-id="4ee8d-2944">Risoluzione dei nomi di tipo con caratteri speciali</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2944">Resolving Type Names with Special Characters</span></span>  
 <span data-ttu-id="4ee8d-2945">Alcuni caratteri hanno significati speciali nei nomi completi di assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2945">Certain characters have special meanings in assembly-qualified names.</span></span> <span data-ttu-id="4ee8d-2946">Se un nome di tipo semplice contiene questi caratteri, i caratteri di causano errori di analisi quando il nome semplice fa parte di un nome qualificato dall'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2946">If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name.</span></span> <span data-ttu-id="4ee8d-2947">Per evitare gli errori di analisi, è necessario eseguire l'escape i caratteri speciali con una barra rovesciata prima di poter passare il nome qualificato dall'assembly per il <xref:System.Type.GetType%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2947">To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="4ee8d-2948">Ad esempio, se un tipo denominato `Strange]Type`, il carattere di escape deve essere aggiunto come indicato di seguito davanti la parentesi quadra: `Strange\]Type`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2948">For example, if a type is named `Strange]Type`, the escape character must be added ahead of the square bracket as follows: `Strange\]Type`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-2949">I nomi con caratteri speciali non possono essere creati in Visual Basic o c#, ma possono essere creati usando Microsoft intermediate language (MSIL) o creazione di assembly dinamici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2949">Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.</span></span>  
  
 <span data-ttu-id="4ee8d-2950">La tabella seguente mostra i caratteri speciali per i nomi dei tipi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2950">The following table shows the special characters for type names.</span></span>  
  
|<span data-ttu-id="4ee8d-2951">Carattere</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2951">Character</span></span>|<span data-ttu-id="4ee8d-2952">Significato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2952">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="4ee8d-2953">`,` (virgola)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2953">`,` (comma)</span></span>|<span data-ttu-id="4ee8d-2954">Delimitatore per i nomi completi di assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2954">Delimiter for assembly-qualified names.</span></span>|  
|<span data-ttu-id="4ee8d-2955">`[]` (parentesi quadre)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2955">`[]` (square brackets)</span></span>|<span data-ttu-id="4ee8d-2956">Come una coppia di suffisso, indica un tipo di matrice. come una coppia di delimitatori racchiudono gli elenchi di argomenti generici e nomi completi di assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2956">As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.</span></span>|  
|<span data-ttu-id="4ee8d-2957">`&` e commerciale (&)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2957">`&` (ampersand)</span></span>|<span data-ttu-id="4ee8d-2958">Come un suffisso, indica che un tipo è un tipo di riferimento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2958">As a suffix, indicates that a type is a reference type.</span></span>|  
|<span data-ttu-id="4ee8d-2959">`*` (asterisco)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2959">`*` (asterisk)</span></span>|<span data-ttu-id="4ee8d-2960">Come un suffisso, indica che un tipo è un tipo di puntatore.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2960">As a suffix, indicates that a type is a pointer type.</span></span>|  
|<span data-ttu-id="4ee8d-2961">`+` (più)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2961">`+` (plus)</span></span>|<span data-ttu-id="4ee8d-2962">Delimitatore per i tipi annidati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2962">Delimiter for nested types.</span></span>|  
|<span data-ttu-id="4ee8d-2963">`\` (barra rovesciata)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2963">`\` (backslash)</span></span>|<span data-ttu-id="4ee8d-2964">Carattere di escape.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2964">Escape character.</span></span>|  
  
 <span data-ttu-id="4ee8d-2965">Proprietà, ad esempio <xref:System.Type.AssemblyQualifiedName%2A> restituito corretto carattere di escape stringhe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2965">Properties such as <xref:System.Type.AssemblyQualifiedName%2A> return correctly escaped strings.</span></span> <span data-ttu-id="4ee8d-2966">È necessario passare stringhe con caratteri di escape in modo corretto per il <xref:System.Type.GetType%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2966">You must pass correctly escaped strings to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="4ee8d-2967">A sua volta, il <xref:System.Type.GetType%2A> metodo passa correttamente i nomi forzati a `typeResolver` e per i metodi di risoluzione del tipo predefinito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2967">In turn, the <xref:System.Type.GetType%2A> method passes correctly escaped names to `typeResolver` and to the default type resolution methods.</span></span> <span data-ttu-id="4ee8d-2968">Se è necessario confrontare un nome a un nome senza caratteri di escape in `typeResolver`, è necessario rimuovere i caratteri di escape.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2968">If you need to compare a name to an unescaped name in `typeResolver`, you must remove the escape characters.</span></span>  
  
 <span data-ttu-id="4ee8d-2969">Tornare a [note sull'utilizzo](#usage_notes).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2969">Back to [Usage Notes](#usage_notes).</span></span>  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a><span data-ttu-id="4ee8d-2970">Risoluzione dei nomi misti</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2970">Mixed Name Resolution</span></span>  
 <span data-ttu-id="4ee8d-2971">Nella tabella seguente sono riepilogate le interazioni tra `assemblyResolver`, `typeResolver`e la risoluzione dei nomi predefinito, per tutte le combinazioni di nome del tipo e nome dell'assembly in `typeName`:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2971">The following table summarizes the interactions between `assemblyResolver`, `typeResolver`, and default name resolution, for all combinations of type name and assembly name in `typeName`:</span></span>  
  
|<span data-ttu-id="4ee8d-2972">Contenuto del nome del tipo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2972">Contents of type name</span></span>|<span data-ttu-id="4ee8d-2973">Metodo resolver dell'assembly</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2973">Assembly resolver method</span></span>|<span data-ttu-id="4ee8d-2974">Metodo con tipo di resolver</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2974">Type resolver method</span></span>|<span data-ttu-id="4ee8d-2975">Risultato</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2975">Result</span></span>|  
|---------------------------|------------------------------|--------------------------|------------|  
|<span data-ttu-id="4ee8d-2976">tipo di assembly</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2976">type, assembly</span></span>|<span data-ttu-id="4ee8d-2977">Null</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2977">null</span></span>|<span data-ttu-id="4ee8d-2978">Null</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2978">null</span></span>|<span data-ttu-id="4ee8d-2979">Equivalente alla chiamata di <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2979">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span>|  
|<span data-ttu-id="4ee8d-2980">tipo di assembly</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2980">type, assembly</span></span>|<span data-ttu-id="4ee8d-2981">fornito</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2981">provided</span></span>|<span data-ttu-id="4ee8d-2982">Null</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2982">null</span></span>|<span data-ttu-id="4ee8d-2983">`assemblyResolver` Restituisce l'assembly oppure `null` se non è possibile risolvere l'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2983">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="4ee8d-2984">Se l'assembly viene risolto, il <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> overload del metodo viene usato per caricare il tipo dell'assembly; in caso contrario, non viene eseguito alcun tentativo di risolvere il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2984">If the assembly is resolved, the <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.</span></span>|  
|<span data-ttu-id="4ee8d-2985">tipo di assembly</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2985">type, assembly</span></span>|<span data-ttu-id="4ee8d-2986">Null</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2986">null</span></span>|<span data-ttu-id="4ee8d-2987">fornito</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2987">provided</span></span>|<span data-ttu-id="4ee8d-2988">Equivale alla conversione il nome dell'assembly a un' <xref:System.Reflection.AssemblyName> oggetto e chiamare il <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> overload del metodo per ottenere l'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2988">Equivalent to converting the assembly name to an <xref:System.Reflection.AssemblyName> object and calling the <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> method overload to get the assembly.</span></span> <span data-ttu-id="4ee8d-2989">Se l'assembly viene risolto, viene passato a `typeResolver`; in caso contrario, `typeResolver` non viene chiamato ed è presente alcun ulteriore tentativo di risolvere il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2989">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="4ee8d-2990">tipo di assembly</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2990">type, assembly</span></span>|<span data-ttu-id="4ee8d-2991">fornito</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2991">provided</span></span>|<span data-ttu-id="4ee8d-2992">fornito</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2992">provided</span></span>|<span data-ttu-id="4ee8d-2993">`assemblyResolver` Restituisce l'assembly oppure `null` se non è possibile risolvere l'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2993">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="4ee8d-2994">Se l'assembly viene risolto, viene passato a `typeResolver`; in caso contrario, `typeResolver` non viene chiamato ed è presente alcun ulteriore tentativo di risolvere il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2994">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="4ee8d-2995">tipo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2995">type</span></span>|<span data-ttu-id="4ee8d-2996">null, fornito</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2996">null, provided</span></span>|<span data-ttu-id="4ee8d-2997">Null</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2997">null</span></span>|<span data-ttu-id="4ee8d-2998">Equivalente alla chiamata di <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2998">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="4ee8d-2999">Poiché il nome dell'assembly non viene specificato, vengono cercati solo mscorlib. dll e assembly attualmente in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-2999">Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched.</span></span> <span data-ttu-id="4ee8d-3000">Se `assemblyResolver` è specificato, viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3000">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="4ee8d-3001">tipo</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3001">type</span></span>|<span data-ttu-id="4ee8d-3002">null, fornito</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3002">null, provided</span></span>|<span data-ttu-id="4ee8d-3003">fornito</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3003">provided</span></span>|<span data-ttu-id="4ee8d-3004">`typeResolver` viene chiamato, e `null` viene passato per l'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3004">`typeResolver` is called, and `null` is passed for the assembly.</span></span> <span data-ttu-id="4ee8d-3005">`typeResolver` può fornire un tipo da qualsiasi assembly, inclusi gli assembly che vengono caricati per lo scopo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3005">`typeResolver` can provide a type from any assembly, including assemblies it loads for the purpose.</span></span> <span data-ttu-id="4ee8d-3006">Se `assemblyResolver` è specificato, viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3006">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="4ee8d-3007">assembly</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3007">assembly</span></span>|<span data-ttu-id="4ee8d-3008">null, fornito</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3008">null, provided</span></span>|<span data-ttu-id="4ee8d-3009">null, fornito</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3009">null, provided</span></span>|<span data-ttu-id="4ee8d-3010">Oggetto <xref:System.IO.FileLoadException> viene generata un'eccezione, perché il nome dell'assembly viene analizzato come se fosse un nome di tipo qualificato dall'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3010">A <xref:System.IO.FileLoadException> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name.</span></span> <span data-ttu-id="4ee8d-3011">Ciò comporta un nome di assembly non valido.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3011">This results in an invalid assembly name.</span></span>|  
  
 <span data-ttu-id="4ee8d-3012">A: [note sull'utilizzo](#usage_notes), [la risoluzione degli assembly](#resolving_assemblies), [la risoluzione dei tipi](#resolving_types).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3012">Back to: [Usage Notes](#usage_notes), [Resolving Assemblies](#resolving_assemblies), [Resolving Types](#resolving_types).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-3013">
            <paramref name="typeName" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3013">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="4ee8d-3014">Viene richiamato un inizializzatore di classi e viene generata un'eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3014">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="4ee8d-3015">
            <paramref name="throwOnError" /> è <see langword="true" /> e il tipo non è stato trovato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3015">
              <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="4ee8d-3016">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3016">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3017">
            <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> contiene caratteri non validi, ad esempio una scheda incorporata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3017">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="4ee8d-3018">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3018">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3019">
            <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> è una stringa vuota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3019">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="4ee8d-3020">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3020">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3021">
            <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> rappresenta un tipo di matrice con una dimensione non valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3021">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="4ee8d-3022">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3022">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3023">
            <paramref name="typeName" /> rappresenta una matrice di <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3023">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-3024">Si verifica un errore quando <paramref name="typeName" /> viene analizzato in un nome del tipo e un nome dell'assembly (ad esempio, quando il nome del tipo semplice include un carattere speciale senza codice di escape).</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3024">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span>
          </span>
          <span data-ttu-id="4ee8d-3025">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3025">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3026">
            <paramref name="throwOnError" /> è <see langword="true" /> e <paramref name="typeName" /> contiene sintassi non valida (ad esempio, "MyType [,\*,]").</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3026">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span>
          </span>
          <span data-ttu-id="4ee8d-3027">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3027">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3028">
            <paramref name="typeName" /> rappresenta un tipo generico che ha un tipo di puntatore, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> tra i relativi argomenti di tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3028">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="4ee8d-3029">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3029">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3030">
            <paramref name="typeName" /> rappresenta un tipo generico che ha un numero errato di argomenti di tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3030">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="4ee8d-3031">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3031">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3032">
            <paramref name="typeName" /> rappresenta un tipo generico e uno dei relativi argomenti di tipo non soddisfa i vincoli per il parametro di tipo corrispondente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3032">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="4ee8d-3033">
            <paramref name="throwOnError" /> è <see langword="true" /> e l'assembly o una delle sue dipendenze non è stato trovato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3033">
              <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="4ee8d-3034">L'assembly o una delle relative dipendenze è stato trovato, ma non può essere caricato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3034">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
          <span data-ttu-id="4ee8d-3035">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3035">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3036">
            <paramref name="typeName" /> contiene un nome dell'assembly non valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3036">
              <paramref name="typeName" /> contains an invalid assembly name.</span>
          </span>
          <span data-ttu-id="4ee8d-3037">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3037">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3038">
            <paramref name="typeName" /> è un nome dell'assembly valido senza un nome di tipi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3038">
              <paramref name="typeName" /> is a valid assembly name without a type name.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="4ee8d-3039">L'assembly o una delle relative dipendenze non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3039">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="4ee8d-3040">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3040">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3041">L'assembly è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3041">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">
          <span data-ttu-id="4ee8d-3042">Matrice di oggetti i cui tipi devono essere determinati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3042">An array of objects whose types to determine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-3043">Ottiene i tipi di oggetti nella matrice specificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3043">Gets the types of the objects in the specified array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3044">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano i tipi degli elementi corrispondenti in <paramref name="args" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3044">An array of <see cref="T:System.Type" /> objects representing the types of the corresponding elements in <paramref name="args" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="4ee8d-3045">Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Type.GetTypeArray%2A> metodo per elencare i tipi degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3045">The following code example demonstrates how to use the <xref:System.Type.GetTypeArray%2A> method to list the types of the elements of an array.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-3046">
            <paramref name="args" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3046">
              <paramref name="args" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3047">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3047">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3048">Uno o più degli elementi in <paramref name="args" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3048">One or more of the elements in <paramref name="args" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="4ee8d-3049">Gli inizializzatori di classi vengono richiamati e almeno uno genera un'eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3049">The class initializers are invoked and at least one throws an exception.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="4ee8d-3050">Tipo il cui codice di tipo sottostante deve essere ottenuto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3050">The type whose underlying type code to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-3051">Ottiene il codice di tipo sottostante dell'oggetto <see cref="T:System.Type" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3051">Gets the underlying type code of the specified <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3052">Codice del tipo sottostante o <see cref="F:System.TypeCode.Empty" /> se <paramref name="type" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3052">The code of the underlying type, or <see cref="F:System.TypeCode.Empty" /> if <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3053">Quando si eredita da <xref:System.Type>, è possibile modificare il comportamento di questo metodo eseguendo l'override di <xref:System.Type.GetTypeCodeImpl%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3053">When you inherit from <xref:System.Type>, you can change the behavior of this method by overriding the <xref:System.Type.GetTypeCodeImpl%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3054">L'esempio di codice seguente illustra come il <xref:System.TypeCode> enumerazione può essere utilizzata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3054">The following code example demonstrates how the <xref:System.TypeCode> enumeration can be used.</span></span> <span data-ttu-id="4ee8d-3055">In un blocco decisionale all'interno di `WriteObjectInfo` metodo, il <xref:System.TypeCode> di un <xref:System.Object> parametro viene esaminato e viene scritto un messaggio appropriato nella console.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3055">In a decision block inside the `WriteObjectInfo` method, the <xref:System.TypeCode> of an <xref:System.Object> parameter is examined, and an appropriate message is written to the console.</span></span>  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3056">Restituisce il codice del tipo sottostante di questa istanza di <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3056">Returns the underlying type code of this <see cref="T:System.Type" /> instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3057">Codice del tipo sottostante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3057">The type code of the underlying type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3058">Questo metodo fornisce l'implementazione per il `static` (in c#) o `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3058">This method provides the implementation for the `static` (in C#) or `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> method.</span></span> <span data-ttu-id="4ee8d-3059">Quando si eredita da <xref:System.Type>, è possibile eseguire l'override di questo metodo per fornire la propria implementazione di <xref:System.Type.GetTypeCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3059">When you inherit from <xref:System.Type>, you can override this method to provide your own implementation of <xref:System.Type.GetTypeCode%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3060">Ottiene il tipo associato all'identificatore di classe specificato (CLSID).</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3060">Gets the type associated with the specified class identifier (CLSID).</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">
          <span data-ttu-id="4ee8d-3061">CLSID del tipo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3061">The CLSID of the type to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-3062">Ottiene il tipo associato all'identificatore di classe specificato (CLSID).</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3062">Gets the type associated with the specified class identifier (CLSID).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3063">
            <see langword="System.__ComObject" /> indipendentemente dalla validità del CLSID.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3063">
              <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3064">Il <xref:System.Type.GetTypeFromCLSID%2A> metodo supporta l'accesso con associazione tardiva a oggetti COM non gestiti dalle app .NET Framework quando si conosce l'identificatore di classe dell'oggetto COM (CLSID).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3064">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="4ee8d-3065">L'identificatore di classe per classi COM a cui è definita nella chiave del Registro di sistema HKEY_CLASSES_ROOT\CLSID.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3065">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="4ee8d-3066">È possibile recuperare il valore della <xref:System.Type.IsCOMObject%2A> proprietà per determinare se il tipo restituito da questo metodo è un oggetto COM.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3066">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="4ee8d-3067">È possibile chiamare il <xref:System.Type.GetTypeFromProgID%2A> metodo per l'accesso con associazione tardiva a COM oggetti il cui identificatore programmatico (ProgID) si conosce.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3067">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="4ee8d-3068">Creare un'istanza di un oggetto COM non gestito dal valore CLSID corrispondente è un processo in due passaggi:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3068">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="4ee8d-3069">Ottenere un <xref:System.Type> oggetto che rappresenta il`__ComObject` che corrisponde al CLSID chiamando il <xref:System.Type.GetTypeFromCLSID%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3069">Get a <xref:System.Type> object that represents the`__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="4ee8d-3070">Chiamare il <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metodo per creare un'istanza dell'oggetto COM.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3070">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="4ee8d-3071">Vedere l'esempio per un'illustrazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3071">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="4ee8d-3072">Il <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> overload Ignora tutte le eccezioni che possono verificarsi quando si crea un' <xref:System.Type> oggetto in base il `clsid` argomento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3072">The <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> overload ignores any exception that may occur when instantiating a <xref:System.Type> object based on the `clsid` argument.</span></span> <span data-ttu-id="4ee8d-3073">Si noti che viene generata alcuna eccezione se `clsid` non viene trovato nel Registro di sistema.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3073">Note that no exception is thrown if `clsid` is not found in the registry.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3074">L'esempio seguente usa il CLSID di Microsoft Word [oggetto applicazione](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) per recuperare un tipo COM che rappresenta l'applicazione di Microsoft Word.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3074">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="4ee8d-3075">Quindi crea un'istanza di tipo chiamando il <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metodo e lo chiuda chiamando il [Application. Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3075">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="4ee8d-3076">Questo metodo è destinato all'uso quando si usano oggetti COM, non con gli oggetti di .NET Framework.</span>
            <span class="sxs-lookup">
              <span data-stu-id="4ee8d-3076">This method is intended for use when working with COM objects, not with .NET Framework objects.</span>
            </span>
            <span data-ttu-id="4ee8d-3077">Tutti oggetti gestiti, inclusi quelli che sono visibili a COM (vale a dire loro <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attributo è <see langword="true" />) hanno un GUID che viene restituito dal <see cref="P:System.Type.GUID" /> proprietà.</span>
            <span class="sxs-lookup">
              <span data-stu-id="4ee8d-3077">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span>
            </span>
            <span data-ttu-id="4ee8d-3078">Anche se il metodo restituisce un <see cref="T:System.Type" /> gli oggetti che corrisponde al GUID di .NET Framework, non è possibile utilizzare <see cref="T:System.Type" /> oggetto per creare un'istanza del tipo chiamando il <see cref="M:System.Activator.CreateInstance(System.Type)" /> metodo, come illustrato nell'esempio seguente.</span>
            <span class="sxs-lookup">
              <span data-stu-id="4ee8d-3078">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span>
            </span>
            <span data-ttu-id="4ee8d-3079">[! codice-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! codice vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span>
            <span class="sxs-lookup">
              <span data-stu-id="4ee8d-3079">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span>
            </span>
            <span data-ttu-id="4ee8d-3080">Al contrario, il <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> deve essere usato solo per recuperare il GUID di un oggetto COM non gestito e risultante <see cref="T:System.Type" /> oggetto passato al <see cref="M:System.Activator.CreateInstance(System.Type)" /> metodo deve rappresentare un oggetto COM non gestito.</span>
            <span class="sxs-lookup">
              <span data-stu-id="4ee8d-3080">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">
          <span data-ttu-id="4ee8d-3081">CLSID del tipo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3081">The CLSID of the type to get.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="4ee8d-3082">
            <see langword="true" /> per generare qualsiasi eccezione si verifichi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3082">
              <see langword="true" /> to throw any exception that occurs.</span>
          </span>
          <span data-ttu-id="4ee8d-3083">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3083">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3084">
            <see langword="false" /> per ignorare qualsiasi eccezione si verifichi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3084">
              <see langword="false" /> to ignore any exception that occurs.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-3085">Ottiene il tipo associato all'identificatore di classe specificato (CLSID) e indica se generare un'eccezione qualora si verifichi un errore durante il caricamento del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3085">Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3086">
            <see langword="System.__ComObject" /> indipendentemente dalla validità del CLSID.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3086">
              <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3087">Il <xref:System.Type.GetTypeFromCLSID%2A> metodo supporta l'accesso con associazione tardiva a oggetti COM non gestiti dalle app .NET Framework quando si conosce l'identificatore di classe dell'oggetto COM (CLSID).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3087">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="4ee8d-3088">L'identificatore di classe per classi COM a cui è definita nella chiave del Registro di sistema HKEY_CLASSES_ROOT\CLSID.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3088">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="4ee8d-3089">È possibile recuperare il valore della <xref:System.Type.IsCOMObject%2A> proprietà per determinare se il tipo restituito da questo metodo è un oggetto COM.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3089">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="4ee8d-3090">È possibile chiamare il <xref:System.Type.GetTypeFromProgID%2A> metodo per l'accesso con associazione tardiva a COM oggetti il cui identificatore programmatico (ProgID) si conosce.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3090">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="4ee8d-3091">Creare un'istanza di un oggetto COM non gestito dal valore CLSID corrispondente è un processo in due passaggi:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3091">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="4ee8d-3092">Ottenere un <xref:System.Type> oggetto che rappresenta il `__ComObject` che corrisponde al CLSID chiamando il <xref:System.Type.GetTypeFromCLSID%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3092">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="4ee8d-3093">Chiamare il <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metodo per creare un'istanza dell'oggetto COM.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3093">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="4ee8d-3094">Vedere l'esempio per un'illustrazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3094">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="4ee8d-3095">Le eccezioni, ad esempio <xref:System.OutOfMemoryException> viene generata quando si specificano `true` per `throwOnError`, ma non avrà esito negativo per il CLSID di annullare la registrazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3095">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3096">L'esempio seguente usa il CLSID di Microsoft Word [oggetto applicazione](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) per recuperare un tipo COM che rappresenta l'applicazione di Microsoft Word.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3096">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="4ee8d-3097">Quindi crea un'istanza di tipo chiamando il <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metodo e lo chiuda chiamando il [Application. Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3097">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span> <span data-ttu-id="4ee8d-3098">Se si verifica un errore durante il caricamento del tipo, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3098">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="4ee8d-3099">Questo metodo è destinato all'uso quando si usano oggetti COM, non con gli oggetti di .NET Framework.</span>
            <span class="sxs-lookup">
              <span data-stu-id="4ee8d-3099">This method is intended for use when working with COM objects, not with .NET Framework objects.</span>
            </span>
            <span data-ttu-id="4ee8d-3100">Tutti oggetti gestiti, inclusi quelli che sono visibili a COM (vale a dire loro <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attributo è <see langword="true" />) hanno un GUID che viene restituito dal <see cref="P:System.Type.GUID" /> proprietà.</span>
            <span class="sxs-lookup">
              <span data-stu-id="4ee8d-3100">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span>
            </span>
            <span data-ttu-id="4ee8d-3101">Anche se il metodo restituisce un <see cref="T:System.Type" /> gli oggetti che corrisponde al GUID di .NET Framework, non è possibile utilizzare <see cref="T:System.Type" /> oggetto per creare un'istanza del tipo chiamando il <see cref="M:System.Activator.CreateInstance(System.Type)" /> metodo, come illustrato nell'esempio seguente.</span>
            <span class="sxs-lookup">
              <span data-stu-id="4ee8d-3101">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span>
            </span>
            <span data-ttu-id="4ee8d-3102">[! codice-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! codice vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span>
            <span class="sxs-lookup">
              <span data-stu-id="4ee8d-3102">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span>
            </span>
            <span data-ttu-id="4ee8d-3103">Al contrario, il <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> deve essere usato solo per recuperare il GUID di un oggetto COM non gestito e risultante <see cref="T:System.Type" /> oggetto passato al <see cref="M:System.Activator.CreateInstance(System.Type)" /> metodo deve rappresentare un oggetto COM non gestito.</span>
            <span class="sxs-lookup">
              <span data-stu-id="4ee8d-3103">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">
          <span data-ttu-id="4ee8d-3104">CLSID del tipo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3104">The CLSID of the type to get.</span>
          </span>
        </param>
        <param name="server">
          <span data-ttu-id="4ee8d-3105">Server da cui caricare il tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3105">The server from which to load the type.</span>
          </span>
          <span data-ttu-id="4ee8d-3106">Se il nome del server è <see langword="null" />, il metodo verrà automaticamente ripristinato sul computer locale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3106">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-3107">Ottiene il tipo associato all'identificatore di classe specificato (CLSID) dal server specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3107">Gets the type associated with the specified class identifier (CLSID) from the specified server.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3108">
            <see langword="System.__ComObject" /> indipendentemente dalla validità del CLSID.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3108">
              <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3109">Il <xref:System.Type.GetTypeFromCLSID%2A> metodo supporta l'accesso con associazione tardiva a oggetti COM non gestiti dalle app .NET Framework quando si conosce l'identificatore di classe dell'oggetto COM (CLSID).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3109">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="4ee8d-3110">L'identificatore di classe per classi COM a cui è definita nella chiave del Registro di sistema HKEY_CLASSES_ROOT\CLSID.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3110">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="4ee8d-3111">È possibile recuperare il valore della <xref:System.Type.IsCOMObject%2A> proprietà per determinare se il tipo restituito da questo metodo è un oggetto COM.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3111">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="4ee8d-3112">È possibile chiamare il <xref:System.Type.GetTypeFromProgID%2A> metodo per l'accesso con associazione tardiva a COM oggetti il cui identificatore programmatico (ProgID) si conosce.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3112">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="4ee8d-3113">Creare un'istanza di un oggetto COM non gestito dal valore CLSID corrispondente è un processo in due passaggi:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3113">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="4ee8d-3114">Ottenere un <xref:System.Type> oggetto che rappresenta il `__ComObject` che corrisponde al CLSID chiamando il <xref:System.Type.GetTypeFromCLSID%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3114">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="4ee8d-3115">Chiamare il <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metodo per creare un'istanza dell'oggetto COM.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3115">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3116">L'esempio seguente usa il CLSID di Microsoft Word [oggetto applicazione](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) per recuperare un tipo COM che rappresenta l'applicazione di Microsoft Word da un server denominato computer17.central.contoso.com.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3116">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com.</span></span> <span data-ttu-id="4ee8d-3117">Quindi crea un'istanza di tipo chiamando il <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metodo e lo chiuda chiamando il [Application. Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3117">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="4ee8d-3118">Questo metodo è destinato all'uso quando si usano oggetti COM, non con gli oggetti di .NET Framework.</span>
            <span class="sxs-lookup">
              <span data-stu-id="4ee8d-3118">This method is intended for use when working with COM objects, not with .NET Framework objects.</span>
            </span>
            <span data-ttu-id="4ee8d-3119">Tutti oggetti gestiti, inclusi quelli che sono visibili a COM (vale a dire loro <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attributo è <see langword="true" />) hanno un GUID che viene restituito dal <see cref="P:System.Type.GUID" /> proprietà.</span>
            <span class="sxs-lookup">
              <span data-stu-id="4ee8d-3119">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span>
            </span>
            <span data-ttu-id="4ee8d-3120">Anche se il metodo restituisce un <see cref="T:System.Type" /> gli oggetti che corrisponde al GUID di .NET Framework, non è possibile utilizzare <see cref="T:System.Type" /> oggetto per creare un'istanza del tipo chiamando il <see cref="M:System.Activator.CreateInstance(System.Type)" /> metodo, come illustrato nell'esempio seguente.</span>
            <span class="sxs-lookup">
              <span data-stu-id="4ee8d-3120">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span>
            </span>
            <span data-ttu-id="4ee8d-3121">[! codice-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! codice vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span>
            <span class="sxs-lookup">
              <span data-stu-id="4ee8d-3121">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span>
            </span>
            <span data-ttu-id="4ee8d-3122">Al contrario, il <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> deve essere usato solo per recuperare il GUID di un oggetto COM non gestito e risultante <see cref="T:System.Type" /> oggetto passato al <see cref="M:System.Activator.CreateInstance(System.Type)" /> metodo deve rappresentare un oggetto COM non gestito.</span>
            <span class="sxs-lookup">
              <span data-stu-id="4ee8d-3122">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">
          <span data-ttu-id="4ee8d-3123">CLSID del tipo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3123">The CLSID of the type to get.</span>
          </span>
        </param>
        <param name="server">
          <span data-ttu-id="4ee8d-3124">Server da cui caricare il tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3124">The server from which to load the type.</span>
          </span>
          <span data-ttu-id="4ee8d-3125">Se il nome del server è <see langword="null" />, il metodo verrà automaticamente ripristinato sul computer locale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3125">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="4ee8d-3126">
            <see langword="true" /> per generare qualsiasi eccezione si verifichi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3126">
              <see langword="true" /> to throw any exception that occurs.</span>
          </span>
          <span data-ttu-id="4ee8d-3127">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3127">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3128">
            <see langword="false" /> per ignorare qualsiasi eccezione si verifichi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3128">
              <see langword="false" /> to ignore any exception that occurs.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-3129">Ottiene il tipo associato all'identificatore di classe specificato (CLSID) dal server specificato e indica se generare un'eccezione in caso di errore durante il caricamento del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3129">Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3130">
            <see langword="System.__ComObject" /> indipendentemente dalla validità del CLSID.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3130">
              <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3131">Il <xref:System.Type.GetTypeFromCLSID%2A> metodo supporta l'accesso con associazione tardiva a oggetti COM non gestiti dalle app .NET Framework quando si conosce l'identificatore di classe dell'oggetto COM (CLSID).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3131">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="4ee8d-3132">L'identificatore di classe per classi COM a cui è definita nella chiave del Registro di sistema HKEY_CLASSES_ROOT\CLSID.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3132">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="4ee8d-3133">È possibile recuperare il valore della <xref:System.Type.IsCOMObject%2A> proprietà per determinare se il tipo restituito da questo metodo è un oggetto COM.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3133">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="4ee8d-3134">È possibile chiamare il <xref:System.Type.GetTypeFromProgID%2A> metodo per l'accesso con associazione tardiva a COM oggetti il cui identificatore programmatico (ProgID) si conosce.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3134">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="4ee8d-3135">Creare un'istanza di un oggetto COM non gestito dal valore CLSID corrispondente è un processo in due passaggi:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3135">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="4ee8d-3136">Ottenere un <xref:System.Type> oggetto che rappresenta il `__ComObject` che corrisponde al CLSID chiamando il <xref:System.Type.GetTypeFromCLSID%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3136">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="4ee8d-3137">Chiamare il <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> metodo per creare un'istanza dell'oggetto COM.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3137">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="4ee8d-3138">Le eccezioni, ad esempio <xref:System.OutOfMemoryException> viene generata quando si specificano `true` per `throwOnError`, ma non avrà esito negativo per il CLSID di annullare la registrazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3138">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3139">L'esempio seguente usa il CLSID di Microsoft Word [oggetto applicazione](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) per recuperare un tipo COM che rappresenta l'applicazione di Microsoft Word da un server denominato computer17.central.contoso.com.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3139">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com.</span></span> <span data-ttu-id="4ee8d-3140">Quindi crea un'istanza di tipo chiamando il <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metodo e lo chiuda chiamando il [Application. Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3140">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span> <span data-ttu-id="4ee8d-3141">Se si verifica un errore durante il caricamento del tipo, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3141">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="4ee8d-3142">Questo metodo è destinato all'uso quando si usano oggetti COM, non con gli oggetti di .NET Framework.</span>
            <span class="sxs-lookup">
              <span data-stu-id="4ee8d-3142">This method is intended for use when working with COM objects, not with .NET Framework objects.</span>
            </span>
            <span data-ttu-id="4ee8d-3143">Tutti oggetti gestiti, inclusi quelli che sono visibili a COM (vale a dire loro <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attributo è <see langword="true" />) hanno un GUID che viene restituito dal <see cref="P:System.Type.GUID" /> proprietà.</span>
            <span class="sxs-lookup">
              <span data-stu-id="4ee8d-3143">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span>
            </span>
            <span data-ttu-id="4ee8d-3144">Anche se il <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> metodo restituisce un <see cref="T:System.Type" /> oggetto che corrisponde al GUID di un oggetto gestito specifico, non è possibile utilizzare <see cref="T:System.Type" /> oggetto per creare un'istanza del tipo chiamando il <see cref="M:System.Activator.CreateInstance(System.Type)" /> (metodo), come illustrato nell'esempio seguente Mostra.</span>
            <span class="sxs-lookup">
              <span data-stu-id="4ee8d-3144">Although the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for a particular managed object, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span>
            </span>
            <span data-ttu-id="4ee8d-3145">[! codice-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! codice vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span>
            <span class="sxs-lookup">
              <span data-stu-id="4ee8d-3145">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span>
            </span>
            <span data-ttu-id="4ee8d-3146">Al contrario, il <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> deve essere usato solo per recuperare il GUID di un oggetto COM non gestito e risultante <see cref="T:System.Type" /> oggetto passato al <see cref="M:System.Activator.CreateInstance(System.Type)" /> metodo deve rappresentare un oggetto COM non gestito.</span>
            <span class="sxs-lookup">
              <span data-stu-id="4ee8d-3146">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="4ee8d-3147">Oggetto che fa riferimento al tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3147">The object that refers to the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-3148">Ottiene il tipo a cui fa riferimento l'handle del tipo specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3148">Gets the type referenced by the specified type handle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3149">Tipo al quale l'oggetto <see cref="T:System.RuntimeTypeHandle" /> specificato fa riferimento, oppure <see langword="null" /> se la proprietà <see cref="P:System.RuntimeTypeHandle.Value" /> di <paramref name="handle" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3149">The type referenced by the specified <see cref="T:System.RuntimeTypeHandle" />, or <see langword="null" /> if the <see cref="P:System.RuntimeTypeHandle.Value" /> property of <paramref name="handle" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3150">I punti di controllo sono validi solo nel dominio dell'applicazione in cui sono stati ottenuti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3150">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3151">L'esempio seguente usa il <xref:System.Type.GetTypeFromHandle%2A> metodo per ottenere un <xref:System.Type> dell'oggetto da un <xref:System.RuntimeTypeHandle> forniti dal <xref:System.Type.GetTypeHandle%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3151">The following example uses the <xref:System.Type.GetTypeFromHandle%2A> method to get a <xref:System.Type> object from a <xref:System.RuntimeTypeHandle> provided by the <xref:System.Type.GetTypeHandle%2A> method.</span></span>  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="4ee8d-3152">Viene richiamato un inizializzatore di classi e viene generata un'eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3152">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3153">Ottiene il tipo associato all'ID di programma specificato (ProgID).</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3153">Gets the type associated with the specified program identifier (ProgID).</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">
          <span data-ttu-id="4ee8d-3154">ProgID del tipo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3154">The ProgID of the type to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-3155">Ottiene il tipo associato all'ID di programma specificato (ProgID), restituendo Null se si verifica un errore durante il caricamento dell'oggetto <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3155">Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3156">Tipo associato al ProgID specificato, se <paramref name="progID" /> è una voce valida del Registro di sistema e vi è associato un tipo; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3156">The type associated with the specified ProgID, if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3157">Questo metodo è fornito per il supporto COM.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3157">This method is provided for COM support.</span></span> <span data-ttu-id="4ee8d-3158">ProgID non vengono utilizzati in Microsoft .NET Framework, perché sono stati sostituiti dal concetto di spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3158">ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-3159">
            <paramref name="progID" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3159">
              <paramref name="progID" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="4ee8d-3160">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3160">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="4ee8d-3161">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3161">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">
          <span data-ttu-id="4ee8d-3162">ProgID del tipo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3162">The ProgID of the type to get.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="4ee8d-3163">
            <see langword="true" /> per generare qualsiasi eccezione si verifichi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3163">
              <see langword="true" /> to throw any exception that occurs.</span>
          </span>
          <span data-ttu-id="4ee8d-3164">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3164">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3165">
            <see langword="false" /> per ignorare qualsiasi eccezione si verifichi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3165">
              <see langword="false" /> to ignore any exception that occurs.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-3166">Ottiene il tipo associato all'ID di programma specificato (ProgID) e indica se generare un'eccezione qualora si verifichi un errore durante il caricamento del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3166">Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3167">Tipo associato all'ID di programma specificato (ProgID) se <paramref name="progID" /> è una voce valida del Registro di sistema e vi è associato un tipo; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3167">The type associated with the specified program identifier (ProgID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3168">Questo metodo è fornito per il supporto COM.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3168">This method is provided for COM support.</span></span> <span data-ttu-id="4ee8d-3169">Gli ID di programma non vengono utilizzati in Microsoft .NET Framework, perché sono stati sostituiti dal concetto di spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3169">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3170">Nell'esempio seguente recupera un tipo passando un ProgID, che specifica se generare un'eccezione se il valore ProgID è valido.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3170">The following example retrieves a type by passing a ProgID, specifying whether to throw an exception if the ProgID is invalid.</span></span> <span data-ttu-id="4ee8d-3171">L'esempio visualizza quindi il ClassID correlato al ProgID, insieme a qualsiasi messaggio di eccezione del caso.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3171">The example then displays the ClassID related to the ProgID, along with any applicable exception message.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-3172">
            <paramref name="progID" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3172">
              <paramref name="progID" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <span data-ttu-id="4ee8d-3173">Il ProgID specificato non è registrato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3173">The specified ProgID is not registered.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="4ee8d-3174">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3174">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="4ee8d-3175">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3175">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">
          <span data-ttu-id="4ee8d-3176">ProgID del tipo da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3176">The progID of the type to get.</span>
          </span>
        </param>
        <param name="server">
          <span data-ttu-id="4ee8d-3177">Server da cui caricare il tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3177">The server from which to load the type.</span>
          </span>
          <span data-ttu-id="4ee8d-3178">Se il nome del server è <see langword="null" />, il metodo verrà automaticamente ripristinato sul computer locale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3178">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-3179">Ottiene il tipo associato all'ID di programma (ProgID) specificato dal server specificato, restituendo Null se si verifica un errore durante il caricamento del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3179">Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3180">Tipo associato all'ID di programma specificato (ProgID) se <paramref name="progID" /> è una voce valida del Registro di sistema e vi è associato un tipo; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3180">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3181">Questo metodo è fornito per il supporto COM.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3181">This method is provided for COM support.</span></span> <span data-ttu-id="4ee8d-3182">Gli ID di programma non vengono utilizzati in Microsoft .NET Framework, perché sono stati sostituiti dal concetto di spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3182">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3183">Nell'esempio seguente recupera un tipo passando un nome del ProgID e un nuovo server.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3183">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="4ee8d-3184">Nell'esempio viene quindi visualizzato il ClassID correlato al ProgID o genera un'eccezione se il valore ProgID o il nome del server non è valido.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3184">The example then displays the ClassID related to the ProgID, or throws an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-3185">
            <paramref name="prodID" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3185">
              <paramref name="prodID" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="4ee8d-3186">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3186">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="4ee8d-3187">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3187">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">
          <span data-ttu-id="4ee8d-3188">ProgID dell'oggetto <see cref="T:System.Type" /> da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3188">The progID of the <see cref="T:System.Type" /> to get.</span>
          </span>
        </param>
        <param name="server">
          <span data-ttu-id="4ee8d-3189">Server da cui caricare il tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3189">The server from which to load the type.</span>
          </span>
          <span data-ttu-id="4ee8d-3190">Se il nome del server è <see langword="null" />, il metodo verrà automaticamente ripristinato sul computer locale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3190">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="4ee8d-3191">
            <see langword="true" /> per generare qualsiasi eccezione si verifichi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3191">
              <see langword="true" /> to throw any exception that occurs.</span>
          </span>
          <span data-ttu-id="4ee8d-3192">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3192">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3193">
            <see langword="false" /> per ignorare qualsiasi eccezione si verifichi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3193">
              <see langword="false" /> to ignore any exception that occurs.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-3194">Ottiene il tipo associato all'ID di programma specificato (ProgID) dal server specificato e indica se generare un'eccezione qualora si verifichi un errore durante il caricamento del tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3194">Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3195">Tipo associato all'ID di programma specificato (ProgID) se <paramref name="progID" /> è una voce valida del Registro di sistema e vi è associato un tipo; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3195">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3196">Questo metodo è fornito per il supporto COM.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3196">This method is provided for COM support.</span></span> <span data-ttu-id="4ee8d-3197">Gli ID di programma non vengono utilizzati in Microsoft .NET Framework, perché sono stati sostituiti dal concetto di spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3197">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3198">Nell'esempio seguente recupera un tipo passando un nome del ProgID e un nuovo server.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3198">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="4ee8d-3199">L'esempio visualizza quindi il ClassID correlato al ProgID, che specifica se generare un'eccezione se il valore ProgID o il nome del server non è valido.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3199">The example then displays the ClassID related to the ProgID, specifying whether to throw an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-3200">
            <paramref name="progID" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3200">
              <paramref name="progID" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <span data-ttu-id="4ee8d-3201">Il progID specificato non è registrato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3201">The specified progID is not registered.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="4ee8d-3202">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3202">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="4ee8d-3203">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3203">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="4ee8d-3204">Oggetto per il quale ottenere l'handle di tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3204">The object for which to get the type handle.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-3205">Ottiene l'handle per l'oggetto <see cref="T:System.Type" /> di un oggetto specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3205">Gets the handle for the <see cref="T:System.Type" /> of a specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3206">Handle per l'oggetto <see cref="T:System.Type" /> del <see cref="T:System.Object" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3206">The handle for the <see cref="T:System.Type" /> of the specified <see cref="T:System.Object" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3207">I punti di controllo sono validi solo nel dominio dell'applicazione in cui sono stati ottenuti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3207">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3208">L'esempio seguente definisce la classe `MyClass1`, ottiene un'istanza di esso e recupera l'handle di runtime dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3208">The following example defines the class `MyClass1`, gets an instance of it, and retrieves the runtime handle of the object.</span></span>  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-3209">
            <paramref name="o" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3209">
              <paramref name="o" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3210">Ottiene il GUID associato all'oggetto <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3210">Gets the GUID associated with the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3211">GUID associato all'oggetto <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3211">The GUID associated with the <see cref="T:System.Type" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3212">Un GUID è associato a un tipo usando il <xref:System.Runtime.InteropServices.GuidAttribute> attributo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3212">A GUID is associated with a type using the <xref:System.Runtime.InteropServices.GuidAttribute> attribute.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3213">L'esempio seguente crea la classe `MyClass1` con un metodo pubblico, viene creata una `Type` oggetto corrispondente a `MyClass1`e ottiene il <xref:System.Guid> struttura utilizzando il `GUID` proprietà del `Type` classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3213">The following example creates the class `MyClass1` with a public method, creates a `Type` object corresponding to `MyClass1`, and gets the <xref:System.Guid> structure using the `GUID` property of the `Type` class.</span></span>  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3214">Ottiene un valore che indica se l'oggetto <see cref="T:System.Type" /> corrente comprende o si riferisce a un altro tipo, ovvero se l'oggetto <see cref="T:System.Type" /> corrente è una matrice, un puntatore o viene passato per riferimento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3214">Gets a value indicating whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3215">
            <see langword="true" /> se <see cref="T:System.Type" /> è una matrice, un puntatore oppure è passato per riferimento; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3215">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3216">Ad esempio, Type.GetType("Int32[]"). Restituisce HasElementType `true`, ma Type.GetType("Int32"). Restituisce HasElementType `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3216">For example, Type.GetType("Int32[]").HasElementType returns `true`, but Type.GetType("Int32").HasElementType returns `false`.</span></span> <span data-ttu-id="4ee8d-3217">HasElementType restituisce `true` per "Int32 \*" e "Int32 &".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3217">HasElementType also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
 <span data-ttu-id="4ee8d-3218">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico o un parametro di tipo nella definizione di un tipo o metodo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3218">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3219">Nell'esempio seguente viene restituito `true` o `false` a seconda se l'oggetto è una matrice, un tipo riferimento o puntatore.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3219">The following example returns `true` or `false` depending on whether or not the object is an array, a reference type, or a pointer.</span></span>  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3220">Quando ne viene eseguito l'override in una classe derivata, implementa la proprietà <see cref="P:System.Type.HasElementType" /> e determina se l'oggetto <see cref="T:System.Type" /> corrente include o contiene riferimenti a un altro tipo, ovvero se l'oggetto <see cref="T:System.Type" /> corrente è costituito da una matrice o da un puntatore o è passato come riferimento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3220">When overridden in a derived class, implements the <see cref="P:System.Type.HasElementType" /> property and determines whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3221">
            <see langword="true" /> se <see cref="T:System.Type" /> è una matrice, un puntatore oppure è passato per riferimento; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3221">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3222">Ad esempio, Type.GetType("Int32[]"). Restituisce HasElementTypeImpl `true`, ma Type.GetType("Int32"). Restituisce HasElementTypeImpl `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3222">For example, Type.GetType("Int32[]").HasElementTypeImpl returns `true`, but Type.GetType("Int32").HasElementTypeImpl returns `false`.</span></span> <span data-ttu-id="4ee8d-3223">HasElementTypeImpl restituisce `true` per "Int32 \*" e "Int32 &".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3223">HasElementTypeImpl also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3224">L'esempio seguente definisce la classe `MyTypeDelegator`, che esegue l'override di `HasElementTypeImpl` (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3224">The following example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="4ee8d-3225">La classe principale cerca di `HasElementType` proprietà e consente di visualizzare il tipo di elemento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3225">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3226">Richiama un membro specifico dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3226">Invokes a specific member of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-3227">Stringa che contiene il nome del costruttore, del metodo, della proprietà o del membro del campo da richiamare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3227">The string containing the name of the constructor, method, property, or field member to invoke.</span>
          </span>
          <span data-ttu-id="4ee8d-3228">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3228">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3229">Stringa vuota ("") per richiamare il membro predefinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3229">An empty string ("") to invoke the default member.</span>
          </span>
          <span data-ttu-id="4ee8d-3230">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3230">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3231">Per i membri <see langword="IDispatch" />, stringa che rappresenta DispID, ad esempio "[DispID=3]".</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3231">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="4ee8d-3232">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3232">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-3233">L'accesso può essere uno dei <see langword="BindingFlags" />, ad esempio <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> e così via.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3233">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span>
          </span>
          <span data-ttu-id="4ee8d-3234">Il tipo di ricerca non deve essere specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3234">The type of lookup need not be specified.</span>
          </span>
          <span data-ttu-id="4ee8d-3235">Se il tipo di ricerca viene omesso, vengono usati <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3235">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="4ee8d-3236">Oggetto che definisce una serie di proprietà e permette il binding, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3236">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="4ee8d-3237">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3237">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3238">Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3238">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3239">Si noti che potrebbe essere necessario definire in modo esplicito un oggetto <see cref="T:System.Reflection.Binder" /> per richiamare correttamente overload di metodo con argomenti variabili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3239">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="4ee8d-3240">Oggetto su cui richiamare il membro specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3240">The object on which to invoke the specified member.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="4ee8d-3241">Matrice che contiene gli argomenti da passare al membro da richiamare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3241">An array containing the arguments to pass to the member to invoke.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-3242">Chiama il membro specificato, usando i vincoli di associazione specificati e associando l'elenco di argomenti specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3242">Invokes the specified member, using the specified binding constraints and matching the specified argument list.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3243">Oggetto che rappresenta il valore restituito di un membro richiamato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3243">An object representing the return value of the invoked member.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-3244">Non è possibile usare <xref:System.Type.InvokeMember%2A> per richiamare un metodo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3244">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="4ee8d-3245">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire quali membri includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3245">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-3246">Specificare `BindingFlags.Public` per includere i membri pubblici nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3246">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-3247">Specificare `BindingFlags.NonPublic` da includere nella ricerca i membri non pubblici (vale a dire, i membri privati e protetti).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3247">Specify `BindingFlags.NonPublic` to include non-public members (that is, private and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-3248">Specificare `BindingFlags.FlattenHierarchy` per includere i membri statici nella gerarchia.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3248">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="4ee8d-3249">Nell'esempio <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare il comportamento della ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3249">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="4ee8d-3250">`BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3250">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="4ee8d-3251">`BindingFlags.DeclaredOnly` Per cercare solo i membri dichiarati nel <xref:System.Type>, non i membri ereditati sono semplicemente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3251">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="4ee8d-3252">Nell'esempio <xref:System.Reflection.BindingFlags> flag di chiamata consente di indicare l'azione da intraprendere con il membro:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3252">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="4ee8d-3253">`CreateInstance` per richiamare un costruttore.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3253">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="4ee8d-3254">`name` viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3254">`name` is ignored.</span></span> <span data-ttu-id="4ee8d-3255">Non è valido con altri flag di chiamata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3255">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="4ee8d-3256">`InvokeMethod` per richiamare un metodo, ma non un costruttore o un inizializzatore di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3256">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="4ee8d-3257">Non è valido con `SetField` o `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3257">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="4ee8d-3258">Se `InvokeMethod` viene specificato di per sé `BindingFlags.Public`, `BindingFlags.Instance`, e `BindingFlags.Static` vengono inclusi automaticamente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3258">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="4ee8d-3259">`GetField` Per ottenere il valore di un campo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3259">`GetField` to get the value of a field.</span></span> <span data-ttu-id="4ee8d-3260">Non è valido con `SetField`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3260">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="4ee8d-3261">`SetField` Per impostare il valore di un campo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3261">`SetField` to set the value of a field.</span></span> <span data-ttu-id="4ee8d-3262">Non è valido con `GetField`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3262">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="4ee8d-3263">`GetProperty` Per ottenere una proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3263">`GetProperty` to get a property.</span></span> <span data-ttu-id="4ee8d-3264">Non è valido con `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3264">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="4ee8d-3265">`SetProperty` Per impostare una proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3265">`SetProperty` to set a property.</span></span> <span data-ttu-id="4ee8d-3266">Non è valido con `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3266">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="4ee8d-3267">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3267">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="4ee8d-3268">Un metodo verrà richiamato se vengono soddisfatte entrambe le condizioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3268">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="4ee8d-3269">Il numero di parametri nella dichiarazione del metodo è uguale al numero di argomenti in di `args` matrice (a meno che gli argomenti predefiniti sono definiti nel membro e `BindingFlags.OptionalParamBinding` è specificato).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3269">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="4ee8d-3270">Il tipo di ciascun argomento può essere convertito dallo strumento di associazione per il tipo del parametro.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3270">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="4ee8d-3271">Lo strumento di associazione disponibili tutti i metodi corrispondenti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3271">The binder will find all of the matching methods.</span></span> <span data-ttu-id="4ee8d-3272">Questi metodi sono disponibili in base al tipo di associazione richiesti (<xref:System.Reflection.BindingFlags> i valori `InvokeMethod`, `GetProperty`e così via).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3272">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="4ee8d-3273">Il set di metodi verrà filtrato per il nome, numero di argomenti e un set di modificatori di ricerca definita nel gestore di associazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3273">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="4ee8d-3274">Dopo aver selezionato il metodo, viene richiamato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3274">After the method is selected, it is invoked.</span></span> <span data-ttu-id="4ee8d-3275">Accessibilità viene verificata a quel punto.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3275">Accessibility is checked at that point.</span></span> <span data-ttu-id="4ee8d-3276">È possibile specificare quale set di metodi vengono ricercati in base all'attributo di accessibilità associata al metodo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3276">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="4ee8d-3277">Il <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> metodo di <xref:System.Reflection.Binder> classe è responsabile della scelta del metodo da richiamare.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3277">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="4ee8d-3278">Il binder predefinito consente di selezionare la corrispondenza più specifica.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3278">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="4ee8d-3279">Restrizioni di accesso vengono ignorate per codice completamente attendibile. vale a dire, i costruttori privati, metodi, campi e proprietà accessibili e richiamate tramite <xref:System.Reflection> ogni volta che il codice è completamente attendibile.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3279">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="4ee8d-3280">È possibile usare `Type.InvokeMember` per impostare un campo a un determinato valore specificando <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3280">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4ee8d-3281">Ad esempio, se si desidera impostare un campo di istanza pubblica denominato F nella classe C e F è un `String`, è possibile usare codice, ad esempio:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3281">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 <span data-ttu-id="4ee8d-3282">Se è F un `String[]`, è possibile usare codice, ad esempio:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3282">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 <span data-ttu-id="4ee8d-3283">in modo da inizializzare il campo su questa nuova matrice.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3283">which will initialize the field F to this new array.</span></span> <span data-ttu-id="4ee8d-3284">È anche possibile usare `Type.InvokeMember` per impostare una posizione nella matrice specificando l'indice del valore e quindi il valore successivo usando codice simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3284">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 <span data-ttu-id="4ee8d-3285">Questa operazione modificherà stringa "z" nella matrice che contiene F alla stringa "b".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3285">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="4ee8d-3286">Quando si richiama un `IDispatch` membro, è possibile specificare il DispID anziché il nome del membro, utilizzando il formato della stringa "[DispID=3 = # #]".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3286">When you invoke an `IDispatch` member, you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="4ee8d-3287">Ad esempio, se il DispID di MyComMethod è 3, è possibile specificare la stringa "[DispID=3 = 3]" anziché "MyComMethod".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3287">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="4ee8d-3288">Richiamare un membro da DispID è più veloce rispetto alla ricerca del membro in base al nome.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3288">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="4ee8d-3289">Negli scenari di aggregazione complessa, a volte il DispID è l'unico modo per richiamare il membro desiderato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3289">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-3290">Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a membri pubblici se il chiamante è stato concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di autorizzazioni dei membri non pubblici è limitato al chiamante concedere set, oppure un subset della stessa.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3290">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="4ee8d-3291">(Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3291">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="4ee8d-3292">Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3292">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3293">L'esempio seguente usa `InvokeMember` per accedere ai membri di un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3293">The following example uses `InvokeMember` to access members of a type.</span></span>  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-3294">
            <paramref name="invokeAttr" /> non contiene <see langword="CreateInstance" /> e <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3294">
              <paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-3295">
            <paramref name="invokeAttr" /> non è un attributo valido di <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3295">
              <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span>
          </span>
          <span data-ttu-id="4ee8d-3296">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3296">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3297">
            <paramref name="invokeAttr" /> non contiene uno dei flag di binding seguenti: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3297">
              <paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3298">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3298">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3299">
            <paramref name="invokeAttr" /> contiene <see langword="CreateInstance" /> in combinazione con <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3299">
              <paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3300">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3300">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3301">
            <paramref name="invokeAttr" /> contiene sia <see langword="GetField" /> che <see langword="SetField" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3301">
              <paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3302">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3302">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3303">
            <paramref name="invokeAttr" /> contiene sia <see langword="GetProperty" /> che <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3303">
              <paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3304">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3304">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3305">
            <paramref name="invokeAttr" /> contiene <see langword="InvokeMethod" /> in combinazione con <see langword="SetField" /> o <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3305">
              <paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3306">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3306">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3307">
            <paramref name="invokeAttr" /> contiene <see langword="SetField" /> e <paramref name="args" /> include più elementi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3307">
              <paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span>
          </span>
          <span data-ttu-id="4ee8d-3308">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3308">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3309">Questo metodo è stato chiamato su un oggetto COM e uno dei flag di binding seguenti non è stato passato: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> o <see langword="BindingFlags.PutRefDispProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3309">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3310">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3310">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3311">Una delle matrici di parametri denominati contiene una stringa <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3311">One of the named parameter arrays contains a string that is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="4ee8d-3312">Il membro specificato è un inizializzatore di classi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3312">The specified member is a class initializer.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingFieldException">
          <span data-ttu-id="4ee8d-3313">Non è possibile trovare il campo o la proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3313">The field or property cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="4ee8d-3314">Non è possibile trovare metodi corrispondenti agli argomenti in <paramref name="args" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3314">No method can be found that matches the arguments in <paramref name="args" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3315">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3315">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3316">L'oggetto <see cref="T:System.Type" /> corrente rappresenta un tipo che contiene parametri di tipo open, ovvero <see cref="P:System.Type.ContainsGenericParameters" /> restituisce <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3316">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="4ee8d-3317">Non è possibile richiamare il metodo specificato su <paramref name="target" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3317">The specified member cannot be invoked on <paramref name="target" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="4ee8d-3318">Più di un metodo corrisponde ai criteri di binding.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3318">More than one method matches the binding criteria.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="4ee8d-3319">Questo metodo non è attualmente supportato in .NET Compact Framework.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3319">The .NET Compact Framework does not currently support this method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4ee8d-3320">Il metodo rappresentato da <paramref name="name" /> include uno o più parametri di tipo generico non specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3320">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span>
          </span>
          <span data-ttu-id="4ee8d-3321">In altri termini, la proprietà <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> del metodo restituisce <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3321">That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="4ee8d-3322">per l'accesso a membri non pubblici indipendentemente dalle autorizzazioni impostate.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3322">for accessing non-public members regardless of their grant set.</span>
          </span>
          <span data-ttu-id="4ee8d-3323">Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3323">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="4ee8d-3324">per chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3324">to call unmanaged code.</span>
          </span>
          <span data-ttu-id="4ee8d-3325">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3325">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-3326">Stringa che contiene il nome del costruttore, del metodo, della proprietà o del membro del campo da richiamare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3326">The string containing the name of the constructor, method, property, or field member to invoke.</span>
          </span>
          <span data-ttu-id="4ee8d-3327">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3327">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3328">Stringa vuota ("") per richiamare il membro predefinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3328">An empty string ("") to invoke the default member.</span>
          </span>
          <span data-ttu-id="4ee8d-3329">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3329">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3330">Per i membri <see langword="IDispatch" />, stringa che rappresenta DispID, ad esempio "[DispID=3]".</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3330">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="4ee8d-3331">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3331">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-3332">L'accesso può essere uno dei <see langword="BindingFlags" />, ad esempio <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> e così via.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3332">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span>
          </span>
          <span data-ttu-id="4ee8d-3333">Il tipo di ricerca non deve essere specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3333">The type of lookup need not be specified.</span>
          </span>
          <span data-ttu-id="4ee8d-3334">Se il tipo di ricerca viene omesso, vengono usati <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3334">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="4ee8d-3335">Oggetto che definisce una serie di proprietà e permette il binding, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3335">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="4ee8d-3336">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3336">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3337">Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3337">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3338">Si noti che potrebbe essere necessario definire in modo esplicito un oggetto <see cref="T:System.Reflection.Binder" /> per richiamare correttamente overload di metodo con argomenti variabili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3338">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="4ee8d-3339">Oggetto su cui richiamare il membro specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3339">The object on which to invoke the specified member.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="4ee8d-3340">Matrice che contiene gli argomenti da passare al membro da richiamare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3340">An array containing the arguments to pass to the member to invoke.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="4ee8d-3341">Oggetto che rappresenta le impostazioni locali di globalizzazione da usare, che possono essere necessarie per conversioni specifiche delle impostazioni locali, ad esempio la conversione di un oggetto <see cref="T:System.String" /> numerico in <see cref="T:System.Double" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3341">The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <see cref="T:System.String" /> to a <see cref="T:System.Double" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3342">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3342">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3343">Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso dell'oggetto <see cref="T:System.Globalization.CultureInfo" /> del thread corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3343">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-3344">Chiama il membro specificato, usando i vincoli di binding specificati e associando l'elenco di argomenti specificati e le impostazioni cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3344">Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3345">Oggetto che rappresenta il valore restituito di un membro richiamato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3345">An object representing the return value of the invoked member.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3346">Anche se il binder predefinito elabora <xref:System.Globalization.CultureInfo> (la `culture` parametro), è possibile usare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per scrivere un binder personalizzato che elaborano `culture`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3346">Although the default binder does not process <xref:System.Globalization.CultureInfo> (the `culture` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `culture`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-3347">Non è possibile usare <xref:System.Type.InvokeMember%2A> per richiamare un metodo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3347">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="4ee8d-3348">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire quali membri includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3348">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-3349">Specificare `BindingFlags.Public` per includere i membri pubblici nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3349">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-3350">Specificare `BindingFlags.NonPublic` da includere nella ricerca i membri non pubblici (vale a dire, i membri privati, interni e protetti).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3350">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-3351">Specificare `BindingFlags.FlattenHierarchy` per includere i membri statici nella gerarchia.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3351">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="4ee8d-3352">Nell'esempio <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare il comportamento della ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3352">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="4ee8d-3353">`BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3353">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="4ee8d-3354">`BindingFlags.DeclaredOnly` Per cercare solo i membri dichiarati nel <xref:System.Type>, non i membri ereditati sono semplicemente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3354">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="4ee8d-3355">Nell'esempio <xref:System.Reflection.BindingFlags> flag di chiamata consente di indicare l'azione da intraprendere con il membro:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3355">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="4ee8d-3356">`CreateInstance` per richiamare un costruttore.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3356">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="4ee8d-3357">`name` viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3357">`name` is ignored.</span></span> <span data-ttu-id="4ee8d-3358">Non è valido con altri flag di chiamata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3358">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="4ee8d-3359">`InvokeMethod` per richiamare un metodo, ma non un costruttore o un inizializzatore di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3359">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="4ee8d-3360">Non è valido con `SetField` o `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3360">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="4ee8d-3361">Se `InvokeMethod` viene specificato di per sé `BindingFlags.Public`, `BindingFlags.Instance`, e `BindingFlags.Static` vengono inclusi automaticamente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3361">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="4ee8d-3362">`GetField` Per ottenere il valore di un campo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3362">`GetField` to get the value of a field.</span></span> <span data-ttu-id="4ee8d-3363">Non è valido con `SetField`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3363">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="4ee8d-3364">`SetField` Per impostare il valore di un campo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3364">`SetField` to set the value of a field.</span></span> <span data-ttu-id="4ee8d-3365">Non è valido con `GetField`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3365">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="4ee8d-3366">`GetProperty` Per ottenere una proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3366">`GetProperty` to get a property.</span></span> <span data-ttu-id="4ee8d-3367">Non è valido con `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3367">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="4ee8d-3368">`SetProperty` Per impostare una proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3368">`SetProperty` to set a property.</span></span> <span data-ttu-id="4ee8d-3369">Non è valido con `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3369">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="4ee8d-3370">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3370">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="4ee8d-3371">Un metodo verrà richiamato se vengono soddisfatte entrambe le condizioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3371">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="4ee8d-3372">Il numero di parametri nella dichiarazione del metodo è uguale al numero di argomenti in di `args` matrice (a meno che gli argomenti predefiniti sono definiti nel membro e `BindingFlags.OptionalParamBinding` è specificato).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3372">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="4ee8d-3373">Il tipo di ciascun argomento può essere convertito dallo strumento di associazione per il tipo del parametro.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3373">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="4ee8d-3374">Lo strumento di associazione disponibili tutti i metodi corrispondenti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3374">The binder will find all of the matching methods.</span></span> <span data-ttu-id="4ee8d-3375">Questi metodi sono disponibili in base al tipo di associazione richiesti (<xref:System.Reflection.BindingFlags> i valori `InvokeMethod`, `GetProperty`e così via).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3375">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="4ee8d-3376">Il set di metodi verrà filtrato per il nome, numero di argomenti e un set di modificatori di ricerca definita nel gestore di associazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3376">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="4ee8d-3377">Dopo aver selezionato il metodo, viene richiamato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3377">After the method is selected, it is invoked.</span></span> <span data-ttu-id="4ee8d-3378">Accessibilità viene verificata a quel punto.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3378">Accessibility is checked at that point.</span></span> <span data-ttu-id="4ee8d-3379">È possibile specificare quale set di metodi vengono ricercati in base all'attributo di accessibilità associata al metodo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3379">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="4ee8d-3380">Il <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> metodo di <xref:System.Reflection.Binder> classe è responsabile della scelta del metodo da richiamare.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3380">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="4ee8d-3381">Il binder predefinito consente di selezionare la corrispondenza più specifica.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3381">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="4ee8d-3382">Restrizioni di accesso vengono ignorate per codice completamente attendibile. vale a dire, proprietà, metodi, campi e i costruttori privati accessibili e richiamate tramite Reflection, ogni volta che il codice è completamente attendibile.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3382">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="4ee8d-3383">È possibile usare `Type.InvokeMember` per impostare un campo a un determinato valore specificando <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3383">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4ee8d-3384">Ad esempio, se si desidera impostare un campo di istanza pubblica denominato F nella classe C e F è un `String` è possibile usare codice, ad esempio:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3384">For example, if you want to set a public instance field named F on class C, and F is a `String` you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 <span data-ttu-id="4ee8d-3385">Se è F un `String[]`, è possibile usare codice, ad esempio:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3385">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 <span data-ttu-id="4ee8d-3386">in modo da inizializzare il campo su questa nuova matrice.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3386">which will initialize the field F to this new array.</span></span> <span data-ttu-id="4ee8d-3387">È anche possibile usare `Type.InvokeMember` per impostare una posizione nella matrice specificando l'indice del valore e quindi il valore successivo usando codice simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3387">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 <span data-ttu-id="4ee8d-3388">Questa operazione modificherà stringa "z" nella matrice che contiene F alla stringa "b".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3388">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="4ee8d-3389">Quando si richiama un `IDispatch` membro è possibile specificare il DispID anziché il nome del membro, utilizzando il formato della stringa "[DispID=3 = # #]".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3389">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="4ee8d-3390">Ad esempio, se il DispID di MyComMethod è 3, è possibile specificare la stringa "[DispID=3 = 3]" anziché "MyComMethod".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3390">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="4ee8d-3391">Richiamare un membro da DispID è più veloce rispetto alla ricerca del membro in base al nome.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3391">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="4ee8d-3392">Negli scenari di aggregazione complessa, a volte il DispID è l'unico modo per richiamare il membro desiderato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3392">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-3393">Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a membri pubblici se il chiamante è stato concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di autorizzazioni dei membri non pubblici è limitato al chiamante concedere set, oppure un subset della stessa.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3393">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="4ee8d-3394">(Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3394">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="4ee8d-3395">Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3395">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-3396">
            <paramref name="invokeAttr" /> non contiene <see langword="CreateInstance" /> e <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3396">
              <paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-3397">
            <paramref name="invokeAttr" /> non è un attributo valido di <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3397">
              <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span>
          </span>
          <span data-ttu-id="4ee8d-3398">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3398">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3399">
            <paramref name="invokeAttr" /> non contiene uno dei flag di binding seguenti: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3399">
              <paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3400">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3400">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3401">
            <paramref name="invokeAttr" /> contiene <see langword="CreateInstance" /> in combinazione con <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3401">
              <paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3402">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3402">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3403">
            <paramref name="invokeAttr" /> contiene sia <see langword="GetField" /> che <see langword="SetField" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3403">
              <paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3404">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3404">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3405">
            <paramref name="invokeAttr" /> contiene sia <see langword="GetProperty" /> che <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3405">
              <paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3406">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3406">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3407">
            <paramref name="invokeAttr" /> contiene <see langword="InvokeMethod" /> in combinazione con <see langword="SetField" /> o <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3407">
              <paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3408">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3408">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3409">
            <paramref name="invokeAttr" /> contiene <see langword="SetField" /> e <paramref name="args" /> include più elementi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3409">
              <paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span>
          </span>
          <span data-ttu-id="4ee8d-3410">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3410">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3411">Questo metodo è stato chiamato su un oggetto COM e uno dei flag di binding seguenti non è stato passato: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> o <see langword="BindingFlags.PutRefDispProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3411">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3412">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3412">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3413">Una delle matrici di parametri denominati contiene una stringa <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3413">One of the named parameter arrays contains a string that is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="4ee8d-3414">Il membro specificato è un inizializzatore di classi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3414">The specified member is a class initializer.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingFieldException">
          <span data-ttu-id="4ee8d-3415">Non è possibile trovare il campo o la proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3415">The field or property cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="4ee8d-3416">Non è possibile trovare metodi corrispondenti agli argomenti in <paramref name="args" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3416">No method can be found that matches the arguments in <paramref name="args" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3417">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3417">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3418">L'oggetto <see cref="T:System.Type" /> corrente rappresenta un tipo che contiene parametri di tipo open, ovvero <see cref="P:System.Type.ContainsGenericParameters" /> restituisce <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3418">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="4ee8d-3419">Non è possibile richiamare il metodo specificato su <paramref name="target" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3419">The specified member cannot be invoked on <paramref name="target" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="4ee8d-3420">Più di un metodo corrisponde ai criteri di binding.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3420">More than one method matches the binding criteria.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4ee8d-3421">Il metodo rappresentato da <paramref name="name" /> include uno o più parametri di tipo generico non specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3421">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span>
          </span>
          <span data-ttu-id="4ee8d-3422">In altri termini, la proprietà <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> del metodo restituisce <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3422">That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="4ee8d-3423">per l'accesso a membri non pubblici indipendentemente dalle autorizzazioni impostate.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3423">for accessing non-public members regardless of their grant set.</span>
          </span>
          <span data-ttu-id="4ee8d-3424">Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3424">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="4ee8d-3425">per chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3425">to call unmanaged code.</span>
          </span>
          <span data-ttu-id="4ee8d-3426">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3426">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="4ee8d-3427">Stringa che contiene il nome del costruttore, del metodo, della proprietà o del membro del campo da richiamare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3427">The string containing the name of the constructor, method, property, or field member to invoke.</span>
          </span>
          <span data-ttu-id="4ee8d-3428">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3428">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3429">Stringa vuota ("") per richiamare il membro predefinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3429">An empty string ("") to invoke the default member.</span>
          </span>
          <span data-ttu-id="4ee8d-3430">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3430">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3431">Per i membri <see langword="IDispatch" />, stringa che rappresenta DispID, ad esempio "[DispID=3]".</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3431">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="4ee8d-3432">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3432">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="4ee8d-3433">L'accesso può essere uno dei <see langword="BindingFlags" />, ad esempio <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> e così via.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3433">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span>
          </span>
          <span data-ttu-id="4ee8d-3434">Il tipo di ricerca non deve essere specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3434">The type of lookup need not be specified.</span>
          </span>
          <span data-ttu-id="4ee8d-3435">Se il tipo di ricerca viene omesso, vengono usati <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3435">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="4ee8d-3436">Oggetto che definisce una serie di proprietà e permette il binding, che può implicare la scelta di un metodo di overload, la coercizione di tipi di argomento e la chiamata di un membro mediante reflection.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3436">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="4ee8d-3437">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3437">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3438">Riferimento Null (Nothing in Visual Basic) per l'uso di <see cref="P:System.Type.DefaultBinder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3438">A null reference (Nothing in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3439">Si noti che potrebbe essere necessario definire in modo esplicito un oggetto <see cref="T:System.Reflection.Binder" /> per richiamare correttamente overload di metodo con argomenti variabili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3439">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="4ee8d-3440">Oggetto su cui richiamare il membro specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3440">The object on which to invoke the specified member.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="4ee8d-3441">Matrice che contiene gli argomenti da passare al membro da richiamare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3441">An array containing the arguments to pass to the member to invoke.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="4ee8d-3442">Matrice di oggetti <see cref="T:System.Reflection.ParameterModifier" /> che rappresentano gli attributi associati all'elemento corrispondente nella matrice <c>args</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3442">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>args</c> array.</span>
          </span>
          <span data-ttu-id="4ee8d-3443">Gli attributi associati di un parametro sono archiviati nella firma digitale del membro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3443">A parameter's associated attributes are stored in the member's signature.</span>
          </span>
          <span data-ttu-id="4ee8d-3444">Il binder predefinito elabora questo parametro solo quando si chiama un componente COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3444">The default binder processes this parameter only when calling a COM component.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="4ee8d-3445">Oggetto <see cref="T:System.Globalization.CultureInfo" /> che rappresenta le impostazioni locali da usare, che possono essere necessarie per conversioni specifiche delle impostazioni locali, ad esempio la conversione di un valore numerico da String a Double.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3445">The <see cref="T:System.Globalization.CultureInfo" /> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</span>
          </span>
          <span data-ttu-id="4ee8d-3446">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3446">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3447">Riferimento Null (<see langword="Nothing" /> in Visual Basic) per l'uso dell'oggetto <see cref="T:System.Globalization.CultureInfo" /> del thread corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3447">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span>
          </span>
        </param>
        <param name="namedParameters">
          <span data-ttu-id="4ee8d-3448">Matrice contenente i nomi dei parametri a cui sono passati i valori della matrice <c>args</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3448">An array containing the names of the parameters to which the values in the <c>args</c> array are passed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-3449">Quando ne viene eseguito l'override in una classe derivata, richiama il membro specificato, usando i vincoli di binding specificati e associando l'elenco di argomenti, i modificatori e le impostazioni cultura specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3449">When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3450">Oggetto che rappresenta il valore restituito di un membro richiamato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3450">An object representing the return value of the invoked member.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3451">`InvokeMember` chiama un membro di costruttore o un metodo, ottiene o imposta un membro di proprietà, ottiene o imposta un membro del campo dati, o Ottiene o imposta un elemento di un membro di matrice.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3451">`InvokeMember` calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-3452">Non è possibile usare <xref:System.Type.InvokeMember%2A> per richiamare un metodo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3452">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="4ee8d-3453">Quando si richiama un `IDispatch` membro è possibile specificare il DispID anziché il nome del membro, utilizzando il formato della stringa "[DispID=3 = # #]".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3453">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="4ee8d-3454">Ad esempio, se il DispID di MyComMethod è 3, è possibile specificare la stringa "[DispID=3 = 3]" anziché "MyComMethod".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3454">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="4ee8d-3455">Richiamare un membro da DispID è più veloce rispetto alla ricerca del membro in base al nome.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3455">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="4ee8d-3456">Negli scenari di aggregazione complessa, a volte il DispID è l'unico modo per richiamare il membro desiderato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3456">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
 <span data-ttu-id="4ee8d-3457">Anche se il binder predefinito elabora <xref:System.Reflection.ParameterModifier> oppure <xref:System.Globalization.CultureInfo> (le `modifiers` e `culture` parametri), è possibile usare la classe astratta <xref:System.Reflection.Binder?displayProperty=nameWithType> classe per scrivere un binder personalizzato che elaborano `modifiers` e`culture`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3457">Although the default binder does not process <xref:System.Reflection.ParameterModifier> or <xref:System.Globalization.CultureInfo> (the `modifiers` and `culture` parameters), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers` and `culture`.</span></span> <span data-ttu-id="4ee8d-3458">`ParameterModifier` viene usato solo quando si chiama tramite l'interoperabilità COM, e vengono gestiti solo i parametri che vengono passati per riferimento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3458">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="4ee8d-3459">Tutti i parametri nella matrice `namedParameters` ottengono il valore nell'elemento corrispondente della matrice `args`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3459">Each parameter in the `namedParameters` array gets the value in the corresponding element in the `args` array.</span></span> <span data-ttu-id="4ee8d-3460">Se la lunghezza di `args` è superiore a quella di `namedParameters`, i valori degli argomenti rimanenti vengono passati in ordine.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3460">If the length of `args` is greater than the length of `namedParameters`, the remaining argument values are passed in order.</span></span>  
  
 <span data-ttu-id="4ee8d-3461">Il `namedParameters` matrice può essere utilizzata per modificare l'ordine degli argomenti in una matrice di input.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3461">The `namedParameters` array can be used to change the order of arguments in an input array.</span></span> <span data-ttu-id="4ee8d-3462">Ad esempio, dato il metodo `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) e la matrice di input `{ 42, "x" }`, la matrice di input può essere passata invariata in `args` se la matrice `{ "b", "a" }` fornito per `namedParameters`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3462">For example, given the method `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) and the input array `{ 42, "x" }`, the input array can be passed unchanged to `args` if the array `{ "b", "a" }` is supplied for `namedParameters`.</span></span>  
  
 <span data-ttu-id="4ee8d-3463">Nell'esempio <xref:System.Reflection.BindingFlags> flag del filtro possono essere utilizzati per definire quali membri includere nella ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3463">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="4ee8d-3464">Specificare `BindingFlags.Public` per includere i membri pubblici nella ricerca.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3464">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-3465">Specificare `BindingFlags.NonPublic` da includere nella ricerca i membri non pubblici (vale a dire, i membri privati, interni e protetti).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3465">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="4ee8d-3466">Specificare `BindingFlags.FlattenHierarchy` per includere i membri statici nella gerarchia.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3466">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="4ee8d-3467">Nell'esempio <xref:System.Reflection.BindingFlags> flag di modifica consente di modificare il comportamento della ricerca:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3467">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="4ee8d-3468">`BindingFlags.IgnoreCase` per ignorare la distinzione di `name`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3468">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="4ee8d-3469">`BindingFlags.DeclaredOnly` Per cercare solo i membri dichiarati nel <xref:System.Type>, non i membri ereditati sono semplicemente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3469">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="4ee8d-3470">Nell'esempio <xref:System.Reflection.BindingFlags> flag di chiamata consente di indicare l'azione da intraprendere con il membro:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3470">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="4ee8d-3471">`CreateInstance` per richiamare un costruttore.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3471">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="4ee8d-3472">`name` viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3472">`name` is ignored.</span></span> <span data-ttu-id="4ee8d-3473">Non è valido con altri flag di chiamata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3473">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="4ee8d-3474">`InvokeMethod` per richiamare un metodo, ma non un costruttore o un inizializzatore di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3474">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="4ee8d-3475">Non è valido con `SetField` o `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3475">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="4ee8d-3476">Se `InvokeMethod` viene specificato di per sé `BindingFlags.Public`, `BindingFlags.Instance`, e `BindingFlags.Static` vengono inclusi automaticamente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3476">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="4ee8d-3477">`GetField` Per ottenere il valore di un campo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3477">`GetField` to get the value of a field.</span></span> <span data-ttu-id="4ee8d-3478">Non è valido con `SetField`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3478">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="4ee8d-3479">`SetField` Per impostare il valore di un campo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3479">`SetField` to set the value of a field.</span></span> <span data-ttu-id="4ee8d-3480">Non è valido con `GetField`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3480">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="4ee8d-3481">`GetProperty` Per ottenere una proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3481">`GetProperty` to get a property.</span></span> <span data-ttu-id="4ee8d-3482">Non è valido con `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3482">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="4ee8d-3483">`SetProperty` Per impostare una proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3483">`SetProperty` to set a property.</span></span> <span data-ttu-id="4ee8d-3484">Non è valido con `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3484">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="4ee8d-3485">Per altre informazioni, vedere <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3485">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="4ee8d-3486">Un metodo verrà richiamato se vengono soddisfatte entrambe le condizioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3486">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="4ee8d-3487">Il numero di parametri nella dichiarazione del metodo è uguale al numero di argomenti in di `args` matrice (a meno che gli argomenti predefiniti sono definiti nel membro e `BindingFlags.OptionalParamBinding` è specificato).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3487">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="4ee8d-3488">Il tipo di ciascun argomento può essere convertito dallo strumento di associazione per il tipo del parametro.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3488">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="4ee8d-3489">Lo strumento di associazione disponibili tutti i metodi corrispondenti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3489">The binder will find all of the matching methods.</span></span> <span data-ttu-id="4ee8d-3490">Questi metodi sono disponibili in base al tipo di associazione richiesti (<xref:System.Reflection.BindingFlags> i valori `InvokeMethod`, `GetProperty`e così via).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3490">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="4ee8d-3491">Il set di metodi verrà filtrato per il nome, numero di argomenti e un set di modificatori di ricerca definita nel gestore di associazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3491">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="4ee8d-3492">Dopo aver selezionato il metodo, viene richiamato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3492">After the method is selected, it is invoked.</span></span> <span data-ttu-id="4ee8d-3493">Accessibilità viene verificata a quel punto.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3493">Accessibility is checked at that point.</span></span> <span data-ttu-id="4ee8d-3494">È possibile specificare quale set di metodi vengono ricercati in base all'attributo di accessibilità associata al metodo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3494">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="4ee8d-3495">Il <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> metodo di <xref:System.Reflection.Binder> classe è responsabile della scelta del metodo da richiamare.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3495">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="4ee8d-3496">Il binder predefinito consente di selezionare la corrispondenza più specifica.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3496">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="4ee8d-3497">`InvokeMember` può essere usata per richiamare metodi con parametri con valori predefiniti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3497">`InvokeMember` can be used to invoke methods with parameters that have default values.</span></span> <span data-ttu-id="4ee8d-3498">Per associare a questi metodi, richiede Reflection <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> specificare.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3498">To bind to these methods, Reflection requires <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> to be specified.</span></span> <span data-ttu-id="4ee8d-3499">Per un parametro che ha un valore predefinito, è possibile fornire un valore diverso, oppure fornire <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> per usare il valore predefinito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3499">For a parameter that has a default value, you can either supply a different value, or supply <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> to use the default value.</span></span>  
  
 <span data-ttu-id="4ee8d-3500">Ad esempio, prendere in considerazione un metodo, ad esempio MyMethod (int x, y float gt;=2.0).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3500">For example, consider a method such as MyMethod(int x, float y = 2.0).</span></span> <span data-ttu-id="4ee8d-3501">Per richiamare questo metodo con solo il primo argomento come MyMethod (4), passare a uno dei flag di binding precedente e passare due argomenti, vale a dire, 4 per il primo argomento e `Missing.Value` per il secondo argomento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3501">To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and `Missing.Value` for the second argument.</span></span> <span data-ttu-id="4ee8d-3502">Se non si usa `Missing.Value`, non è possibile omettere i parametri facoltativi di `Invoke` (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3502">Unless you use `Missing.Value`, you may not omit optional parameters with the `Invoke` method.</span></span> <span data-ttu-id="4ee8d-3503">Se è necessario farlo, usare `InvokeMember` invece.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3503">If you must do so, use `InvokeMember` instead.</span></span>  
  
 <span data-ttu-id="4ee8d-3504">Restrizioni di accesso vengono ignorate per codice completamente attendibile. vale a dire, i costruttori privati, metodi, campi e proprietà accessibili e richiamate tramite <xref:System.Reflection> ogni volta che il codice è completamente attendibile.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3504">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="4ee8d-3505">È possibile usare `Type.InvokeMember` per impostare un campo a un determinato valore specificando <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3505">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4ee8d-3506">Ad esempio, se si desidera impostare un campo di istanza pubblica denominato F nella classe C e F è un `String`, è possibile usare codice, ad esempio:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3506">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 <span data-ttu-id="4ee8d-3507">Se è F un `String[]`, è possibile usare codice, ad esempio:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3507">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 <span data-ttu-id="4ee8d-3508">in modo da inizializzare il campo su questa nuova matrice.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3508">which will initialize the field F to this new array.</span></span> <span data-ttu-id="4ee8d-3509">È anche possibile usare `Type.InvokeMember` per impostare una posizione nella matrice specificando l'indice del valore e quindi il valore successivo usando codice simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3509">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 <span data-ttu-id="4ee8d-3510">Questa operazione modificherà stringa "z" nella matrice che contiene F alla stringa "b".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3510">This will change string "z" in the array that F holds to string "b".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-3511">Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo metodo può essere utilizzato per accedere a membri pubblici se il chiamante è stato concesso <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, se il set di autorizzazioni dei membri non pubblici è limitato al chiamante concedere set, oppure un subset della stessa.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3511">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="4ee8d-3512">(Vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3512">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="4ee8d-3513">Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3513">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-3514">
            <paramref name="invokeAttr" /> non contiene <see langword="CreateInstance" /> e <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3514">
              <paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-3515">
            <paramref name="args" /> e <paramref name="modifiers" /> non hanno la stessa lunghezza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3515">
              <paramref name="args" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
          <span data-ttu-id="4ee8d-3516">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3516">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3517">
            <paramref name="invokeAttr" /> non è un attributo valido di <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3517">
              <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span>
          </span>
          <span data-ttu-id="4ee8d-3518">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3518">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3519">
            <paramref name="invokeAttr" /> non contiene uno dei flag di binding seguenti: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3519">
              <paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3520">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3520">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3521">
            <paramref name="invokeAttr" /> contiene <see langword="CreateInstance" /> in combinazione con <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3521">
              <paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3522">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3522">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3523">
            <paramref name="invokeAttr" /> contiene sia <see langword="GetField" /> che <see langword="SetField" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3523">
              <paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3524">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3524">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3525">
            <paramref name="invokeAttr" /> contiene sia <see langword="GetProperty" /> che <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3525">
              <paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3526">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3526">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3527">
            <paramref name="invokeAttr" /> contiene <see langword="InvokeMethod" /> in combinazione con <see langword="SetField" /> o <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3527">
              <paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3528">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3528">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3529">
            <paramref name="invokeAttr" /> contiene <see langword="SetField" /> e <paramref name="args" /> include più elementi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3529">
              <paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span>
          </span>
          <span data-ttu-id="4ee8d-3530">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3530">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3531">La matrice di parametri denominata è più grande della matrice di argomenti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3531">The named parameter array is larger than the argument array.</span>
          </span>
          <span data-ttu-id="4ee8d-3532">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3532">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3533">Questo metodo è stato chiamato su un oggetto COM e uno dei flag di binding seguenti non è stato passato: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> o <see langword="BindingFlags.PutRefDispProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3533">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3534">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3534">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3535">Una delle matrici di parametri denominati contiene una stringa <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3535">One of the named parameter arrays contains a string that is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="4ee8d-3536">Il membro specificato è un inizializzatore di classi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3536">The specified member is a class initializer.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingFieldException">
          <span data-ttu-id="4ee8d-3537">Non è possibile trovare il campo o la proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3537">The field or property cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="4ee8d-3538">Non è possibile trovare metodi corrispondenti agli argomenti in <paramref name="args" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3538">No method can be found that matches the arguments in <paramref name="args" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3539">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3539">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3540">Non è possibile trovare membri con i nomi di argomento forniti in <paramref name="namedParameters" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3540">No member can be found that has the argument names supplied in <paramref name="namedParameters" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3541">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3541">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-3542">L'oggetto <see cref="T:System.Type" /> corrente rappresenta un tipo che contiene parametri di tipo open, ovvero <see cref="P:System.Type.ContainsGenericParameters" /> restituisce <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3542">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="4ee8d-3543">Non è possibile richiamare il metodo specificato su <paramref name="target" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3543">The specified member cannot be invoked on <paramref name="target" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="4ee8d-3544">Più di un metodo corrisponde ai criteri di binding.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3544">More than one method matches the binding criteria.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4ee8d-3545">Il metodo rappresentato da <paramref name="name" /> include uno o più parametri di tipo generico non specificati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3545">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span>
          </span>
          <span data-ttu-id="4ee8d-3546">In altri termini, la proprietà <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> del metodo restituisce <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3546">That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="4ee8d-3547">per l'accesso a membri non pubblici indipendentemente dalle autorizzazioni impostate.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3547">for accessing non-public members regardless of their grant set.</span>
          </span>
          <span data-ttu-id="4ee8d-3548">Enumerazione associata: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3548">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="4ee8d-3549">per chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3549">to call unmanaged code.</span>
          </span>
          <span data-ttu-id="4ee8d-3550">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3550">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3551">Ottiene un valore che indica se <see cref="T:System.Type" /> è astratto e se è necessario eseguirne l'override.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3551">Gets a value indicating whether the <see cref="T:System.Type" /> is abstract and must be overridden.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3552">
            <see langword="true" /> se il <see cref="T:System.Type" /> è astratto. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3552">
              <see langword="true" /> if the <see cref="T:System.Type" /> is abstract; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3553">Il <xref:System.Type.IsAbstract%2A> restituisce proprietà `true` nei casi seguenti:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3553">The <xref:System.Type.IsAbstract%2A> property returns `true` in the following cases:</span></span>  
  
-   <span data-ttu-id="4ee8d-3554">Il tipo corrente è astratto. vale a dire, non è possibile creare un'istanza, ma può essere utilizzato solo come classe di base per le classi derivate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3554">The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes.</span></span> <span data-ttu-id="4ee8d-3555">In c#, le classi astratte sono contrassegnate con il [astratto](~/docs/csharp/language-reference/keywords/abstract.md) parola chiave; in Visual Basic, questi elementi sono contrassegnati con la [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) (parola chiave).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3555">In C#, abstract classes are marked with the [abstract](~/docs/csharp/language-reference/keywords/abstract.md) keyword; in Visual Basic, they are marked with the [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) keyword.</span></span>  
  
-   <span data-ttu-id="4ee8d-3556">Il tipo corrente è un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3556">The current type is an interface.</span></span>  
  
 <span data-ttu-id="4ee8d-3557">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3557">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3558">L'esempio seguente crea una matrice di <xref:System.Type> gli oggetti che rappresentano i tipi seguenti: contiene tipo restituisce `true` se l'oggetto specificato è `abstract`; in caso contrario, restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3558">The following example creates an array of <xref:System.Type> objects that represent the following types:contains type returns `true` if the specified object is `abstract`; otherwise, it returns `false`.</span></span>  
  
-   <span data-ttu-id="4ee8d-3559">`AbstractClass`, una classe astratta (una classe contrassegnata come `abstract` in c# e `MustInherit` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3559">`AbstractClass`, an abstract class (a class marked as `abstract` in C# and `MustInherit` in Visual Basic).</span></span>  
  
-   <span data-ttu-id="4ee8d-3560">`DerivedClass`, una classe che eredita da `AbstractClass`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3560">`DerivedClass`, a class that inherits from `AbstractClass`.</span></span>  
  
-   <span data-ttu-id="4ee8d-3561">`SingleClass`, una classe non è ereditabile.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3561">`SingleClass`, a non-inheritable class.</span></span> <span data-ttu-id="4ee8d-3562">Viene definito come `sealed` in c# e `NotInheritable` in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3562">It is defined as `sealed` in C# and `NotInheritable` in Visual Basic.</span></span>  
  
-   <span data-ttu-id="4ee8d-3563">`ITypeInfo`, un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3563">`ITypeInfo`, an interface.</span></span>  
  
-   <span data-ttu-id="4ee8d-3564">`ImplementingClass`, una classe che implementa il `ITypeInfo` interfaccia.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3564">`ImplementingClass`, a class that implements the `ITypeInfo` interface.</span></span>  
  
 <span data-ttu-id="4ee8d-3565">Il metodo restituisce `true` solo per `AbstractClass`, la classe astratta, e `ITypeInfo`, l'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3565">The method returns `true` only for `AbstractClass`, the abstract class, and `ITypeInfo`, the interface.</span></span>  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3566">Ottiene un valore che indica se l'attributo di formato della stringa <see langword="AnsiClass" /> è selezionato per <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3566">Gets a value indicating whether the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3567">
            <see langword="true" /> se l'attributo di formato della stringa <see langword="AnsiClass" /> è selezionato per <see cref="T:System.Type" />; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3567">
              <see langword="true" /> if the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3568">Il <xref:System.Reflection.TypeAttributes.StringFormatMask> consente di selezionare gli attributi del formato stringa.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3568">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="4ee8d-3569">Gli attributi di formato di stringa migliorano l'interoperabilità con la definizione di modalità di interpretazione di stringhe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3569">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="4ee8d-3570">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico, questa proprietà si riferisce alla definizione del tipo generico da cui è stato costruito il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3570">If the current <xref:System.Type> represents a generic type, this property pertains to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="4ee8d-3571">Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato dalla `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3571">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="4ee8d-3572">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3572">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3573">Nell'esempio seguente ottiene le informazioni sul campo e verifica la presenza di `AnsiClass` attributo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3573">The following example gets the field information and checks for the `AnsiClass` attribute.</span></span>  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3574">Ottiene un valore che indica se il tipo è una matrice.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3574">Gets a value that indicates whether the type is an array.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3575">
            <see langword="true" /> se il tipo corrente è una matrice; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3575">
              <see langword="true" /> if the current type is an array; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3576">Il <xref:System.Type.IsArray%2A> proprietà restituisce `false` per il <xref:System.Array> classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3576">The <xref:System.Type.IsArray%2A> property returns `false` for the <xref:System.Array> class.</span></span> <span data-ttu-id="4ee8d-3577">Restituisce inoltre `false` se l'istanza corrente è un <xref:System.Type> che rappresenta un tipo di raccolta o un'interfaccia progettata per funzionare con le raccolte, ad esempio <xref:System.Collections.IEnumerable> o <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3577">It also returns `false` if the current instance is a <xref:System.Type> object that represents a collection type or an interface designed to work with collections, such as <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
 <span data-ttu-id="4ee8d-3578">Per verificare una matrice, usare codice, ad esempio:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3578">To check for an array, use code such as:</span></span>  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 <span data-ttu-id="4ee8d-3579">Se il tipo corrente rappresenta un tipo generico o un parametro di tipo nella definizione di un tipo o metodo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3579">If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="4ee8d-3580">Questa proprietà è di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3580">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3581">Nell'esempio seguente viene illustrato l'utilizzo di <xref:System.Type.IsArray%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3581">The following example demonstrates using the <xref:System.Type.IsArray%2A> property.</span></span>  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3582">Quando ne viene eseguito l'override in una classe derivata, implementa la proprietà <see cref="P:System.Type.IsArray" /> e determina se l'oggetto <see cref="T:System.Type" /> è una matrice.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3582">When overridden in a derived class, implements the <see cref="P:System.Type.IsArray" /> property and determines whether the <see cref="T:System.Type" /> is an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3583">
            <see langword="true" /> se <see cref="T:System.Type" /> è una matrice. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3583">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an array; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3584">Un'istanza di <xref:System.Array> classe deve restituire `false` perché è un oggetto, non è una matrice.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3584">An instance of the <xref:System.Array> class must return `false` because it is an object, not an array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3585">Nell'esempio seguente esegue l'override di `IsArrayImpl` metodo nel `MyTypeDelegator` classe, controlla se una variabile è una matrice e viene visualizzato il risultato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3585">The following example overrides the `IsArrayImpl` method in the `MyTypeDelegator` class, checks if a variable is an array, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <span data-ttu-id="4ee8d-3586">Tipo da confrontare con il tipo corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3586">The type to compare with the current type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-3587">Determina se un'istanza di un tipo specificato può essere assegnata a un'istanza del tipo corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3587">Determines whether an instance of a specified type can be assigned to an instance of the current type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3588">
            <see langword="true" /> se una o più delle condizioni seguenti sono vere:</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3588">
              <see langword="true" /> if any of the following conditions is true:</span>
          </span>
          <span data-ttu-id="4ee8d-3589">
-   <paramref name="c" /> e l'istanza corrente rappresentano lo stesso tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3589">
-   <paramref name="c" /> and the current instance represent the same type.</span>
          </span>
          <span data-ttu-id="4ee8d-3590">
-   <paramref name="c" /> deriva direttamente o indirettamente dall'istanza corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3590">
-   <paramref name="c" /> is derived either directly or indirectly from the current instance.</span>
          </span>
          <span data-ttu-id="4ee8d-3591">
            <paramref name="c" /> deriva direttamente dall'istanza corrente se eredita dall'istanza corrente. <paramref name="c" /> deriva indirettamente dall'istanza corrente se eredita da una successione di una o più classi che ereditano dall'istanza corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3591">
              <paramref name="c" /> is derived directly from the current instance if it inherits from the current instance; <paramref name="c" /> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.</span>
          </span>
          <span data-ttu-id="4ee8d-3592">-   L'istanza corrente è un'interfaccia implementata da <paramref name="c" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3592">-   The current instance is an interface that <paramref name="c" /> implements.</span>
          </span>
          <span data-ttu-id="4ee8d-3593">
-   <paramref name="c" /> è un parametro di tipo generico e l'istanza corrente rappresenta uno dei vincoli di <paramref name="c" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3593">
-   <paramref name="c" /> is a generic type parameter, and the current instance represents one of the constraints of <paramref name="c" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3594">Nell'esempio seguente, l'istanza corrente è un oggetto <see cref="T:System.Type" /> che rappresenta la classe <see cref="T:System.IO.Stream" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3594">In the following example, the current instance is a <see cref="T:System.Type" /> object that represents the <see cref="T:System.IO.Stream" /> class.</span>
          </span>
          <span data-ttu-id="4ee8d-3595">
            <c>GenericWithConstraint</c> è un tipo generico il cui parametro di tipo generico deve essere di tipo <see cref="T:System.IO.Stream" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3595">
              <c>GenericWithConstraint</c> is a generic type whose generic type parameter must be of type    <see cref="T:System.IO.Stream" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3596">Passando il parametro di tipo generico a <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> si indica che un'istanza del parametro di tipo generico può essere assegnata a un oggetto <see cref="T:System.IO.Stream" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3596">Passing its generic type parameter to the <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> indicates that  an instance of the generic type parameter can be assigned to an <see cref="T:System.IO.Stream" /> object.</span>
          </span>
          <span data-ttu-id="4ee8d-3597">[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3597">[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]</span>
          </span>
          <span data-ttu-id="4ee8d-3598">
-   <paramref name="c" /> rappresenta un tipo valore e l'istanza corrente rappresenta <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> in Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3598">
-   <paramref name="c" /> represents a value type, and the current instance represents <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> in Visual Basic).</span>
          </span>
          <span data-ttu-id="4ee8d-3599">
            <see langword="false" /> se non viene soddisfatta nessuna di queste condizioni oppure se <paramref name="c" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3599">
              <see langword="false" /> if none of these conditions are true, or if <paramref name="c" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3600">Il <xref:System.Type.IsAssignableFrom%2A> metodo può essere utilizzato per determinare se un'istanza di `c` possono essere assegnati a un'istanza del tipo corrente, il metodo è particolarmente utile quando si gestiscono oggetti i cui tipi non sono noti in fase di progettazione e consente di condizionale assegnazione, come illustrato nell'esempio seguente viene illustrato come.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3600">The <xref:System.Type.IsAssignableFrom%2A> method can be used to determine whether an instance of `c` can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 <span data-ttu-id="4ee8d-3601">Questo metodo garantisce pertanto che una riga di codice, come nell'esempio verrà eseguito in fase di esecuzione senza generare un <xref:System.InvalidCastException> eccezione o un'eccezione simile:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3601">This method thus ensures that a line of code like the following will execute at runtime without throwing an <xref:System.InvalidCastException> exception or a similar exception:</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 <span data-ttu-id="4ee8d-3602">Questo metodo può essere sostituito da una classe derivata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3602">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-3603">Definice obecného typu. non è assegnabile da un tipo costruito chiuso.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3603">A generic type definition is not assignable from a closed constructed type.</span></span> <span data-ttu-id="4ee8d-3604">Vale a dire, non è possibile assegnare il tipo costruito chiuso `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) a una variabile di tipo `MyGenericList<T>`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3604">That is, you cannot assign the closed constructed type `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) to a variable of type `MyGenericList<T>`.</span></span>  
  
 <span data-ttu-id="4ee8d-3605">Se il `c` parametro è di tipo <xref:System.Reflection.Emit.TypeBuilder>, il risultato sarà basato sul tipo che deve essere compilata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3605">If the `c` parameter is of type <xref:System.Reflection.Emit.TypeBuilder>, the result is based on the type that is to be built.</span></span> <span data-ttu-id="4ee8d-3606">Esempio di codice seguente si illustra l'uso di un tipo incorporato denominato `B`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3606">The following code example demonstrates this using a built type named `B`.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3607">Nell'esempio seguente viene illustrato il `IsAssignableFrom` metodo utilizzando definiti classi, matrici di interi e generics.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3607">The following example demonstrates the `IsAssignableFrom` method using defined classes, integer arrays, and generics.</span></span>  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3608">Ottiene un valore che indica se l'attributo di formato della stringa <see langword="AutoClass" /> è selezionato per <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3608">Gets a value indicating whether the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3609">
            <see langword="true" /> se l'attributo di formato della stringa <see langword="AutoClass" /> è selezionato per <see cref="T:System.Type" />; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3609">
              <see langword="true" /> if the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3610">Il <xref:System.Reflection.TypeAttributes.StringFormatMask> consente di selezionare gli attributi del formato stringa.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3610">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="4ee8d-3611">Gli attributi di formato di stringa migliorano l'interoperabilità con la definizione di modalità di interpretazione di stringhe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3611">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="4ee8d-3612">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione del tipo generico da cui è stato costruito il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3612">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="4ee8d-3613">Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato dalla `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3613">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="4ee8d-3614">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3614">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3615">Ottiene un valore che indica se i campi del tipo corrente sono disposti automaticamente dal Common Language Runtime.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3615">Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3616">
            <see langword="true" /> se la proprietà <see cref="P:System.Type.Attributes" /> del tipo corrente include <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3616">
              <see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3617">Questa proprietà viene fornita per praticità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3617">This property is provided as a convenience.</span></span> <span data-ttu-id="4ee8d-3618">In alternativa, è possibile usare la <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valore di enumerazione per selezionare gli attributi di layout di tipo e quindi testare se <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> è impostata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3618">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="4ee8d-3619">Il <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, e <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valori dell'enumerazione indicano il modo in cui i campi del tipo vengono disposti nella memoria.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3619">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="4ee8d-3620">Per i tipi dinamici, è possibile specificare <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> quando si crea il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3620">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="4ee8d-3621">Nel codice, si applicano i <xref:System.Runtime.InteropServices.StructLayoutAttribute> dell'attributo con il <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> valore di enumerazione al tipo, per consentire il runtime di determinare il modo più appropriato per il layout della classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3621">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-3622">Non è possibile usare la <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metodo per determinare se il <xref:System.Runtime.InteropServices.StructLayoutAttribute> viene applicato a un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3622">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="4ee8d-3623">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione del tipo generico da cui è stato costruito il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3623">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="4ee8d-3624">Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato da `MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3624">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="4ee8d-3625">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3625">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3626">Nell'esempio seguente crea un'istanza del tipo e visualizza il <xref:System.Type.IsAutoLayout%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3626">The following example creates an instance of the type and displays the <xref:System.Type.IsAutoLayout%2A> property.</span></span>  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">
          <span data-ttu-id="4ee8d-3627">Metadati e componenti auto-descrittivi</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3627">Metadata and Self-Describing Components</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3628">Ottiene un valore che indica se l'oggetto <see cref="T:System.Type" /> viene passato per riferimento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3628">Gets a value indicating whether the <see cref="T:System.Type" /> is passed by reference.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3629">
            <see langword="true" /> se <see cref="T:System.Type" /> viene passato per riferimento. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3629">
              <see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3630">Per ottenere il tipo effettivo, il tipo passato per riferimento di dereferenziazione e quindi chiamare <xref:System.Type.GetElementType%2A> su tale tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3630">To get to the actual type, dereference the type that was passed by reference, and then call <xref:System.Type.GetElementType%2A> on that type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3631">L'esempio seguente illustra un uso di `IsByRef` proprietà per controllare se un tipo specificato viene passato per riferimento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3631">The following example demonstrates a use of the `IsByRef` property to check whether a specified type is passed by reference.</span></span> <span data-ttu-id="4ee8d-3632">L'esempio definisce la classe `MyTypeDelegator`, che esegue l'override di `HasElementTypeImpl` (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3632">The example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="4ee8d-3633">La classe principale cerca di `HasElementType` proprietà e consente di visualizzare il tipo di elemento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3633">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3634">Quando ne viene eseguito l'override in una classe derivata, implementa la proprietà <see cref="P:System.Type.IsByRef" /> e determina se l'oggetto <see cref="T:System.Type" /> viene passato per riferimento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3634">When overridden in a derived class, implements the <see cref="P:System.Type.IsByRef" /> property and determines whether the <see cref="T:System.Type" /> is passed by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3635">
            <see langword="true" /> se <see cref="T:System.Type" /> viene passato per riferimento. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3635">
              <see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3636">Ottiene un valore che indica se <see cref="T:System.Type" /> è una classe o un delegato, ovvero se non è un tipo di valore o un'interfaccia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3636">Gets a value indicating whether the <see cref="T:System.Type" /> is a class or a delegate; that is, not a value type or interface.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3637">
            <see langword="true" /> se il <see cref="T:System.Type" /> è una classe. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3637">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a class; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3638">Questa proprietà restituisce `true` per classi, nonché i delegati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3638">This property returns `true` for classes as well as delegates.</span></span> <span data-ttu-id="4ee8d-3639">Restituisce `false` per i tipi di valore (per le strutture ed enumerazioni) anche se essi vengono sottoposti a boxing.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3639">It returns `false` for value types (for structures and enumerations) even if they are boxed.</span></span>  
  
 <span data-ttu-id="4ee8d-3640">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questa proprietà restituisce sempre `true`. Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà restituisce `true` se la definizione di tipo generico è una definizione di classe; vale a dire, non definisce un'interfaccia o un tipo di valore.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3640">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `true`.If the current <xref:System.Type> represents a constructed generic type, this property returns `true` if the generic type definition is a class definition; that is, it does not define an interface or a value type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-3641">Questa proprietà restituisce `true` per `Type` istanze che rappresentano le <xref:System.Enum> e <xref:System.ValueType> classi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3641">This property returns `true` for `Type` instances that represent the <xref:System.Enum> and <xref:System.ValueType> classes.</span></span> <span data-ttu-id="4ee8d-3642">Queste due classi sono tipi di base per le enumerazioni e tipi di valore, rispettivamente, ma non sono le enumerazioni o i tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3642">These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves.</span></span> <span data-ttu-id="4ee8d-3643">Per altre informazioni, vedere la <xref:System.Type.IsValueType%2A> e <xref:System.Type.IsEnum%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3643">For more information, see the <xref:System.Type.IsValueType%2A> and <xref:System.Type.IsEnum%2A> properties.</span></span>  
  
 <span data-ttu-id="4ee8d-3644">Il <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> valore di enumerazione distingue una dichiarazione del tipo di classe o interfaccia. Tuttavia, entrambe le classi e tipi di valore sono contrassegnati con il <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> attributo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3644">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> attribute.</span></span> <span data-ttu-id="4ee8d-3645">Se si recupera il valore della proprietà di attributi e utilizzare un tipo di <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> valore per determinare se un tipo è una classe anziché un tipo di valore, è necessario chiamare anche il <xref:System.Type.IsValueType%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3645">If you retrieve the value of a type's Attributes property and use the <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> value to determine whether a type is a class instead of a value type, you must also call the <xref:System.Type.IsValueType%2A> property.</span></span> <span data-ttu-id="4ee8d-3646">L'esempio per il <xref:System.Reflection.TypeAttributes> enumerazione contiene informazioni aggiuntive, nonché anexample.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3646">The example for the <xref:System.Reflection.TypeAttributes> enumeration contains additional information as well as anexample.</span></span>  
  
 <span data-ttu-id="4ee8d-3647">Questa proprietà è di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3647">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3648">Nell'esempio seguente crea un'istanza di un tipo e indica se il tipo è una classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3648">The following example creates an instance of a type and indicates whether the type is a class.</span></span>  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3649">Ottiene un valore che indica se <see cref="T:System.Type" /> è un oggetto COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3649">Gets a value indicating whether the <see cref="T:System.Type" /> is a COM object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3650">
            <see langword="true" /> se <see cref="T:System.Type" /> è un oggetto COM; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3650">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3651">Questo metodo restituisce `false` per interfacce COM, perché non sono oggetti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3651">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="4ee8d-3652">Interfacce COM possono essere implementate da oggetti Microsoft .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3652">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 <span data-ttu-id="4ee8d-3653">È anche possibile caricare una classe COM e ottenere un `Type` oggetto per la classe COM usando il [Tlbimp.exe (tipo di libreria utilità di importazione)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) dello strumento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3653">You can also load a COM class and get a `Type` object for that COM class by using the [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool.</span></span>  
  
 <span data-ttu-id="4ee8d-3654">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione del tipo generico da cui è stato costruito il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3654">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="4ee8d-3655">Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int`> (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato dalla `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3655">For example, if the current <xref:System.Type> represents `MyGenericType<int`> (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="4ee8d-3656">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3656">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3657">Quando ne viene eseguito l'override in una classe derivata, implementa la proprietà <see cref="P:System.Type.IsCOMObject" /> e determina se <see cref="T:System.Type" /> è un oggetto COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3657">When overridden in a derived class, implements the <see cref="P:System.Type.IsCOMObject" /> property and determines whether the <see cref="T:System.Type" /> is a COM object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3658">
            <see langword="true" /> se <see cref="T:System.Type" /> è un oggetto COM; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3658">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3659">Questo metodo restituisce `false` per interfacce COM, perché non sono oggetti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3659">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="4ee8d-3660">Interfacce COM possono essere implementate da oggetti Microsoft .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3660">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3661">Ottiene un valore che indica se l'oggetto rappresenta un tipo generico costruito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3661">Gets a value that indicates whether this object represents a constructed generic type.</span>
          </span>
          <span data-ttu-id="4ee8d-3662">È possibile creare istanze di un tipo generico costruito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3662">You can create instances of a constructed generic type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3663">
            <see langword="true" /> se questo oggetto rappresenta una definizione di tipo generico; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3663">
              <see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3664">Un tipo generico costruito è stati forniti per tutti i relativi parametri di tipo generico di tipi espliciti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3664">A constructed generic type has had explicit types supplied for all of its generic type parameters.</span></span> <span data-ttu-id="4ee8d-3665">Si è detta anche un tipo generico chiuso.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3665">It is also referred to as a closed generic type.</span></span>  
  
 <span data-ttu-id="4ee8d-3666">Quando questa proprietà è impostata `true`, è possibile creare istanze del tipo corrente; quando è `false`, non è possibile.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3666">When this property is `true`, you can create instances of the current type; when it is `false`, you can't.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3667">Ottiene un valore che indica se è possibile includere <see cref="T:System.Type" /> in un contesto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3667">Gets a value indicating whether the <see cref="T:System.Type" /> can be hosted in a context.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3668">
            <see langword="true" /> se <see cref="T:System.Type" /> può essere contenuto in un contesto; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3668">
              <see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3669">Un contesto intercetta le chiamate ai membri della classe e impone i criteri vengono applicati alla classe, ad esempio la sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3669">A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization.</span></span> <span data-ttu-id="4ee8d-3670">Per altre informazioni sui contesti remoti, vedere <xref:System.Runtime.Remoting.Contexts.Context>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3670">For more detailed information on remoting contexts, see <xref:System.Runtime.Remoting.Contexts.Context>.</span></span>  
  
 <span data-ttu-id="4ee8d-3671">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3671">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3672">Nell'esempio seguente viene illustrato il `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, e <xref:System.Type.IsPrimitive%2A> delle proprietà del <xref:System.Type> classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3672">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="4ee8d-3673">Controlla se il tipo specificato può essere contenuto nel contesto, se può essere sottoposta a marshalling per riferimento e, se il tipo è un tipo di dati primitivi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3673">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3674">Implementa la proprietà <see cref="P:System.Type.IsContextful" /> e determina se <see cref="T:System.Type" /> può essere contenuto in un contesto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3674">Implements the <see cref="P:System.Type.IsContextful" /> property and determines whether the <see cref="T:System.Type" /> can be hosted in a context.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3675">
            <see langword="true" /> se <see cref="T:System.Type" /> può essere contenuto in un contesto; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3675">
              <see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3676">Questo metodo può essere sostituito da una classe derivata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3676">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="4ee8d-3677">Un contesto intercetta le chiamate ai membri della classe e applicare criteri che vengono applicati alla classe, ad esempio la sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3677">A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3678">L'esempio seguente illustra un uso di `IsContextfulImpl` (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3678">The following example demonstrates a use of the `IsContextfulImpl` method.</span></span>  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3679">Ottiene un valore che indica se l'oggetto <see cref="T:System.Type" /> è un'enumerazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3679">Gets a value indicating whether the current <see cref="T:System.Type" /> represents an enumeration.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3680">
            <see langword="true" /> se l'oggetto <see cref="T:System.Type" /> corrente è un'enumerazione; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3680">
              <see langword="true" /> if the current <see cref="T:System.Type" /> represents an enumeration; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3681">Questa proprietà restituisce `true` per un'enumerazione, ma non per il <xref:System.Enum> tipo stesso.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3681">This property returns `true` for an enumeration, but not for the <xref:System.Enum> type itself.</span></span>  
  
 <span data-ttu-id="4ee8d-3682">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione del tipo generico da cui è stato costruito il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3682">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="4ee8d-3683">Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato dalla `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3683">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="4ee8d-3684">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3684">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="4ee8d-3685">Questa proprietà è di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3685">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3686">Nell'esempio seguente viene illustrato come utilizzare il `IsEnum` proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3686">The following example demonstrates how to use the `IsEnum` property.</span></span>  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="4ee8d-3687">Valore da verificare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3687">The value to be tested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-3688">Restituisce un valore che indica se il valore specificato esiste nel tipo di enumerazione corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3688">Returns a value that indicates whether the specified value exists in the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3689">
            <see langword="true" /> se il valore specificato è un membro del tipo di enumerazione corrente; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3689">
              <see langword="true" /> if the specified value is a member of the current enumeration type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-3690">Il tipo corrente non è un'enumerazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3690">The current type is not an enumeration.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-3691">
            <paramref name="value" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3691">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4ee8d-3692">Il tipo di <paramref name="value" /> non può essere il tipo sottostante di un'enumerazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3692">
              <paramref name="value" /> is of a type that cannot be the underlying type of an enumeration.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="4ee8d-3693">Tipo COM di cui si verifica l'equivalenza con il tipo corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3693">The COM type that is tested for equivalence with the current type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-3694">Determina se due tipi COM presentano la stessa identità e sono idonei per l'equivalenza di tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3694">Determines whether two COM types have the same identity and are eligible for type equivalence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3695">
            <see langword="true" /> se i tipi COM sono equivalenti; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3695">
              <see langword="true" /> if the COM types are equivalent; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="4ee8d-3696">Questo metodo restituisce <see langword="false" /> anche se un tipo si trova in un assembly caricato per l'esecuzione e l'altro si trova in un assembly caricato nel contesto ReflectionOnly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3696">This method also returns <see langword="false" /> if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3697">A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], common language runtime supporta l'incorporamento di informazioni sui tipi COM direttamente negli assembly gestiti, anziché richiedere agli assembly gestiti ottenere informazioni sui tipi COM dall'interoperabilità assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3697">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies.</span></span> <span data-ttu-id="4ee8d-3698">Dato che le informazioni sui tipi incorporate includono solo i tipi e membri che vengono effettivamente usati da un assembly gestito, due assembly gestiti potrebbero avere viste diverse dello stesso tipo COM.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3698">Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type.</span></span> <span data-ttu-id="4ee8d-3699">Ogni assembly gestito a un oggetto <xref:System.Type> diverso per rappresentare la vista specifica del tipo COM.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3699">Each managed assembly has a different <xref:System.Type> object to represent its view of the COM type.</span></span> <span data-ttu-id="4ee8d-3700">Common Language Runtime supporta l'equivalenza del tipo tra queste viste diverse per interfacce, strutture, enumerazioni e delegati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3700">The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.</span></span>  
  
 <span data-ttu-id="4ee8d-3701">Equivalenza del tipo significa che è possibile eseguire il cast di un oggetto COM passato da un assembly gestito a un altro sul tipo gestito appropriato nell'assembly ricevente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3701">Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly.</span></span> <span data-ttu-id="4ee8d-3702">Il <xref:System.Type.IsEquivalentTo%2A> metodo consente a un assembly determinare che un oggetto COM ottenuto da un altro assembly ha la stessa identità COM come uno dei tipi di interoperabilità prima dell'assembly personalizzati incorporati e pertanto può essere convertito in quel tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3702">The <xref:System.Type.IsEquivalentTo%2A> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.</span></span>  
  
 <span data-ttu-id="4ee8d-3703">Per altre informazioni, vedere [equivalenza dei tipi e i tipi di interoperabilità incorporati](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3703">For more information, see [Type Equivalence and Embedded Interop Types](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3704">Ottiene un valore che indica se i campi del tipo corrente sono disposti a offset specificati in modo esplicito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3704">Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3705">
            <see langword="true" /> se la proprietà <see cref="P:System.Type.Attributes" /> del tipo corrente include <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3705">
              <see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3706">Questa proprietà viene fornita per praticità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3706">This property is provided as a convenience.</span></span> <span data-ttu-id="4ee8d-3707">In alternativa, è possibile usare la <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valore di enumerazione per selezionare gli attributi di layout di tipo e quindi testare se <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> è impostata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3707">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="4ee8d-3708">Il <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, e <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valori dell'enumerazione indicano il modo in cui i campi del tipo vengono disposti nella memoria.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3708">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="4ee8d-3709">Per i tipi dinamici, è possibile specificare <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> quando si crea il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3709">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="4ee8d-3710">Nel codice, si applicano i <xref:System.Runtime.InteropServices.StructLayoutAttribute> dell'attributo con il <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> valore di enumerazione al tipo, per specificare che gli offset in corrispondenza del quale avviare i campi vengono specificati in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3710">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-3711">Non è possibile usare la <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metodo per determinare se il <xref:System.Runtime.InteropServices.StructLayoutAttribute> viene applicato a un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3711">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="4ee8d-3712">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione del tipo generico da cui è stato costruito il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3712">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="4ee8d-3713">Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato dalla `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3713">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="4ee8d-3714">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3714">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3715">Nell'esempio seguente crea un'istanza di un tipo e visualizza il valore della relativa <xref:System.Type.IsExplicitLayout%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3715">The following example creates an instance of a type and displays the value of its <xref:System.Type.IsExplicitLayout%2A> property.</span></span> <span data-ttu-id="4ee8d-3716">Usa il `MySystemTime` (classe), che è anche nell'esempio di codice per <xref:System.Runtime.InteropServices.StructLayoutAttribute>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3716">It uses the `MySystemTime` class, which is also in the code example for <xref:System.Runtime.InteropServices.StructLayoutAttribute>.</span></span>  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">
          <span data-ttu-id="4ee8d-3717">Metadati e componenti auto-descrittivi</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3717">Metadata and Self-Describing Components</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3718">Ottiene un valore che indica se l'oggetto <see cref="T:System.Type" /> corrente rappresenta un parametro di tipo nella definizione di un tipo o metodo generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3718">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3719">
            <see langword="true" /> se l'oggetto <see cref="T:System.Type" /> rappresenta un parametro di tipo di una definizione di tipo o metodo generico. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3719">
              <see langword="true" /> if the <see cref="T:System.Type" /> object represents a type parameter of a generic type definition or generic method definition; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3720"><xref:System.Type> gli oggetti che rappresentano i parametri di tipo generico possono essere ottenuti chiamando il <xref:System.Type.GetGenericArguments%2A> metodo di un <xref:System.Type> che rappresenta una definizione di tipo generico, o il <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> metodo di un <xref:System.Reflection.MethodInfo> oggetto che rappresenta un metodo generico definizione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3720"><xref:System.Type> objects that represent generic type parameters can be obtained by calling the <xref:System.Type.GetGenericArguments%2A> method of a <xref:System.Type> object that represents a generic type definition, or the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> method of a <xref:System.Reflection.MethodInfo> object that represents a generic method definition.</span></span>  
  
-   <span data-ttu-id="4ee8d-3721">Per un tipo generico o una definizione di metodo, il <xref:System.Type.IsGenericParameter%2A> restituisce proprietà `true` per ogni elemento della matrice risultante.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3721">For a generic type or method definition, the <xref:System.Type.IsGenericParameter%2A> property returns `true` for every element of the resulting array.</span></span>  
  
-   <span data-ttu-id="4ee8d-3722">Per un tipo costruito chiuso o un metodo, il <xref:System.Type.IsGenericParameter%2A> proprietà restituisce `false` per ogni elemento della matrice restituita dal <xref:System.Type.GetGenericArguments%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3722">For a closed constructed type or method, the <xref:System.Type.IsGenericParameter%2A> property returns `false` for every element of the array returned by the <xref:System.Type.GetGenericArguments%2A> method.</span></span>  
  
-   <span data-ttu-id="4ee8d-3723">Per un metodo o un tipo costruito aperto, alcuni elementi della matrice potrebbero essere tipi specifici e altre possono essere parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3723">For an open constructed type or method, some elements of the array might be specific types and others might be type parameters.</span></span> <span data-ttu-id="4ee8d-3724"><xref:System.Type.IsGenericParameter%2A> Restituisce `false` per i tipi e `true` per i parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3724"><xref:System.Type.IsGenericParameter%2A> returns `false` for the types and `true` for the type parameters.</span></span> <span data-ttu-id="4ee8d-3725">L'esempio di codice per il <xref:System.Type.ContainsGenericParameters%2A> proprietà illustra una classe generica con una combinazione di tipi e i parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3725">The code example for the <xref:System.Type.ContainsGenericParameters%2A> property demonstrates a generic class with a mixture of types and type parameters.</span></span>  
  
 <span data-ttu-id="4ee8d-3726">Per un elenco delle condizioni invariabili relative ai termini usati dal processo di reflection generico, vedere i commenti sulla proprietà <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3726">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3727">L'esempio seguente usa il <xref:System.Type.IsGenericParameter%2A> proprietà da verificare per i parametri di tipo generico in un tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3727">The following example uses the <xref:System.Type.IsGenericParameter%2A> property to test for generic type parameters in a generic type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="4ee8d-3728">Reflection e tipi generici</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3728">Reflection and Generic Types</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="4ee8d-3729">Procedura: esaminare e creare istanze di tipi generici tramite reflection</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3729">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3730">Ottiene un valore che indica se il tipo corrente è un tipo generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3730">Gets a value indicating whether the current type is a generic type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3731">
            <see langword="true" /> Se il tipo corrente è un tipo generico. in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3731">
              <see langword="true" /> if the current type is a generic type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3732">Usare la <xref:System.Type.IsGenericType%2A> proprietà per determinare se un <xref:System.Type> oggetto rappresenta un tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3732">Use the <xref:System.Type.IsGenericType%2A> property to determine whether a <xref:System.Type> object represents a generic type.</span></span> <span data-ttu-id="4ee8d-3733">Usare la <xref:System.Type.ContainsGenericParameters%2A> proprietà per determinare se un <xref:System.Type> oggetto rappresenta un tipo costruito aperto o un tipo costruito chiuso.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3733">Use the <xref:System.Type.ContainsGenericParameters%2A> property to determine whether a <xref:System.Type> object represents an open constructed type or a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-3734">Il <xref:System.Type.IsGenericType%2A> restituisce proprietà `false` se il tipo di controllo immediato non è generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3734">The <xref:System.Type.IsGenericType%2A> property returns `false` if the immediate type is not generic.</span></span> <span data-ttu-id="4ee8d-3735">Ad esempio, una matrice il cui elementi sono di tipo `A<int>` (`A(Of Integer)` in Visual Basic) non è un tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3735">For example, an array whose elements are of type `A<int>` (`A(Of Integer)` in Visual Basic) is not itself a generic type.</span></span>  
  
 <span data-ttu-id="4ee8d-3736">Nella tabella seguente vengono riepilogate le condizioni invariabili relative ai termini comuni usati nel processo di reflection generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3736">The following table summarizes the invariant conditions for common terms used in generic reflection.</span></span>  
  
|<span data-ttu-id="4ee8d-3737">Termine</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3737">Term</span></span>|<span data-ttu-id="4ee8d-3738">Invariante</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3738">Invariant</span></span>|  
|----------|---------------|  
|<span data-ttu-id="4ee8d-3739">definizione di tipo generico</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3739">generic type definition</span></span>|<span data-ttu-id="4ee8d-3740">La proprietà <xref:System.Type.IsGenericTypeDefinition%2A> è `true`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3740">The <xref:System.Type.IsGenericTypeDefinition%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="4ee8d-3741">Definisce un tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3741">Defines a generic type.</span></span> <span data-ttu-id="4ee8d-3742">Viene creato un tipo costruito chiamando il <xref:System.Type.MakeGenericType%2A> metodo su un <xref:System.Type> dell'oggetto che rappresenta una definizione di tipo generico e si specifica una matrice di argomenti di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3742">A constructed type is created by calling the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object that represents a generic type definition and specifying an array of type arguments.</span></span><br /><br /> <span data-ttu-id="4ee8d-3743"><xref:System.Type.MakeGenericType%2A> può essere chiamato solo su definizioni di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3743"><xref:System.Type.MakeGenericType%2A> can be called only on generic type definitions.</span></span><br /><br /> <span data-ttu-id="4ee8d-3744">Qualsiasi definizione di tipo generico è un tipo generico (il <xref:System.Type.IsGenericType%2A> è di proprietà `true`), ma non è vero il contrario.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3744">Any generic type definition is a generic type (the <xref:System.Type.IsGenericType%2A> property is `true`), but the converse is not true.</span></span>|  
|<span data-ttu-id="4ee8d-3745">tipo generico</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3745">generic type</span></span>|<span data-ttu-id="4ee8d-3746">La proprietà <xref:System.Type.IsGenericType%2A> è `true`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3746">The <xref:System.Type.IsGenericType%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="4ee8d-3747">Può essere una definizione di tipo generico, un tipo costruito aperto o un tipo costruito chiuso.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3747">Can be a generic type definition, an open constructed type, or a closed constructed type.</span></span><br /><br /> <span data-ttu-id="4ee8d-3748">Si noti che una matrice di tipo il cui tipo di elemento sono di tipo generico non è un tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3748">Note that an array type whose element type is generic is not itself a generic type.</span></span> <span data-ttu-id="4ee8d-3749">Lo stesso vale per un <xref:System.Type> oggetto che rappresenta un puntatore a un tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3749">The same is true of a <xref:System.Type> object representing a pointer to a generic type.</span></span>|  
|<span data-ttu-id="4ee8d-3750">tipo costruito aperto</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3750">open constructed type</span></span>|<span data-ttu-id="4ee8d-3751">La proprietà <xref:System.Type.ContainsGenericParameters%2A> è `true`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3751">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="4ee8d-3752">Gli esempi sono un tipo generico non assegnati parametri di tipo, un tipo annidato in una definizione di tipo generico o in un tipo costruito aperto o un tipo generico che ha un argomento di tipo per cui il <xref:System.Type.ContainsGenericParameters%2A> è di proprietà `true`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3752">Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="4ee8d-3753">Non è possibile creare un'istanza di un tipo costruito aperto.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3753">It is not possible to create an instance of an open constructed type.</span></span><br /><br /> <span data-ttu-id="4ee8d-3754">Si noti che i tipi costruiti aperti non tutti sono generici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3754">Note that not all open constructed types are generic.</span></span> <span data-ttu-id="4ee8d-3755">Ad esempio, una matrice il cui tipo di elemento è una definizione di tipo generico non è generica e un puntatore a un tipo costruito aperto non è generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3755">For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.</span></span>|  
|<span data-ttu-id="4ee8d-3756">tipo costruito chiuso</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3756">closed constructed type</span></span>|<span data-ttu-id="4ee8d-3757">La proprietà <xref:System.Type.ContainsGenericParameters%2A> è `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3757">The <xref:System.Type.ContainsGenericParameters%2A> property is `false`.</span></span><br /><br /> <span data-ttu-id="4ee8d-3758">Quando viene esaminato in modo ricorsivo, il tipo non dispone di alcun parametro generico non assegnati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3758">When examined recursively, the type has no unassigned generic parameters.</span></span>|  
|<span data-ttu-id="4ee8d-3759">parametro di tipo generico</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3759">generic type parameter</span></span>|<span data-ttu-id="4ee8d-3760">La proprietà <xref:System.Type.IsGenericParameter%2A> è `true`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3760">The <xref:System.Type.IsGenericParameter%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="4ee8d-3761">La proprietà <xref:System.Type.ContainsGenericParameters%2A> è `true`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3761">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="4ee8d-3762">In una definizione di tipo generico, un segnaposto per un tipo che verrà assegnato in un secondo momento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3762">In a generic type definition, a placeholder for a type that will be assigned later.</span></span>|  
|<span data-ttu-id="4ee8d-3763">argomento di tipo generico</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3763">generic type argument</span></span>|<span data-ttu-id="4ee8d-3764">Può essere qualsiasi tipo, incluso un parametro di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3764">Can be any type, including a generic type parameter.</span></span><br /><br /> <span data-ttu-id="4ee8d-3765">Gli argomenti di tipo vengono specificati come una matrice di <xref:System.Type> gli oggetti passati al <xref:System.Type.MakeGenericType%2A> metodo durante la creazione di un tipo generico costruito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3765">Type arguments are specified as an array of <xref:System.Type> objects passed to the <xref:System.Type.MakeGenericType%2A> method when creating a constructed generic type.</span></span> <span data-ttu-id="4ee8d-3766">Se vengono create, le istanze del tipo risultante il <xref:System.Type.ContainsGenericParameters%2A> deve essere proprietà `false` per tutti gli argomenti tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3766">If instances of the resulting type are to be created, the <xref:System.Type.ContainsGenericParameters%2A> property must be `false` for all the type arguments.</span></span>|  
  
 <span data-ttu-id="4ee8d-3767">L'esempio di codice e la tabella seguenti illustrano alcune delle presenti condizioni invarianti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3767">The following code example and table illustrate some of these terms and invariants.</span></span> <span data-ttu-id="4ee8d-3768">Il `Derived` classe è di particolare interesse, perché il tipo di base è un tipo costruito con una combinazione di tipi e i parametri di tipo nel relativo elenco di argomenti tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3768">The `Derived` class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 <span data-ttu-id="4ee8d-3769">Nella tabella seguente vengono illustrati esempi che usano e di compilazione per le classi `Base`, `Derived`, e `G`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3769">The following table shows examples that use and build on the classes `Base`, `Derived`, and `G`.</span></span> <span data-ttu-id="4ee8d-3770">Quando il codice C++ e c# è lo stesso, solo una voce viene visualizzata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3770">When the C++ and C# code is the same, only one entry is shown.</span></span>  
  
|<span data-ttu-id="4ee8d-3771">Esempio</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3771">Example</span></span>|<span data-ttu-id="4ee8d-3772">Invarianti</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3772">Invariants</span></span>|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|<span data-ttu-id="4ee8d-3773">Per questo tipo:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3773">For this type:</span></span><br /><br /> <span data-ttu-id="4ee8d-3774"><xref:System.Type.IsGenericType%2A> è `true`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3774"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="4ee8d-3775"><xref:System.Type.IsGenericTypeDefinition%2A> è `true`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3775"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="4ee8d-3776"><xref:System.Type.ContainsGenericParameters%2A> è `true`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3776"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|<span data-ttu-id="4ee8d-3777">Per questo tipo:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3777">For this type:</span></span><br /><br /> <span data-ttu-id="4ee8d-3778"><xref:System.Type.IsGenericType%2A> è `true`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3778"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="4ee8d-3779"><xref:System.Type.IsGenericTypeDefinition%2A> è `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3779"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="4ee8d-3780"><xref:System.Type.ContainsGenericParameters%2A> è `true`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3780"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|<span data-ttu-id="4ee8d-3781">Per il tipo di variabile `d`:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3781">For the type of variable `d`:</span></span><br /><br /> <span data-ttu-id="4ee8d-3782"><xref:System.Type.IsGenericType%2A> viene `false` perché `d` è una matrice.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3782"><xref:System.Type.IsGenericType%2A> is `false` because `d` is an array.</span></span><br /><br /> <span data-ttu-id="4ee8d-3783"><xref:System.Type.IsGenericTypeDefinition%2A> è `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3783"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="4ee8d-3784"><xref:System.Type.ContainsGenericParameters%2A> è `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3784"><xref:System.Type.ContainsGenericParameters%2A> is `false`.</span></span>|  
|<span data-ttu-id="4ee8d-3785">`T`, `U`, e `V` (ovunque visualizzati)</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3785">`T`, `U`, and `V` (everywhere they appear)</span></span>|<span data-ttu-id="4ee8d-3786"><xref:System.Type.IsGenericParameter%2A> è `true`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3786"><xref:System.Type.IsGenericParameter%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="4ee8d-3787"><xref:System.Type.IsGenericType%2A> è `false` perché non è possibile vincolare un parametro di tipo per tipi generici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3787"><xref:System.Type.IsGenericType%2A> is `false` because there is no way to constrain a type parameter to generic types.</span></span><br /><br /> <span data-ttu-id="4ee8d-3788"><xref:System.Type.IsGenericTypeDefinition%2A> è `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3788"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="4ee8d-3789"><xref:System.Type.ContainsGenericParameters%2A> viene `true` poiché `T`, `U`, e `V` stessi sono parametri di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3789"><xref:System.Type.ContainsGenericParameters%2A> is `true` because `T`, `U`, and `V` are themselves generic type parameters.</span></span> <span data-ttu-id="4ee8d-3790">Ciò non implica alcuna operazione sugli argomenti di tipo che a loro assegnati in un secondo momento.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3790">This does not imply anything about type arguments that are assigned to them later.</span></span>|  
|<span data-ttu-id="4ee8d-3791">Il tipo di campo `F`</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3791">The type of field `F`</span></span>|<span data-ttu-id="4ee8d-3792"><xref:System.Type.IsGenericType%2A> è `true`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3792"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="4ee8d-3793"><xref:System.Type.IsGenericTypeDefinition%2A> viene `false` perché è stato assegnato un tipo per il parametro di tipo `G`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3793"><xref:System.Type.IsGenericTypeDefinition%2A> is `false` because a type has been assigned to the type parameter of `G`.</span></span> <span data-ttu-id="4ee8d-3794">Si noti che ciò equivale alla chiamata di <xref:System.Type.MakeGenericType%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3794">Note that this is equivalent to having called the <xref:System.Type.MakeGenericType%2A> method.</span></span><br /><br /> <span data-ttu-id="4ee8d-3795"><xref:System.Type.ContainsGenericParameters%2A> viene `true` perché il tipo di campo `F` contiene un argomento di tipo che è un tipo costruito aperto.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3795"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the type of field `F` has a type argument that is an open constructed type.</span></span> <span data-ttu-id="4ee8d-3796">Il tipo costruito è aperto perché il relativo argomento di tipo (vale a dire `Base`) è una definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3796">The constructed type is open because its type argument (that is, `Base`) is a generic type definition.</span></span> <span data-ttu-id="4ee8d-3797">L'esempio illustra la natura ricorsiva del <xref:System.Type.IsGenericType%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3797">This illustrates the recursive nature of the <xref:System.Type.IsGenericType%2A> property.</span></span>|  
|<span data-ttu-id="4ee8d-3798">La classe annidata `Nested`</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3798">The nested class `Nested`</span></span>|<span data-ttu-id="4ee8d-3799"><xref:System.Type.IsGenericType%2A> viene `true`, anche se il `Nested` classe non dispone di alcun parametro di tipo generico proprio, perché è annidata in un tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3799"><xref:System.Type.IsGenericType%2A> is `true`, even though the `Nested` class has no generic type parameters of its own, because it is nested in a generic type.</span></span><br /><br /> <span data-ttu-id="4ee8d-3800"><xref:System.Type.IsGenericTypeDefinition%2A> è `true`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3800"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span> <span data-ttu-id="4ee8d-3801">Vale a dire, è possibile chiamare il <xref:System.Type.MakeGenericType%2A> metodo e fornire il parametro di tipo del tipo di inclusione, `Derived`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3801">That is, you can call the <xref:System.Type.MakeGenericType%2A> method and supply the type parameter of the enclosing type, `Derived`.</span></span><br /><br /> <span data-ttu-id="4ee8d-3802"><xref:System.Type.ContainsGenericParameters%2A> viene `true` poiché il tipo contenitore, `Derived`, dispone di parametri di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3802"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the enclosing type, `Derived`, has generic type parameters.</span></span> <span data-ttu-id="4ee8d-3803">L'esempio illustra la natura ricorsiva del <xref:System.Type.ContainsGenericParameters%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3803">This illustrates the recursive nature of the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3804">Esempio di codice seguente consente di visualizzare il valore della <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, e <xref:System.Type.ContainsGenericParameters%2A> proprietà per i tipi descritti nella sezione Osservazioni.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3804">The following code example displays the value of the <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, and <xref:System.Type.ContainsGenericParameters%2A> properties for the types described in the Remarks section.</span></span> <span data-ttu-id="4ee8d-3805">Per informazioni sul significato dei valori di proprietà, vedere la tabella nella sezione Osservazioni.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3805">For explanations of the property values, see the accompanying table in Remarks.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="4ee8d-3806">Reflection e tipi generici</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3806">Reflection and Generic Types</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="4ee8d-3807">Procedura: esaminare e creare istanze di tipi generici tramite reflection</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3807">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3808">Ottiene un valore che indica se la classe <see cref="T:System.Type" /> corrente rappresenta una definizione di tipo generico, da cui è possibile costruire altri tipi generici.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3808">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a generic type definition, from which other generic types can be constructed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3809">
            <see langword="true" /> se l'oggetto <see cref="T:System.Type" /> rappresenta una definizione di tipo generico. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3809">
              <see langword="true" /> if the <see cref="T:System.Type" /> object represents a generic type definition; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3810">Una definizione di tipo generico è un modello da cui è possibile costruire altri tipi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3810">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="4ee8d-3811">Ad esempio, dalla definizione di tipo generico `G<T>` (espressi nella sintassi c#; `G(Of T)` in Visual Basic o `generic <typename T> ref class G` in C++) è possibile costruire e creare un'istanza di tipo `G<int>` (`G(Of Integer)` in Visual Basic), chiamando il <xref:System.Type.MakeGenericType%2A> metodo con un elenco di argomento generico che contiene il <xref:System.Int32> tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3811">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic), by calling the <xref:System.Type.MakeGenericType%2A> method with a generic argument list containing the <xref:System.Int32> type.</span></span> <span data-ttu-id="4ee8d-3812">Dato un <xref:System.Type> oggetto che rappresenta questo tipo, costruito il <xref:System.Type.GetGenericTypeDefinition%2A> metodo ottiene la definizione di tipo generico nuovamente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3812">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method gets the generic type definition back again.</span></span>  
  
 <span data-ttu-id="4ee8d-3813">Usare il <xref:System.Type.IsGenericTypeDefinition%2A> proprietà per determinare se è possibile creare nuovi tipi dal tipo corrente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3813">Use the <xref:System.Type.IsGenericTypeDefinition%2A> property to determine whether you can create new types from the current type.</span></span> <span data-ttu-id="4ee8d-3814">Se il <xref:System.Type.IsGenericTypeDefinition%2A> proprietà restituisce `true`, è possibile chiamare il <xref:System.Type.MakeGenericType%2A> metodo per creare nuovi tipi generici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3814">If the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `true`, you can call the <xref:System.Type.MakeGenericType%2A> method to create new generic types.</span></span>  
  
 <span data-ttu-id="4ee8d-3815">Per un elenco delle condizioni invariabili relative ai termini usati dal processo di reflection generico, vedere i commenti sulla proprietà <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3815">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3816">Nell'esempio seguente visualizza informazioni su un tipo, tra cui una definizione di tipo generico o meno.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3816">The following example displays information about a type, including whether or not it is a generic type definition.</span></span> <span data-ttu-id="4ee8d-3817">Vengono visualizzate informazioni per un tipo costruito, per la definizione di tipo generico e per un tipo ordinario.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3817">Information is displayed for a constructed type, for its generic type definition, and for an ordinary type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="4ee8d-3818">Reflection e tipi generici</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3818">Reflection and Generic Types</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="4ee8d-3819">Procedura: esaminare e creare istanze di tipi generici tramite reflection</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3819">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3820">Ottiene un valore che indica se <see cref="T:System.Type" /> dispone di un attributo <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> applicato, che ne indica l'importazione da una libreria di tipi COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3820">Gets a value indicating whether the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> attribute applied, indicating that it was imported from a COM type library.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3821">
            <see langword="true" /> se <see cref="T:System.Type" /> dispone di <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3821">
              <see langword="true" /> if the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3822">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione del tipo generico da cui è stato costruito il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3822">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="4ee8d-3823">Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato da `MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3823">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="4ee8d-3824">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3824">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="4ee8d-3825">Oggetto da confrontare con il tipo corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3825">The object to compare with the current type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-3826">Determina se l'oggetto specificato è un'istanza dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3826">Determines whether the specified object is an instance of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3827">
            <see langword="true" /> se l'oggetto <see langword="Type" /> corrente è incluso nella gerarchia di ereditarietà dell'oggetto rappresentato da <paramref name="o" /> oppure se l'oggetto <see langword="Type" /> corrente è un'interfaccia implementata da <paramref name="o" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3827">
              <see langword="true" /> if the current <see langword="Type" /> is in the inheritance hierarchy of the object represented by <paramref name="o" />, or if the current <see langword="Type" /> is an interface that <paramref name="o" /> implements.</span>
          </span>
          <span data-ttu-id="4ee8d-3828">
            <see langword="false" /> se non viene soddisfatta nessuna di queste condizioni, se <paramref name="o" /> è <see langword="null" /> oppure se l'oggetto <see langword="Type" /> corrente è un tipo generico aperto, ovvero la proprietà <see cref="P:System.Type.ContainsGenericParameters" /> restituisce <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3828">
              <see langword="false" /> if neither of these conditions is the case, if <paramref name="o" /> is <see langword="null" />, or if the current <see langword="Type" /> is an open generic type (that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3829">Questo metodo può essere sostituito da una classe derivata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3829">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-3830">Un tipo costruito non è un'istanza della relativa definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3830">A constructed type is not an instance of its generic type definition.</span></span> <span data-ttu-id="4ee8d-3831">Vale a dire `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) non è un'istanza di `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3831">That is, `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) is not an instance of `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3832">Nell'esempio seguente viene illustrato l'uso del metodo `IsInstanceOfType`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3832">The following example demonstrates the use of the `IsInstanceOfType` method.</span></span>  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3833">Ottiene un valore che indica se <see cref="T:System.Type" /> è un'interfaccia, ovvero non è una classe né un tipo di valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3833">Gets a value indicating whether the <see cref="T:System.Type" /> is an interface; that is, not a class or a value type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3834">
            <see langword="true" /> se <see cref="T:System.Type" /> è un'interfaccia; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3834">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an interface; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3835">Il <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distingue una dichiarazione di tipo come tipo di classe, interfaccia o valore.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3835">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distinguishes a type declaration as class, interface or value type.</span></span>  
  
 <span data-ttu-id="4ee8d-3836">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3836">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="4ee8d-3837">Questa proprietà è di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3837">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3838">Nell'esempio seguente crea un'interfaccia, controlla il tipo di interfaccia e indica se una classe dispone di `IsInterface` set di proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3838">The following example creates an interface, checks for the interface type, and indicates whether a class has the `IsInterface` property set.</span></span>  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3839">Ottiene un valore che indica se i campi del tipo corrente sono disposti in sequenza, nell'ordine in cui sono stati definiti o rilasciati ai metadati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3839">Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3840">
            <see langword="true" /> se la proprietà <see cref="P:System.Type.Attributes" /> del tipo corrente include <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3840">
              <see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3841">Questa proprietà viene fornita per praticità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3841">This property is provided as a convenience.</span></span> <span data-ttu-id="4ee8d-3842">In alternativa, è possibile usare la <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valore di enumerazione per selezionare gli attributi di layout di tipo e quindi testare se <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> è impostata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3842">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="4ee8d-3843">Il <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, e <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valori dell'enumerazione indicano il modo in cui i campi del tipo vengono disposti nella memoria.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3843">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="4ee8d-3844">Per i tipi dinamici, è possibile specificare <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> quando si crea il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3844">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="4ee8d-3845">Nel codice, si applicano i <xref:System.Runtime.InteropServices.StructLayoutAttribute> dell'attributo con il <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> valore di enumerazione al tipo, per specificare che il layout è sequenza.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3845">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value to the type, to specify that layout is sequential.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-3846">Non è possibile usare la <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> metodo per determinare se il <xref:System.Runtime.InteropServices.StructLayoutAttribute> viene applicato a un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3846">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="4ee8d-3847">Per altre informazioni, vedere la sezione 9.1.2 della specifica per la documentazione di Common Language Infrastructure (CLI), "Partition II: Metadata Definition and Semantics".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3847">For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="4ee8d-3848">La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3848">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="4ee8d-3849">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione del tipo generico da cui è stato costruito il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3849">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="4ee8d-3850">Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato dalla `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3850">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="4ee8d-3851">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3851">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3852">L'esempio seguente crea un'istanza di una classe per cui il <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> valore di enumerazione nel <xref:System.Runtime.InteropServices.StructLayoutAttribute> classe è stata impostata, verifica la presenza del <xref:System.Type.IsLayoutSequential%2A> proprietà e visualizza il risultato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3852">The following example creates an instance of a class for which the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value in the <xref:System.Runtime.InteropServices.StructLayoutAttribute> class has been set, checks for the <xref:System.Type.IsLayoutSequential%2A> property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">
          <span data-ttu-id="4ee8d-3853">Metadati e componenti auto-descrittivi</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3853">Metadata and Self-Describing Components</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3854">Ottiene un valore che indica se l'oggetto <see cref="T:System.Type" /> viene sottoposto a marshalling per riferimento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3854">Gets a value indicating whether the <see cref="T:System.Type" /> is marshaled by reference.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3855">
            <see langword="true" /> se <see cref="T:System.Type" /> viene sottoposto a marshalling per riferimento; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3855">
              <see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="4ee8d-3856">Nell'esempio seguente viene illustrato il `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, e <xref:System.Type.IsPrimitive%2A> delle proprietà del <xref:System.Type> classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3856">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="4ee8d-3857">Controlla se il tipo specificato può essere contenuto nel contesto, se può essere sottoposta a marshalling per riferimento e, se il tipo è un tipo di dati primitivi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3857">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3858">Implementa la proprietà <see cref="P:System.Type.IsMarshalByRef" /> e determina se l'oggetto <see cref="T:System.Type" /> viene sottoposto a marshalling per riferimento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3858">Implements the <see cref="P:System.Type.IsMarshalByRef" /> property and determines whether the <see cref="T:System.Type" /> is marshaled by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3859">
            <see langword="true" /> se <see cref="T:System.Type" /> viene sottoposto a marshalling per riferimento; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3859">
              <see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3860">Questo metodo può essere sostituito da una classe derivata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3860">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3861">Nell'esempio seguente determina se il tipo specificato viene sottoposto a marshalling per riferimento e viene visualizzato il risultato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3861">The following example determines whether the given type is marshaled by reference and displays the result.</span></span>  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3862">Ottiene un valore che indica se l'oggetto <see cref="T:System.Type" /> corrente rappresenta un tipo la cui definizione è annidata all'interno della definizione di un altro tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3862">Gets a value indicating whether the current <see cref="T:System.Type" /> object represents a type whose definition is nested inside the definition of another type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3863">
            <see langword="true" /> se l'oggetto <see cref="T:System.Type" /> è annidato all'interno di un altro tipo; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3863">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested inside another type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3864">Il <xref:System.Type.IsNested%2A> restituisce proprietà `true` per tutti i tipi annidati, indipendentemente dalla visibilità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3864">The <xref:System.Type.IsNested%2A> property returns `true` for all nested types, regardless of visibility.</span></span> <span data-ttu-id="4ee8d-3865">Per testare l'annidamento e la visibilità nello stesso momento, usare le proprietà correlate <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, o <xref:System.Type.IsNestedPublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3865">To test for nesting and visibility at the same time, use the related properties <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, or <xref:System.Type.IsNestedPublic%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-3866">Il <xref:System.Reflection.TypeAttributes.VisibilityMask> membro di enumerazione consente di selezionare gli attributi di visibilità per un tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3866">The <xref:System.Reflection.TypeAttributes.VisibilityMask> enumeration member selects the visibility attributes for a type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3867">L'esempio seguente crea una classe esterna con un numero di classi annidate che hanno tipi diversi di visibilità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3867">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="4ee8d-3868">Recupera quindi il valore di un numero di correlate alla visibilità <xref:System.Type> le proprietà per il tipo padre e ognuno dei relativi tipi annidati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3868">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3869">Ottiene un valore che indica se <see cref="T:System.Type" /> è annidato e visibile soltanto all'interno dell'assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3869">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3870">
            <see langword="true" /> se <see cref="T:System.Type" /> è annidato e visibile soltanto all'interno dell'assembly; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3870">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own assembly; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3871">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3871">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="4ee8d-3872"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Consente di selezionare gli attributi di visibilità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3872"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3873">L'esempio seguente crea una classe esterna con un numero di classi annidate che hanno tipi diversi di visibilità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3873">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="4ee8d-3874">Recupera quindi il valore di un numero di correlate alla visibilità <xref:System.Type> le proprietà per il tipo padre e ognuno dei relativi tipi annidati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3874">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3875">Ottiene un valore che indica se <see cref="T:System.Type" /> è annidato e visibile soltanto alle classi della stessa famiglia e dello stesso assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3875">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3876">
            <see langword="true" /> se <see cref="T:System.Type" /> è annidato e visibile soltanto alle classi della stessa famiglia e dello stesso assembly. In caso contrario <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3876">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3877">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3877">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="4ee8d-3878"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Consente di selezionare gli attributi di visibilità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3878"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-3879">I linguaggi c# e Visual Basic non includono la semantica che consentono di definire un tipo annidato che è visibile solo per i tipi protetti nel proprio assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3879">The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly.</span></span> <span data-ttu-id="4ee8d-3880">`protected internal` visibilità in c# e `Protected Friend` visibilità in Visual Basic definisce un tipo annidato che è visibile per i tipi protetti e per i tipi nello stesso assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3880">`protected internal` visibility in C# and `Protected Friend` visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.</span></span>  
  
 <span data-ttu-id="4ee8d-3881">Oggetto <xref:System.Type> famiglia dell'oggetto è definita come tutti gli oggetti dello stesso <xref:System.Type> e dei relativi sottotipi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3881">A <xref:System.Type> object's family is defined as all objects of the same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3882">L'esempio seguente crea una classe esterna con un numero di classi annidate che hanno tipi diversi di visibilità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3882">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="4ee8d-3883">Recupera quindi il valore di un numero di correlate alla visibilità <xref:System.Type> le proprietà per il tipo padre e ognuno dei relativi tipi annidati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3883">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3884">Ottiene un valore che indica se <see cref="T:System.Type" /> è annidato e visibile solo all'interno della famiglia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3884">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own family.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3885">
            <see langword="true" /> se <see cref="T:System.Type" /> è annidato e visibile solo all'interno della famiglia; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3885">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own family; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3886">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3886">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="4ee8d-3887"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Consente di selezionare gli attributi di visibilità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3887"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="4ee8d-3888">Oggetto <xref:System.Type> famiglia dell'oggetto è definita come tutti gli oggetti di uno stesso <xref:System.Type> e dei relativi sottotipi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3888">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3889">L'esempio seguente crea una classe esterna con un numero di classi annidate che hanno tipi diversi di visibilità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3889">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="4ee8d-3890">Recupera quindi il valore di un numero di correlate alla visibilità <xref:System.Type> le proprietà per il tipo padre e ognuno dei relativi tipi annidati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3890">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3891">Ottiene un valore che indica se <see cref="T:System.Type" /> è annidato e visibile solo alle classi della stessa famiglia o dello stesso assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3891">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to either its own family or to its own assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3892">
            <see langword="true" /> se <see cref="T:System.Type" /> è annidato e visibile solo alle classi della stessa famiglia o dello stesso assembly; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3892">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3893">Se la visibilità di un tipo è `protected internal` in c# o `Protected Friend` in Visual Basic, il <xref:System.Type.IsNestedFamORAssem%2A> restituisce proprietà `true`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3893">If the visibility of a type is `protected internal` in C# or `Protected Friend` in Visual Basic, the <xref:System.Type.IsNestedFamORAssem%2A> property returns `true`.</span></span>  
  
 <span data-ttu-id="4ee8d-3894">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3894">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="4ee8d-3895"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Consente di selezionare gli attributi di visibilità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3895"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="4ee8d-3896">Oggetto <xref:System.Type> famiglia dell'oggetto è definita come tutti gli oggetti di uno stesso <xref:System.Type> e dei relativi sottotipi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3896">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3897">L'esempio seguente crea una classe esterna con un numero di classi annidate che hanno tipi diversi di visibilità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3897">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="4ee8d-3898">Recupera quindi il valore di un numero di correlate alla visibilità <xref:System.Type> le proprietà per il tipo padre e ognuno dei relativi tipi annidati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3898">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3899">Ottiene un valore che indica se <see cref="T:System.Type" /> è annidato e dichiarato privato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3899">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and declared private.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3900">
            <see langword="true" /> se <see cref="T:System.Type" /> è annidato e dichiarato privato; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3900">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and declared private; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3901">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3901">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="4ee8d-3902"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Consente di selezionare gli attributi di visibilità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3902"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3903">L'esempio seguente crea una classe esterna con un numero di classi annidate che hanno tipi diversi di visibilità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3903">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="4ee8d-3904">Recupera quindi il valore di un numero di correlate alla visibilità <xref:System.Type> le proprietà per il tipo padre e ognuno dei relativi tipi annidati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3904">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3905">Ottiene un valore che indica se una classe è annidata e dichiarata pubblica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3905">Gets a value indicating whether a class is nested and declared public.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3906">
            <see langword="true" /> se la classe è annidata e dichiarata pubblica. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3906">
              <see langword="true" /> if the class is nested and declared public; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3907">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3907">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="4ee8d-3908"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Consente di selezionare gli attributi di visibilità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3908"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3909">L'esempio seguente crea una classe esterna con un numero di classi annidate che hanno tipi diversi di visibilità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3909">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="4ee8d-3910">Recupera quindi il valore di un numero di correlate alla visibilità <xref:System.Type> le proprietà per il tipo padre e ognuno dei relativi tipi annidati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3910">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3911">Ottiene un valore che indica se l'oggetto <see cref="T:System.Type" /> non è dichiarato pubblico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3911">Gets a value indicating whether the <see cref="T:System.Type" /> is not declared public.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3912">
            <see langword="true" /> se l'oggetto <see cref="T:System.Type" /> non è dichiarato pubblico e non è un tipo annidato; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3912">
              <see langword="true" /> if the <see cref="T:System.Type" /> is not declared public and is not a nested type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3913">Non usare questa proprietà con i tipi annidati; usare il <xref:System.Type.IsNestedPublic%2A> proprietà invece.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3913">Do not use this property with nested types; use the <xref:System.Type.IsNestedPublic%2A> property instead.</span></span>  
  
 <span data-ttu-id="4ee8d-3914">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3914">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3915">Usa questo esempio `IsNotPublic` proprietà da ottenere la visibilità del tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3915">This example usesthe `IsNotPublic` property to get the visibility of the type.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 <span data-ttu-id="4ee8d-3916">Esempio di codice seguente viene illustrato il motivo per cui non è possibile usare `IsPublic` e `IsNotPublic` per le classi annidate.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3916">The following code example demonstrates why you cannot use `IsPublic` and `IsNotPublic` for nested classes.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 <span data-ttu-id="4ee8d-3917">Per le classi annidate, ignorare i risultati della `IsPublic` e `IsNotPublic` e tenere in considerazione solo i risultati del `IsNestedPublic` e `IsNestedPrivate`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3917">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of `IsNestedPublic` and `IsNestedPrivate`.</span></span> <span data-ttu-id="4ee8d-3918">L'output di reflection per questo frammento di codice sarà come segue:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3918">The reflection output for this code fragment would be as follows:</span></span>  
  
|<span data-ttu-id="4ee8d-3919">Classe</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3919">Class</span></span>|<span data-ttu-id="4ee8d-3920">IsNotPublic</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3920">IsNotPublic</span></span>|<span data-ttu-id="4ee8d-3921">IsPublic</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3921">IsPublic</span></span>|<span data-ttu-id="4ee8d-3922">IsNestedPublic</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3922">IsNestedPublic</span></span>|<span data-ttu-id="4ee8d-3923">IsNestedPrivate</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3923">IsNestedPrivate</span></span>|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|<span data-ttu-id="4ee8d-3924">A</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3924">A</span></span>|<span data-ttu-id="4ee8d-3925">false</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3925">FALSE</span></span>|<span data-ttu-id="4ee8d-3926">true</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3926">TRUE</span></span>|<span data-ttu-id="4ee8d-3927">false</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3927">FALSE</span></span>|<span data-ttu-id="4ee8d-3928">false</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3928">FALSE</span></span>|  
|<span data-ttu-id="4ee8d-3929">B</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3929">B</span></span>|<span data-ttu-id="4ee8d-3930">false</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3930">FALSE</span></span>|<span data-ttu-id="4ee8d-3931">false</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3931">FALSE</span></span>|<span data-ttu-id="4ee8d-3932">true</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3932">TRUE</span></span>|<span data-ttu-id="4ee8d-3933">false</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3933">FALSE</span></span>|  
|<span data-ttu-id="4ee8d-3934">C</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3934">C</span></span>|<span data-ttu-id="4ee8d-3935">false</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3935">FALSE</span></span>|<span data-ttu-id="4ee8d-3936">false</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3936">FALSE</span></span>|<span data-ttu-id="4ee8d-3937">false</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3937">FALSE</span></span>|<span data-ttu-id="4ee8d-3938">true</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3938">TRUE</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3939">Ottiene un valore che indica se <see cref="T:System.Type" /> è un puntatore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3939">Gets a value indicating whether the <see cref="T:System.Type" /> is a pointer.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3940">
            <see langword="true" /> se <see cref="T:System.Type" /> è un puntatore. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3940">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3941">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico o un parametro di tipo nella definizione di un tipo o metodo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3941">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="4ee8d-3942">Questa proprietà è di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3942">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3943">L'esempio seguente illustra un uso di `IsPointer` proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3943">The following example shows a use of the `IsPointer` property.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3944">Quando ne viene eseguito l'override in una classe derivata, implementa la proprietà <see cref="P:System.Type.IsPointer" /> e determina se l'oggetto <see cref="T:System.Type" /> è un puntatore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3944">When overridden in a derived class, implements the <see cref="P:System.Type.IsPointer" /> property and determines whether the <see cref="T:System.Type" /> is a pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3945">
            <see langword="true" /> se <see cref="T:System.Type" /> è un puntatore. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3945">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3946">Ottiene un valore che indica se <see cref="T:System.Type" /> è uno dei tipi primitivi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3946">Gets a value indicating whether the <see cref="T:System.Type" /> is one of the primitive types.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3947">
            <see langword="true" /> se <see cref="T:System.Type" /> è uno dei tipi primitivi. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3947">
              <see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3948">Sono tipi primitivi <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, e <xref:System.Single>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3948">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
 <span data-ttu-id="4ee8d-3949">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico o un parametro di tipo nella definizione di un tipo o metodo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3949">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3950">Nell'esempio seguente viene illustrato il `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, e <xref:System.Type.IsPrimitive%2A> delle proprietà del <xref:System.Type> classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3950">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="4ee8d-3951">Controlla se il tipo specificato può essere contenuto nel contesto, se può essere sottoposta a marshalling per riferimento e, se il tipo è un tipo di dati primitivi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3951">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3952">Quando ne viene eseguito l'override in una classe derivata, implementa la proprietà <see cref="P:System.Type.IsPrimitive" /> e determina se l'oggetto <see cref="T:System.Type" /> corrisponde a uno dei tipi primitivi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3952">When overridden in a derived class, implements the <see cref="P:System.Type.IsPrimitive" /> property and determines whether the <see cref="T:System.Type" /> is one of the primitive types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-3953">
            <see langword="true" /> se <see cref="T:System.Type" /> è uno dei tipi primitivi. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3953">
              <see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3954">Sono tipi primitivi <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, e <xref:System.Single>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3954">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3955">Nell'esempio seguente determina se il tipo specificato è un tipo primitivo e visualizza il risultato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3955">The following example determines whether the given type is a primitive type and displays the result.</span></span>  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3956">Ottiene un valore che indica se l'oggetto <see cref="T:System.Type" /> è dichiarato pubblico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3956">Gets a value indicating whether the <see cref="T:System.Type" /> is declared public.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3957">
            <see langword="true" /> se l'oggetto <see cref="T:System.Type" /> è dichiarato pubblico e non è un tipo annidato; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3957">
              <see langword="true" /> if the <see cref="T:System.Type" /> is declared public and is not a nested type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3958">Non usare con i tipi annidati; usare <xref:System.Type.IsNestedPublic%2A> invece.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3958">Do not use with nested types; use <xref:System.Type.IsNestedPublic%2A> instead.</span></span>  
  
 <span data-ttu-id="4ee8d-3959">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3959">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `true`.</span></span>  
  
 <span data-ttu-id="4ee8d-3960"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Consente di selezionare gli attributi di visibilità.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3960"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3961">L'esempio seguente crea un'istanza di `MyTestClass`, verifica la presenza di `IsPublic` proprietà e visualizza il risultato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3961">The following example creates an instance of `MyTestClass`, checks for the `IsPublic` property, and displays the result.</span></span>  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 <span data-ttu-id="4ee8d-3962">Per le classi annidate, ignorare i risultati della `IsPublic` e `IsNotPublic` e tenere in considerazione solo i risultati del <xref:System.Type.IsNestedPublic%2A> e <xref:System.Type.IsNestedPrivate%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3962">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of <xref:System.Type.IsNestedPublic%2A> and <xref:System.Type.IsNestedPrivate%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3963">Ottiene un valore che indica se <see cref="T:System.Type" /> è dichiarato sealed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3963">Gets a value indicating whether the <see cref="T:System.Type" /> is declared sealed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3964">
            <see langword="true" /> se <see cref="T:System.Type" /> è dichiarato sealed; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3964">
              <see langword="true" /> if the <see cref="T:System.Type" /> is declared sealed; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3965">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo di un tipo generico, questa proprietà restituisce sempre `true`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3965">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-3966">L'esempio seguente crea un'istanza di un `sealed` classe, Cerca il `IsSealed` proprietà e visualizza il risultato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3966">The following example creates an instance of a `sealed` class, checks for the `IsSealed` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3967">Ottiene un valore che indica se il tipo corrente è SecurityCritical o SecuritySafeCritical al livello di attendibilità corrente e può pertanto eseguire operazioni critiche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3967">Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3968">
            <see langword="true" /> se il tipo corrente è SecurityCritical o SecuritySafeCritical al livello di attendibilità corrente, <see langword="false" /> se è trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3968">
              <see langword="true" /> if the current type is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3969">Il <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, e <xref:System.Type.IsSecurityTransparent%2A> riportano il livello di trasparenza del tipo al livello di attendibilità corrente, come determinato da common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3969">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="4ee8d-3970">Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3970">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="4ee8d-3971">Livello di sicurezza</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3971">Security level</span></span>|<span data-ttu-id="4ee8d-3972">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3972">IsSecurityCritical</span></span>|<span data-ttu-id="4ee8d-3973">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3973">IsSecuritySafeCritical</span></span>|<span data-ttu-id="4ee8d-3974">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3974">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="4ee8d-3975">Critico</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3975">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="4ee8d-3976">Critico per la sicurezza</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3976">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="4ee8d-3977">Trasparente</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3977">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="4ee8d-3978">Usare queste proprietà è molto più semplice che non esaminare le annotazioni di sicurezza di un assembly e dei suoi tipi, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3978">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4ee8d-3979">Per gli assembly con attendibilità parziale, il valore di questa proprietà dipende dal livello di attendibilità corrente dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3979">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="4ee8d-3980">Se l'assembly viene caricato in un dominio applicazione parzialmente attendibile (ad esempio, in un dominio applicazione creato mediante sandbox), il runtime ignora le annotazioni di sicurezza dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3980">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="4ee8d-3981">L'assembly e tutti i relativi tipi vengono considerati come trasparenti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3981">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="4ee8d-3982">Il runtime presta attenzione per le annotazioni di sicurezza di un assembly con attendibilità parziale solo quando tale assembly viene caricato in un dominio applicazione con attendibilità totale (ad esempio, nel dominio applicazione predefinito di un'applicazione desktop).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3982">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="4ee8d-3983">Al contrario, un assembly attendibile (vale a dire, un assembly con nome sicuro che viene installato nella global assembly cache) è sempre caricato con attendibilità totale indipendentemente dal livello di trust del dominio dell'applicazione, pertanto il livello di attendibilità corrente è sempre completamente attendibile.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3983">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="4ee8d-3984">È possibile determinare i livelli di attendibilità corrente di domini applicazione e assembly usando il <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> e <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3984">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="4ee8d-3985">Per altre informazioni sulla reflection e trasparenza, vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3985">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="4ee8d-3986">Per informazioni sulla trasparenza, vedere [modifiche della sicurezza](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3986">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">
          <span data-ttu-id="4ee8d-3987">Considerazioni sulla sicurezza in relazione alla reflection</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3987">Security Considerations for Reflection</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">
          <span data-ttu-id="4ee8d-3988">Modifiche della sicurezza in .NET Framework</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3988">Security Changes in the .NET Framework</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-3989">Ottiene un valore che indica se il tipo corrente è SecuritySafeCritical al livello di attendibilità corrente, vale a dire se può eseguire operazioni critiche e se è possibile accedervi tramite codice trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3989">Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-3990">
            <see langword="true" /> se il tipo corrente è SecuritySafeCritical al livello di attendibilità corrente, <see langword="false" /> se è SecurityCritical o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-3990">
              <see langword="true" /> if the current type is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-3991">Il <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, e <xref:System.Type.IsSecurityTransparent%2A> riportano il livello di trasparenza del tipo al livello di attendibilità corrente, come determinato da common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3991">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="4ee8d-3992">Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3992">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="4ee8d-3993">Livello di sicurezza</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3993">Security level</span></span>|<span data-ttu-id="4ee8d-3994">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3994">IsSecurityCritical</span></span>|<span data-ttu-id="4ee8d-3995">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3995">IsSecuritySafeCritical</span></span>|<span data-ttu-id="4ee8d-3996">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3996">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="4ee8d-3997">Critico</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3997">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="4ee8d-3998">Critico per la sicurezza</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3998">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="4ee8d-3999">Trasparente</span><span class="sxs-lookup"><span data-stu-id="4ee8d-3999">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="4ee8d-4000">Usare queste proprietà è molto più semplice che non esaminare le annotazioni di sicurezza di un assembly e dei suoi tipi, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4000">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4ee8d-4001">Per gli assembly con attendibilità parziale, il valore di questa proprietà dipende dal livello di attendibilità corrente dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4001">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="4ee8d-4002">Se l'assembly viene caricato in un dominio applicazione parzialmente attendibile (ad esempio, in un dominio applicazione creato mediante sandbox), il runtime ignora le annotazioni di sicurezza dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4002">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="4ee8d-4003">L'assembly e tutti i relativi tipi vengono considerati come trasparenti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4003">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="4ee8d-4004">Il runtime presta attenzione per le annotazioni di sicurezza di un assembly con attendibilità parziale solo quando tale assembly viene caricato in un dominio applicazione con attendibilità totale (ad esempio, nel dominio applicazione predefinito di un'applicazione desktop).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4004">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="4ee8d-4005">Al contrario, un assembly attendibile (vale a dire, un assembly con nome sicuro che viene installato nella global assembly cache) è sempre caricato con attendibilità totale indipendentemente dal livello di trust del dominio dell'applicazione, pertanto il livello di attendibilità corrente è sempre completamente attendibile.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4005">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="4ee8d-4006">È possibile determinare i livelli di attendibilità corrente di domini applicazione e assembly usando il <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> e <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4006">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="4ee8d-4007">Per altre informazioni sulla reflection e trasparenza, vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4007">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="4ee8d-4008">Per informazioni sulla trasparenza, vedere [modifiche della sicurezza](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4008">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">
          <span data-ttu-id="4ee8d-4009">Considerazioni sulla sicurezza in relazione alla reflection</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4009">Security Considerations for Reflection</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">
          <span data-ttu-id="4ee8d-4010">Modifiche della sicurezza in .NET Framework</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4010">Security Changes in the .NET Framework</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-4011">Ottiene un valore che indica se il tipo corrente è trasparente al livello di attendibilità corrente e non può quindi eseguire operazioni critiche.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4011">Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-4012">
            <see langword="true" /> se il tipo è SecurityTransparent al livello di attendibilità corrente; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4012">
              <see langword="true" /> if the type is security-transparent at the current trust level; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4013">Se questa proprietà restituisce `true`, il <xref:System.Type.IsSecurityCritical%2A> e <xref:System.Type.IsSecuritySafeCritical%2A> restituiscono proprietà `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4013">If this property returns `true`, the <xref:System.Type.IsSecurityCritical%2A> and <xref:System.Type.IsSecuritySafeCritical%2A> properties return `false`.</span></span>  
  
 <span data-ttu-id="4ee8d-4014">Il <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, e <xref:System.Type.IsSecurityTransparent%2A> riportano il livello di trasparenza del tipo al livello di attendibilità corrente, come determinato da common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4014">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="4ee8d-4015">Usare queste proprietà è molto più semplice che non esaminare le annotazioni di sicurezza di un assembly e dei suoi tipi, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4015">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4ee8d-4016">Per gli assembly con attendibilità parziale, il valore di questa proprietà dipende dal livello di attendibilità corrente dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4016">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="4ee8d-4017">Se l'assembly viene caricato in un dominio applicazione parzialmente attendibile (ad esempio, in un dominio applicazione creato mediante sandbox), il runtime ignora le annotazioni di sicurezza dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4017">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="4ee8d-4018">L'assembly e tutti i relativi tipi vengono considerati come trasparenti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4018">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="4ee8d-4019">Il runtime presta attenzione per le annotazioni di sicurezza di un assembly con attendibilità parziale solo quando tale assembly viene caricato in un dominio applicazione con attendibilità totale (ad esempio, nel dominio applicazione predefinito di un'applicazione desktop).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4019">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="4ee8d-4020">Al contrario, un assembly attendibile (vale a dire, un assembly con nome sicuro che viene installato nella global assembly cache) è sempre caricato con attendibilità totale indipendentemente dal livello di trust del dominio dell'applicazione, pertanto il livello di attendibilità corrente è sempre completamente attendibile.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4020">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="4ee8d-4021">È possibile determinare i livelli di attendibilità corrente di domini applicazione e assembly usando il <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> e <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4021">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="4ee8d-4022">Per altre informazioni sulla reflection e trasparenza, vedere [considerazioni sulla sicurezza per Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4022">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="4ee8d-4023">Per informazioni sulla trasparenza, vedere [modifiche della sicurezza](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4023">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">
          <span data-ttu-id="4ee8d-4024">Considerazioni sulla sicurezza in relazione alla reflection</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4024">Security Considerations for Reflection</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">
          <span data-ttu-id="4ee8d-4025">Modifiche della sicurezza in .NET Framework</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4025">Security Changes in the .NET Framework</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-4026">Ottiene un valore che indica se <see cref="T:System.Type" /> è serializzabile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4026">Gets a value indicating whether the <see cref="T:System.Type" /> is serializable.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-4027">
            <see langword="true" /> se <see cref="T:System.Type" /> è serializzabile; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4027">
              <see langword="true" /> if the <see cref="T:System.Type" /> is serializable; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="4ee8d-4028">Tipi definiti in .NET Standard non sono contrassegnati con <xref:System.SerializableAttribute>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4028">Types that are defined in the .NET Standard are not marked with <xref:System.SerializableAttribute>.</span></span> <span data-ttu-id="4ee8d-4029">Ogni implementazione .NET determina invece se un tipo è serializzabile.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4029">Instead, each .NET implementation determines whether a type is serializable.</span></span> <span data-ttu-id="4ee8d-4030">In fase di esecuzione, è possibile usare il <xref:System.Type.IsSerializable%2A> proprietà per determinare se tale implementazione supporta la serializzazione di un'istanza del tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4030">At run time, you can use the <xref:System.Type.IsSerializable%2A> property to determine whether that implementation supports serialization of an instance of the type.</span></span> <span data-ttu-id="4ee8d-4031">Per altre informazioni e un esempio, vedere [come determinare se un oggetto .NET Standard è serializzabile](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4031">For more information and an example, see [How to determine if a .NET Standard object is serializable](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).</span></span>
  
 <span data-ttu-id="4ee8d-4032">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione del tipo generico da cui è stato costruito il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4032">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="4ee8d-4033">Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato dalla `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4033">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="4ee8d-4034">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4034">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-4035">L'esempio seguente crea un'istanza di `MyTestClass` classe, imposta l'attributo [Serializable] e controlla le `IsSerializable` proprietà per `true` o `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4035">The following example creates an instance of `MyTestClass` class, sets the [Serializable] attribute, and checks the `IsSerializable` property for `true` or `false`.</span></span>  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-4036">Ottiene un valore che indica se per il nome del tipo richiede una gestione speciale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4036">Gets a value indicating whether the type has a name that requires special handling.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-4037">
            <see langword="true" /> se il nome del tipo richiede una gestione speciale; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4037">
              <see langword="true" /> if the type has a name that requires special handling; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4038">I nomi che iniziano con o contengono un carattere di sottolineatura (_), le funzioni di accesso di proprietà e metodi di overload degli operatori sono esempi di tipi che possono richiedere un trattamento speciale da alcuni compilatori.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4038">Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</span></span>  
  
 <span data-ttu-id="4ee8d-4039">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione del tipo generico da cui è stato costruito il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4039">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="4ee8d-4040">Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato dalla `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4040">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="4ee8d-4041">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4041">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <span data-ttu-id="4ee8d-4042">Tipo da confrontare con il tipo corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4042">The type to compare with the current type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-4043">Determina se l'oggetto <see cref="T:System.Type" /> corrente deriva dall'oggetto <see cref="T:System.Type" /> specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4043">Determines whether the current <see cref="T:System.Type" /> derives from the specified <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-4044">
            <see langword="true" /> se l'oggetto <see langword="Type" /> corrente deriva da <paramref name="c" />; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4044">
              <see langword="true" /> if the current <see langword="Type" /> derives from <paramref name="c" />; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="4ee8d-4045">Questo metodo restituisce anche <see langword="false" /> se <paramref name="c" /> e l'oggetto <see langword="Type" /> corrente sono uguali.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4045">This method also returns <see langword="false" /> if <paramref name="c" /> and the current <see langword="Type" /> are equal.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4046">È possibile chiamare il <xref:System.Type.IsSubclassOf%2A> metodo per determinare quanto segue:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4046">You can call the <xref:System.Type.IsSubclassOf%2A> method to determine any of the following:</span></span>  
  
-   <span data-ttu-id="4ee8d-4047">Una classe che deriva da un altro.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4047">Whether one class derives from another.</span></span>  
  
-   <span data-ttu-id="4ee8d-4048">Se un tipo deriva da <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4048">Whether a type derives from <xref:System.ValueType>.</span></span> <span data-ttu-id="4ee8d-4049">Tuttavia, il <xref:System.Type.IsValueType%2A> è un modo più efficiente per determinare se un tipo è un tipo di valore.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4049">However, the <xref:System.Type.IsValueType%2A> is a more efficient way to determine whether a type is a value type.</span></span>  
  
-   <span data-ttu-id="4ee8d-4050">Se un tipo deriva da <xref:System.Enum>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4050">Whether a type derives from <xref:System.Enum>.</span></span> <span data-ttu-id="4ee8d-4051">Tuttavia, il <xref:System.Type.IsEnum%2A> metodo è un modo più efficiente per determinare se un tipo è un'enumerazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4051">However, the <xref:System.Type.IsEnum%2A> method is a more efficient way to determine whether a type is an enumeration.</span></span>  
  
-   <span data-ttu-id="4ee8d-4052">Se un tipo è un delegato, vale a dire, se deriva da una <xref:System.Delegate> o <xref:System.MulticastDelegate>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4052">Whether a type is a delegate, that is, whether it derives from either <xref:System.Delegate> or <xref:System.MulticastDelegate>.</span></span>  
  
 <span data-ttu-id="4ee8d-4053">Il <xref:System.Type.IsSubclassOf%2A> metodo non può essere usato per determinare se un'interfaccia deriva da un'altra interfaccia o se una classe implementa un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4053">The <xref:System.Type.IsSubclassOf%2A> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface.</span></span> <span data-ttu-id="4ee8d-4054">Usare il <xref:System.Type.IsAssignableFrom%2A> metodo a tale scopo, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4054">Use the <xref:System.Type.IsAssignableFrom%2A> method for that purpose, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 <span data-ttu-id="4ee8d-4055">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, deriva dal vincolo di classe o da <xref:System.Object?displayProperty=nameWithType> se non sono presenti vincoli di classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4055">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <xref:System.Object?displayProperty=nameWithType> if it has no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-4056">Tranne quando è usato con le interfacce <xref:System.Type.IsSubclassOf%2A> è l'opposto di <xref:System.Type.IsAssignableFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4056">Except when used with interfaces, <xref:System.Type.IsSubclassOf%2A> is the converse of <xref:System.Type.IsAssignableFrom%2A>.</span></span> <span data-ttu-id="4ee8d-4057">Vale a dire, se `t1.IsSubclassOf(t2)` viene `true`, quindi `t2.IsAssignableFrom(t1)` anche `true`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4057">That is, if `t1.IsSubclassOf(t2)` is `true`, then `t2.IsAssignableFrom(t1)` is also `true`.</span></span>  
  
 <span data-ttu-id="4ee8d-4058">Questo metodo può essere sostituito da una classe derivata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4058">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-4059">L'esempio seguente crea una classe denominata `Class1` e una classe derivata denominata `DerivedC1`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4059">The following example creates a class named `Class1` and a derived class named `DerivedC1`.</span></span> <span data-ttu-id="4ee8d-4060">Chiama il <xref:System.Type.IsSubclassOf%2A> metodo per verificare che `DerivedC1` è una sottoclasse di `Class1`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4060">It calls the <xref:System.Type.IsSubclassOf%2A> method to show that `DerivedC1` is a subclass of `Class1`.</span></span>  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-4061">
            <paramref name="c" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4061">
              <paramref name="c" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-4062">Ottiene un valore che indica se l'attributo di formato della stringa <see langword="UnicodeClass" /> è selezionato per <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4062">Gets a value indicating whether the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-4063">
            <see langword="true" /> se l'attributo di formato della stringa <see langword="UnicodeClass" /> è selezionato per <see cref="T:System.Type" />; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4063">
              <see langword="true" /> if the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4064">Il <xref:System.Reflection.TypeAttributes.StringFormatMask> viene usato per selezionare gli attributi del formato stringa.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4064">The <xref:System.Reflection.TypeAttributes.StringFormatMask> is used to select the string format attributes.</span></span> <span data-ttu-id="4ee8d-4065">Gli attributi di formato di stringa migliorano l'interoperabilità con la definizione di modalità di interpretazione di stringhe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4065">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="4ee8d-4066">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione del tipo generico da cui è stato costruito il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4066">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="4ee8d-4067">Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato dalla `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4067">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="4ee8d-4068">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questa proprietà restituisce sempre `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4068">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-4069">Ottiene un valore che indica se <see cref="T:System.Type" /> è un tipo di valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4069">Gets a value indicating whether the <see cref="T:System.Type" /> is a value type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-4070">
            <see langword="true" /> se <see cref="T:System.Type" /> è un tipo di valore. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4070">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4071">I tipi di valore sono tipi che sono rappresentati come una sequenza di bit. i tipi di valore non sono classi o interfacce.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4071">Value types are types that are represented as sequences of bits; value types are not classes or interfaces.</span></span> <span data-ttu-id="4ee8d-4072">Tipi di valore sono definiti come "struct" in alcuni linguaggi di programmazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4072">Value types are referred to as "structs" in some programming languages.</span></span> <span data-ttu-id="4ee8d-4073">Enumerazioni rappresentano un caso speciale di tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4073">Enums are a special case of value types.</span></span>  
  
 <span data-ttu-id="4ee8d-4074">Questa proprietà restituisce `false` per il <xref:System.ValueType> classe, poiché <xref:System.ValueType> non è un tipo di valore stesso.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4074">This property returns `false` for the <xref:System.ValueType> class, because <xref:System.ValueType> is not a value type itself.</span></span> <span data-ttu-id="4ee8d-4075">È la classe base per tutti i tipi di valore e di conseguenza qualsiasi tipo di valore può essere assegnato a esso.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4075">It is the base class for all value types, and therefore any value type can be assigned to it.</span></span> <span data-ttu-id="4ee8d-4076">Ciò non sarebbe possibile se <xref:System.ValueType> stesso è un tipo di valore.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4076">This would not be possible if <xref:System.ValueType> itself was a value type.</span></span> <span data-ttu-id="4ee8d-4077">Tipi di valore sono boxed quando vengono assegnate a un campo di tipo <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4077">Value types are boxed when they are assigned to a field of type <xref:System.ValueType>.</span></span>  
  
 <span data-ttu-id="4ee8d-4078">Questa proprietà restituisce `true` per le enumerazioni, ma non per il <xref:System.Enum> tipo stesso.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4078">This property returns `true` for enumerations, but not for the <xref:System.Enum> type itself.</span></span> <span data-ttu-id="4ee8d-4079">Per un esempio che illustra questo comportamento, vedere <xref:System.Type.IsEnum%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4079">For an example that demonstrates this behavior, see <xref:System.Type.IsEnum%2A>.</span></span>  
  
 <span data-ttu-id="4ee8d-4080">Questa proprietà è di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4080">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-4081">L'esempio seguente crea una variabile di tipo `MyEnum`, verifica la presenza di `IsValueType` proprietà e visualizza il risultato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4081">The following example creates a variable of type `MyEnum`, checks for the `IsValueType` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-4082">Implementa la proprietà <see cref="P:System.Type.IsValueType" /> e determina se l'oggetto <see cref="T:System.Type" /> è un tipo di valore, ovvero, non una classe o un'interfaccia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4082">Implements the <see cref="P:System.Type.IsValueType" /> property and determines whether the <see cref="T:System.Type" /> is a value type; that is, not a class or an interface.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-4083">
            <see langword="true" /> se <see cref="T:System.Type" /> è un tipo di valore. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4083">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4084">Questo metodo è fornito per abilitare l'implementazione di sistemi di tipi alternativo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4084">This method is provided to enable the implementation of alternate type systems.</span></span> <span data-ttu-id="4ee8d-4085">Non è in genere usato nel codice dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4085">It is not generally used in application code.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-4086">Ottiene un valore che indica se è possibile accedere a <see cref="T:System.Type" /> da codice esterno all'assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4086">Gets a value indicating whether the <see cref="T:System.Type" /> can be accessed by code outside the assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-4087">
            <see langword="true" /> se l'oggetto <see cref="T:System.Type" /> corrente è un tipo pubblico o un tipo pubblico annidato in modo che tutti i tipi contenitore siano pubblici; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4087">
              <see langword="true" /> if the current <see cref="T:System.Type" /> is a public type or a public nested type such that all the enclosing types are public; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4088">Utilizzare questa proprietà per determinare se un tipo è parte dell'interfaccia pubblica di un assembly del componente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4088">Use this property to determine whether a type is part of the public interface of a component assembly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-4089">Esempio di codice seguente verifica due classi, solo uno dei quali è visibile all'esterno dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4089">The following code example tests two classes, only one of which is visible outside the assembly.</span></span>  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-4090">Restituisce un oggetto <see cref="T:System.Type" /> che rappresenta una matrice del tipo corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4090">Returns a <see cref="T:System.Type" /> object that represents an array of the current type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-4091">Restituisce un oggetto <see cref="T:System.Type" /> che rappresenta una matrice unidimensionale del tipo corrente, con limite inferiore zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4091">Returns a <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-4092">Oggetto <see cref="T:System.Type" /> che rappresenta una matrice unidimensionale del tipo corrente, con limite inferiore zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4092">A <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4093">Il <xref:System.Type.MakeArrayType%2A> metodo fornisce un modo per generare i tipi di matrice i cui tipi di elemento vengono calcolati in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4093">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
 <span data-ttu-id="4ee8d-4094">**Nota** common language runtime viene fatta distinzione tra i vettori (vale a dire, matrici unidimensionali che sono sempre in base zero) e le matrici multidimensionali.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4094">**Note** The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="4ee8d-4095">Un vettore, che ha sempre una sola dimensione, non è lo stesso come una matrice multidimensionale che ha solo una dimensione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4095">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="4ee8d-4096">Questo overload del metodo è utilizzabile solo per creare i tipi di vettore ed è l'unico modo per creare un tipo di vettore.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4096">This method overload can only be used to create vector types, and it is the only way to create a vector type.</span></span> <span data-ttu-id="4ee8d-4097">Usare il <xref:System.Type.MakeArrayType%28System.Int32%29> overload del metodo per creare tipi di matrici multidimensionali.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4097">Use the <xref:System.Type.MakeArrayType%28System.Int32%29> method overload to create multidimensional array types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-4098">Esempio di codice seguente crea una matrice `ref` (`ByRef` in Visual Basic) e i tipi di puntatore per il `Test` classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4098">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="4ee8d-4099">Il metodo richiamato non è supportato nella classe base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4099">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="4ee8d-4100">Le classi derivate devono fornire un'implementazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4100">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="4ee8d-4101">Il tipo corrente è <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4101">The current type is <see cref="T:System.TypedReference" />.</span>
          </span>
          <span data-ttu-id="4ee8d-4102">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4102">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-4103">Il tipo corrente è <see langword="ByRef" />,</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4103">The current type is a <see langword="ByRef" /> type.</span>
          </span>
          <span data-ttu-id="4ee8d-4104">Ciò significa che <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4104">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">
          <span data-ttu-id="4ee8d-4105">Numero di dimensioni della matrice.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4105">The number of dimensions for the array.</span>
          </span>
          <span data-ttu-id="4ee8d-4106">Il numero deve essere minore o uguale a 32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4106">This number must be less than or equal to 32.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-4107">Restituisce un oggetto <see cref="T:System.Type" /> che rappresenta una matrice del tipo corrente, con il numero specificato di dimensioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4107">Returns a <see cref="T:System.Type" /> object representing an array of the current type, with the specified number of dimensions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-4108">Oggetto che rappresenta una matrice del tipo corrente, con il numero specificato di dimensioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4108">An object representing an array of the current type, with the specified number of dimensions.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4109">Il <xref:System.Type.MakeArrayType%2A> metodo fornisce un modo per generare i tipi di matrice i cui tipi di elemento vengono calcolati in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4109">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-4110">Common language runtime viene fatta distinzione tra i vettori (vale a dire, matrici unidimensionali che sono sempre in base zero) e le matrici multidimensionali.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4110">The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="4ee8d-4111">Un vettore, che ha sempre una sola dimensione, non è lo stesso come una matrice multidimensionale che ha solo una dimensione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4111">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="4ee8d-4112">È possibile utilizzare questo overload del metodo per creare un tipo di vettore. Se `rank` è 1, questo overload del metodo restituisce un tipo di matrice multidimensionale che ha una dimensione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4112">You cannot use this method overload to create a vector type; if `rank` is 1, this method overload returns a multidimensional array type that happens to have one dimension.</span></span> <span data-ttu-id="4ee8d-4113">Usare il <xref:System.Type.MakeArrayType> overload del metodo per creare i tipi di vettore.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4113">Use the <xref:System.Type.MakeArrayType> method overload to create vector types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-4114">Esempio di codice seguente crea una matrice `ref` (`ByRef` in Visual Basic) e i tipi di puntatore per il `Test` classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4114">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="4ee8d-4115">
            <paramref name="rank" /> non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4115">
              <paramref name="rank" /> is invalid.</span>
          </span>
          <span data-ttu-id="4ee8d-4116">Ad esempio, 0 o negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4116">For example, 0 or negative.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="4ee8d-4117">Il metodo richiamato non è supportato nella classe base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4117">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="4ee8d-4118">Il tipo corrente è <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4118">The current type is <see cref="T:System.TypedReference" />.</span>
          </span>
          <span data-ttu-id="4ee8d-4119">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4119">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-4120">Il tipo corrente è <see langword="ByRef" />,</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4120">The current type is a <see langword="ByRef" /> type.</span>
          </span>
          <span data-ttu-id="4ee8d-4121">Ciò significa che <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4121">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span>
          </span>
          <span data-ttu-id="4ee8d-4122">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4122">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-4123">
            <paramref name="rank" /> è maggiore di 32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4123">
              <paramref name="rank" /> is greater than 32.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-4124">Restituisce un oggetto <see cref="T:System.Type" /> che rappresenta il tipo corrente quando viene passato come parametro <see langword="ref" /> (parametro <see langword="ByRef" /> in Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4124">Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-4125">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo corrente quando viene passato come parametro <see langword="ref" /> (parametro <see langword="ByRef" /> in Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4125">A <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4126">Il <xref:System.Type.MakeByRefType%2A> metodo fornisce un modo per generare `ref` tipi (`ByRef` in Visual Basic) per elenchi di parametri.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4126">The <xref:System.Type.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.</span></span>  
  
 <span data-ttu-id="4ee8d-4127">Usando la sintassi di Microsoft intermediate language (MSIL), se l'oggetto corrente <xref:System.Type> oggetto <xref:System.Int32>, questo metodo restituisce un <xref:System.Type> che rappresenta l'oggetto `Int32&`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4127">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32&`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-4128">Esempio di codice seguente crea una matrice `ref` (`ByRef` in Visual Basic) e i tipi di puntatore per il `Test` classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4128">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="4ee8d-4129">Il metodo richiamato non è supportato nella classe base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4129">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="4ee8d-4130">Il tipo corrente è <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4130">The current type is <see cref="T:System.TypedReference" />.</span>
          </span>
          <span data-ttu-id="4ee8d-4131">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4131">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-4132">Il tipo corrente è <see langword="ByRef" />,</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4132">The current type is a <see langword="ByRef" /> type.</span>
          </span>
          <span data-ttu-id="4ee8d-4133">Ciò significa che <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4133">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">
          <span data-ttu-id="4ee8d-4134">Matrice di tipi con cui sostituire i parametri di tipo del tipo generico corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4134">An array of types to be substituted for the type parameters of the current generic type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-4135">Sostituisce gli elementi di una matrice di tipi ai parametri di tipo della definizione di tipo generico corrente e restituisce un oggetto <see cref="T:System.Type" /> che rappresenta il tipo costruito risultante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4135">Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <see cref="T:System.Type" /> object representing the resulting constructed type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-4136">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo costruito ottenuto sostituendo i parametri di tipo del tipo generico corrente con gli elementi di <paramref name="typeArguments" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4136">A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4137">Il <xref:System.Type.MakeGenericType%2A> metodo consente di scrivere codice che assegna tipi specifici per i parametri di tipo di una definizione di tipo generico, creando così un <xref:System.Type> oggetto che rappresenta un determinato tipo costruito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4137">The <xref:System.Type.MakeGenericType%2A> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <xref:System.Type> object that represents a particular constructed type.</span></span> <span data-ttu-id="4ee8d-4138">È possibile usare questo <xref:System.Type> oggetto per creare istanze di runtime del tipo costruito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4138">You can use this <xref:System.Type> object to create run-time instances of the constructed type.</span></span>  
  
 <span data-ttu-id="4ee8d-4139">I tipi costruiti con <xref:System.Type.MakeGenericType%2A> possono essere aperti, vale a dire, alcuni dei rispettivi argomenti tipo possono essere parametri di tipo di inclusione i tipi o metodi generici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4139">Types constructed with <xref:System.Type.MakeGenericType%2A> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types.</span></span> <span data-ttu-id="4ee8d-4140">È possibile utilizzare tali tipi costruiti aperti quando si generano assembly dinamici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4140">You might use such open constructed types when you emit dynamic assemblies.</span></span> <span data-ttu-id="4ee8d-4141">Si consideri ad esempio le classi `Base` e `Derived` nel codice seguente.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4141">For example, consider the classes `Base` and `Derived` in the following code.</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="4ee8d-4142">Per generare `Derived` in un assembly dinamico, è necessario costruire il tipo di base.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4142">To generate `Derived` in a dynamic assembly, it is necessary to construct its base type.</span></span> <span data-ttu-id="4ee8d-4143">A tale scopo, chiamare il <xref:System.Type.MakeGenericType%2A> metodo su un <xref:System.Type> oggetto che rappresenta la classe `Base`, usando gli argomenti di tipo generico <xref:System.Int32> e il parametro di tipo `V` da `Derived`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4143">To do this, call the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object representing the class `Base`, using the generic type arguments <xref:System.Int32> and the type parameter `V` from `Derived`.</span></span> <span data-ttu-id="4ee8d-4144">Perché i tipi e parametri di tipo generico sono rappresentati da <xref:System.Type> oggetti, può passare una matrice che contiene sia il <xref:System.Type.MakeGenericType%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4144">Because types and generic type parameters are both represented by <xref:System.Type> objects, an array containing both can be passed to the <xref:System.Type.MakeGenericType%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-4145">Un tipo costruito, ad esempio `Base<int, V>` è utile quando la creazione di codice, ma non è possibile chiamare il <xref:System.Type.MakeGenericType%2A> metodo su questo tipo perché non è una definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4145">A constructed type such as `Base<int, V>` is useful when emitting code, but you cannot call the <xref:System.Type.MakeGenericType%2A> method on this type because it is not a generic type definition.</span></span> <span data-ttu-id="4ee8d-4146">Per creare un tipo costruito chiuso che è possibile creare istanze, chiamare prima il <xref:System.Type.GetGenericTypeDefinition%2A> metodo per ottenere un <xref:System.Type> dell'oggetto che rappresenta la definizione di tipo generico e quindi chiamare <xref:System.Type.MakeGenericType%2A> con gli argomenti di tipo desiderato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4146">To create a closed constructed type that can be instantiated, first call the <xref:System.Type.GetGenericTypeDefinition%2A> method to get a <xref:System.Type> object representing the generic type definition and then call <xref:System.Type.MakeGenericType%2A> with the desired type arguments.</span></span>  
  
 <span data-ttu-id="4ee8d-4147">Il <xref:System.Type> oggetto restituito da <xref:System.Type.MakeGenericType%2A> equivale al <xref:System.Type> ottenuto chiamando il <xref:System.Object.GetType%2A> metodo il risultato di tipo costruito, o <xref:System.Object.GetType%2A> metodo di qualsiasi tipo che è stato creato dalla stessa generico costruito definizione di tipo con gli stessi argomenti di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4147">The <xref:System.Type> object returned by <xref:System.Type.MakeGenericType%2A> is the same as the <xref:System.Type> obtained by calling the <xref:System.Object.GetType%2A> method of the resulting constructed type, or the <xref:System.Object.GetType%2A> method of any constructed type that was created from the same generic type definition using the same type arguments.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4ee8d-4148">Una matrice di tipi generici non è un tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4148">An array of generic types is not itself a generic type.</span></span> <span data-ttu-id="4ee8d-4149">Non è possibile chiamare <xref:System.Type.MakeGenericType%2A> su un tipo matrice, ad esempio `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4149">You cannot call <xref:System.Type.MakeGenericType%2A> on an array type such as `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic).</span></span> <span data-ttu-id="4ee8d-4150">Per costruire un tipo generico chiuso dal `C<T>[]`, chiamare <xref:System.Type.GetElementType%2A> per ottenere la definizione di tipo generico `C<T>`; chiamare <xref:System.Type.MakeGenericType%2A> sulla definizione di tipo generico per creare il tipo costruito; e infine chiamare il <xref:System.Type.MakeArrayType%2A> metodo su il tipo costruito per creare il tipo di matrice.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4150">To construct a closed generic type from `C<T>[]`, call <xref:System.Type.GetElementType%2A> to obtain the generic type definition `C<T>`; call <xref:System.Type.MakeGenericType%2A> on the generic type definition to create the constructed type; and finally call the <xref:System.Type.MakeArrayType%2A> method on the constructed type to create the array type.</span></span> <span data-ttu-id="4ee8d-4151">Lo stesso vale per i tipi di puntatore e `ref` tipi (`ByRef` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4151">The same is true of pointer types and `ref` types (`ByRef` in Visual Basic).</span></span>  
  
 <span data-ttu-id="4ee8d-4152">Per un elenco delle condizioni invariabili relative ai termini usati dal processo di reflection generico, vedere i commenti sulla proprietà <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4152">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
## <a name="nested-types"></a><span data-ttu-id="4ee8d-4153">Tipi annidati</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4153">Nested Types</span></span>  
 <span data-ttu-id="4ee8d-4154">Se un tipo generico viene definito mediante c#, C++ o Visual Basic, i relativi tipi annidati sono tutti generici.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4154">If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic.</span></span> <span data-ttu-id="4ee8d-4155">Questo vale anche se i tipi annidati non dispongono di alcun parametro di tipo i propri, perché tutte le tre lingue comprendono i parametri dei tipi in inclusione negli elenchi di parametri di tipo per i tipi annidati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4155">This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types.</span></span> <span data-ttu-id="4ee8d-4156">Prendere in considerazione le classi seguenti:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4156">Consider the following classes:</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 <span data-ttu-id="4ee8d-4157">Elenco di parametri di tipo della classe annidata `Inner` ha due parametri di tipo `T` e `U`, il primo dei quali è il parametro di tipo della relativa classe che lo contiene.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4157">The type parameter list of the nested class `Inner` has two type parameters, `T` and `U`, the first of which is the type parameter of its enclosing class.</span></span> <span data-ttu-id="4ee8d-4158">Analogamente, l'elenco di parametri di tipo della classe annidata `Innermost1` ha tre parametri di tipo `T`, `U`, e `V`, con `T` e `U` che provengono dalle relative classi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4158">Similarly, the type parameter list of the nested class `Innermost1` has three type parameters, `T`, `U`, and `V`, with `T` and `U` coming from its enclosing classes.</span></span> <span data-ttu-id="4ee8d-4159">La classe annidata `Innermost2` ha due parametri di tipo, `T` e `U`, provenienti da classi che la contengono.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4159">The nested class `Innermost2` has two type parameters, `T` and `U`, which come from its enclosing classes.</span></span>  
  
 <span data-ttu-id="4ee8d-4160">Se l'elenco di parametri del tipo contenitore ha più di un parametro di tipo, tutti i parametri di tipo nell'ordine vengono incluse nell'elenco di parametri di tipo del tipo annidato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4160">If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.</span></span>  
  
 <span data-ttu-id="4ee8d-4161">Per costruire un tipo generico dalla definizione di tipo generico per un tipo annidato, chiamare il <xref:System.Type.MakeGenericType%2A> metodo con la matrice è costituito dalla concatenazione di matrici di argomenti tipo di tutti i tipi in inclusione, che inizia con il tipo generico più esterno e terminando con il tipo di matrice di argomenti del tipo annidato, se ha parametri di tipo propri.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4161">To construct a generic type from the generic type definition for a nested type, call the <xref:System.Type.MakeGenericType%2A> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own.</span></span> <span data-ttu-id="4ee8d-4162">Per creare un'istanza di `Innermost1`, chiamare il <xref:System.Type.MakeGenericType%2A> metodo con una matrice che contiene tre tipi, da assegnare a T, U e V. Per creare un'istanza di `Innermost2`, chiamare il <xref:System.Type.MakeGenericType%2A> metodo con una matrice che contiene due tipi, da assegnare a T e U.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4162">To create an instance of `Innermost1`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing three types, to be assigned to T, U, and V. To create an instance of `Innermost2`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing two types, to be assigned to T and U.</span></span>  
  
 <span data-ttu-id="4ee8d-4163">I linguaggi si propagano i parametri di tipo dei tipi in inclusione in questo modo quindi è possibile usare i parametri di tipo di un tipo di inclusione per definire i campi di tipi annidati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4163">The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types.</span></span> <span data-ttu-id="4ee8d-4164">In caso contrario, i parametri di tipo non è nell'ambito all'interno del corpo di tipi annidati.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4164">Otherwise, the type parameters would not be in scope within the bodies of the nested types.</span></span> <span data-ttu-id="4ee8d-4165">È possibile definire i tipi annidati senza propagare i parametri di tipo tipi di inclusione, con la creazione di codice negli assembly dinamico o usando il [Ilasm.exe (Assembler IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4165">It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span> <span data-ttu-id="4ee8d-4166">Si consideri il codice seguente per l'assembler MSIL:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4166">Consider the following code for the MSIL assembler:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="4ee8d-4167">In questo esempio, non è possibile definire un campo di tipo `T` oppure `U` nella classe `Innermost`, perché questi parametri di tipo non sono nell'ambito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4167">In this example, it is not possible to define a field of type `T` or `U` in class `Innermost`, because those type parameters are not in scope.</span></span> <span data-ttu-id="4ee8d-4168">Il codice assembler seguente definisce le classi annidate che presentano lo stesso comportamento che se definita in C++, Visual Basic e c#:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4168">The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="4ee8d-4169">È possibile usare la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare le classi annidate definite in linguaggi di alto livello e osservare questo schema di denominazione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4169">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine nested classes defined in the high-level languages and observe this naming scheme.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-4170">L'esempio seguente usa il <xref:System.Type.MakeGenericType%2A> metodo per creare un tipo costruito dalla definizione di tipo generico per il <xref:System.Collections.Generic.Dictionary%602> tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4170">The following example uses the <xref:System.Type.MakeGenericType%2A> method to create a constructed type from the generic type definition for the <xref:System.Collections.Generic.Dictionary%602> type.</span></span> <span data-ttu-id="4ee8d-4171">Rappresenta il tipo costruito un <xref:System.Collections.Generic.Dictionary%602> di `Test` oggetti con chiavi di stringa.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4171">The constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="4ee8d-4172">Il tipo corrente non rappresenta una definizione di tipo generico,</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4172">The current type does not represent a generic type definition.</span>
          </span>
          <span data-ttu-id="4ee8d-4173">Ciò significa che <see cref="P:System.Type.IsGenericTypeDefinition" /> restituisce <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4173">That is, <see cref="P:System.Type.IsGenericTypeDefinition" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-4174">
            <paramref name="typeArguments" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4174">
              <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-4175">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4175">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-4176">Qualsiasi elemento di <paramref name="typeArguments" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4176">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-4177">Il numero di elementi in <paramref name="typeArguments" /> non corrisponde al numero di parametri di tipo nella definizione di tipo generico corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4177">The number of elements in <paramref name="typeArguments" /> is not the same as the number of type parameters in the current generic type definition.</span>
          </span>
          <span data-ttu-id="4ee8d-4178">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4178">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-4179">Nessun elemento di <paramref name="typeArguments" /> soddisfa i vincoli specificati per il parametro di tipo corrispondente del tipo generico corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4179">Any element of <paramref name="typeArguments" /> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.</span>
          </span>
          <span data-ttu-id="4ee8d-4180">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4180">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-4181">
            <paramref name="typeArguments" /> contiene un elemento che è un tipo di puntatore (<see cref="P:System.Type.IsPointer" /> restituisce <see langword="true" />), un tipo by-ref (<see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />) o <see cref="T:System.Void" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4181">
              <paramref name="typeArguments" /> contains an element that is a pointer type (<see cref="P:System.Type.IsPointer" /> returns <see langword="true" />), a by-ref type (<see cref="P:System.Type.IsByRef" /> returns <see langword="true" />), or <see cref="T:System.Void" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="4ee8d-4182">Il metodo richiamato non è supportato nella classe base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4182">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="4ee8d-4183">Le classi derivate devono fornire un'implementazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4183">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">
          <span data-ttu-id="4ee8d-4184">Reflection e tipi generici</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4184">Reflection and Generic Types</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">
          <span data-ttu-id="4ee8d-4185">Procedura: esaminare e creare istanze di tipi generici tramite reflection</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4185">How to: Examine and Instantiate Generic Types with Reflection</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-4186">Restituisce un oggetto <see cref="T:System.Type" /> che rappresenta un puntatore al tipo corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4186">Returns a <see cref="T:System.Type" /> object that represents a pointer to the current type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-4187">Oggetto <see cref="T:System.Type" /> che rappresenta un puntatore al tipo corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4187">A <see cref="T:System.Type" /> object that represents a pointer to the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4188">Il <xref:System.Type.MakePointerType%2A> metodo fornisce un modo per generare i tipi di puntatore per gli elenchi di parametri.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4188">The <xref:System.Type.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.</span></span>  
  
 <span data-ttu-id="4ee8d-4189">Usando la sintassi di Microsoft intermediate language (MSIL), se l'oggetto corrente <xref:System.Type> oggetto <xref:System.Int32>, questo metodo restituisce un <xref:System.Type> che rappresenta l'oggetto `Int32*`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4189">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32*`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-4190">Esempio di codice seguente crea una matrice `ref` (`ByRef` in Visual Basic) e i tipi di puntatore per il `Test` classe.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4190">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="4ee8d-4191">Il metodo richiamato non è supportato nella classe base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4191">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="4ee8d-4192">Il tipo corrente è <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4192">The current type is <see cref="T:System.TypedReference" />.</span>
          </span>
          <span data-ttu-id="4ee8d-4193">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4193">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-4194">Il tipo corrente è <see langword="ByRef" />,</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4194">The current type is a <see langword="ByRef" /> type.</span>
          </span>
          <span data-ttu-id="4ee8d-4195">Ciò significa che <see cref="P:System.Type.IsByRef" /> restituisce <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4195">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-4196">Ottiene un valore <see cref="T:System.Reflection.MemberTypes" /> che indica che questo membro è un tipo o un tipo annidato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4196">Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-4197">Valore <see cref="T:System.Reflection.MemberTypes" /> che indica che questo membro è un tipo o un tipo annidato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4197">A <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4198">Esegue l'override di questa proprietà <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4198">This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4ee8d-4199">Pertanto, quando si esamina un set di <xref:System.Reflection.MemberInfo> oggetti, ad esempio, la matrice restituita dal <xref:System.Type.GetMembers%2A>, ovvero il <xref:System.Reflection.MemberInfo.MemberType%2A> restituisce proprietà <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> quando un membro specificato è un tipo annidato.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4199">Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objects—for example, the array returned by <xref:System.Type.GetMembers%2A>—the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> when a given member is a nested type.</span></span>  
  
 <span data-ttu-id="4ee8d-4200">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà si applica alla definizione del tipo generico da cui è stato costruito il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4200">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="4ee8d-4201">Ad esempio, se l'oggetto corrente <xref:System.Type> rappresenta `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), il valore di questa proprietà è determinato dalla `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4201">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="4ee8d-4202">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questa proprietà restituisce sempre <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4202">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-4203">Nell'esempio di codice riportato di seguito viene illustrato il `MemberType` campo come parametro per il `GetMember` metodo:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4203">The following code example shows the `MemberType` field as a parameter to the `GetMember` method:</span></span>  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-4204">Rappresenta un valore mancante nelle informazioni <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4204">Represents a missing value in the <see cref="T:System.Type" /> information.</span>
          </span>
          <span data-ttu-id="4ee8d-4205">Questo campo è di sola lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4205">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4206">Usare il `Missing` campo per la chiamata tramite la reflection per ottenere il valore predefinito di un parametro.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4206">Use the `Missing` field for invocation through reflection to obtain the default value of a parameter.</span></span> <span data-ttu-id="4ee8d-4207">Se il `Missing` campo viene passato per valore di parametro e vi è alcun valore predefinito per tale parametro, un <xref:System.ArgumentException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4207">If the `Missing` field is passed in for a parameter value and there is no default value for that parameter, an <xref:System.ArgumentException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-4208">Esempio di codice seguente viene illustrato l'utilizzo del `Missing` campo per richiamare un metodo con argomenti predefiniti.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4208">The following code example shows the use of the `Missing` field to invoke a method with its default arguments.</span></span>  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 <span data-ttu-id="4ee8d-4209">L'output del codice è il seguente:</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4209">This code produces the following output:</span></span>  
  
 <span data-ttu-id="4ee8d-4210">un = 10 b = 55,3 c = 12</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4210">a = 10 b = 55.3 c = 12</span></span>  
  
 <span data-ttu-id="4ee8d-4211">un = 10 b = 1.3 c = 1</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4211">a = 10 b = 1.3 c = 1</span></span>  
  
 <span data-ttu-id="4ee8d-4212">un = 10 b = 1.2. c = 1</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4212">a = 10 b = 1.2 c = 1</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-4213">Ottiene il modulo (DLL) in cui è definito l'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4213">Gets the module (the DLL) in which the current <see cref="T:System.Type" /> is defined.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-4214">Modulo in cui è definito l'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4214">The module in which the current <see cref="T:System.Type" /> is defined.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4215">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà restituisce il modulo in cui è stata definita la definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4215">If the current <xref:System.Type> represents a constructed generic type, this property returns the module in which the generic type definition was defined.</span></span> <span data-ttu-id="4ee8d-4216">Ad esempio, se si crea un'istanza di `MyGenericStack<int>`, il <xref:System.Type.Module%2A> proprietà per il tipo costruito restituisce il modulo in cui `MyGenericStack<T>` è definito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4216">For example, if you create an instance of `MyGenericStack<int>`, the <xref:System.Type.Module%2A> property for the constructed type returns the module in which `MyGenericStack<T>` is defined.</span></span>  
  
 <span data-ttu-id="4ee8d-4217">Analogamente, se l'oggetto corrente <xref:System.Type> rappresenta un parametro generico `T`, questa proprietà restituisce l'assembly che contiene il tipo generico che definisce `T`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4217">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-4218">Nell'esempio seguente viene illustrato un utilizzo del <xref:System.Type.Namespace%2A> e `Module` delle proprietà e il <xref:System.Type.ToString%2A> metodo <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4218">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and `Module` properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-4219">Ottiene lo spazio dei nomi dell'oggetto <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4219">Gets the namespace of the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-4220">Spazio dei nomi di <see cref="T:System.Type" />; <see langword="null" /> se l'istanza corrente non dispone di alcuno spazio dei nomi o rappresenta un parametro generico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4220">The namespace of the <see cref="T:System.Type" />; <see langword="null" /> if the current instance has no namespace or represents a generic parameter.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4221">Uno spazio dei nomi è utile denominazione in fase di progettazione logica, utilizzato principalmente per definire l'ambito in un'applicazione e organizzare le classi e altri tipi in una singola struttura gerarchica.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4221">A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure.</span></span> <span data-ttu-id="4ee8d-4222">Dal punto di vista del runtime, non ci sono spazi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4222">From the viewpoint of the runtime, there are no namespaces.</span></span>  
  
 <span data-ttu-id="4ee8d-4223">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico costruito, questa proprietà restituisce lo spazio dei nomi che contiene la definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4223">If the current <xref:System.Type> represents a constructed generic type, this property returns the namespace that contains the generic type definition.</span></span> <span data-ttu-id="4ee8d-4224">Analogamente, se l'oggetto corrente <xref:System.Type> rappresenta un parametro generico `T`, questa proprietà restituisce lo spazio dei nomi che contiene la definizione di tipo generico che definisce `T`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4224">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the namespace that contains the generic type definition that defines `T`.</span></span>  
  
 <span data-ttu-id="4ee8d-4225">Se l'oggetto corrente <xref:System.Type> oggetto rappresenta un parametro generico, questa proprietà restituisce `null`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4225">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-4226">Nell'esempio seguente viene illustrato un utilizzo del `Namespace` e <xref:System.Type.Module%2A> delle proprietà e il <xref:System.Type.ToString%2A> metodo <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4226">This following example demonstrates a use of the `Namespace` and <xref:System.Type.Module%2A> properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">
          <span data-ttu-id="4ee8d-4227">Specifica di nomi di tipo completi</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4227">Specifying Fully Qualified Type Names</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="4ee8d-4228">Primo oggetto da confrontare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4228">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="4ee8d-4229">Secondo oggetto da confrontare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4229">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-4230">Indica se due oggetti <see cref="T:System.Type" /> sono uguali.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4230">Indicates whether two <see cref="T:System.Type" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-4231">
            <see langword="true" /> se <paramref name="left" /> è uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4231">
              <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="4ee8d-4232">Primo oggetto da confrontare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4232">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="4ee8d-4233">Secondo oggetto da confrontare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4233">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-4234">Indica se due oggetti <see cref="T:System.Type" /> non sono uguali.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4234">Indicates whether two <see cref="T:System.Type" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-4235">
            <see langword="true" /> se <paramref name="left" /> non è uguale a <paramref name="right" />; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4235">
              <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-4236">Ottiene l'oggetto classe usato per ottenere questo membro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4236">Gets the class object that was used to obtain this member.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-4237">Oggetto <see langword="Type" /> tramite il quale è stato ottenuto questo oggetto <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4237">The <see langword="Type" /> object through which this <see cref="T:System.Type" /> object was obtained.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4238">Per la <xref:System.Type> oggetti, il valore di questa proprietà è sempre identico al valore della <xref:System.Type.DeclaringType%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4238">For <xref:System.Type> objects, the value of this property is always the same as the value of the <xref:System.Type.DeclaringType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-4239">Questo esempio visualizza il tipo riflesso di una classe annidata.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4239">This example displays the reflected type of a nested class.</span></span>  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="4ee8d-4240">Nome completo di assembly dell'oggetto <see cref="T:System.Type" /> da ottenere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4240">The assembly-qualified name of the <see cref="T:System.Type" /> to get.</span>
          </span>
        </param>
        <param name="throwIfNotFound">
          <span data-ttu-id="4ee8d-4241">
            <see langword="true" /> per generare un'eccezione <see cref="T:System.TypeLoadException" /> se non è possibile trovare il tipo, <see langword="false" /> per restituire <see langword="null" /> se non è possibile trovare il tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4241">
              <see langword="true" /> to throw a <see cref="T:System.TypeLoadException" /> if the type cannot be found; <see langword="false" /> to return <see langword="null" /> if the type cannot be found.</span>
          </span>
          <span data-ttu-id="4ee8d-4242">Se si specifica <see langword="false" /> vengono eliminate alcune condizioni di eccezione, ma non tutte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4242">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="4ee8d-4243">Vedere la sezione relativa alle eccezioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4243">See the Exceptions section.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="4ee8d-4244">
            <see langword="true" /> per eseguire una ricerca di <c>typeName</c> senza distinzione tra maiuscole e minuscole, <see langword="false" /> per eseguire una ricerca di <c>typeName</c> con distinzione tra maiuscole e minuscole.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4244">
              <see langword="true" /> to perform a case-insensitive search for <c>typeName</c>; <see langword="false" /> to perform a case-sensitive search for <c>typeName</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-4245">Ottiene l'oggetto <see cref="T:System.Type" /> con il nome specificato, indicando se eseguire una ricerca con distinzione tra maiuscole e minuscole e se generare un'eccezione in caso il tipo non venga trovato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4245">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found.</span>
          </span>
          <span data-ttu-id="4ee8d-4246">Il tipo viene caricato a scopo di reflection, non per l'esecuzione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4246">The type is loaded for reflection only, not for execution.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-4247">Tipo con il nome specificato, se presente; in caso contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4247">The type with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
          <span data-ttu-id="4ee8d-4248">Se il tipo non viene trovato, il parametro <paramref name="throwIfNotFound" /> specifica se viene restituito <see langword="null" /> o se viene generata un'eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4248">If the type is not found, the <paramref name="throwIfNotFound" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="4ee8d-4249">In alcuni casi, viene generata un'eccezione indipendentemente dal valore di <paramref name="throwIfNotFound" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4249">In some cases, an exception is thrown regardless of the value of <paramref name="throwIfNotFound" />.</span>
          </span>
          <span data-ttu-id="4ee8d-4250">Vedere la sezione relativa alle eccezioni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4250">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4251">Se l'assembly contenente il tipo non è già caricato nel contesto reflection-only, usando il <xref:System.Type.ReflectionOnlyGetType%2A> metodo è equivalente al primo caricamento dell'assembly per reflection, usando il <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> (metodo) e quindi il caricamento del tipo chiamando il dell'assembly <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4251">If the assembly containing the type is not already loaded into the reflection-only context, using the <xref:System.Type.ReflectionOnlyGetType%2A> method is equivalent to first loading the assembly for reflection only, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, and then loading the type by calling the assembly's <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4ee8d-4252">Per informazioni su nomi completi di assembly, vedere il <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4252">For information about assembly-qualified names, see the <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="4ee8d-4253">Per altre informazioni su come specificare i nomi dei tipi, vedere il <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4253">For additional details on specifying type names, see the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="4ee8d-4254">Se l'assembly è già caricato per l'esecuzione, un'altra copia viene caricata nel contesto reflection-only.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4254">If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.</span></span>  
  
 <span data-ttu-id="4ee8d-4255">Il `throwIfNotFound` parametro specifica che cosa avviene quando non viene trovato, il tipo e vengono eliminate alcune condizioni di eccezione, come descritto nella sezione delle eccezioni.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4255">The `throwIfNotFound` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="4ee8d-4256">Alcune eccezioni vengono generate indipendentemente dal valore di `throwIfNotFound`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4256">Some exceptions are thrown regardless of the value of `throwIfNotFound`.</span></span> <span data-ttu-id="4ee8d-4257">Se l'assembly non è valido, ad esempio un <xref:System.BadImageFormatException> viene generata anche se `throwIfNotFound` è `false`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4257">For example, if the assembly is not valid, a <xref:System.BadImageFormatException> is thrown even if `throwIfNotFound` is `false`.</span></span>  
  
 <span data-ttu-id="4ee8d-4258">Per altre informazioni sull'utilizzo del contesto reflection-only, vedere [procedura: caricare assembly nel contesto Reflection-only](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4258">For more information about using the reflection-only context, see [How to: Load Assemblies into the Reflection-Only Context](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4ee8d-4259">
            <paramref name="typeName" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4259">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="4ee8d-4260">Viene richiamato un inizializzatore di classi e viene generata un'eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4260">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="4ee8d-4261">
            <paramref name="throwIfNotFound" /> è <see langword="true" /> e il tipo non è stato trovato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4261">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="4ee8d-4262">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4262">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-4263">
            <paramref name="throwIfNotFound" /> è <see langword="true" /> e <paramref name="typeName" /> contiene caratteri non validi, ad esempio una scheda incorporata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4263">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="4ee8d-4264">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4264">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-4265">
            <paramref name="throwIfNotFound" /> è <see langword="true" /> e <paramref name="typeName" /> è una stringa vuota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4265">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="4ee8d-4266">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4266">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-4267">
            <paramref name="throwIfNotFound" /> è <see langword="true" /> e <paramref name="typeName" /> rappresenta un tipo di matrice con una dimensione non valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4267">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="4ee8d-4268">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4268">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-4269">
            <paramref name="typeName" /> rappresenta una matrice di oggetti <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4269">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" /> objects.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="4ee8d-4270">
            <paramref name="typeName" /> non include il nome dell'assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4270">
              <paramref name="typeName" /> does not include the assembly name.</span>
          </span>
          <span data-ttu-id="4ee8d-4271">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4271">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-4272">
            <paramref name="throwIfNotFound" /> è <see langword="true" /> e <paramref name="typeName" /> contiene sintassi non valida, ad esempio "MyType[,\*,]".</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4272">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax; for example, "MyType[,\*,]".</span>
          </span>
          <span data-ttu-id="4ee8d-4273">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4273">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-4274">
            <paramref name="typeName" /> rappresenta un tipo generico che ha un tipo di puntatore, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> tra i relativi argomenti di tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4274">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="4ee8d-4275">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4275">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-4276">
            <paramref name="typeName" /> rappresenta un tipo generico che ha un numero errato di argomenti di tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4276">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="4ee8d-4277">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4277">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-4278">
            <paramref name="typeName" /> rappresenta un tipo generico e uno dei relativi argomenti di tipo non soddisfa i vincoli per il parametro di tipo corrispondente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4278">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="4ee8d-4279">
            <paramref name="throwIfNotFound" /> è <see langword="true" /> e l'assembly o una delle sue dipendenze non è stato trovato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4279">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="4ee8d-4280">L'assembly o una delle relative dipendenze è stato trovato, ma non può essere caricato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4280">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="4ee8d-4281">L'assembly o una delle relative dipendenze non è valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4281">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="4ee8d-4282">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4282">-or-</span>
          </span>
          <span data-ttu-id="4ee8d-4283">L'assembly è stato compilato con una versione successiva di Common Language Runtime rispetto alla versione attualmente caricata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4283">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">
          <span data-ttu-id="4ee8d-4284">Specifica di nomi di tipo completi</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4284">Specifying Fully Qualified Type Names</span>
          </span>
        </related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md">
          <span data-ttu-id="4ee8d-4285">Procedura: caricare assembly nel contesto Reflection-Only</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4285">How to: Load Assemblies into the Reflection-Only Context</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-4286">Ottiene una classe <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> che descrive il layout del tipo corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4286">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the layout of the current type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-4287">Ottiene una classe <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> che descrive le caratteristiche complessive di layout del tipo corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4287">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the gross layout features of the current type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4288"><xref:System.Runtime.InteropServices.StructLayoutAttribute> non viene restituito dal <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4288"><xref:System.Runtime.InteropServices.StructLayoutAttribute> is not returned by the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method.</span></span> <span data-ttu-id="4ee8d-4289">In alternativa, usare questa proprietà per ottenerla.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4289">Instead, use this property to get it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-4290">Esempio di codice seguente definisce prima di tutto una classe, una struttura e una struttura con attributi di layout speciale (le strutture sono annidate all'interno della classe).</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4290">The following code example first defines a class, a structure, and a structure with special layout attributes (the structures are nested within the class).</span></span> <span data-ttu-id="4ee8d-4291">Nell'esempio viene utilizzata la <xref:System.Type.StructLayoutAttribute%2A> proprietà per ottenere un <xref:System.Runtime.InteropServices.StructLayoutAttribute> per ogni tipo e consente di visualizzare le proprietà degli attributi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4291">The example then uses the <xref:System.Type.StructLayoutAttribute%2A> property to obtain a <xref:System.Runtime.InteropServices.StructLayoutAttribute> for each type, and displays the properties of the attributes.</span></span>  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="4ee8d-4292">Il metodo richiamato non è supportato nella classe base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4292">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="4ee8d-4293">Riservato per utilizzi futuri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4293">Reserved for future use.</span>
          </span>
          <span data-ttu-id="4ee8d-4294">Deve essere IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4294">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="4ee8d-4295">Matrice di nomi passata di cui eseguire il mapping.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4295">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="4ee8d-4296">Conteggio dei nomi di cui eseguire il mapping.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4296">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="4ee8d-4297">Contesto delle impostazioni locali in cui interpretare i nomi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4297">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="4ee8d-4298">Matrice allocata dal chiamante che riceve gli ID corrispondenti ai nomi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4298">Caller-allocated array which receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-4299">Esegue il mapping di un set di nomi a un set corrispondente di ID dispatch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4299">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4300">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4300">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="4ee8d-4301">Per altre informazioni sulle `IDispatch::GetIDsOfNames`, consultare la MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4301">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="4ee8d-4302">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4302">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="4ee8d-4303">Informazioni sul tipo da restituire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4303">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="4ee8d-4304">Identificatore delle impostazioni locali per le informazioni sul tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4304">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="4ee8d-4305">Puntatore all'oggetto di informazioni sul tipo richiesto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4305">A pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-4306">Recupera le informazioni sul tipo relative a un oggetto che può quindi essere usato per ottenere informazioni sul tipo relative a un'interfaccia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4306">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4307">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4307">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="4ee8d-4308">Per altre informazioni sulle `IDispatch::GetTypeInfo`, consultare la MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4308">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="4ee8d-4309">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4309">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="4ee8d-4310">Punta a una posizione che riceve il numero di interfacce di informazioni sul tipo fornite dall'oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4310">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-4311">Recupera il numero delle interfacce di informazioni sul tipo fornite da un oggetto (0 o 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4311">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4312">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4312">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="4ee8d-4313">Per altre informazioni sulle `IDispatch::GetTypeInfoCount`, consultare la MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4313">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="4ee8d-4314">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4314">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="4ee8d-4315">Identifica il membro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4315">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="4ee8d-4316">Riservato per utilizzi futuri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4316">Reserved for future use.</span>
          </span>
          <span data-ttu-id="4ee8d-4317">Deve essere IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4317">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="4ee8d-4318">Contesto di impostazioni locali all'interno del quale devono essere interpretati gli argomenti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4318">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="4ee8d-4319">Flag che descrivono il contesto della chiamata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4319">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="4ee8d-4320">Puntatore a una struttura contenente una matrice di argomenti, una matrice di DISPID per argomenti denominati e i conteggi del numero di elementi nelle matrici.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4320">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="4ee8d-4321">Puntatore alla posizione in cui deve essere archiviato il risultato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4321">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="4ee8d-4322">Puntatore a una struttura contenente informazioni sull'eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4322">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="4ee8d-4323">Indice del primo argomento che contiene un errore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4323">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4ee8d-4324">Fornisce l'accesso a proprietà e metodi esposti da un oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4324">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4325">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4325">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="4ee8d-4326">Per altre informazioni sulle `IDispatch::Invoke`, consultare la MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4326">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="4ee8d-4327">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4327">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-4328">Restituisce un valore <see langword="String" /> che rappresenta il nome del <see langword="Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4328">Returns a <see langword="String" /> representing the name of the current <see langword="Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4ee8d-4329">Oggetto <see cref="T:System.String" /> che rappresenta il nome dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4329">A <see cref="T:System.String" /> representing the name of the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4330">Questo metodo restituisce il nome completo common language runtime lo spazio dei nomi e il nome per tutti i tipi primitivi.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4330">This method returns the fully qualified common language runtime namespace and name for all primitive types.</span></span> <span data-ttu-id="4ee8d-4331">Ad esempio, l'istruzione c#, `(long)0.Type().ToString()` restituisce "System.Int64" anziché semplicemente "Int64".</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4331">For example, the C# instruction, `(long)0.Type().ToString()` returns "System.Int64" instead of merely "Int64".</span></span>  
  
 <span data-ttu-id="4ee8d-4332">Se l'oggetto corrente <xref:System.Type> rappresenta un tipo generico, il tipo e i relativi argomenti di tipo sono qualificati dallo spazio dei nomi e dal tipo annidato, ma non dall'assembly.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4332">If the current <xref:System.Type> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly.</span></span> <span data-ttu-id="4ee8d-4333">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo generico o metodo generico, questo metodo restituisce il nome non qualificato del parametro di tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4333">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-4334">Nell'esempio seguente viene illustrato un utilizzo del <xref:System.Type.Namespace%2A> e <xref:System.Type.Module%2A> delle proprietà e il `ToString` metodo <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4334">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and <xref:System.Type.Module%2A> properties and the `ToString` method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 <span data-ttu-id="4ee8d-4335">Nell'esempio seguente vengono confrontate le stringhe restituite dal <xref:System.Type.ToString%2A> metodo e il `Name`, <xref:System.Type.FullName%2A>, e <xref:System.Type.AssemblyQualifiedName%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4335">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-4336">che rappresenta il nome dell'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4336">Gets the handle for the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-4337">Handle per l'oggetto <see cref="T:System.Type" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4337">The handle for the current <see cref="T:System.Type" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4338">`TypeHandle` Incapsula un puntatore a una struttura dati interna che rappresenta il tipo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4338">`TypeHandle` encapsulates a pointer to an internal data structure that represents the type.</span></span> <span data-ttu-id="4ee8d-4339">Questo handle è univoco nel corso della durata del processo.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4339">This handle is unique during the process lifetime.</span></span> <span data-ttu-id="4ee8d-4340">L'handle è valido solo nel dominio dell'applicazione in cui è stato ottenuto.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4340">The handle is valid only in the application domain in which it was obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4ee8d-4341">Nell'esempio seguente restituisce l'handle del tipo corrispondente e passa l'handle a un metodo che ottiene il tipo dal punto di controllo e lo visualizza.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4341">The following example returns the handle of the corresponding type and passes the handle to a method that gets the type from the handle and displays it.</span></span>  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="4ee8d-4342">Questa proprietà non è attualmente supportata in .NET Compact Framework.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4342">The .NET Compact Framework does not currently support this property.</span>
          </span>
        </exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-4343">Ottiene l'inizializzatore per il tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4343">Gets the initializer for the type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-4344">Oggetto che contiene il nome del costruttore di classe per l'oggetto <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4344">An object that contains the name of the class constructor for the <see cref="T:System.Type" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4ee8d-4345">Gli inizializzatori di classi sono disponibili anche tramite il <xref:System.Type.FindMembers%2A> metodo, o tramite gli overload del <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, e <xref:System.Type.GetConstructors%2A> metodi che accettano <xref:System.Reflection.BindingFlags> come parametro.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4345">Class initializers are also available through the <xref:System.Type.FindMembers%2A> method, or through overloads of the <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, and <xref:System.Type.GetConstructors%2A> methods that take <xref:System.Reflection.BindingFlags> as a parameter.</span></span>  
  
 <span data-ttu-id="4ee8d-4346">Se l'oggetto corrente <xref:System.Type> rappresenta un parametro di tipo nella definizione di un tipo o metodo generico, questa proprietà restituisce `null`.</span><span class="sxs-lookup"><span data-stu-id="4ee8d-4346">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4ee8d-4347">Indica il tipo fornito da Common Language Runtime che rappresenta questo tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4347">Indicates the type provided by the common language runtime that represents this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4ee8d-4348">Tipo di sistema sottostante per l'oggetto <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4ee8d-4348">The underlying system type for the <see cref="T:System.Type" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>