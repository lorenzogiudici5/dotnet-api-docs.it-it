<Type Name="String" FullName="System.String">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="13166f4319f43d09858115b7de7824cc8b38e13e" />
    <Meta Name="ms.sourcegitcommit" Value="ad09e88f48ca55b181e8d272cfc3742eadc3f939" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/08/2018" />
    <Meta Name="ms.locfileid" Value="35231216" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta il testo come sequenza di unità di codice UTF-16.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Una stringa è una raccolta sequenziale di caratteri utilizzato per rappresentare del testo. Oggetto <xref:System.String> oggetto è una raccolta sequenziale di <xref:System.Char?displayProperty=nameWithType> gli oggetti che rappresentano una stringa, un <xref:System.Char?displayProperty=nameWithType> oggetto corrisponde a un'unità di codice UTF-16. Il valore di <xref:System.String> oggetto è il contenuto della raccolta sequenziale di <xref:System.Char?displayProperty=nameWithType> oggetti e che il valore è non modificabile (ovvero, è in sola lettura). Per ulteriori informazioni sull'immutabilità delle stringhe, vedere il [immutabilità e della classe StringBuilder](#Immutability) sezione più avanti in questo argomento. Le dimensioni massime di un <xref:System.String> oggetto in memoria è 2 GB o circa 1 miliardo caratteri.  
  
 Contenuto della sezione:  
  
 [Creazione di un oggetto String](#Instantiation)   
 [Oggetti char e caratteri Unicode](#Characters)   
 [Le stringhe e lo Standard Unicode](#Unicode)   
 [Le stringhe e caratteri null incorporati](#EmbeddedNulls)   
 [Le stringhe e indici](#Indexes)   
 [Le stringhe null e stringhe vuote](#Nulls)   
 [Immutabilità e della classe StringBuilder](#Immutability)   
 [Numero ordinale di operazioni dipendenti dalle impostazioni cultura](#CultureSensitive)   
 [Normalizzazione](#Normalization)   
 [Operazioni su stringhe per categoria](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>Creazione di un oggetto String  
 È possibile creare un'istanza di un <xref:System.String> oggetto nei modi seguenti:  
  
-   Assegnando una valore letterale stringa a un <xref:System.String> variabile. Questo è il metodo più comunemente usato per la creazione di una stringa. Nell'esempio seguente usa l'assegnazione per creare più stringhe. Si noti che in c#, perché la barra rovesciata (\\) è un carattere di escape, deve usare caratteri di escape barra rovesciata letterale in una stringa o l'intera stringa deve essere @-quoted.  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   Chiamando un <xref:System.String> costruttore della classe. Nell'esempio seguente viene creata un'istanza di stringhe chiamando diversi costruttori di classe. Si noti che alcuni costruttori includono puntatori a matrici di caratteri o matrici di byte con segno come parametri. Visual Basic non supporta le chiamate a questi costruttori. Per informazioni dettagliate su <xref:System.String> costruttori, vedere il <xref:System.String.%23ctor%2A> costruttore riepilogo.  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   Utilizzando l'operatore di concatenazione di stringhe (+ in c# e & o + in Visual Basic) per creare una singola stringa da qualsiasi combinazione di <xref:System.String> istanze e i valori letterali stringa. Nell'esempio seguente viene illustrato l'utilizzo dell'operatore di concatenazione di stringhe.  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   Recupero di una proprietà o chiamando un metodo che restituisce una stringa. L'esempio seguente usa i metodi del <xref:System.String> classe per estrarre una sottostringa da una stringa più grande.  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   Chiamando un metodo di formattazione per convertire un valore o un oggetto nella relativa rappresentazione di stringa. L'esempio seguente usa il [formattazione composita](~/docs/standard/base-types/composite-formatting.md) funzionalità per incorporare la rappresentazione di stringa di due oggetti in una stringa.  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>Oggetti char e caratteri Unicode  
 Ogni carattere in una stringa è definito da un valore scalare Unicode, definito anche come un punto di codice Unicode o il valore ordinale (numerico) del carattere Unicode. Ogni punto di codice verrà codificato utilizzando la codifica UTF-16 e il valore numerico di ogni elemento della codifica è rappresentato da un <xref:System.Char> oggetto.  
  
> [!NOTE]
>  Si noti che, poiché un <xref:System.String> istanza è costituita da una raccolta sequenziale di unità di codice UTF-16, è possibile creare un <xref:System.String> oggetto che non è una stringa Unicode in formato corretto. Ad esempio, è possibile creare una stringa che contiene un surrogato basso senza un surrogato alto corrispondente. Anche se alcuni metodi, ad esempio i metodi di codifica e decodifica gli oggetti di <xref:System.Text> dello spazio dei nomi, potrebbe esegue i controlli per assicurarsi che le stringhe siano in formato corretto, <xref:System.String> i membri di classe non garantiscono che una stringa è ben formata.  
  
 Un singolo <xref:System.Char> oggetto in genere rappresenta un singolo punto di codice, vale a dire il valore numerico del <xref:System.Char> è uguale al punto di codice. Ad esempio, il punto di codice per il carattere "a" è U + 0061. Tuttavia, un punto di codice potrebbe richiedere più di un elemento codificato (più <xref:System.Char> oggetto). Lo standard Unicode definisce due tipi di caratteri che corrispondono a più <xref:System.Char> oggetti: grafema e punti di codice supplementari Unicode che corrispondono ai caratteri nei piani supplementari Unicode.  
  
-   Un grafemi sono rappresentato da un carattere di base seguito da uno o più caratteri di combinazione. Ad esempio, il carattere ä è rappresentato da un <xref:System.Char> il cui punto di codice è U + 0061 seguito da un oggetto <xref:System.Char> oggetto il cui punto di codice è U + 0308. Questo carattere può essere definito anche da un singolo <xref:System.Char> oggetto con un punto di codice di U + 00E4. Come illustrato nell'esempio seguente, un confronto con distinzione delle impostazioni cultura per verificarne l'uguaglianza indica che le due rappresentazioni sono uguali, anche se non esegue un confronto ordinale comune. Tuttavia, se le due stringhe sono normalizzate, un confronto ordinale anche indica che sono uguali. (Per ulteriori informazioni sulla normalizzazione di stringhe, vedere il [normalizzazione](#Normalization) sezione.)  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   Unicode punto di codice supplementare (una coppia di surrogati) è rappresentato da un <xref:System.Char> oggetto il cui punto di codice è un surrogato alto seguito da un <xref:System.Char> oggetto il cui punto di codice è un surrogato basso. Le unità di codice di surrogati alti compreso tra U + D800 e U + DBFF. Le unità di codice di surrogati bassi compreso tra U + DC00 e U + DFFF. Le coppie di surrogati vengono utilizzate per rappresentare i caratteri nei piani supplementari Unicode 16. Nell'esempio seguente viene creato un carattere surrogato e lo passa al <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> metodo per determinare se si tratta di una coppia di surrogati.  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>Le stringhe e lo Standard Unicode  
 In una stringa di caratteri sono rappresentati dalle unità di codice codificata UTF-16, che corrisponde a <xref:System.Char> valori.  
  
 Ogni carattere in una stringa è una categoria di caratteri Unicode associata, che viene rappresentata in .NET Framework per il <xref:System.Globalization.UnicodeCategory> enumerazione. La categoria di un carattere o una coppia di surrogati può essere determinata chiamando il <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> metodo.  
  
 .NET gestisce la propria tabella di caratteri e le rispettive categorie corrispondente, che assicura che una versione specifica di un'implementazione di .NET in esecuzione su piattaforme diverse restituisce informazioni sulle categorie di caratteri identici. La tabella seguente elenca le versioni di .NET e le versioni di Unicode Standard in cui sono in base alle categorie di caratteri.  
  
|Versione di .NET Framework|Versione dello Standard Unicode|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[Lo Standard Unicode, versione 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[Lo Standard Unicode, versione 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[Lo Standard Unicode, versione 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[Lo Standard Unicode, versione 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]|[Lo Standard Unicode, versione 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v451](~/includes/net-v451-md.md)]|[Lo Standard Unicode, versione 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v452](~/includes/net-v452-md.md)]|[Lo Standard Unicode, versione 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v46](~/includes/net-v46-md.md)]|[Lo Standard Unicode, versione 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v461](~/includes/net-v461-md.md)]|[Lo Standard Unicode, versione 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v462](~/includes/net-v462-md.md)]|[Lo Standard Unicode, versione 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/)|  
|.NET core (tutte le versioni)|[Lo Standard Unicode, versione 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/)|
  
 Inoltre, .NET Framework supporta il confronto di stringa e ordinamento in base allo standard Unicode. Nelle versioni di .NET Framework tramite il [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], .NET Framework gestisce la propria tabella di dati stringa. Ciò vale anche delle versioni di .NET Framework a partire dal [!INCLUDE[net_v45](~/includes/net-v45-md.md)] in esecuzione in Windows 7. A partire dal [!INCLUDE[net_v45](~/includes/net-v45-md.md)] i delegati di runtime in esecuzione in Windows 8 e versioni successive del sistema operativo Windows, stringa di confronto e ordinamento di operazioni al sistema operativo. La tabella seguente elenca le versioni di .NET Framework e le versioni dello Unicode Standard su quale carattere si basano confronto e ordinamento.  
  
|Versione di .NET Framework|Versione dello Standard Unicode|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[Lo Standard Unicode, versione 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[Lo Standard Unicode, versione 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[Lo Standard Unicode, versione 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[Lo Standard Unicode, versione 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] e versioni successive in Windows 7|[Lo Standard Unicode, versione 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] e versioni successive in Windows 8 e versioni successive i sistemi operativi Windows|[Lo Standard Unicode, versione 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  

In .NET Core, si basano le operazioni di ordinamento e confronto [versione 8.0.0 dello Unicode Standard](https://www.unicode.org/versions/Unicode8.0.0/).

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>Le stringhe e caratteri null incorporati  
 In .NET Framework, un <xref:System.String> l'oggetto può includere caratteri null incorporati vengono contati come parte di lunghezza della stringa. Tuttavia, in alcune lingue, ad esempio C e C++, un carattere null indica la fine di una stringa, ma non viene considerato parte della stringa e non viene contato come parte della lunghezza della stringa. Ciò significa che i seguenti presupposti comuni che potrebbero risultare ai programmatori di C e C++ o in librerie scritte in C o C++ sulle stringhe non sono necessariamente validi quando applicato a <xref:System.String> oggetti:  
  
-   Il valore restituito dal `strlen` o `wcslen` funzioni non è necessariamente uguale <xref:System.String.Length%2A?displayProperty=nameWithType>.  
  
-   La stringa creata mediante il `strcpy_s` o `wcscpy_s` funzioni non è necessariamente identico alla stringa creata dal <xref:System.String.Copy%2A?displayProperty=nameWithType> (metodo).  
  
 È necessario assicurarsi che C e C++ il codice nativo che crea un'istanza <xref:System.String> oggetti e il codice che viene passato <xref:System.String> oggetti mediante platform invoke, non presupporre che un carattere null incorporato contrassegna la fine della stringa.  
  
 Caratteri null incorporati in una stringa sono inoltre trattati in modo diverso quando è una stringa ordinata (o confrontata) e quando viene eseguita la ricerca di una stringa. Caratteri null vengono ignorati quando si eseguono confronti dipendenti dalle impostazioni cultura tra due stringhe, inclusi i confronti usando la lingua inglese. Vengono considerati solo per i confronti ordinali ordinali o tra maiuscole e minuscole. D'altra parte, i caratteri null incorporati vengono sempre considerati durante la ricerca di una stringa con metodi come <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, e <xref:System.String.IndexOf%2A>.  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>Le stringhe e indici  
 Un indice è la posizione di un <xref:System.Char> oggetto (non un carattere Unicode) in un <xref:System.String>. Un indice è un numero non negativo in base zero che inizia dalla prima posizione nella stringa, ovvero la posizione di indice zero. Un numero di metodi di ricerca, ad esempio <xref:System.String.IndexOf%2A> e <xref:System.String.LastIndexOf%2A>, restituisce l'indice di un carattere o una sottostringa nell'istanza di stringa.  
  
 Il <xref:System.String.Chars%2A> proprietà consente di accedere a singoli <xref:System.Char> oggetti in base alla posizione nella stringa di indice. Poiché il <xref:System.String.Chars%2A> è la proprietà predefinita (in Visual Basic) o l'indicizzatore (in c#), è possibile accedere ai singoli <xref:System.Char> oggetti in una stringa utilizzando codice simile al seguente. Questo codice cerca gli spazi vuoti o punteggiatura in una stringa per determinare la stringa contiene il numero di parole.  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 Perché il <xref:System.String> classe implementa il <xref:System.Collections.IEnumerable> interfaccia, è anche possibile scorrere il <xref:System.Char> oggetti in una stringa con un `foreach` costrutto, come illustrato nell'esempio seguente.  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 I valori di indice consecutive potrebbero non corrispondere ai caratteri Unicode consecutivi, dal momento che un carattere Unicode può essere codificato in più di un <xref:System.Char> oggetto. In particolare, una stringa può contenere più caratteri unità di testo che sono costituite da un carattere di base seguito da uno o più caratteri di unione o da coppie di surrogati. Per utilizzare i caratteri Unicode anziché <xref:System.Char> oggetti, utilizzare il <xref:System.Globalization.StringInfo?displayProperty=nameWithType> e <xref:System.Globalization.TextElementEnumerator> classi. Nell'esempio seguente viene illustrata la differenza tra il codice che interagisce con <xref:System.Char> oggetti e il codice che funziona con i caratteri Unicode. Confronta il numero di caratteri o elementi di testo di ogni parola di una frase. La stringa include due sequenze di un carattere di base seguiti da un carattere di combinazione.  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 In questo esempio funziona con elementi di testo utilizzando il <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> (metodo) e <xref:System.Globalization.TextElementEnumerator> classe per enumerare tutti gli elementi di testo in una stringa. È inoltre possibile recuperare una matrice che contiene l'indice iniziale di ogni elemento di testo chiamando il <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> metodo.  
  
 Per ulteriori informazioni sull'utilizzo di unità di testo anziché singoli <xref:System.Char> valori, vedere la <xref:System.Globalization.StringInfo> classe.  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>Le stringhe null e stringhe vuote  
 È una stringa che è stata dichiarata ma non è stata assegnata un valore `null`. Il tentativo di chiamare metodi su quella stringa genera un <xref:System.NullReferenceException>. Una stringa null è diversa da una stringa vuota, che è una stringa il cui valore è "" o <xref:System.String.Empty?displayProperty=nameWithType>. In alcuni casi, passando una stringa null o una stringa vuota come argomento in una chiamata al metodo genera un'eccezione. Ad esempio, passare una stringa null per il <xref:System.Int32.Parse%2A?displayProperty=nameWithType> metodo genera un <xref:System.ArgumentNullException>e passando una stringa vuota genera un <xref:System.FormatException>. In altri casi, un argomento del metodo può essere una stringa null o una stringa vuota. Ad esempio, se si fornisce un <xref:System.IFormattable> implementazione per una classe, che si desidera compensare sia una stringa null e una stringa vuota con l'identificatore di formato generale ("G").  
  
 Il <xref:System.String> classe include i seguenti due metodi pratici che consentono di verificare se è una stringa `null` o vuoto:  
  
-   <xref:System.String.IsNullOrEmpty%2A>, che indica se una stringa è `null` o è uguale a <xref:System.String.Empty?displayProperty=nameWithType>. Questo metodo elimina la necessità di usare codice analogo al seguente:  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>, che indica se una stringa è `null`, è uguale a <xref:System.String.Empty?displayProperty=nameWithType>, o composto solo da spazi vuoti. Questo metodo elimina la necessità di usare codice analogo al seguente:  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 L'esempio seguente usa il <xref:System.String.IsNullOrEmpty%2A> metodo il <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementazione di un oggetto personalizzato `Temperature` classe. Il metodo supporta le stringhe di formato "G", "C", "F" e "K". Se una stringa di formato vuoto o un formato stringa il cui valore è `null` viene passato al metodo, il valore viene modificato per la stringa di formato "G".  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>Immutabilità e della classe StringBuilder  
 Oggetto <xref:System.String> oggetto viene chiamato non modificabile (sola lettura), perché il relativo valore non può essere modificato dopo che è stato creato. Metodi che vengono visualizzati per modificare un <xref:System.String> oggetto restituiscono in realtà un nuovo <xref:System.String> oggetto che contiene la modifica.  
  
 Poiché le stringhe non sono modificabili, routine di modifica di stringhe che eseguono aggiunte o eliminazioni ripetute a quello che sembra essere che una singola stringa possa esatte una riduzione significativa delle prestazioni. Ad esempio, il codice seguente viene utilizzato un generatore di numeri casuali per creare una stringa con 1000 caratteri nell'intervallo 0x0001 a 0x052F. Anche se il codice sembra utilizzare concatenazione di stringhe per aggiungere un carattere di nuova stringa esistente denominata `str`, effettivamente crea un nuovo <xref:System.String> oggetto per ogni operazione di concatenazione.  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 È possibile utilizzare il <xref:System.Text.StringBuilder> classe anziché la <xref:System.String> classe per le operazioni che modificano più il valore di una stringa. A differenza delle istanze di <xref:System.String> (classe), <xref:System.Text.StringBuilder> gli oggetti sono modificabili, quando si concatenano, aggiungere o eliminare sottostringhe da una stringa, le operazioni vengono eseguite su una singola stringa. Una volta terminata la modifica del valore di un <xref:System.Text.StringBuilder> dell'oggetto, è possibile chiamare il relativo <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> metodo per convertirlo in una stringa. Nell'esempio seguente sostituisce il <xref:System.String> utilizzato nell'esempio precedente per concatenare 1000 caratteri casuali nell'intervallo da 0x0001 a 0x052F con un <xref:System.Text.StringBuilder> oggetto.  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>Numero ordinale di operazioni dipendenti dalle impostazioni cultura  
 I membri del <xref:System.String> classe operazioni ordinali o dipendenti dalle impostazioni cultura (linguistiche) su un <xref:System.String> oggetto. Viene eseguita un'operazione ordinale al valore numerico di ogni <xref:System.Char> oggetto. Un'operazione di distinzione delle impostazioni cultura, agisce sul valore della <xref:System.String> , oggetto e maiuscole e minuscole delle impostazioni cultura specifiche accetta, ordinamento, la formattazione e le regole di analisi in considerazione. Operazioni dipendenti dalle impostazioni cultura vengono eseguite nel contesto di una lingua dichiarata in modo esplicito o implicita impostazioni cultura correnti. I due tipi di operazioni possono produrre risultati molto diversi quando vengono eseguiti sulla stessa stringa.  
  
 .NET Framework supporta anche le operazioni di stringhe linguistico indipendente dalle impostazioni cultura usando la lingua inglese (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), che si basa fortemente alle impostazioni cultura della lingua inglese indipendente dell'area. A differenza degli altri <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> impostazioni, le impostazioni della lingua inglese è garantite per mantenere la coerenza in un singolo computer, dal sistema al sistema e in tutte le versioni di .NET Framework. Le impostazioni cultura invarianti possono essere considerata come un tipo di casella nera che assicura la stabilità dei confronti tra stringhe e ordinamento tra tutte le impostazioni cultura.  
  
> [!IMPORTANT]
>  Se l'applicazione effettua una decisione di sicurezza su un identificatore simbolico, ad esempio un nome di file o sulla named pipe o sui dati persistenti, ad esempio i dati basati su testo in un file XML, l'operazione deve utilizzare un confronto ordinale anziché un confronto con distinzione delle impostazioni cultura. In questo modo un confronto con distinzione delle impostazioni cultura può restituire risultati diversi a seconda delle impostazioni cultura in effetti, mentre un confronto ordinale dipende esclusivamente dal valore binario dei caratteri confrontati.  
  
> [!IMPORTANT]
>  La maggior parte dei metodi che eseguono operazioni di stringa includono un overload che dispone di un parametro di tipo <xref:System.StringComparison>, che consente di specificare se il metodo esegue un'operazione ordinale o dipendenti dalle impostazioni cultura. In generale, è necessario chiamare questo overload per rendere lo scopo del metodo di chiamata non crittografato. Per procedure consigliate e indicazioni per l'utilizzo di numeri ordinali e cultura operazioni sulle stringhe, vedere [procedure consigliate per l'uso di stringhe](~/docs/standard/base-types/best-practices-strings.md).  
  
 Operazioni per [maiuscole e minuscole](#casing), [l'analisi e formattazione](#parsing), [confronto e ordinamento](#comparison), e [la verifica dell'uguaglianza](#equality) possono essere ordinali o dipendenti dalle impostazioni cultura. Le sezioni seguenti illustrano ogni categoria di operazione.  
  
> [!TIP]
>  È sempre necessario chiamare un overload del metodo che esegue lo scopo del metodo di chiamata non crittografato. Ad esempio, anziché chiamare il <xref:System.String.Compare%28System.String%2CSystem.String%29> metodo per eseguire un confronto con distinzione delle impostazioni cultura di due stringhe utilizzando le convenzioni delle impostazioni cultura correnti, è necessario chiamare il <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metodo con un valore di <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> per il `comparisonType` argomento. Per altre informazioni, vedere [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md) (Procedure consigliate per l'uso di stringhe).  
  
<a name="casing"></a>   
### <a name="casing"></a>Maiuscole e minuscole  
 Le regole di maiuscole e minuscole determinano come modificare le lettere maiuscole di un carattere Unicode; ad esempio, da minuscolo a maiuscolo. Spesso, prima di un confronto tra stringhe viene eseguita un'operazione di maiuscole e minuscole. Una stringa, ad esempio, potrebbe essere convertita in caratteri maiuscoli in modo che può essere confrontato con un'altra stringa in caratteri maiuscoli. È possibile convertire i caratteri in una stringa in minuscolo chiamando il <xref:System.String.ToLower%2A> o <xref:System.String.ToLowerInvariant%2A> metodo ed è possibile eseguirne la conversione in maiuscolo chiamando il <xref:System.String.ToUpper%2A> o <xref:System.String.ToUpperInvariant%2A> metodo. Inoltre, è possibile utilizzare il <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> metodo per convertire una stringa in maiuscole.  
  
 Le operazioni di maiuscole e minuscole possono essere basate sulle regole di impostazioni cultura correnti, impostazioni cultura specifiche o le impostazioni cultura invarianti. Poiché il mapping di maiuscole e può variare a seconda delle impostazioni cultura utilizzate, il risultato delle operazioni di maiuscole e minuscole può variare in base alle impostazioni cultura. Le differenze nelle maiuscole e minuscole effettivi sono tre tipi:  
  
-   Le differenze nel mapping di maiuscole dell'ALFABETO LATINO I (U + 0049), LATIN SMALL lettera I (U + 0069), LATIN CAPITAL LETTER I con punto sopra (U + 0130) e LATIN SMALL lettera punto I (U + 0131). Tr-TR (Turco (Turchia)) e le impostazioni cultura az-Latn-AZ (Azerbaigian, alfabeto latino), tr, az e az-Latn neutre, equivalente in caratteri minuscoli dell'ALFABETO LATINO I è LATIN SMALL lettera punto I ed equivalente in caratteri maiuscoli dell'alfabeto LATINO SMALL lettera I è LATIN CAPITAL LETTER I con punto superiore. In tutte le altre lingue, incluse le impostazioni cultura invarianti, LATIN SMALL lettera I e lettera latina a maiuscola I sono equivalenti in lettere minuscole e maiuscole.  
  
     Nell'esempio seguente viene illustrato come un confronto tra stringhe progettato per impedire l'accesso al file system può non riuscire se si basa su un confronto tra maiuscole e minuscole delle impostazioni cultura. (Le convenzioni delle impostazioni cultura invarianti devono sono state utilizzate.)  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   Mapping di maiuscole e differenze tra le impostazioni cultura invarianti e tutte le altre impostazioni cultura. In questi casi, usando le regole di maiuscole e minuscole delle impostazioni cultura invarianti per modificare un carattere in maiuscolo o minuscolo restituisce lo stesso carattere. Per tutte le altre lingue, restituisce un carattere diverso. Nella tabella seguente sono elencati alcuni dei caratteri interessati.  
  
    |Carattere|Se impostata su|Valore restituito|  
    |---------------|-------------------|-------------|  
    |SIGN MICRON (U + 00B5)|Maiuscole|LETTERA GRECA MAIUSCOLA MU (U +-39C)|  
    |LATINO CON PUNTO SOPRA (U + 0130)|Minuscole|LATINO (U + 0069)|  
    |CARATTERE ALFABETO SI (U + 0131)|Maiuscole|LATINO (U + 0049)|  
    |CARATTERE ALFABETO LATINO (U + 017F)|Maiuscole|LATIN CAPITAL LETTER S (U + 0053)|  
    |LETTERA DI CAPITALE LATINO D CON Z ALFABETO LATINO (U + 01C 5)|Minuscole|CARATTERE ALFABETO LATINO LATINO (U + 01C 6)|  
    |COMBINAZIONE YPOGEGRAMMENI GRECO (U + 0345)|Maiuscole|LETTERA GRECA MAIUSCOLA IOTA (U + 0399)|  
  
-   Differenze nel mapping di maiuscole e delle coppie di due lettere minuscole nell'intervallo di caratteri ASCII. La maggior parte delle impostazioni cultura, una coppia di due lettere maiuscole e minuscole è uguale alla coppia di caratteri maiuscola o minuscola due lettere equivalente. Ciò non è possibile per le seguenti coppie di due lettere nelle lingue seguenti, poiché in ogni caso di confronto per un digraph:  
  
    -   "lJ" e "nJ" nelle impostazioni cultura hr-HR (croato (Croazia)).  
  
    -   "cH" in cs-CZ (ceco (Repubblica ceca)) e le impostazioni cultura sk-SK (Slovacco (Slovacchia)).  
  
    -   "aA" nelle impostazioni cultura da-DK (danese (Danimarca)).  
  
    -   "cS", "dZ", "dZS", "nY", "sZ", "tY" e "zS" nelle impostazioni cultura hu-HU (ungherese (Ungheria)).  
  
    -   "cH" e "lL" nelle impostazioni cultura es-ES tradnl (spagnolo (Spagna-ordinamento tradizionale)).  
  
    -   "cH", "gI", "kH", "nG" "nH", "pH", "qU", "tH" e "tR" nelle impostazioni cultura vi-VN (vietnamita (Vietnam)).  
  
     Tuttavia, è insolito che in una situazione in cui un confronto con distinzione delle impostazioni cultura di queste coppie crea problemi, perché queste coppie non sono comuni in stringhe fisse o identificatori.  
  
 L'esempio seguente illustra alcune delle differenze nelle regole di maiuscole e minuscole tra le impostazioni cultura per la conversione di stringhe in lettere maiuscole.  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>L'analisi e formattazione  
 Formattazione e analisi sono operazioni inverse. Regole di formattazione determinano come convertire un valore, ad esempio una data e ora o un numero, nella relativa rappresentazione di stringa, mentre le regole di analisi determinano come convertire una rappresentazione di stringa in un valore, ad esempio una data e ora. La formattazione sia le regole di analisi sono dipendenti dalle convenzioni culturali. Nell'esempio seguente viene illustrata l'ambiguità che può verificarsi durante l'interpretazione di una stringa di data specifici delle impostazioni cultura. Senza conoscere le convenzioni delle impostazioni cultura che è stato utilizzato per produrre una stringa di data, non è possibile sapere se 01/03/2011, 03/01/2011 e 3/1/2011 rappresentano il 3 gennaio 2011 o il 1 marzo 2011.  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 Analogamente, come illustrato nell'esempio seguente, una singola stringa può produrre date diverse a seconda delle impostazioni cultura cui convenzioni vengono usate nell'operazione di analisi.  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>Confronto tra stringhe e l'ordinamento  
 Convenzioni per il confronto e ordinamento delle stringhe variano alle impostazioni cultura. Ad esempio, il tipo di ordinamento può essere basato sulla fonetica o sulla rappresentazione visiva dei caratteri. In lingue dell'Asia orientale, i caratteri sono ordinati per il tratto e radicale di ideogrammi. Ordinamento dipende inoltre le lingue di ordine e utilizzano le impostazioni cultura per la lettera dell'alfabeto. Nella lingua danese, ad esempio, è presente un carattere "Æ" che viene ordinato alfabeticamente dopo la lettera Z. Inoltre, confronti possono essere tra maiuscole e minuscole o maiuscole/minuscole, e in alcuni casi le regole di maiuscole e minuscole anche differiscono dalle impostazioni cultura. Confronto ordinale, invece, utilizza i punti di codice Unicode dei singoli caratteri in una stringa quando il confronto e ordinamento delle stringhe.  
  
 Le regole di ordinamento determinano che l'ordine alfabetico dei caratteri Unicode e come due stringhe da confrontare a altro. Ad esempio, il <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> metodo confronta due stringhe in base il <xref:System.StringComparison> parametro. Se il valore del parametro <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, il metodo esegue un confronto linguistico che utilizza le convenzioni delle impostazioni cultura correnti; se il valore del parametro <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, il metodo esegue un confronto ordinale. Di conseguenza, come illustrato nell'esempio seguente, se le impostazioni cultura correnti sono US Inglese, la prima chiamata al <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> (metodo) (mediante confronto con distinzione delle impostazioni cultura) considera "a" minore di "A", ma la seconda chiamata al metodo stesso (tramite un confronto ordinale) considera "a" maggiore di "A".  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 .NET Framework supporta word, stringa e le regole di ordinamento:  
  
-   Un ordinamento di word esegue un confronto con distinzione delle impostazioni cultura delle stringhe in cui alcuni caratteri Unicode potrebbero essere assegnati a tali di pesi speciali. Ad esempio, il trattino (-) potrebbe essere un peso molto piccolo assegnato in modo che "coop" e "co" vengono visualizzati uno accanto a altro in un elenco ordinato. Per un elenco di <xref:System.String> metodi che consentono di confrontare due stringhe utilizzando le regole di ordinamento di word, vedere il [operazioni su stringhe in base alla categoria](#ByCategory) sezione.  
  
-   Un ordinamento di stringa esegue inoltre un confronto con distinzione delle impostazioni cultura. È simile a un ordinamento di word, ad eccezione del fatto che esistono casi speciali e tutti i simboli non alfanumerici precedono a tutti i caratteri Unicode alfanumerici. Possibile confrontare due stringhe utilizzando le regole di ordinamento di stringa chiamando il <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> gli overload di metodo che hanno un `options` parametro che viene fornito un valore di <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>. Si noti che questo è l'unico metodo che .NET Framework fornisce per confrontare due stringhe utilizzando le regole di ordinamento delle stringhe.  
  
-   L'ordinamento ordinale confronta le stringhe in base al valore numerico di ogni <xref:System.Char> oggetto nella stringa. Un confronto ordinale è automaticamente tra maiuscole e minuscole, perché le versioni maiuscole e minuscole di un carattere dispongono di punti di codice diversi. Tuttavia, se non è importante, è possibile specificare un confronto ordinale che ignori tale distinzione. Questo è equivalente alla conversione di una stringa in lettere maiuscole, usando la lingua inglese e quindi di eseguire un confronto ordinale al risultato. Per un elenco di <xref:System.String> metodi che consentono di confrontare due stringhe utilizzando le regole di ordinamento ordinali, vedere il [operazioni su stringhe in base alla categoria](#ByCategory) sezione.  
  
 Un confronto con distinzione delle impostazioni cultura è qualsiasi confronto che utilizza in modo esplicito o implicito un <xref:System.Globalization.CultureInfo> oggetto, incluse le impostazioni cultura invarianti specificati tramite il <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> proprietà. Le impostazioni cultura implicite sono la lingua corrente, specificata dal <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> e <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> proprietà. È variare notevolmente l'ordinamento dei caratteri alfabetici (ovvero i caratteri per il quale il <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> restituisce proprietà `true`) nelle impostazioni cultura. È possibile specificare un confronto con distinzione delle impostazioni cultura che utilizza le convenzioni delle impostazioni cultura specifiche, fornendo un <xref:System.Globalization.CultureInfo> oggetto a un metodo di confronto di stringa, ad esempio <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>. È possibile specificare un confronto con distinzione delle impostazioni cultura che utilizza le convenzioni delle impostazioni cultura correnti fornendo <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, o qualsiasi membro del <xref:System.Globalization.CompareOptions> enumerazione diverso da <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> o <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> a un overload appropriato del <xref:System.String.Compare%2A> metodo. Un confronto con distinzione delle impostazioni cultura è generalmente appropriato per l'ordinamento, mentre non è un confronto ordinale. Un confronto ordinale è generalmente appropriato per determinare se due stringhe sono uguali (ovvero, per determinare l'identità) che non è un confronto con distinzione delle impostazioni cultura.  
  
 Nell'esempio seguente viene illustrata la differenza tra confronto dipendenti dalle impostazioni cultura e ordinale. L'esempio restituisce tre stringhe "Apple", "Æble" e "AEble", utilizzando un confronto ordinale e le convenzioni delle impostazioni cultura da-DK ed en-US (ognuno dei quali è la lingua predefinita al momento il <xref:System.String.Compare%2A> metodo viene chiamato). Poiché la lingua danese considera il carattere "Æ" come una singola lettera e Ordina "Z" dopo la lettera dell'alfabeto, la stringa "Æble" è maggiore di "Apple". Tuttavia, "Æble" non è considerata equivalente a "AEble", "Æble" rappresenta anche maggiore di "AEble". Le impostazioni cultura en-US non includono la lettera "Æ", ma viene considerata equivalente a "AE", che spiega perché "Æble" è minore di "Apple" ma uguale a "AEble". Confronto ordinale, d'altra parte, considera "Apple" deve essere inferiore a "Æble" e "Æble" devono essere maggiori di "AEble".  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 Utilizzare le seguenti linee guida generali per scegliere un metodo di confronto di ordinamento o di stringa appropriato:  
  
-   Se si desidera, le stringhe devono essere ordinati in base alle impostazioni cultura dell'utente, è consigliabile ordinare in base alle convenzioni delle impostazioni cultura correnti. Se viene modificata la lingua dell'utente, l'ordine delle stringhe ordinate inoltre è in grado di modificare di conseguenza. Ad esempio, un'applicazione del thesaurus deve sempre ordinare parole in base alle impostazioni cultura dell'utente.  
  
-   Se si desidera, le stringhe devono essere ordinati in base alle convenzioni delle impostazioni cultura specifiche, sarà necessario ordinare li fornendo un <xref:System.Globalization.CultureInfo> oggetto che rappresenta quelle impostazioni cultura per un metodo di confronto. Ad esempio, in un'applicazione progettata per illustrare gli studenti che una determinata lingua, si desidera stringhe devono essere ordinati in base alle convenzioni di una delle lingue che legge di tale lingua.  
  
-   Se si desidera che l'ordine delle stringhe di mantenere invariate nelle impostazioni cultura, si deve ordinarle in base alle convenzioni della lingua inglese o utilizzare un confronto ordinale. Ad esempio, si utilizzerebbe un ordinamento ordinali per organizzare i nomi dei file, i processi, i mutex o named pipe.  
  
-   Per un confronto che implica una decisione relativa alla sicurezza (ad esempio, se un nome utente è valido), è necessario eseguire sempre un ordinale nel test di uguaglianza chiamando un overload di <xref:System.String.Equals%2A> metodo.  
  
> [!NOTE]
>  Ordinamento delle impostazioni cultura e le regole di confronto tra stringhe usate di maiuscole e minuscole dipendono dalla versione di .NET Framework. In .NET Framework [!INCLUDE[net_v45](~/includes/net-v45-md.md)] eseguono il [!INCLUDE[win8](~/includes/win8-md.md)] sistema operativo, ordinamento, maiuscole e minuscole, la normalizzazione e le informazioni dei caratteri Unicode conforme allo standard Unicode 6.0. In altri sistemi operativi, è conforme allo standard Unicode 5.0.  
  
 Per ulteriori informazioni sulle regole di ordinamento ordinali, stringa e word, vedere il <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> argomento. Per ulteriori indicazioni su quando utilizzare ogni regola, vedere [procedure consigliate per l'uso di stringhe](~/docs/standard/base-types/best-practices-strings.md).  
  
 In genere, non chiamare stringa metodi di confronto come <xref:System.String.Compare%2A> direttamente per determinare l'ordinamento delle stringhe. Al contrario, i metodi di confronto vengono chiamati i metodi di ordinamento, ad esempio <xref:System.Array.Sort%2A?displayProperty=nameWithType> o <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>. Nell'esempio seguente esegue quattro diverse le operazioni di ordinamento (ordinamento word utilizzando le impostazioni cultura correnti, ordinamento word usando la lingua inglese, ordinamento ordinali e ordinamento delle stringhe utilizzando la lingua inglese) senza chiamare in modo esplicito un metodo di confronto tra stringhe, sebbene specificano il tipo di confronto da utilizzare. Si noti che ogni tipo di ordinamento produce un ordinamento univoco delle stringhe nella matrice.  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  Internamente,.NET Framework Usa chiavi di ordinamento per supportare il confronto di stringhe culturallysensitive. Ogni carattere in una stringa viene assegnato a varie categorie di ordinamenti, inclusi i caratteri alfabetici, case e segni diacritici. Una chiave di ordinamento, rappresentato dalla <xref:System.Globalization.SortKey> classe, fornisce un repository di questi fattori per una determinata stringa. Se l'app esegue un numero elevato di ricerca o le operazioni nello stesso set di stringhe di ordinamento, è possibile migliorare le prestazioni tramite la generazione e l'archiviazione delle chiavi di ordinamento per tutte le stringhe che utilizza. Quando viene richiesta un'operazione di confronto o di ordinamento, utilizzare le chiavi di ordinamento anziché le stringhe. Per altre informazioni, vedere la classe <xref:System.Globalization.SortKey>.  
  
 Se non si specifica una convenzione di confronto di stringhe, ordinamento, ad esempio <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> eseguire un ordinamento con distinzione delle impostazioni cultura senza distinzione tra maiuscole e minuscole nelle stringhe. Nell'esempio seguente viene illustrato come modificare le impostazioni cultura correnti influisce sull'ordine di stringhe ordinate in una matrice. Crea una matrice di tre stringhe. Imposta innanzitutto il `System.Threading.Thread.CurrentThread.CurrentCulture` proprietà en-US e chiamate di <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> metodo. L'ordinamento risultante è basato su convenzioni di ordinamento per le impostazioni cultura inglese (Stati Uniti). Successivamente, nell'esempio viene impostato il `System.Threading.Thread.CurrentThread.CurrentCulture` proprietà da-DK e chiamate di <xref:System.Array.Sort%2A?displayProperty=nameWithType> nuovo metodo. Si noti come l'ordinamento risultante differisce dai risultati en-US perché utilizza le convenzioni di ordinamento per il danese (Danimarca).  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  Se lo scopo primario nel confronto tra stringhe consiste nel determinare se sono uguali, è necessario chiamare il <xref:System.String.Equals%2A?displayProperty=nameWithType> metodo. In genere, è consigliabile utilizzare <xref:System.String.Equals%2A> per eseguire un confronto ordinale. Il <xref:System.String.Compare%2A?displayProperty=nameWithType> metodo è destinato principalmente per l'ordinamento delle stringhe.  
  
 Metodi di ricerca di stringhe, ad esempio <xref:System.String.StartsWith%2A?displayProperty=nameWithType> e <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, può inoltre effettuare confronti tra stringhe dipendenti dalle impostazioni cultura o per ordinale. Nell'esempio seguente vengono illustrate le differenze tra i confronti ordinali e delle impostazioni cultura utilizzando il <xref:System.String.IndexOf%2A> metodo. Una ricerca dipendente dalla lingua in cui le impostazioni cultura correnti sono quelle inglesi (Stati Uniti) considera la sottostringa "oe" in modo che corrisponda alla legatura "œ". Poiché un segno meno facoltativo (U + 00AD) è un carattere a larghezza zero, la ricerca lo tratta come equivalente a <xref:System.String.Empty> e trova una corrispondenza all'inizio della stringa. Una ricerca ordinale, d'altra parte, non viene trovata una corrispondenza in entrambi i casi.  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>Ricerca di stringhe  
 Metodi di ricerca di stringhe, ad esempio <xref:System.String.StartsWith%2A?displayProperty=nameWithType> e <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, può inoltre effettuare distinzione delle impostazioni cultura o confronti di stringhe ordinali per determinare se un carattere o una sottostringa è presente in una stringa specificata.  
  
 I metodi di ricerca nel <xref:System.String> classe per l'individuazione di un singolo carattere, ad esempio il <xref:System.String.IndexOf%2A> , metodo o un set di caratteri, ad esempio il <xref:System.String.IndexOfAny%2A> (metodo), eseguire una ricerca ordinale. Per eseguire una ricerca con distinzione delle impostazioni cultura per un carattere, è necessario chiamare un <xref:System.Globalization.CompareInfo> metodo, ad esempio <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> o <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>. Si noti che i risultati della ricerca di un carattere mediante il confronto ordinale e delle impostazioni cultura possono essere molto diversi. Ad esempio, una ricerca di un carattere Unicode precomposto, ad esempio "æ" (U + 00 C 6) potrebbe corrispondere tutte le occorrenze dei relativi componenti nella sequenza corretta, ad esempio "AE" (U + 041U + 0045), a seconda delle impostazioni cultura. Nell'esempio seguente viene illustrata la differenza tra il <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> e <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> metodi per la ricerca di un singolo carattere. Alfabeto "æ" (U + 00E6) viene trovato nella stringa "aereo" quando si utilizza le convenzioni delle impostazioni cultura en-US, ma non quando si usano le convenzioni delle impostazioni cultura da-DK o quando si esegue un confronto ordinale.  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 D'altra parte, <xref:System.String> metodi che eseguono la ricerca per una stringa anziché come un carattere eseguita una ricerca con distinzione delle impostazioni cultura, se le opzioni di ricerca non sono specificate in modo esplicito da un parametro di tipo della classe <xref:System.StringComparison>. L'unica eccezione è <xref:System.String.Contains%2A>, che esegue una ricerca ordinale.  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>La verifica dell'uguaglianza  
 Utilizzare il <xref:System.String.Compare%2A?displayProperty=nameWithType> metodo per determinare la relazione tra due stringhe nell'ordinamento. In genere si tratta di un'operazione con distinzione delle impostazioni cultura. Chiamare invece il <xref:System.String.Equals%2A?displayProperty=nameWithType> metodo per verificare l'uguaglianza. Poiché il test di uguaglianza confronta in genere l'input dell'utente con alcune stringhe note, ad esempio un nome utente valido, una password o un percorso del file system, in genere è un'operazione ordinale.  
  
> [!WARNING]
>  È possibile verificare l'uguaglianza chiamando il <xref:System.String.Compare%2A?displayProperty=nameWithType> (metodo) e determinare se il valore restituito è zero. Tuttavia, questa procedura non è consigliata. Per determinare se due stringhe sono uguali, è necessario chiamare uno degli overload di <xref:System.String.Equals%2A?displayProperty=nameWithType> metodo. L'overload preferito da chiamare è l'istanza <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> statica o metodo <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> metodo, perché entrambi i metodi includono un <xref:System.StringComparison?displayProperty=nameWithType> parametro che specifichi esplicitamente il tipo di confronto.  
  
 Nell'esempio seguente viene illustrato il rischio di eseguire un confronto con distinzione delle impostazioni cultura per verificarne l'uguaglianza quando un numero ordinale deve essere utilizzato invece. In questo caso, lo scopo del codice è impedire l'accesso al file system di URL che iniziano con "FILE://" o "file://" eseguendo un confronto senza distinzione dell'inizio di un URL con la stringa "FILE://". Tuttavia, se viene eseguito un confronto con distinzione delle impostazioni cultura utilizzando le impostazioni cultura Turco (Turchia) in un URL che inizia con "file://", il confronto di uguaglianza ha esito negativo, perché la lingua turca equivalente maiuscolo del carattere minuscolo "i" è "i" anziché "I". Di conseguenza, è consentito inavvertitamente accesso al file system. D'altra parte, se viene eseguito un confronto ordinale, il confronto di uguaglianza ha esito positivo e viene negato l'accesso al file system.  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>Normalization  
 Alcuni caratteri Unicode hanno più rappresentazioni. Uno dei punti di codice seguente, ad esempio, può rappresentare la lettera "ắ":  
  
-   U + 1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 Più rappresentazioni di un singolo carattere complicano la ricerca, ordinamento, corrispondenza e altre operazioni sulle stringhe.  
  
 Lo standard Unicode definisce un processo denominato normalizzazione che restituisce una rappresentazione binaria di un carattere Unicode per le relative rappresentazioni binarie equivalenti. Normalizzazione è possibile utilizzare diversi algoritmi, denominati normalizzazione, che seguono regole diverse. .NET Framework supporta i formati di normalizzazione Unicode C, D, KC e KD. Quando le stringhe sono state normalizzate per lo stesso formato di normalizzazione, gli possono essere confrontati utilizzando il confronto ordinale.  
  
 Un confronto ordinale è un confronto binario del valore scalare Unicode del corrispondente <xref:System.Char> oggetti in ciascuna stringa. La <xref:System.String> classe include una serie di metodi che è possibile eseguire un confronto ordinale, inclusi i seguenti:  
  
-   Un overload del <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>, <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, e <xref:System.String.LastIndexOf%2A> metodi che include un <xref:System.StringComparison> parametro. Il metodo esegue un confronto ordinale, se si specifica un valore di <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> o <xref:System.StringComparison.OrdinalIgnoreCase> per questo parametro.  
  
-   Gli overload di <xref:System.String.CompareOrdinal%2A> metodo.  
  
-   Metodi che usano un confronto ordinale per impostazione predefinita, ad esempio <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, e <xref:System.String.Split%2A>.  
  
-   Metodi che cercano una <xref:System.Char> valore o per gli elementi in un <xref:System.Char> matrice in un'istanza di stringa. Tali metodi includono <xref:System.String.IndexOf%28System.Char%29> e <xref:System.String.Split%28System.Char%5B%5D%29>.  
  
 È possibile determinare se una stringa è normalizzata in formato di normalizzazione C chiamando il <xref:System.String.IsNormalized?displayProperty=nameWithType> metodo, altrimenti è possibile chiamare il <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> metodo per determinare se una stringa è normalizzata in un formato di normalizzazione specificato. È inoltre possibile chiamare il <xref:System.String.Normalize?displayProperty=nameWithType> metodo per convertire una stringa in formato di normalizzazione C oppure è possibile chiamare il <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> metodo per convertire una stringa in un formato di normalizzazione specificato. Per informazioni dettagliate sulla normalizzazione e il confronto di stringhe, vedere il <xref:System.String.Normalize> e <xref:System.String.Normalize%28System.Text.NormalizationForm%29> metodi.  
  
 L'esempio seguente viene illustrata la normalizzazione di stringa. Definisce la lettera "ố" in tre modi diversi in tre diverse stringhe e utilizza un confronto ordinale per verificarne l'uguaglianza per determinare che ogni stringa differenze tra le due stringhe. Converte quindi ogni stringa ai moduli supportati di normalizzazione e nuovamente esegue un confronto ordinale di ogni stringa in un formato di normalizzazione specificato. In ogni caso, il secondo test per verificarne l'uguaglianza mostra che le stringhe sono uguali.  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 Per ulteriori informazioni sulla normalizzazione e la normalizzazione, vedere <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, così come [Unicode Standard Annex #15: di normalizzazione Unicode](https://unicode.org/reports/tr15/) e [domande frequenti di normalizzazione](https://www.unicode.org/faq/normalization.html) di sito Web www.Unicode.org.  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>Operazioni su stringhe per categoria  
 Il <xref:System.String> classe fornisce i membri per il confronto di stringhe, stringhe per verificarne l'uguaglianza di test, la ricerca di caratteri o sottostringhe in una stringa, la modifica di una stringa, l'estrazione di sottostringhe da una stringa, la combinazione di stringhe, la formattazione di valori, la copia di una stringa e normalizzazione di una stringa.  
  
### <a name="comparing-strings"></a>Confronto di stringhe  
 È possibile confrontare le stringhe per determinare la posizione relativa nell'ordinamento usando i seguenti <xref:System.String> metodi:  
  
-   <xref:System.String.Compare%2A> Restituisce un intero che indica la relazione tra una stringa di due stringhe nell'ordinamento.  
  
-   <xref:System.String.CompareOrdinal%2A> Restituisce un intero che indica la relazione tra una stringa in una stringa secondo basata su un confronto dei punti di codice.  
  
-   <xref:System.String.CompareTo%2A> Restituisce un intero che indica la relazione tra l'istanza corrente della stringa di due stringhe nell'ordinamento. Il <xref:System.String.CompareTo%28System.String%29> metodo fornisce il <xref:System.IComparable> e <xref:System.IComparable%601> implementazioni per le <xref:System.String> classe.  
  
### <a name="testing-strings-for-equality"></a>Test di uguaglianza delle stringhe  
 Chiamare il <xref:System.String.Equals%2A> metodo per determinare se due stringhe sono uguali. L'istanza <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> e statica <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> overload consentono di specificare se il confronto è distinzione delle impostazioni cultura o per ordinale e se i case è considerato o ignorato. La maggior parte dei test di uguaglianza sono ordinali e i confronti di uguaglianza che determinano l'accesso a una risorsa di sistema (ad esempio un oggetto file system) devono essere sempre ordinale.  
  
### <a name="finding-characters-in-a-string"></a>Ricerca di caratteri in una stringa  
 La <xref:System.String> classe include due tipi di metodi di ricerca:  
  
-   Metodi che restituiscono un <xref:System.Boolean> valore per indicare se una particolare sottostringa è presente in un'istanza di stringa. Queste includono la <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, e <xref:System.String.StartsWith%2A> metodi.  
  
-   Metodi che indicano la posizione iniziale di una sottostringa in un'istanza di stringa. Queste includono la <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, e <xref:System.String.LastIndexOfAny%2A> metodi.  
  
> [!WARNING]
>  Se si desidera cercare una stringa per un modello specifico anziché una sottostringa specifica, utilizzare le espressioni regolari. Per altre informazioni, vedere [Espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
### <a name="modifying-a-string"></a>Modifica di una stringa  
 La <xref:System.String> classe include i metodi seguenti che vengono visualizzati per modificare il valore di una stringa:  
  
-   <xref:System.String.Insert%2A> Inserisce una stringa in corrente <xref:System.String> istanza.  
  
-   <xref:System.String.PadLeft%2A> Inserisce una o più occorrenze di un carattere specificato all'inizio di una stringa.  
  
-   <xref:System.String.PadRight%2A> Inserisce una o più occorrenze di un carattere specificato alla fine di una stringa.  
  
-   <xref:System.String.Remove%2A> Elimina una sottostringa da corrente <xref:System.String> istanza.  
  
-   <xref:System.String.Replace%2A> sostituisce una sottostringa con un'altra sottostringa nell'oggetto <xref:System.String> istanza.  
  
-   <xref:System.String.ToLower%2A> e <xref:System.String.ToLowerInvariant%2A> convertire tutti i caratteri in una stringa in caratteri minuscoli.  
  
-   <xref:System.String.ToUpper%2A> e <xref:System.String.ToUpperInvariant%2A> convertire tutti i caratteri in una stringa in caratteri maiuscoli.  
  
-   <xref:System.String.Trim%2A> Rimuove tutte le occorrenze di un carattere di inizio e alla fine di una stringa.  
  
-   <xref:System.String.TrimEnd%2A> Rimuove tutte le occorrenze di un carattere dalla fine di una stringa.  
  
-   <xref:System.String.TrimStart%2A> Rimuove tutte le occorrenze di un carattere dall'inizio di una stringa.  
  
> [!IMPORTANT]
>  Tutti i metodi di modifica stringa restituiscono un nuovo <xref:System.String> oggetto. Non modificare il valore dell'istanza corrente.  
  
### <a name="extracting-substrings-from-a-string"></a>Estrazione di sottostringhe da una stringa  
 Il <xref:System.String.Split%2A?displayProperty=nameWithType> metodo suddivide una singola stringa in più stringhe. Gli overload del metodo consentono di specificare più delimitatori per determinare il numero massimo di sottostringhe che il metodo estrae e per determinare se le stringhe vuote (che si verificano quando i delimitatori sono adiacenti) sono incluse tra le stringhe restituite.  
  
### <a name="combining-strings"></a>Stringhe di combinazione  
 Le operazioni seguenti <xref:System.String> metodi possono essere utilizzati per la concatenazione di stringhe:  
  
-   <xref:System.String.Concat%2A> Consente di combinare uno o più sottostringhe in una singola stringa.  
  
-   <xref:System.String.Join%2A> Concatena una o più sottostringhe in un singolo elemento e aggiunge un separatore tra ogni sottostringa.  
  
### <a name="formatting-values"></a>Formattazione di valori  
 Il <xref:System.String.Format%2A?displayProperty=nameWithType> metodo utilizza la funzionalità di formattazione composita per sostituire uno o più i segnaposto in una stringa con la rappresentazione di stringa di un oggetto o un valore. Il <xref:System.String.Format%2A> metodo viene spesso utilizzato per eseguire le operazioni seguenti:  
  
-   Per incorporare la rappresentazione di stringa di un valore numerico in una stringa.  
  
-   Per incorporare la rappresentazione di stringa di un valore di data e ora in una stringa.  
  
-   Per incorporare la rappresentazione di stringa del valore di enumerazione in una stringa.  
  
-   Per incorporare la rappresentazione di stringa di un oggetto che supporta il <xref:System.IFormattable> interfaccia in una stringa.  
  
-   Per giustificare a destra o giustificato a sinistra di una sottostringa in un campo all'interno di una stringa più grande.  
  
 Per informazioni dettagliate sulla formattazione di operazioni ed esempi, vedere il <xref:System.String.Format%2A> overload riepilogo.  
  
### <a name="copying-a-string"></a>Copia di una stringa  
 È possibile chiamare le operazioni seguenti <xref:System.String> metodi per creare una copia di una stringa:  
  
-   <xref:System.String.Clone%2A> Restituisce un riferimento a un oggetto esistente <xref:System.String> oggetto.  
  
-   <xref:System.String.Copy%2A> Crea una copia di una stringa esistente.  
  
-   <xref:System.String.CopyTo%2A> copia una parte di una stringa in una matrice di caratteri.  
  
### <a name="normalizing-a-string"></a>Normalizzazione di una stringa  
 In formato Unicode, un singolo carattere può avere più punti di codice. Normalizzazione converte questi caratteri equivalenti in rappresentazione binaria stesso. Il <xref:System.String.Normalize%2A?displayProperty=nameWithType> metodo esegue la normalizzazione e <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> metodo determina se una stringa è normalizzata.  
  
 Per ulteriori informazioni e un esempio, vedere il [normalizzazione](#Normalization) in precedenza in questo argomento.  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.String" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contenuto della sezione:  
  
 [Sintassi del costruttore di overload](#Syntax)   
 [Parametri](#Params)   
 [Eccezioni](#Exceptions)   
 [Quale metodo si chiama?](#Tasks)   
 [La creazione di stringhe](#Creating_Strings)   
 [Gestione delle stringhe ricorrenti](#Repetitive)   
 Esempi di stringhe di istanze:   
 [Utilizzo dell'assegnazione di stringhe](#Ctor1_Example)  
 [Utilizzando una matrice di caratteri](#Ctor2_Example)  
 [Utilizzando una parte di una matrice di caratteri e un singolo carattere di ripetizione](#Ctor3_Example)  
 [Utilizzando un puntatore a una matrice di caratteri](#Ctor4_Example)  
 [Utilizzo di un puntatore e un intervallo di una matrice](#Ctor5_Example)  
 [Utilizzando un puntatore a una matrice di byte con segno](#Ctor6_Example)  
[Informazioni sulla versione](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>Sintassi del costruttore di overload  
 Costruttori di stringa rientrano in due categorie: privi di parametri di puntatore, mentre quelle con i parametri di puntatore. I costruttori che utilizzano i puntatori non sono conformi a CLS. Inoltre, Visual Basic non supporta l'utilizzo dei puntatori, e in c# il codice che utilizza i puntatori per eseguire in un contesto unsafe. Per altre informazioni, vedere [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md).  
  
 Per informazioni aggiuntive sulla scelta di un overload, vedere [quale metodo chiamato?](#Tasks)  
  
 `String(Char[] value)`  
 Inizializza la nuova istanza sul valore indicato da una matrice di caratteri Unicode. Questo costruttore consente di copiare i caratteri Unicode ([esempio](#Ctor2_Example)).  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 Inizializza la nuova istanza sul valore indicato da una matrice di caratteri Unicode, una posizione iniziale del carattere all'interno di tale matrice e da una lunghezza ([esempio](#Ctor3_Example)).  
  
 `String(Char c, Int32 count)`  
 Consente di inizializzare la nuova istanza per il valore indicata da uno specifico carattere Unicode ripetuto un numero precisato di volte ([esempio](#Ctor3_Example)).  
  
 `String(char* value)`  
 **(Non conforme a CLS) ** Inizializza la nuova istanza sul valore indicato da un puntatore a una matrice di caratteri Unicode che termina con un carattere null (U + 0000 o '\0'). ([esempio](#Ctor4_Example)).  
  
 Autorizzazione: <xref:System.Security.SecurityCriticalAttribute>, richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **(Non conforme a CLS) ** Inizializza la nuova istanza sul valore indicato da un puntatore a una matrice di caratteri Unicode, una posizione iniziale del carattere all'interno di tale matrice e da una lunghezza. Il costruttore di copia i caratteri Unicode da `value` a partire dall'indice `startIndex` e termina in corrispondenza dell'indice `startIndex`  +  `length` – 1 ([esempio](#Ctor5_Example)).  
  
 Autorizzazione: <xref:System.Security.SecurityCriticalAttribute>, richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.  
  
 `String(SByte* value)`  
 **(Non conforme a CLS) ** Inizializza la nuova istanza sul valore indicato da un puntatore a una matrice di interi con segno a 8 bit. Si presuppone che la matrice rappresentano una stringa codificata utilizzando la tabella codici di sistema corrente (ovvero, la codifica specificata da <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Il costruttore elabora i caratteri `value` a partire dalla posizione specificata dal puntatore fino a quando non viene raggiunto un carattere null (0x00) ([esempio](#Ctor6_Example)).  
  
 Autorizzazione: <xref:System.Security.SecurityCriticalAttribute>, richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **(Non conforme a CLS) ** Inizializza la nuova istanza sul valore indicato da un puntatore a una matrice di interi con segno a 8 bit, da una posizione inizia all'interno di tale matrice e da una lunghezza.  Si presuppone che la matrice rappresentano una stringa codificata utilizzando la tabella codici di sistema corrente (ovvero, la codifica specificata da <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Il costruttore elabora i caratteri a partire valore `startIndex` e fine `startIndex`  +  `length` – 1 ([esempio](#Ctor6_Example)).  
  
 Autorizzazione: <xref:System.Security.SecurityCriticalAttribute>, richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **(Non conforme a CLS) ** Inizializza la nuova istanza sul valore indicato da un puntatore a una matrice di interi con segno a 8 bit, una posizione iniziale all'interno della matrice, una lunghezza e un <xref:System.Text.Encoding> oggetto.  
  
 Autorizzazione: <xref:System.Security.SecurityCriticalAttribute>, richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.  
  
<a name="Params"></a>   
## <a name="parameters"></a>Parametri  
 Ecco un elenco completo dei parametri usati dalla <xref:System.String> costruttori che non includono un parametro del puntatore. Per i parametri utilizzati da ogni overload, vedere la sintassi di overload precedente.  
  
|Parametro|Tipo|Descrizione|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|Matrice di caratteri Unicode.|  
|`c`|<xref:System.Char>|Carattere Unicode.|  
|`startIndex`|<xref:System.Int32>|La posizione iniziale nella `value` del primo carattere nella stringa di nuovo.<br /><br /> Il valore predefinito: 0|  
|`length`|<xref:System.Int32>|Il numero di caratteri in `value` da includere nella nuova stringa.<br /><br /> Valore predefinito: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`count`|<xref:System.Int32>|Il numero di volte in cui il carattere `c` viene ripetuta nella stringa di nuovo. Se `count` è zero, il valore del nuovo oggetto è <xref:System.String.Empty?displayProperty=nameWithType>.|  
  
 Ecco un elenco completo dei parametri usati dalla <xref:System.String> costruttori che includono un parametro del puntatore. Per i parametri utilizzati da ogni overload, vedere la sintassi di overload precedente.  
  
|Parametro|Tipo|Descrizione|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> oppure<br /><br /> <xref:System.SByte>\*|Un puntatore a una matrice con terminazione null di caratteri Unicode o una matrice di interi con segno a 8 bit. Se `value` è `null` o una matrice vuota, il valore della nuova stringa è <xref:System.String.Empty?displayProperty=nameWithType>.|  
|`startIndex`|<xref:System.Int32>|Indice dell'elemento della matrice che definisce il primo carattere nella stringa di nuovo.<br /><br /> Il valore predefinito: 0|  
|`length`|<xref:System.Int32>|Il numero di elementi della matrice da utilizzare per creare la nuova stringa. Se length è zero, il costruttore crea una stringa il cui valore è <xref:System.String.Empty?displayProperty=nameWithType>.<br /><br /> Valore predefinito: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`enc`|<xref:System.Text.Encoding>|Oggetto che specifica il modo in `value` viene codificata.<br /><br /> Il valore predefinito: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, o tabella codici ANSI corrente del sistema|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>Eccezioni  
 Di seguito è riportato un elenco delle eccezioni generate dai costruttori che non includono parametri di puntatore.  
  
|Eccezione|Condizione|Generata dal|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value` è `null`.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex`,`length`, o `count` è minore di zero.<br /><br /> oppure<br /><br /> la somma dei parametri `startIndex` e `length` è maggiore del numero di elementi nel parametro `value`.<br /><br /> oppure<br /><br /> `count` è minore di zero.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 Di seguito è riportato un elenco delle eccezioni generate dai costruttori che includono parametri di puntatore.  
  
|Eccezione|Condizione|Generata dal|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value` Specifica una matrice che contiene un carattere Unicode non valido.<br /><br /> oppure<br /><br /> `value` o `value`  +  `startIndex` specifica un indirizzo minore di 64 K.<br /><br /> oppure<br /><br /> Un nuovo <xref:System.String> istanza potrebbe non essere inizializzata dal `value` della matrice di byte perché `value` non utilizza il codice codifica predefinita.|Tutti i costruttori con puntatori.|  
|<xref:System.ArgumentNullException>|`value` è null.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|Il processo corrente non ha accesso in lettura a tutti i caratteri considerati.<br /><br /> oppure<br /><br /> `startIndex` o `length` è minore di zero, `value` + `startIndex` causa un overflow del puntatore o il processo corrente non ha accesso in lettura a tutti i caratteri considerati.<br /><br /> oppure<br /><br /> La lunghezza della nuova stringa è troppo grande da allocare.|Tutti i costruttori con puntatori.|  
|<xref:System.AccessViolationException>|`value`, o `value`  +  `startIndex`  +  `length` – 1, specifica un indirizzo non valido.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>Quale metodo si chiama?  
  
|A|Chiamata o utilizzo|  
|--------|-----------------|  
|Creare una stringa.|Assegnazione di un valore letterale stringa o una stringa esistente ([esempio](#Ctor1_Example))|  
|Creare una stringa da un'intera matrice di caratteri.|<xref:System.String.%23ctor%28System.Char%5B%5D%29> ([esempio](#Ctor2_Example))|  
|Crea un stringa da una parte di una matrice di caratteri.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([esempio](#Ctor3_Example))|  
|Creare una stringa che si ripete di più volte lo stesso carattere.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([esempio](#Ctor3_Example))|  
|Creare una stringa da un puntatore a una matrice di caratteri wide Unicode.|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|Creare una stringa da una parte di una matrice di caratteri wide Unicode tramite il relativo puntatore.|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|Creare una stringa da C++ `char` matrice.|<xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> oppure<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|Creare una stringa di caratteri ASCII.|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>La creazione di stringhe  
 Più diffuse tecnica per la creazione di stringhe a livello di codice è una semplice assegnazione, come illustrato nel [in questo esempio](#Ctor1_Example). La <xref:System.String> classe include anche i quattro tipi di overload del costruttore che consentono di creare stringhe tra i valori seguenti:  
  
-   Da una matrice di caratteri (una matrice di caratteri con codifica UTF-16). È possibile creare un nuovo <xref:System.String> oggetto dai caratteri l'intera matrice o una parte di esso. Il <xref:System.String.%23ctor%28System.Char%5B%5D%29> costruttore copia tutti i caratteri nella matrice per la nuova stringa. Il <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> costruttore copia i caratteri da indice `startIndex` all'indice `startIndex`  +  `length` – 1 per la nuova stringa. Se `length` è zero, il valore della nuova stringa è <xref:System.String.Empty?displayProperty=nameWithType>.  
  
     Se il codice crea ripetutamente le stringhe che presentano lo stesso valore, è possibile migliorare le prestazioni dell'applicazione utilizzando un metodo alternativo di creazione di stringhe. Per ulteriori informazioni, vedere [la gestione delle stringhe ricorrenti](#Repetitive).  
  
-   Da un singolo carattere che è duplicato zero, a una o più volte, tramite il <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> costruttore. Se `count` è zero, il valore della nuova stringa è <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Da un puntatore a una matrice di caratteri con terminazione null, tramite il <xref:System.String.%23ctor%28System.Char%2A%29> o <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> costruttore. L'intera matrice o un intervallo specificato può essere utilizzato per inizializzare la stringa. Il costruttore di copia di una sequenza di caratteri Unicode a partire dal puntatore specificato o dal puntatore specificato più `startIndex` e continuando fino alla fine della matrice o per `length` caratteri. Se `value` è un puntatore null o `length` è zero, il costruttore crea una stringa il cui valore è <xref:System.String.Empty?displayProperty=nameWithType>. Se l'operazione di copia continua alla fine della matrice e la matrice non è con terminazione null, il comportamento del costruttore è dipendente dal sistema. Questa condizione potrebbe causare una violazione di accesso.  
  
     Se la matrice contiene eventuali caratteri null incorporati (U + 0000 o '\0') e <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> l'overload del metodo, l'istanza di stringa contiene `length` incorporati di caratteri, inclusi gli eventuali valori null. Nell'esempio seguente mostra cosa accade quando viene passato un puntatore a una matrice di 10 elementi che include due caratteri null per il <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> metodo. Poiché l'indirizzo è l'inizio della matrice e devono essere aggiunti alla stringa di tutti gli elementi nella matrice, il costruttore crea un'istanza di una stringa con dieci caratteri, inclusi i due valori null incorporati. D'altra parte, se la stessa matrice viene passata la <xref:System.String.%23ctor%28System.Char%2A%29> costruttore, il risultato è una stringa di quattro caratteri che non include il primo carattere null.  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     La matrice deve contenere caratteri Unicode. In C++, ciò significa che la matrice di caratteri deve essere definito come gestito <xref:System.Char>tipo [] o non gestito`wchar_t`tipo [].  
  
     Se il <xref:System.String.%23ctor%28System.Char%2A%29> l'overload del metodo e la matrice non è con terminazione null o se il <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> l'overload del metodo e `startIndex`  +  `length`-1 include un intervallo all'esterno della memoria allocata per la sequenza di caratteri, il comportamento del costruttore è dipendente dal sistema e potrebbe verificarsi una violazione di accesso. Inoltre, sul processore Intel Itanium, le chiamate al <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> costruttore potrebbe generare un <xref:System.DataMisalignedException> eccezione. In questo caso, chiamare il <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> invece.  
  
-   Da un puntatore a una matrice di byte con segno. L'intera matrice o un intervallo specificato può essere utilizzato per inizializzare la stringa. La sequenza di byte può essere interpretata utilizzando la tabella codici predefinita di codifica, o una codifica può essere specificata nella chiamata al costruttore. Se il costruttore tenta di creare un'istanza di una stringa da un'intera matrice che non è con terminazione null o se l'intervallo della matrice da `value`  +  `startIndex` a `value`  +  `startIndex`  +  `length` -1 è all'esterno della memoria allocata per la matrice, il comportamento di questo costruttore è dipendente dal sistema e potrebbe verificarsi una violazione di accesso.  
  
     I tre costruttori che includono una matrice di byte con segno come un parametro sono progettati principalmente per convertire un C++ `char` matrice in una stringa, come illustrato in questo esempio:  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     Se la matrice contiene caratteri null ('\0') o byte il cui valore è 0 e <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> l'overload del metodo, l'istanza di stringa contiene `length` incorporati di caratteri, inclusi gli eventuali valori null. Nell'esempio seguente mostra cosa accade quando viene passato un puntatore a una matrice di 10 elementi che include due caratteri null per il <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> metodo. Poiché l'indirizzo è l'inizio della matrice e devono essere aggiunti alla stringa di tutti gli elementi nella matrice, il costruttore crea un'istanza di una stringa con dieci caratteri, inclusi i due valori null incorporati. D'altra parte, se la stessa matrice viene passata la <xref:System.String.%23ctor%28System.SByte%2A%29> costruttore, il risultato è una stringa di quattro caratteri che non include il primo carattere null.  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     Poiché il <xref:System.String.%23ctor%28System.SByte%2A%29> e <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> costruttori interpretano `value` utilizzando la tabella codici ANSI predefinita, chiamare questi costruttori con matrici di byte identici possono creare le stringhe che presentano valori diversi in sistemi diversi.  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>Gestione delle stringhe ricorrenti  
 Le applicazioni che analizzano o decodificano flussi di testo spesso utilizzano il <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> costruttore o <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodo per convertire le sequenze di caratteri in una stringa. Creazione di nuove stringhe più volte con lo stesso valore invece di creare e riutilizzare una stringa costituisce uno spreco di memoria. Se si è probabilmente di creare più volte lo stesso valore di stringa chiamando il <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> costruttore, anche se non si conosce anticipo quale potrebbero essere tali valori di stringa identica, è possibile usare invece una tabella di ricerca.  
  
 Si supponga, ad esempio, leggere e analizzare un flusso di caratteri da un file che contiene tag e attributi XML. Quando si utilizza il flusso, si verifica ripetutamente determinati token (sequenze di caratteri che hanno un significato simbolico). Token equivalenti per le stringhe "0", "1", "true" e "false" è probabile che si verificano di frequente in un flusso XML.  
  
 Anziché convertire ciascun token in una nuova stringa, è possibile creare un <xref:System.Xml.NameTable?displayProperty=nameWithType> oggetto per le stringhe che si ripetono frequentemente. Il <xref:System.Xml.NameTable> oggetto migliora le prestazioni, poiché recupera le stringhe archiviate senza allocare memoria temporanea. Quando si verifica un token, utilizzare il <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodo per recuperare il token dalla tabella. Se il token esiste, il metodo restituisce la stringa corrispondente. Se il token non esiste, utilizzare il <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodo per inserire il token nella tabella e per ottenere la stringa corrispondente.  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>Esempio 1: Utilizzo dell'assegnazione di stringhe  
 L'esempio seguente crea una nuova stringa mediante l'assegnazione di un valore letterale stringa. Crea una seconda stringa assegnandogli il valore della prima stringa. Questi sono i due modi più comuni per creare un'istanza di un nuovo <xref:System.String> oggetto.  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>Esempio 2: Utilizzo di una matrice di caratteri  
 Nell'esempio seguente viene illustrato come creare un nuovo <xref:System.String> oggetto da una matrice di caratteri.  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>Esempio 3: Utilizzo di una parte di una matrice di caratteri e ripetizione di un singolo carattere  
 Nell'esempio seguente viene illustrato come creare un nuovo <xref:System.String> oggetto da una parte di una matrice di caratteri e come creare un nuovo <xref:System.String> oggetto che contiene più occorrenze di un singolo carattere.  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>Esempio 4: Utilizzo di un puntatore a una matrice di caratteri  
 Nell'esempio seguente viene illustrato come creare un nuovo <xref:System.String> oggetto da un puntatore a una matrice di caratteri. Nell'esempio c# debba essere compilata usando la `/unsafe` opzione del compilatore.  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>Esempio 5: Creazione di una stringa da un puntatore e un intervallo di una matrice  
 Nell'esempio seguente vengono esaminati gli elementi di una matrice di caratteri per un punto o un punto esclamativo. Se viene trovato uno, crea un'istanza di una stringa di caratteri nella matrice che precedono il simbolo di punteggiatura. In caso contrario, viene creata un'istanza di una stringa con l'intero contenuto della matrice. Nell'esempio c# deve essere compilata usando la `/unsafe` opzione del compilatore.  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>Esempio 6: Creazione di una stringa da un puntatore a una matrice di byte con segno  
 Nell'esempio seguente viene illustrato come è possibile creare un'istanza di <xref:System.String> classe con il <xref:System.String.%23ctor%28System.SByte%2A%29> costruttore.  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>Informazioni sulla versione  
 .NET Framework  
 Tutti gli overload sono supportati in: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0  
  
 .NET Framework Client Profile  
 Tutti gli overload sono supportati in: 4, 3.5 SP1  
  
 Libreria di classi portabile  
 Tutti gli overload senza un <xref:System.SByte> `*` parametro sono supportati  
  
 .NET per applicazioni Windows Store  
 Tutti gli overload senza un <xref:System.SByte> `*` parametro sono supportati in: Windows 8  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">Puntatore a una matrice con terminazione Null di caratteri Unicode.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.String" /> sul valore indicato da uno specifico puntatore a una matrice di caratteri Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Per esempi e informazioni complete sull'utilizzo per questo e altri `String` overload del costruttore, vedere il <xref:System.String.%23ctor%2A> costruttore riepilogo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il processo corrente non ha accesso in lettura a tutti i caratteri considerati.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> specifica una matrice che contiene un carattere Unicode non valido, oppure <paramref name="value" /> specifica un indirizzo minore di 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Matrice di caratteri Unicode.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.String" /> sul valore indicato da una matrice di caratteri Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Per esempi e informazioni complete sull'utilizzo per questo e altri `String` overload del costruttore, vedere il <xref:System.String.%23ctor%2A> costruttore riepilogo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
      </Parameters>
      <Docs>
        <param name="value">Puntatore a una matrice a terminazione Null di interi con segno a 8 bit. I numeri interi vengono interpretati in base alla codifica della tabella codici di sistema corrente, ovvero alla codifica specificata da <see cref="P:System.Text.Encoding.Default" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.String" /> sul valore indicato da un puntatore a una matrice di interi con segno a 8 bit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Per esempi e informazioni complete sull'utilizzo per questo e altri `String` overload del costruttore, vedere il <xref:System.String.%23ctor%2A> costruttore riepilogo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Non è stato possibile inizializzare una nuova istanza di <see cref="T:System.String" /> mediante <paramref name="value" />, supponendo che <paramref name="value" /> sia codificato in ANSI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La lunghezza della nuova stringa da inizializzare, che è determinata dal carattere a terminazione Null del parametro <paramref name="value" />, è troppo grande da allocare.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" /> specifica un indirizzo non valido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">Carattere Unicode.</param>
        <param name="count">Numero di occorrenze di <c>c</c>.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.String" /> sul valore indicato da uno specifico carattere Unicode ripetuto un numero precisato di volte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Per esempi e informazioni complete sull'utilizzo per questo e altri `String` overload del costruttore, vedere il <xref:System.String.%23ctor%2A> costruttore riepilogo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è minore di zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Puntatore a una matrice di caratteri Unicode.</param>
        <param name="startIndex">Posizione iniziale all'interno di <c>value</c>.</param>
        <param name="length">Numero di caratteri in <c>value</c> da usare.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.String" /> sul valore indicato da uno specifico puntatore a una matrice di caratteri Unicode, da una posizione iniziale del carattere all'interno di tale matrice e da una lunghezza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Per esempi e informazioni complete sull'utilizzo per questo e altri `String` overload del costruttore, vedere il <xref:System.String.%23ctor%2A> costruttore riepilogo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> o <paramref name="length" /> è minore di zero, <paramref name="value" /> + <paramref name="startIndex" /> causa un overflow del puntatore o il processo corrente non ha accesso in lettura a tutti i caratteri considerati.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> specifica una matrice che contiene un carattere Unicode non valido o <paramref name="value" /> + <paramref name="startIndex" /> specifica un indirizzo minore di 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Matrice di caratteri Unicode.</param>
        <param name="startIndex">Posizione iniziale all'interno di <c>value</c>.</param>
        <param name="length">Numero di caratteri in <c>value</c> da usare.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.String" /> sul valore indicato da una matrice di caratteri Unicode, da una posizione iniziale del carattere all'interno di tale matrice e da una lunghezza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Per esempi e informazioni complete sull'utilizzo per questo e altri `String` overload del costruttore, vedere il <xref:System.String.%23ctor%2A> costruttore riepilogo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> o <paramref name="length" /> è minore di zero.  oppure  La somma di <paramref name="startIndex" /> e <paramref name="length" /> è maggiore del numero di elementi in <paramref name="value" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Puntatore a una matrice di interi con segno a 8 bit. I numeri interi vengono interpretati in base alla codifica della tabella codici di sistema corrente, ovvero alla codifica specificata da <see cref="P:System.Text.Encoding.Default" />.</param>
        <param name="startIndex">Posizione iniziale all'interno di <c>value</c>.</param>
        <param name="length">Numero di caratteri in <c>value</c> da usare.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.String" /> sul valore indicato da uno specifico puntatore a una matrice di interi con segno a 8 bit, da una posizione iniziale all'interno di tale matrice e da una lunghezza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Per esempi e informazioni complete sull'utilizzo per questo e altri `String` overload del costruttore, vedere il <xref:System.String.%23ctor%2A> costruttore riepilogo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> o <paramref name="length" /> è minore di zero.  oppure  L'indirizzo specificato da <paramref name="value" /> + <paramref name="startIndex" /> è troppo grande per la piattaforma corrente, ovvero il calcolo dell'indirizzo ha causato un overflow.  oppure  La lunghezza della nuova stringa da inizializzare è troppo grande da allocare.</exception>
        <exception cref="T:System.ArgumentException">L'indirizzo specificato da <paramref name="value" /> + <paramref name="startIndex" /> è minore di 64 K.  oppure  Non è stato possibile inizializzare una nuova istanza di <see cref="T:System.String" /> tramite <paramref name="value" />, supponendo che <paramref name="value" /> sia codificato in ANSI.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" /> e <paramref name="length" /> specificano collettivamente un indirizzo non valido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="enc" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="value">Puntatore a una matrice di interi con segno a 8 bit.</param>
        <param name="startIndex">Posizione iniziale all'interno di <c>value</c>.</param>
        <param name="length">Numero di caratteri in <c>value</c> da usare.</param>
        <param name="enc">Oggetto che specifica la modalità di codifica della matrice a cui fa riferimento <c>value</c>. Se <c>enc</c> è <see langword="null" />, verrà usata la codifica ANSI.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.String" /> sul valore indicato da uno specifico puntatore a una matrice di interi con segno a 8 bit, da una posizione iniziale all'interno di tale matrice e da un oggetto <see cref="T:System.Text.Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Per esempi e informazioni complete sull'utilizzo per questo e altri `String` overload del costruttore, vedere il <xref:System.String.%23ctor%2A> costruttore riepilogo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> o <paramref name="length" /> è minore di zero.  oppure  L'indirizzo specificato da <paramref name="value" /> + <paramref name="startIndex" /> è troppo grande per la piattaforma corrente, ovvero il calcolo dell'indirizzo ha causato un overflow.  oppure  La lunghezza della nuova stringa da inizializzare è troppo grande da allocare.</exception>
        <exception cref="T:System.ArgumentException">L'indirizzo specificato da <paramref name="value" /> + <paramref name="startIndex" /> è minore di 64 K.  oppure  Non è stato possibile inizializzare una nuova istanza di <see cref="T:System.String" /> tramite <paramref name="value" />, supponendo che <paramref name="value" /> sia stato codificato secondo quanto specificato da <paramref name="enc" />.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" /> e <paramref name="length" /> specificano collettivamente un indirizzo non valido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Posizione nella stringa corrente.</param>
        <summary>Ottiene l'oggetto <see cref="T:System.Char" /> in una posizione specificata dell'oggetto <see cref="T:System.String" /> corrente.</summary>
        <value>Oggetto in corrispondenza della posizione <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `index` in base zero.  
  
 Questa proprietà restituisce il <xref:System.Char> oggetto in corrispondenza della posizione specificata dal `index` parametro. Tuttavia, un carattere Unicode può essere rappresentato da più <xref:System.Char>. Utilizzare il <xref:System.Globalization.StringInfo?displayProperty=nameWithType> classe per funzionare con Unicode caratteri anziché <xref:System.Char> oggetti. Per ulteriori informazioni, vedere la sezione "Char oggetti e i caratteri Unicode" il <xref:System.String> Cenni preliminari sulla classe.  
  
 In c#, la <xref:System.String.Chars%2A> proprietà è un indicizzatore. In Visual Basic la proprietà predefinita è la <xref:System.String> classe. Ogni <xref:System.Char> oggetto nella stringa è possibile accedere usando codice simile al seguente.  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come è possibile utilizzare l'indicizzatore in una routine per convalidare una stringa.  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> è maggiore o uguale alla lunghezza dell'oggetto o minore di zero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un riferimento a questa istanza della classe <see cref="T:System.String" />.</summary>
        <returns>Questa istanza di <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore restituito non è una copia indipendente di questa istanza. è semplicemente un'altra visualizzazione degli stessi dati. Utilizzare il <xref:System.String.Copy%2A> o <xref:System.String.CopyTo%2A> metodo per creare un apposito <xref:System.String> oggetto con lo stesso valore di questa istanza.  
  
 Poiché il <xref:System.String.Clone%2A> metodo restituisce semplicemente l'istanza di stringa esistente, è necessario chiamarlo direttamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Confronta due oggetti <see cref="T:System.String" /> specificati e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tutti gli overload del metodo <xref:System.String.Compare%2A> restituiscono un intero con segno a 32 bit che indica la relazione lessicale tra i due termini del confronto.  
  
|Valore|Condizione|  
|-----------|---------------|  
|Minore di zero|La prima sottostringa precede la seconda sottostringa nell'ordinamento.|  
|Zero|Le sottostringhe si trovano nella stessa posizione nell'ordinamento oppure `length` è zero.|  
|Maggiore di zero|La prima sottostringa segue la seconda sottostringa nell'ordinamento.|  
  
> [!WARNING]
>  Quando possibile, è necessario chiamare un overload di <xref:System.String.Compare%2A> metodo che include un <xref:System.StringComparison> parametro. Per altre informazioni, vedere [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md) (Procedure consigliate per l'uso di stringhe).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da confrontare.</param>
        <param name="strB">Seconda stringa da confrontare.</param>
        <summary>Confronta due oggetti <see cref="T:System.String" /> specificati e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</summary>
        <returns>Intero con segno a 32 bit che indica la relazione lessicale tra i due termini di confronto.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description><paramref name="strA" /> precede <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Zero  </term><description><paramref name="strA" /> si trova nella stessa posizione di <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Maggiore di zero  </term><description><paramref name="strA" /> segue <paramref name="strB" /> nell'ordinamento.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei singoli caratteri, il confronto utilizza le impostazioni cultura correnti. Ad esempio, possibile specificare una lingua che alcune combinazioni di caratteri siano considerate come un singolo carattere o caratteri maiuscoli e minuscoli da confrontare in modo specifico o che l'ordinamento di un carattere dipende i caratteri che precedono o seguono.  
  
 Il confronto viene eseguito utilizzando le regole di ordinamento di word. Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Quando si confrontano stringhe, è necessario chiamare il <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metodo, che richiede di specificare in modo esplicito il tipo di confronto di stringhe che utilizza il metodo. Per altre informazioni, vedere [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md) (Procedure consigliate per l'uso di stringhe).  
  
 Uno o entrambi i termini di confronto possono essere `null`. Per definizione, una stringa qualsiasi, compresa la stringa vuota (""), risulta maggiore di un riferimento null. e due riferimenti null risultano uguali tra loro.  
  
 Il confronto termina quando viene rilevata una disuguaglianza o entrambe le stringhe sono state confrontate. Se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, tuttavia, la stringa con caratteri rimanenti è considerata maggiore. Il valore restituito è il risultato dell'ultimo confronto eseguito.  
  
 Quando i confronti vengono applicati le regole specifiche delle impostazioni cultura di maiuscole e minuscole, possono verificarsi risultati imprevisti. In lingua turca, ad esempio, il nell'esempio seguente restituirà un risultato errato poiché il file system in turco non utilizza regole linguistiche maiuscole e minuscole per la lettera "i" in "file".  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 Confrontare il nome del percorso "file" mediante un confronto ordinale. Il codice corretto per eseguire questa operazione è il seguente:  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.String.Compare%28System.String%2CSystem.String%29> metodo per confrontare tre set di stringhe.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 Nell'esempio seguente, il `ReverseStringComparer` classe illustra come è possibile valutare due stringhe con il <xref:System.String.Compare%2A> metodo.  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.Compare(System.String,System.String)" /> metodo non prende in considerazione tali caratteri quando viene eseguito un confronto dipendente dalle impostazioni cultura. Se, ad esempio, il codice seguente viene eseguito su di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, un confronto con distinzione delle impostazioni cultura di "animale" con "ani-mal" (con un segno meno facoltativo o U + 00AD) indica che le due stringhe sono equivalenti.  [! codice csharp [System.String.Compare#21] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.Compare/cs/compare21.cs#21)] [! codice vb [System.String.Compare#21] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.Compare/vb/compare21.vb#21)] per riconoscere i caratteri ignorabili in un confronto tra stringhe, chiamata di <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> metodo e fornire un valore di <see cref="F:System.Globalization.CompareOptions.Ordinal" /> o <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> per il parametro 'comparisonType'.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da confrontare.</param>
        <param name="strB">Seconda stringa da confrontare.</param>
        <param name="ignoreCase">
          <see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole durante il confronto; in caso contrario, <see langword="false" />.</param>
        <summary>Confronta due oggetti <see cref="T:System.String" /> specificati, ignorando o rispettando la distinzione tra maiuscole e minuscole, e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</summary>
        <returns>Intero con segno a 32 bit che indica la relazione lessicale tra i due termini di confronto.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description><paramref name="strA" /> precede <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Zero  </term><description><paramref name="strA" /> si trova nella stessa posizione di <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Maggiore di zero  </term><description><paramref name="strA" /> segue <paramref name="strB" /> nell'ordinamento.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei singoli caratteri, il confronto utilizza le impostazioni cultura correnti. Ad esempio, possibile specificare una lingua che alcune combinazioni di caratteri siano considerate come un singolo carattere o caratteri maiuscoli e minuscoli da confrontare in modo specifico o che l'ordinamento di un carattere dipende i caratteri che precedono o seguono.  
  
 Il confronto viene eseguito utilizzando le regole di ordinamento di word. Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Quando si confrontano stringhe, è necessario chiamare il <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metodo, che richiede di specificare in modo esplicito il tipo di confronto di stringhe che utilizza il metodo. Per altre informazioni, vedere [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md) (Procedure consigliate per l'uso di stringhe).  
  
 Uno o entrambi i termini di confronto possono essere `null`. Per definizione, una stringa qualsiasi, compresa la stringa vuota (""), risulta maggiore di un riferimento null. e due riferimenti null risultano uguali tra loro.  
  
 Il confronto termina quando viene rilevata una disuguaglianza o entrambe le stringhe sono state confrontate. Se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, tuttavia, la stringa con caratteri rimanenti è considerata maggiore. Il valore restituito è il risultato dell'ultimo confronto eseguito.  
  
 Quando i confronti vengono applicati le regole specifiche delle impostazioni cultura di maiuscole e minuscole, possono verificarsi risultati imprevisti. In lingua turca, ad esempio, il nell'esempio seguente restituirà un risultato errato poiché il file system in turco non utilizza regole linguistiche maiuscole e minuscole per la lettera "i" in "file".  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 Confrontare il nome del percorso "file" mediante un confronto ordinale. Il codice corretto per eseguire questa operazione è il seguente:  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 Nell'esempio seguente viene dimostrato che la <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> metodo equivale all'utilizzo <xref:System.String.ToUpper%2A> o <xref:System.String.ToLower%2A> durante il confronto di stringhe.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> metodo non prende in considerazione tali caratteri quando viene eseguito un confronto dipendente dalle impostazioni cultura. Se, ad esempio, il codice seguente viene eseguito su di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, un confronto dipendente dalle impostazioni cultura senza distinzione tra maiuscole e minuscole di "animale" con "Ani-mal" (con un segno meno facoltativo o U + 00AD) indica che le due stringhe sono equivalenti.  [! codice csharp [System.String.Compare#22] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.Compare/cs/compare22.cs#22)] [! codice vb [System.String.Compare#22] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.Compare/vb/compare22.vb#22)] per riconoscere i caratteri ignorabili in un confronto tra stringhe, chiamata di <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> metodo e fornire un valore di <see cref="F:System.Globalization.CompareOptions.Ordinal" /> o <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> per il <paramref name="comparisonType" /> parametro.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da confrontare.</param>
        <param name="strB">Seconda stringa da confrontare.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che specifica le regole da usare per il confronto.</param>
        <summary>Confronta due oggetti <see cref="T:System.String" /> specificati usando le regole specificate e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</summary>
        <returns>Intero con segno a 32 bit che indica la relazione lessicale tra i due termini di confronto.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description><paramref name="strA" /> precede <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Zero  </term><description><paramref name="strA" /> si trova nella stessa posizione di <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Maggiore di zero  </term><description><paramref name="strA" /> segue <paramref name="strB" /> nell'ordinamento.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `comparisonType` parametro indica se il confronto deve utilizzare le impostazioni cultura correnti o invarianti, rispettare o ignorare la distinzione tra i termini di confronto o utilizzare word (impostazioni cultura) o le regole di ordinamento (senza distinzione delle impostazioni cultura).  
  
 Uno o entrambi i termini di confronto possono essere `null`. Per definizione, una stringa qualsiasi, compresa la stringa vuota (""), risulta maggiore di un riferimento null. e due riferimenti null risultano uguali tra loro.  
  
 Il confronto termina quando viene rilevata una disuguaglianza o entrambe le stringhe sono state confrontate. Tuttavia, se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, la stringa con caratteri rimanenti è considerata maggiore. Il valore restituito è il risultato dell'ultimo confronto eseguito.  
  
 Quando i confronti vengono applicati le regole specifiche delle impostazioni cultura di maiuscole e minuscole, possono verificarsi risultati imprevisti. In lingua turca, ad esempio, il nell'esempio seguente restituirà un risultato errato poiché il file system in turco non utilizza regole linguistiche maiuscole e minuscole per la lettera "i" in "file".  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 Confrontare il nome del percorso "file" mediante un confronto ordinale. Il codice corretto per eseguire questa operazione è il seguente:  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 Nell'esempio seguente vengono confrontati tre versioni della lettera "I". I risultati sono interessati dalla scelta di impostazioni cultura, se è ignorare maiuscole/minuscole e se viene eseguito un confronto ordinale.  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore di <see cref="T:System.StringComparison" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.StringComparison" /> non è supportato.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> metodo non prende in considerazione tali caratteri quando viene eseguito un confronto dipendente dalle impostazioni cultura. Per riconoscere caratteri ignorabili il confronto, fornire un valore <see cref="F:System.StringComparison.Ordinal" /> oppure <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> per il <paramref name="comparisonType" /> parametro.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da confrontare.</param>
        <param name="strB">Seconda stringa da confrontare.</param>
        <param name="ignoreCase">
          <see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole durante il confronto; in caso contrario, <see langword="false" />.</param>
        <param name="culture">Oggetto che fornisce informazioni di confronto specifiche delle impostazioni cultura.</param>
        <summary>Confronta due oggetti <see cref="T:System.String" /> specificati, ignorando o rispettando la distinzione tra maiuscole e minuscole e usando le informazioni specifiche delle impostazioni cultura per influenzare il confronto, e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</summary>
        <returns>Intero con segno a 32 bit che indica la relazione lessicale tra i due termini di confronto.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description><paramref name="strA" /> precede <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Zero  </term><description><paramref name="strA" /> si trova nella stessa posizione di <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Maggiore di zero  </term><description><paramref name="strA" /> segue <paramref name="strB" /> nell'ordinamento.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nel confronto viene utilizzato il `culture` parametro per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei singoli caratteri. Ad esempio, possibile specificare una lingua che alcune combinazioni di caratteri siano considerate come un singolo carattere o caratteri maiuscoli e minuscoli da confrontare in modo specifico o che l'ordinamento di un carattere dipende i caratteri che precedono o seguono.  
  
 Il confronto viene eseguito utilizzando le regole di ordinamento di word. Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Uno o entrambi i termini di confronto possono essere `null`. Per definizione, una stringa qualsiasi, compresa la stringa vuota (""), risulta maggiore di un riferimento null. e due riferimenti null risultano uguali tra loro.  
  
 Il confronto termina quando viene rilevata una disuguaglianza o entrambe le stringhe sono state confrontate. Se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, tuttavia, la stringa con caratteri rimanenti è considerata maggiore. Il valore restituito è il risultato dell'ultimo confronto eseguito.  
  
 Quando i confronti vengono applicati le regole specifiche delle impostazioni cultura di maiuscole e minuscole, possono verificarsi risultati imprevisti. In lingua turca, ad esempio, il nell'esempio seguente restituirà un risultato errato poiché il file system in turco non utilizza regole linguistiche maiuscole e minuscole per la lettera "i" in "file".  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 Confrontare il nome del percorso "file" mediante un confronto ordinale. Il codice corretto per eseguire questa operazione è il seguente:  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come impostazioni cultura possono influire su un confronto. In ceco - impostazioni cultura Repubblica ceca, "ch" è un singolo carattere che è maggiore di "d". Tuttavia, in inglese - impostazioni cultura di Stati Uniti, "ch" è costituito da due caratteri e "c" è minore di "d".  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> è <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> metodo non prende in considerazione tali caratteri quando viene eseguito un confronto dipendente dalle impostazioni cultura. Se, ad esempio, il codice seguente viene eseguito su di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, un confronto senza distinzione di "animale" con "Ani-mal" (con un segno meno facoltativo o U + 00AD) tramite invariante delle impostazioni cultura indica che le due stringhe sono equivalenti.  [! codice csharp [System.String.Compare#23] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.Compare/cs/compare23.cs#23)] [! codice vb [System.String.Compare#23] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.Compare/vb/compare23.vb#23)] per riconoscere i caratteri ignorabili in un confronto tra stringhe, chiamata di <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> metodo e fornire un valore di <see cref="F:System.Globalization.CompareOptions.Ordinal" /> o <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> per il <paramref name="options" /> parametro.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da confrontare.</param>
        <param name="strB">Seconda stringa da confrontare.</param>
        <param name="culture">Impostazioni cultura che forniscono informazioni di confronto specifiche delle impostazioni cultura.</param>
        <param name="options">Opzioni da usare durante l'esecuzione del confronto (ad esempio, per ignorare la distinzione tra maiuscole e minuscole o i simboli).</param>
        <summary>Confronta due oggetti <see cref="T:System.String" /> specificati, usando le opzioni di confronto specificate e le informazioni specifiche delle impostazioni cultura per influenzare il confronto, e restituisce un intero che indica la relazione reciproca tra le due stringhe nell'ordinamento.</summary>
        <returns>Intero con segno a 32 bit che indica la relazione lessicale tra <paramref name="strA" /> e <paramref name="strB" />, come illustrato nella tabella seguente  <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description><paramref name="strA" /> precede <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Zero  </term><description><paramref name="strA" /> si trova nella stessa posizione di <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Maggiore di zero  </term><description><paramref name="strA" /> segue <paramref name="strB" /> nell'ordinamento.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nel confronto viene utilizzato il `culture` parametro per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei singoli caratteri. Ad esempio, possibile specificare determinate impostazioni cultura che alcune combinazioni di caratteri siano considerate come un singolo carattere, che i caratteri maiuscoli e minuscoli essere confrontati in modo specifico, o che varia a seconda dell'ordinamento di un carattere i caratteri che è preceduto o seguito.  
  
> [!CAUTION]
>  Il <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> metodo è progettato principalmente per l'utilizzo nelle operazioni di ordinamento alfabetico di ordinamento. Non deve essere utilizzato quando lo scopo principale della chiamata al metodo consiste nel determinare se due stringhe sono equivalenti (ovvero, quando lo scopo della chiamata al metodo consiste nel verificare la presenza di un valore restituito pari a zero). Per determinare se due stringhe sono equivalenti, chiamare il <xref:System.String.Equals%2A> metodo.  
  
 Il confronto può essere ulteriormente specificato mediante il `options` parametro, che è costituito da uno o più membri del <xref:System.Globalization.CompareOptions> enumerazione. Tuttavia, poiché lo scopo di questo metodo è eseguire un confronto tra stringhe con distinzione delle impostazioni cultura, il <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> e <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> valori non hanno alcun effetto.  
  
 Uno o entrambi i termini di confronto possono essere `null`. Per definizione, qualsiasi stringa, inclusi <xref:System.String.Empty?displayProperty=nameWithType>, risulta maggiore di un riferimento null e due riferimenti null risultano uguali tra loro.  
  
 Il confronto termina quando viene rilevata una disuguaglianza o entrambe le stringhe sono state confrontate. Tuttavia, se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, la stringa con i caratteri rimanenti è considerata maggiore.  
  
   
  
## Examples  
 Nell'esempio seguente vengono confrontate due stringhe in tre modi diversi: utilizzando il confronto linguistico per le impostazioni cultura en-US; tramite il confronto tra maiuscole e minuscole linguistico per le impostazioni cultura en-US; e l'utilizzo di un confronto ordinale. Viene illustrato come i tre metodi di confronto producano tre risultati diversi.  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> non è un valore di <see cref="T:System.Globalization.CompareOptions" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> è <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati quando si esegue un confronto linguistico o dipendente dalla lingua. Il <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> metodo non prende in considerazione tali caratteri quando viene eseguito un confronto dipendente dalle impostazioni cultura. Per riconoscere caratteri ignorabili il confronto, fornire un valore <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oppure <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> per il <paramref name="options" /> parametro.</para>
        </block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da usare nel confronto.</param>
        <param name="indexA">Posizione della sottostringa all'interno di <c>strA</c>.</param>
        <param name="strB">Seconda stringa da usare nel confronto.</param>
        <param name="indexB">Posizione della sottostringa all'interno di <c>strB</c>.</param>
        <param name="length">Numero massimo di caratteri contenuti nelle sottostringhe da confrontare.</param>
        <summary>Confronta le sottostringhe di due oggetti <see cref="T:System.String" /> specificati e restituisce un intero che indica la relativa posizione nell'ordinamento.</summary>
        <returns>Intero con segno a 32 bit che indica la relazione lessicale tra i due termini del confronto.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description> La sottostringa in <paramref name="strA" /> precede la sottostringa in <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Zero  </term><description>  Le sottostringhe si trovano nella stessa posizione nell'ordinamento oppure <paramref name="length" /> è zero.  </description></item><item><term> Maggiore di zero  </term><description> La sottostringa in <paramref name="strA" /> segue la sottostringa in <paramref name="strB" /> nell'ordinamento.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avviare le sottostringhe da confrontare in `strA` in `indexA` e `strB` in `indexB`. Entrambi `indexA` e `indexB` sono in base zero, ovvero il primo carattere in `strA` e `strB` alla posizione zero. La lunghezza della prima sottostringa è uguale alla lunghezza di `strA` meno `indexA` più uno. La lunghezza della seconda sottostringa è uguale alla lunghezza di `strB` meno `indexB` più uno.  
  
 Il numero di caratteri da confrontare è il minore tra le lunghezze delle due sottostringhe, e `length`. Il `indexA`, `indexB`, e `length` i parametri devono essere non negativi.  
  
 Per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei singoli caratteri, il confronto utilizza le impostazioni cultura correnti. Ad esempio, possibile specificare una lingua che alcune combinazioni di caratteri siano considerate come un singolo carattere o caratteri maiuscoli e minuscoli da confrontare in modo specifico o che l'ordinamento di un carattere dipende i caratteri che precedono o seguono.  
  
 Il confronto viene eseguito utilizzando le regole di ordinamento di word. Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Quando si confrontano stringhe, è necessario chiamare il <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> metodo, che richiede di specificare in modo esplicito il tipo di confronto di stringhe che utilizza il metodo. Per altre informazioni, vedere [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md) (Procedure consigliate per l'uso di stringhe).  
  
 Uno o entrambi i termini di confronto possono essere `null`. Per definizione, una stringa qualsiasi, compresa la stringa vuota (""), risulta maggiore di un riferimento null. e due riferimenti null risultano uguali tra loro.  
  
 Il confronto termina quando viene rilevata una disuguaglianza o sono state confrontate entrambe le sottostringhe. Se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, tuttavia, la stringa con caratteri rimanenti è considerata maggiore. Il valore restituito è il risultato dell'ultimo confronto eseguito.  
  
 Quando i confronti vengono applicati le regole specifiche delle impostazioni cultura di maiuscole e minuscole, possono verificarsi risultati imprevisti. In lingua turca, ad esempio, il nell'esempio seguente restituirà un risultato errato poiché il file system in turco non utilizza regole linguistiche maiuscole e minuscole per la lettera "i" in "file".  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 Confrontare il nome del percorso "file" mediante un confronto ordinale. Il codice corretto per eseguire questa operazione è il seguente:  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 Nell'esempio seguente confronta le sottostringhe di due.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> è maggiore di <paramref name="strA" /><see cref="P:System.String.Length" />.  oppure  <paramref name="indexB" /> è maggiore di <paramref name="strB" />.<see cref="P:System.String.Length" />.  oppure  <paramref name="indexA" />, <paramref name="indexB" /> o <paramref name="length" /> è negativo.  oppure  <paramref name="indexA" /> o <paramref name="indexB" /> è <see langword="null" /> e <paramref name="length" /> è maggiore di zero.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> metodo non prende in considerazione tali caratteri quando viene eseguito un confronto linguistico o dipendente dalle impostazioni cultura. Per riconoscere caratteri ignorabili il confronto, chiamare il <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> metodo e fornire un valore <see cref="F:System.Globalization.CompareOptions.Ordinal" /> o <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> per il <paramref name="comparisonType" /> parametro.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da usare nel confronto.</param>
        <param name="indexA">Posizione della sottostringa all'interno di <c>strA</c>.</param>
        <param name="strB">Seconda stringa da usare nel confronto.</param>
        <param name="indexB">Posizione della sottostringa all'interno di <c>strB</c>.</param>
        <param name="length">Numero massimo di caratteri contenuti nelle sottostringhe da confrontare.</param>
        <param name="ignoreCase">
          <see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole durante il confronto; in caso contrario, <see langword="false" />.</param>
        <summary>Confronta le sottostringhe di due oggetti <see cref="T:System.String" /> specificati, ignorando o rispettando la distinzione tra maiuscole e minuscole, e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</summary>
        <returns>Intero con segno a 32 bit che indica la relazione lessicale tra i due termini di confronto.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description> La sottostringa in <paramref name="strA" /> precede la sottostringa in <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Zero  </term><description>  Le sottostringhe si trovano nella stessa posizione nell'ordinamento oppure <paramref name="length" /> è zero.  </description></item><item><term> Maggiore di zero  </term><description> La sottostringa in <paramref name="strA" /> segue la sottostringa in <paramref name="strB" /> nell'ordinamento.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avviare le sottostringhe da confrontare in `strA` in `indexA`e in `strB` in `indexB`. Entrambi `indexA` e `indexB` sono in base zero, ovvero il primo carattere in `strA` e `strB` alla posizione zero. La lunghezza della prima sottostringa è uguale alla lunghezza di `strA` meno `indexA` più uno. La lunghezza della seconda sottostringa è uguale alla lunghezza di `strB` meno `indexB` più uno.  
  
 Il numero di caratteri da confrontare è il minore tra le lunghezze delle due sottostringhe, e `length`. Il `indexA`, `indexB`, e `length` i parametri devono essere non negativi.  
  
 Per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei singoli caratteri, il confronto utilizza le impostazioni cultura correnti. Ad esempio, possibile specificare una lingua che alcune combinazioni di caratteri siano considerate come un singolo carattere o caratteri maiuscoli e minuscoli da confrontare in modo specifico o che l'ordinamento di un carattere dipende i caratteri che precedono o seguono.  
  
 Il confronto viene eseguito utilizzando le regole di ordinamento di word. Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Quando si confrontano stringhe, è necessario chiamare il <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> metodo, che richiede di specificare in modo esplicito il tipo di confronto di stringhe che utilizza il metodo. Per altre informazioni, vedere [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md) (Procedure consigliate per l'uso di stringhe).  
  
 Uno o entrambi i termini di confronto possono essere `null`. Per definizione, una stringa qualsiasi, compresa la stringa vuota (""), risulta maggiore di un riferimento null. e due riferimenti null risultano uguali tra loro.  
  
 Il confronto termina quando viene rilevata una disuguaglianza o sono state confrontate entrambe le sottostringhe. Se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, tuttavia, la stringa con caratteri rimanenti è considerata maggiore. Il valore restituito è il risultato dell'ultimo confronto eseguito.  
  
 Quando i confronti vengono applicati le regole specifiche delle impostazioni cultura di maiuscole e minuscole, possono verificarsi risultati imprevisti. In lingua turca, ad esempio, il nell'esempio seguente restituirà un risultato errato poiché il file system in turco non utilizza regole linguistiche maiuscole e minuscole per la lettera "i" in "file".  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 Il nome del percorso deve essere confrontato in modo invariante. Il codice corretto per eseguire questa operazione è come indicato di seguito.  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 Nell'esempio seguente esegue due confronti fra due sottostringhe che differiscono solo nel caso. Ignora il primo confronto e il confronto secondo considera caso.  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> è maggiore di <paramref name="strA" /><see cref="P:System.String.Length" />.  oppure  <paramref name="indexB" /> è maggiore di <paramref name="strB" />.<see cref="P:System.String.Length" />.  oppure  <paramref name="indexA" />, <paramref name="indexB" /> o <paramref name="length" /> è negativo.  oppure  <paramref name="indexA" /> o <paramref name="indexB" /> è <see langword="null" /> e <paramref name="length" /> è maggiore di zero.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> metodo non prende in considerazione tali caratteri quando viene eseguito un confronto linguistico o dipendente dalle impostazioni cultura. Per riconoscere caratteri ignorabili il confronto, chiamare il <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> metodo e fornire un valore <see cref="F:System.Globalization.CompareOptions.Ordinal" /> o <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> per il <paramref name="comparisonType" /> parametro.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da usare nel confronto.</param>
        <param name="indexA">Posizione della sottostringa all'interno di <c>strA</c>.</param>
        <param name="strB">Seconda stringa da usare nel confronto.</param>
        <param name="indexB">Posizione della sottostringa all'interno di <c>strB</c>.</param>
        <param name="length">Numero massimo di caratteri contenuti nelle sottostringhe da confrontare.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che specifica le regole da usare per il confronto.</param>
        <summary>Confronta sottostringhe di due oggetti <see cref="T:System.String" /> specificati usando le regole specificate e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</summary>
        <returns>Intero con segno a 32 bit che indica la relazione lessicale tra i due termini di confronto.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description> La sottostringa in <paramref name="strA" /> precede la sottostringa in <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Zero  </term><description> Le sottostringhe si trovano nella stessa posizione nell'ordinamento oppure il parametro <paramref name="length" /> è zero.  </description></item><item><term> Maggiore di zero  </term><description> La sottostringa in <paramref name="strA" /> segue la sottostringa in <paramref name="strB" /> nell'ordinamento.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avviare le sottostringhe da confrontare in `strA` in `indexA` e `strB` in `indexB`. Entrambi `indexA` e `indexB` sono in base zero, ovvero il primo carattere in `strA` e `strB` si trova nella posizione zero, non nella posizione uno. La lunghezza della prima sottostringa è uguale alla lunghezza di `strA` meno `indexA` più uno. La lunghezza della seconda sottostringa è uguale alla lunghezza di `strB` meno `indexB` più uno.  
  
 Il numero di caratteri da confrontare è il minore tra le lunghezze delle due sottostringhe, e `length`. Il `indexA`, `indexB`, e `length` i parametri devono essere non negativi.  
  
 Il `comparisonType` parametro indica se il confronto deve utilizzare le impostazioni cultura correnti o invarianti, rispettare o ignorare la distinzione tra i termini di confronto o utilizzare word (impostazioni cultura) o le regole di ordinamento (senza distinzione delle impostazioni cultura).  
  
 Uno o entrambi i termini di confronto possono essere `null`. Per definizione, una stringa qualsiasi, compresa la stringa vuota (""), risulta maggiore di un riferimento null. e due riferimenti null risultano uguali tra loro.  
  
 Il confronto termina quando viene rilevata una disuguaglianza o sono state confrontate entrambe le sottostringhe. Tuttavia, se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, la stringa con caratteri rimanenti è considerata maggiore. Il valore restituito è il risultato dell'ultimo confronto eseguito.  
  
 Quando i confronti vengono applicati le regole specifiche delle impostazioni cultura di maiuscole e minuscole, possono verificarsi risultati imprevisti. In lingua turca, ad esempio, il nell'esempio seguente restituirà un risultato errato poiché il file system in turco non utilizza regole linguistiche maiuscole e minuscole per la lettera "i" in "file".  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 Confrontare il nome del percorso "file" mediante un confronto ordinale. Il codice corretto per eseguire questa operazione è il seguente:  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 Nell'esempio seguente confronta le sottostringhe di due.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> è maggiore di <paramref name="strA" /><see cref="P:System.String.Length" />.  oppure  <paramref name="indexB" /> è maggiore di <paramref name="strB" />.<see cref="P:System.String.Length" />.  oppure  <paramref name="indexA" />, <paramref name="indexB" /> o <paramref name="length" /> è negativo.  oppure  <paramref name="indexA" /> o <paramref name="indexB" /> è <see langword="null" /> e <paramref name="length" /> è maggiore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore di <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> metodo non prende in considerazione tali caratteri quando viene eseguito un confronto linguistico o dipendente dalle impostazioni cultura. Per riconoscere caratteri ignorabili il confronto, fornire un valore <see cref="F:System.StringComparison.Ordinal" /> oppure <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> per il <paramref name="comparisonType" /> parametro.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da usare nel confronto.</param>
        <param name="indexA">Posizione della sottostringa all'interno di <c>strA</c>.</param>
        <param name="strB">Seconda stringa da usare nel confronto.</param>
        <param name="indexB">Posizione della sottostringa all'interno di <c>strB</c>.</param>
        <param name="length">Numero massimo di caratteri contenuti nelle sottostringhe da confrontare.</param>
        <param name="ignoreCase">
          <see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole durante il confronto; in caso contrario, <see langword="false" />.</param>
        <param name="culture">Oggetto che fornisce informazioni di confronto specifiche delle impostazioni cultura.</param>
        <summary>Confronta le sottostringhe di due oggetti <see cref="T:System.String" /> specificati, ignorando o rispettando la distinzione tra maiuscole e minuscole e usando le informazioni specifiche delle impostazioni cultura per influenzare il confronto, e restituisce un intero che ne indica la posizione relativa nell'ordinamento.</summary>
        <returns>Intero che indica la relazione lessicale tra i due termini di confronto.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description> La sottostringa in <paramref name="strA" /> precede la sottostringa in <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Zero  </term><description>  Le sottostringhe si trovano nella stessa posizione nell'ordinamento oppure <paramref name="length" /> è zero.  </description></item><item><term> Maggiore di zero  </term><description> La sottostringa in <paramref name="strA" /> segue la sottostringa in <paramref name="strB" /> nell'ordinamento.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avviare le sottostringhe da confrontare in `strA` in `indexA`e in `strB` in `indexB`. Entrambi `indexA` e `indexB` sono in base zero, ovvero il primo carattere in `strA` e `strB` si trova nella posizione zero, non nella posizione uno. La lunghezza della prima sottostringa è uguale alla lunghezza di `strA` meno `indexA` più uno. La lunghezza della seconda sottostringa è uguale alla lunghezza di `strB` meno `indexB` più uno.  
  
 Il numero di caratteri da confrontare è il minore tra le lunghezze delle due sottostringhe, e `length`. Il `indexA`, `indexB`, e `length` i parametri devono essere non negativi.  
  
 Nel confronto viene utilizzato il `culture` parametro per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei singoli caratteri. Ad esempio, possibile specificare una lingua che alcune combinazioni di caratteri siano considerate come un singolo carattere o caratteri maiuscoli e minuscoli da confrontare in modo specifico o che l'ordinamento di un carattere dipende i caratteri che precedono o seguono.  
  
 Il confronto viene eseguito utilizzando le regole di ordinamento di word. Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Uno o entrambi i termini di confronto possono essere `null`. Per definizione, una stringa qualsiasi, compresa la stringa vuota (""), risulta maggiore di un riferimento null. e due riferimenti null risultano uguali tra loro.  
  
 Il confronto termina quando viene rilevata una disuguaglianza o sono state confrontate entrambe le sottostringhe. Se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, tuttavia, la stringa con caratteri rimanenti è considerata maggiore. Il valore restituito è il risultato dell'ultimo confronto eseguito.  
  
 Quando i confronti vengono applicati le regole specifiche delle impostazioni cultura di maiuscole e minuscole, possono verificarsi risultati imprevisti. In lingua turca, ad esempio, il nell'esempio seguente restituirà un risultato errato poiché il file system in turco non utilizza regole linguistiche maiuscole e minuscole per la lettera "i" in "file".  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 Confrontare il nome del percorso "file" mediante un confronto ordinale. Il codice corretto per eseguire questa operazione è il seguente:  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 L'esempio seguente confronta le sottostringhe di due usando diverse impostazioni cultura e ignorare la distinzione tra delle sottostringhe. La scelta della lingua influisce sul modo in cui la lettera "I" viene confrontato.  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> è maggiore di <paramref name="strA" /><see cref="P:System.String.Length" />.  oppure  <paramref name="indexB" /> è maggiore di <paramref name="strB" />.<see cref="P:System.String.Length" />.  oppure  <paramref name="indexA" />, <paramref name="indexB" /> o <paramref name="length" /> è negativo.  oppure  <paramref name="strA" /> o <paramref name="strB" /> è <see langword="null" /> e <paramref name="length" /> è maggiore di zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> è <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> metodo non prende in considerazione tali caratteri quando viene eseguito un confronto linguistico o dipendente dalle impostazioni cultura. Per riconoscere caratteri ignorabili il confronto, chiamare il <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> metodo e fornire un valore <see cref="F:System.Globalization.CompareOptions.Ordinal" /> o <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> per il <paramref name="options" /> parametro.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da usare nel confronto.</param>
        <param name="indexA">Posizione iniziale della sottostringa all'interno di <c>strA</c>.</param>
        <param name="strB">Seconda stringa da usare nel confronto.</param>
        <param name="indexB">Posizione iniziale della sottostringa all'interno di <c>strB</c>.</param>
        <param name="length">Numero massimo di caratteri contenuti nelle sottostringhe da confrontare.</param>
        <param name="culture">Oggetto che fornisce informazioni di confronto specifiche delle impostazioni cultura.</param>
        <param name="options">Opzioni da usare durante l'esecuzione del confronto (ad esempio, per ignorare la distinzione tra maiuscole e minuscole o i simboli).</param>
        <summary>Confronta le sottostringhe di due oggetti <see cref="T:System.String" /> specificati, usando le opzioni di confronto specificate e le informazioni specifiche delle impostazioni cultura per influenzare il confronto, e restituisce un intero che indica la relazione reciproca tra le due sottostringhe nell'ordinamento.</summary>
        <returns>Intero che indica la relazione lessicale tra le due sottostringhe, come illustrato nella tabella seguente.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description> La sottostringa in <paramref name="strA" /> precede la sottostringa in <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Zero  </term><description>  Le sottostringhe si trovano nella stessa posizione nell'ordinamento oppure <paramref name="length" /> è zero.  </description></item><item><term> Maggiore di zero  </term><description> La sottostringa in <paramref name="strA" /> segue la sottostringa in <paramref name="strB" /> nell'ordinamento.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avviare le sottostringhe da confrontare in `strA` posizione `indexA` e `strB` nella posizione `indexB`. La lunghezza della prima sottostringa è la lunghezza di `strA` meno `indexA`. La lunghezza della seconda sottostringa è la lunghezza di `strB` meno `indexB`.  
  
 Il numero di caratteri da confrontare è il minore tra le lunghezze delle due sottostringhe, e `length`. Il `indexA`, `indexB`, e `length` i parametri devono essere non negativi.  
  
 Nel confronto viene utilizzato il `culture` parametro per ottenere informazioni specifiche delle impostazioni cultura, ad esempio le regole di maiuscole e minuscole e l'ordine alfabetico dei singoli caratteri. Ad esempio, possibile specificare determinate impostazioni cultura che alcune combinazioni di caratteri siano considerate come un singolo carattere, che i caratteri maiuscoli e minuscoli essere confrontati in modo specifico, o che varia a seconda dell'ordinamento di un carattere i caratteri che è preceduto o seguito.  
  
> [!CAUTION]
>  Il <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> metodo è progettato principalmente per l'utilizzo nelle operazioni di ordinamento alfabetico di ordinamento. Non deve essere utilizzato quando lo scopo principale della chiamata al metodo consiste nel determinare se le due sottostringhe sono equivalenti (ovvero, quando lo scopo della chiamata al metodo consiste nel verificare la presenza di un valore restituito pari a zero). Per determinare se due stringhe sono equivalenti, chiamare il <xref:System.String.Equals%2A> metodo.  
  
 Uno o entrambi `strA` e `strB` può essere `null`. Per definizione, qualsiasi stringa, inclusi <xref:System.String.Empty?displayProperty=nameWithType>, risulta maggiore di un riferimento null e due riferimenti null risultano uguali tra loro.  
  
 Il confronto può essere ulteriormente specificato mediante il `options` parametro, che è costituito da uno o più membri del <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumerazione. Tuttavia, poiché lo scopo di questo metodo è eseguire un confronto tra stringhe con distinzione delle impostazioni cultura, il <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> e <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> valori non hanno alcun effetto.  
  
 Il confronto termina quando viene rilevata una disuguaglianza o sono state confrontate entrambe le sottostringhe. Tuttavia, se le due stringhe risultano uguali alla fine di una stringa e l'altra stringa contiene caratteri rimanenti, la stringa con i caratteri rimanenti è considerata maggiore. Il valore restituito è il risultato dell'ultimo confronto eseguito.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> metodo per confrontare i cognomi di due persone. Vengono quindi elencati in ordine alfabetico.  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> non è un valore di <see cref="T:System.Globalization.CompareOptions" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> è maggiore di <paramref name="strA" /><see langword=".Length" />.  oppure  <paramref name="indexB" /> è maggiore di <paramref name="strB" /><see langword=".Length" />.  oppure  <paramref name="indexA" />, <paramref name="indexB" /> o <paramref name="length" /> è negativo.  oppure  <paramref name="strA" /> o <paramref name="strB" /> è <see langword="null" /> e <paramref name="length" /> è maggiore di zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> è <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> metodo non prende in considerazione tali caratteri quando viene eseguito un confronto linguistico o dipendente dalle impostazioni cultura. Per riconoscere caratteri ignorabili il confronto, fornire un valore <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oppure <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> per il <paramref name="options" /> parametro.</para>
        </block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Confronta due oggetti <see cref="T:System.String" /> in base all'analisi dei valori numerici dei corrispondenti oggetti <see cref="T:System.Char" /> in ciascuna stringa.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da confrontare.</param>
        <param name="strB">Seconda stringa da confrontare.</param>
        <summary>Confronta due oggetti <see cref="T:System.String" /> specificati in base all'analisi dei valori numerici dei corrispondenti oggetti <see cref="T:System.Char" /> in ogni stringa.</summary>
        <returns>Intero che indica la relazione lessicale tra i due termini di confronto.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description><paramref name="strA" /> è minore di <paramref name="strB" />.  </description></item><item><term> Zero  </term><description><paramref name="strA" /> e <paramref name="strB" /> sono uguali.  </description></item><item><term> Maggiore di zero  </term><description><paramref name="strA" /> è maggiore di <paramref name="strB" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue un confronto tra maiuscole e minuscole usando le regole di ordinamento. Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Per eseguire un confronto tra maiuscole e minuscole usando le regole di ordinamento, chiamare il <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> metodo con il `comparisonType` argomento impostato su <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 Poiché <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> è un metodo statico, `strA` e `strB` può essere `null`. Se entrambi i valori sono `null`, il metodo restituisce 0 (zero), che indica che `strA` e `strB` sono uguali. Se solo uno dei valori è `null`, il metodo considererà il valore non null devono essere maggiori.  
  
   
  
## Examples  
 Nell'esempio seguente viene eseguito e un confronto ordinale di due stringhe che differiscono solo per i casi.  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Prima stringa da usare nel confronto.</param>
        <param name="indexA">Indice iniziale della sottostringa di <c>strA</c>.</param>
        <param name="strB">Seconda stringa da usare nel confronto.</param>
        <param name="indexB">Indice iniziale della sottostringa di <c>strB</c>.</param>
        <param name="length">Numero massimo di caratteri contenuti nelle sottostringhe da confrontare.</param>
        <summary>Effettua il confronto fra sottostringhe di due determinati oggetti <see cref="T:System.String" /> in base all'analisi dei valori numerici dei corrispondenti oggetti <see cref="T:System.Char" /> in ogni sottostringa.</summary>
        <returns>Intero con segno a 32 bit che indica la relazione lessicale tra i due termini di confronto.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description> La sottostringa in <paramref name="strA" /> è minore della sottostringa in <paramref name="strB" />.  </description></item><item><term> Zero  </term><description> Le sottostringhe sono uguali o <paramref name="length" /> è zero.  </description></item><item><term> Maggiore di zero  </term><description> La sottostringa in <paramref name="strA" /> è maggiore della sottostringa in <paramref name="strB" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `indexA`, `indexB`, e `length` i parametri devono essere non negativi.  
  
 Il numero di caratteri confrontato sia il valore minore della lunghezza di `strA` meno `indexA`, la lunghezza di `strB` meno `indexB`, e `length`.  
  
 Questo metodo esegue un confronto tra maiuscole e minuscole usando le regole di ordinamento. Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Per eseguire un confronto tra maiuscole e minuscole usando le regole di ordinamento, chiamare il <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> metodo con il `comparisonType` argomento impostato su <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 Poiché <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> è un metodo statico, `strA` e `strB` può essere `null`. Se entrambi i valori sono `null`, il metodo restituisce 0 (zero), che indica che `strA` e `strB` sono uguali. Se solo uno dei valori è `null`, il metodo considererà il valore non null devono essere maggiori.  
  
   
  
## Examples  
 Nell'esempio seguente viene dimostrato che <xref:System.String.CompareOrdinal%2A> e <xref:System.String.Compare%2A> utilizzare diversi tipi di ordinamento.  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="strA" /> non è <see langword="null" /> e <paramref name="indexA" /> è maggiore di <paramref name="strA" /><see cref="P:System.String.Length" />.  oppure  <paramref name="strB" /> non è <see langword="null" /> e <paramref name="indexB" /> è maggiore di <paramref name="strB" />.<see cref="P:System.String.Length" />.  oppure  <paramref name="indexA" />, <paramref name="indexB" /> o <paramref name="length" /> è negativo.</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Confronta questa istanza con <see cref="T:System.String" /> o un oggetto specificato e restituisce un intero che indica se questa istanza precede, segue o si trova nella stessa posizione di <see cref="T:System.String" /> o dell'oggetto specificato nell'ordinamento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Entrambi gli overload di <xref:System.String.CompareTo%2A> metodo eseguire confronto dipendenti dalle impostazioni cultura e tra maiuscole e minuscole. È possibile utilizzare questo metodo per eseguire confronti con distinzione delle impostazioni cultura o per ordinale. Per maggiore chiarezza del codice, è consigliabile evitare il <xref:System.String.CompareTo%2A> metodo e chiamare il <xref:System.String.Compare%2A> metodo invece.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Oggetto che restituisce un oggetto <see cref="T:System.String" />.</param>
        <summary>Confronta questa istanza con un oggetto <see cref="T:System.Object" /> specificato e indica se questa istanza precede, segue o si trova nella stessa posizione dell'oggetto <see cref="T:System.Object" /> specificato all'interno dell'ordinamento.</summary>
        <returns>Intero con segno a 32 bit che indica se questa istanza precede, segue o si trova nella stessa posizione del parametro <paramref name="value" /> nell'ordinamento.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description> L'istanza precede <paramref name="value" />.  </description></item><item><term> Zero  </term><description> L'istanza si trova nella stessa posizione di <paramref name="value" /> nell'ordinamento.  </description></item><item><term> Maggiore di zero  </term><description> L'istanza segue <paramref name="value" />. .  oppure  <paramref name="value" /> è <see langword="null" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` deve essere un <xref:System.String> oggetto.  
  
> [!CAUTION]
>  Il <xref:System.String.CompareTo%2A> metodo è stato progettato principalmente per l'utilizzo nelle operazioni di ordinamento alfabetico di ordinamento. Non deve essere utilizzato quando lo scopo principale della chiamata al metodo consiste nel determinare se due stringhe sono equivalenti. Per determinare se due stringhe sono equivalenti, chiamare il <xref:System.String.Equals%2A> metodo.  
  
 Questo metodo esegue un confronto per parola (maiuscole/minuscole e distinzione delle impostazioni cultura) utilizzando le impostazioni cultura correnti. Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Per ulteriori informazioni sul comportamento di questo metodo, vedere la sezione Note del <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> metodo.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.String.CompareTo%2A> metodo con un <xref:System.Object>. Perché tenta di confrontare un <xref:System.String> istanza a un `TestClass` dell'oggetto, il metodo genera un <xref:System.ArgumentException>.  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> non è un oggetto <see cref="T:System.String" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.CompareTo(System.Object)" /> metodo non prende in considerazione tali caratteri quando viene eseguito un confronto dipendente dalle impostazioni cultura. Se, ad esempio, il codice seguente viene eseguito su di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, un confronto tra "animale" con "ani-mal" (con un segno meno facoltativo o U + 00AD) indica che le due stringhe sono equivalenti.  [! code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [! code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)]  Per riconoscere caratteri ignorabili in un confronto tra stringhe, chiamare il <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> metodo.</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">Stringa da confrontare con questa istanza.</param>
        <summary>Confronta questa istanza con un oggetto <see cref="T:System.String" /> specificato e indica se questa istanza precede, segue o si trova nella stessa posizione della stringa specificata all'interno dei criteri di ordinamento.</summary>
        <returns>Intero con segno a 32 bit che indica se questa istanza precede, segue o si trova nella stessa posizione del parametro <paramref name="strB" /> nell'ordinamento.  
  
 <list type="table"><listheader><term> Valore  </term><description> Condizione  </description></listheader><item><term> Minore di zero  </term><description> L'istanza precede <paramref name="strB" />.  </description></item><item><term> Zero  </term><description> L'istanza si trova nella stessa posizione di <paramref name="strB" /> nell'ordinamento.  </description></item><item><term> Maggiore di zero  </term><description> L'istanza segue <paramref name="strB" />. .  oppure  <paramref name="strB" /> è <see langword="null" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue un confronto per parola (maiuscole/minuscole e distinzione delle impostazioni cultura) utilizzando le impostazioni cultura correnti. Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  Il <xref:System.String.CompareTo%2A> metodo è stato progettato principalmente per l'utilizzo nelle operazioni di ordinamento alfabetico di ordinamento. Non deve essere utilizzato quando lo scopo principale della chiamata al metodo consiste nel determinare se due stringhe sono equivalenti. Per determinare se due stringhe sono equivalenti, chiamare il <xref:System.String.Equals%2A> metodo.  
  
 Per ulteriori informazioni sul comportamento di questo metodo, vedere la sezione Note del <xref:System.String.Compare%28System.String%2CSystem.String%29> metodo.  
  
 Questo metodo implementa il <xref:System.IComparable%601?displayProperty=nameWithType> interfaccia ed esegue leggermente migliori rispetto di <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> metodo, perché non è necessario determinare se il `strB` argomento è un tipo di valore modificabile che deve essere di tipo boxed e non deve eseguire il cast relativo parametro da un <xref:System.Object> per un <xref:System.String>.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.String.CompareTo%2A> metodo per confrontare l'istanza di stringa corrente con un'altra stringa.  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 Nell'esempio seguente vengono illustrate le versioni generiche e non generici del metodo CompareTo per vari tipi di valore e riferimento.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili. Il <see cref="M:System.String.CompareTo(System.String)" /> metodo non prende in considerazione tali caratteri quando viene eseguito un confronto dipendente dalle impostazioni cultura. Se, ad esempio, il codice seguente viene eseguito su di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, un confronto tra "animale" con "ani-mal" (con un segno meno facoltativo o U + 00AD) indica che le due stringhe sono equivalenti.  [! code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [! code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)]  Per riconoscere caratteri ignorabili in un confronto tra stringhe, chiamare il <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> metodo.</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatena una o più istanze di <see cref="T:System.String" /> oppure le rappresentazioni <see cref="T:System.String" /> dei valori di una o più istanze di <see cref="T:System.Object" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="values">Oggetto Collection che implementa <see cref="T:System.Collections.Generic.IEnumerable`1" /> e il cui argomento di tipo generico è <see cref="T:System.String" />.</param>
        <summary>Concatena i membri di una raccolta <see cref="T:System.Collections.Generic.IEnumerable`1" /> costruita di tipo <see cref="T:System.String" />.</summary>
        <returns>Stringhe concatenate in <paramref name="values" /> o <see cref="F:System.String.Empty" /> se <paramref name="values" /> è un oggetto <see langword="IEnumerable(Of String)" /> vuoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo concatena ogni oggetto in `values`; non vengono aggiunti i delimitatori. Per specificare un delimitatore tra ogni membro di `values`, chiamare il <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metodo.  
  
 Un <xref:System.String.Empty> stringa viene utilizzata al posto di qualsiasi elemento null in `values`.  
  
 Se `values` è un oggetto vuoto `IEnumerable(Of String)`, il metodo restituisce <xref:System.String.Empty?displayProperty=nameWithType>. Se `values` è `null`, il metodo genera un <xref:System.ArgumentNullException> eccezione.  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> è un metodo pratico che consente di concatenare ogni elemento in un `IEnumerable(Of String)` insieme senza prima di convertire gli elementi in una matrice di stringhe. È particolarmente utile con le espressioni di query Language-Integrated Query (LINQ). Nell'esempio seguente viene passato un `List(Of String)` oggetto contenente le lettere maiuscole o minuscole dell'alfabeto in un'espressione lambda che consente di selezionare lettere uguale a o maggiore di una determinata lettera (ovvero, nell'esempio, "M"). Il `IEnumerable(Of String)` raccolta restituita dal <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> viene passato per il <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metodo per visualizzare il risultato come stringa singola.  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 L'esempio seguente usa l'algoritmo del crivello di Eratostene per calcolare i numeri primi che sono minori o uguali a 100. Assegna il risultato a un <xref:System.Collections.Generic.List%601> oggetto di tipo <xref:System.String>, che passa quindi il <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> (metodo).  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Oggetto da rappresentare oppure <see langword="null" />.</param>
        <summary>Crea la rappresentazione di stringa di un oggetto specificato.</summary>
        <returns>Rappresentazione di stringa del valore di <paramref name="arg0" /> oppure <see cref="F:System.String.Empty" /> se <paramref name="arg0" /> è <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.Concat%28System.Object%29> metodo rappresenta `arg0` sotto forma di stringa chiamando il relativo senza parametri `ToString` metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.Concat%2A> metodo.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Matrice di oggetti contenente gli elementi da concatenare.</param>
        <summary>Concatena le rappresentazioni di stringa degli elementi in una matrice <see cref="T:System.Object" /> specificata.</summary>
        <returns>Rappresentazioni di stringa concatenate dei valori degli elementi di <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo concatena ogni oggetto in `args` chiamando il metodo senza parametri `ToString` metodo dell'oggetto; non vengono aggiunti i delimitatori.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> viene utilizzato al posto di qualsiasi oggetto null nella matrice.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.String.Concat%2A> metodo con un <xref:System.Object> matrice.  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> è <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente.</exception>
        <block subset="none" type="usage">
          <para>Questo metodo non viene chiamato da codice C++. Il compilatore C++ risolve le chiamate a <see cref="Overload:System.String.Concat" /> che dispone di quattro o più parametri di oggetto come una chiamata a <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</para>
        </block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">Matrice di istanze di stringa.</param>
        <summary>Concatena gli elementi di una matrice di oggetti <see cref="T:System.String" /> specificati.</summary>
        <returns>Elementi concatenati del parametro <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo concatena ogni oggetto in `values`; non vengono aggiunti i delimitatori.  
  
 Un <xref:System.String.Empty> stringa viene utilizzata al posto di qualsiasi oggetto null nella matrice.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.String.Concat%2A> metodo con un <xref:System.String> matrice.  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> è <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente.</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Primo oggetto da concatenare.</param>
        <param name="arg1">Secondo oggetto da concatenare.</param>
        <summary>Concatena le rappresentazioni di stringa di due oggetti specificati.</summary>
        <returns>Rappresentazioni di stringa concatenate dei valori di <paramref name="arg0" /> e <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo concatena `arg0` e `arg1` chiamando il metodo senza parametri `ToString` metodo `arg0` e `arg1`; non vengono aggiunti i delimitatori.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> viene utilizzato al posto di qualsiasi argomento null.  
  
 Se uno degli argomenti è un riferimento a una matrice, il metodo consente di concatenare una stringa che rappresenta la matrice, anziché i relativi membri (ad esempio, "System.String[]").  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.Concat%2A> metodo.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Prima stringa da concatenare.</param>
        <param name="str1">Seconda stringa da concatenare.</param>
        <summary>Concatena due istanze specificate della classe <see cref="T:System.String" />.</summary>
        <returns>Concatenazione dei parametri <paramref name="str0" /> e <paramref name="str1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo concatena `str0` e `str1`; non vengono aggiunti i delimitatori.  
  
> [!NOTE]
>  È inoltre possibile utilizzare operatore di concatenazione di stringhe del linguaggio, ad esempio `+` in c# o `&` e `+` in Visual Basic)  
>   
>  , per concatenare stringhe.  
  
 Un <xref:System.String.Empty> stringa viene utilizzata al posto di qualsiasi argomento null.  
  
   
  
## Examples  
 Nell'esempio seguente consente di concatenare, intermedio, nome e cognome una persona.  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Primo oggetto da concatenare.</param>
        <param name="arg1">Secondo oggetto da concatenare.</param>
        <param name="arg2">Terzo oggetto da concatenare.</param>
        <summary>Concatena le rappresentazioni di stringa di tre oggetti specificati.</summary>
        <returns>Rappresentazioni di stringa concatenate dei valori di <paramref name="arg0" />, <paramref name="arg1" /> e <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo concatena `arg0`, `arg1`, e `arg2` chiamando il metodo senza parametri `ToString` metodo di ciascun oggetto; non vengono aggiunti i delimitatori.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> viene utilizzato al posto di qualsiasi argomento null.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.Concat%2A> metodo.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Prima stringa da concatenare.</param>
        <param name="str1">Seconda stringa da concatenare.</param>
        <param name="str2">Terza stringa da concatenare.</param>
        <summary>Concatena tre istanze specificate della classe <see cref="T:System.String" />.</summary>
        <returns>Concatenazione dei parametri <paramref name="str0" />, <paramref name="str1" /> e <paramref name="str2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo concatena `str0`, `str1`, e `str2`; non vengono aggiunti i delimitatori.  
  
> [!NOTE]
>  È inoltre possibile utilizzare operatore di concatenazione di stringhe del linguaggio, ad esempio `+` in c# o `&` e `+` in Visual Basic)  
>   
>  , per concatenare stringhe.  
  
 Un <xref:System.String.Empty> stringa viene utilizzata al posto di qualsiasi argomento null.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.String.Concat%2A> per concatenare tre stringhe e viene visualizzato il risultato.  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Primo oggetto da concatenare.</param>
        <param name="arg1">Secondo oggetto da concatenare.</param>
        <param name="arg2">Terzo oggetto da concatenare.</param>
        <param name="arg3">Quarto oggetto da concatenare.</param>
        <summary>Concatena le rappresentazioni di stringa di quattro oggetti specificati e di qualsiasi oggetto specificato in un elenco di parametri di lunghezza variabile facoltativo.</summary>
        <returns>Rappresentazione di stringa concatenata di ogni valore nell'elenco dei parametri.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Questa API non è conforme a CLS. L'alternativa conforme a CLS è <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>. I compilatori c# e Visual Basic Risolvi automaticamente una chiamata a questo metodo come una chiamata a <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Il metodo concatena ogni oggetto nell'elenco dei parametri chiamando il relativo senza parametri `ToString` metodo; non vengono aggiunti i delimitatori.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> viene utilizzato al posto di qualsiasi argomento null.  
  
> [!NOTE]
>  L'ultimo parametro del <xref:System.String.Concat%2A> metodo è un elenco facoltativo delimitato da virgole di uno o più oggetti aggiuntivi da concatenare.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> per concatenare un elenco di parametri variabile. In questo caso, il metodo viene chiamato con nove parametri.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Questo metodo è contrassegnato con il <see langword="vararg" /> (parola chiave), il che significa che supporta un numero variabile di parametri. Il metodo può essere chiamato da Visual C++, ma non può essere chiamato dal codice c# o Visual Basic. I compilatori c# e Visual Basic risolvere le chiamate ai <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> come chiamate a <see cref="M:System.String.Concat(System.Object[])" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Prima stringa da concatenare.</param>
        <param name="str1">Seconda stringa da concatenare.</param>
        <param name="str2">Terza stringa da concatenare.</param>
        <param name="str3">Quarta stringa da concatenare.</param>
        <summary>Concatena quattro istanze specificate della classe <see cref="T:System.String" />.</summary>
        <returns>Concatenazione dei parametri <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> e <paramref name="str3" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo concatena `str0`, `str1`, `str2`, e `str3`; non vengono aggiunti i delimitatori.  
  
> [!NOTE]
>  È inoltre possibile utilizzare operatore di concatenazione di stringhe del linguaggio, ad esempio `+` in c# o `&` e `+` in Visual Basic)  
>   
>  , per concatenare stringhe.  
  
 Un <xref:System.String.Empty> stringa viene utilizzata al posto di qualsiasi oggetto null nella matrice.  
  
   
  
## Examples  
 Nell'esempio seguente definisce una matrice di quattro – lettera parole e archivia le singole lettere di una matrice di stringhe per decodificate. Chiama quindi il <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> metodo riassemblare le singole parole.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Il tipo dei membri di <c>valori</c>.</typeparam>
        <param name="values">Oggetto Collection che implementa l'interfaccia <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
        <summary>Concatena i membri di un'implementazione di <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Membri concatenati in <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo concatena ogni oggetto in `values`; non vengono aggiunti i delimitatori.  
  
 Un <xref:System.String.Empty> stringa viene utilizzata al posto di qualsiasi argomento null.  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> è un metodo pratico che consente di concatenare ogni elemento in un <xref:System.Collections.Generic.IEnumerable%601> insieme senza prima di convertire gli elementi in stringhe. È particolarmente utile con espressioni di query Language-Integrated Query (LINQ), come illustrato nell'esempio. La rappresentazione di stringa di ogni oggetto di <xref:System.Collections.Generic.IEnumerable%601> raccolta derivata mediante la chiamata di tale oggetto `ToString` (metodo).  
  
   
  
## Examples  
 L'esempio seguente definisce un semplice `Animal` classe che contiene il nome di un animale e l'ordine a cui appartiene. Definisce quindi un <xref:System.Collections.Generic.List%601> oggetto deve contenere un numero di `Animal` oggetti. Il <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> viene chiamato il metodo di estensione per estrarre il `Animal` oggetti la cui proprietà `Order` proprietà è uguale a "Roditori". Il risultato viene passato per il <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> metodo e visualizzato nella console.  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <summary>Restituisce un valore che indica se una sottostringa specificata è presente all'interno della stringa.</summary>
        <returns>
          <see langword="true" /> se il parametro <paramref name="value" /> è presente all'interno della stringa o se il parametro <paramref name="value" /> è la stringa vuota (""); in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue un confronto ordinale (maiuscole/minuscole e senza distinzione di impostazioni cultura). La ricerca inizia in corrispondenza della posizione di carattere prima di questa stringa e continua fino all'ultima posizione di carattere.  
  
 Per determinare se una stringa contiene la sottostringa specificata con un valore diverso da un confronto ordinale (ad esempio, confronto con distinzione delle impostazioni cultura o un confronto ordinale tra maiuscole e minuscole), è possibile creare un metodo personalizzato. Nell'esempio seguente viene illustrato un approccio. Definisce un <xref:System.String> metodo di estensione che include un <xref:System.StringComparison> parametro e indica se una stringa contiene una sottostringa quando si usa il modulo di confronto di stringhe specificato.  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 Nell'esempio seguente viene chiamato il `Contains` metodo di estensione per determinare se una sottostringa è presente in una stringa quando si utilizza un confronto ordinale e confronto ordinale tra maiuscole e minuscole.  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 Se si è interessati nella posizione della sottostringa `value` nell'istanza corrente, è possibile chiamare il <xref:System.String.IndexOf%2A> metodo per ottenere la posizione iniziale della prima occorrenza, oppure è possibile chiamare il <xref:System.String.LastIndexOf%2A> metodo per ottenere l'avvio di posizione del relativo ultima occorrenza. L'esempio include una chiamata al <xref:System.String.IndexOf%28System.String%29> metodo se viene trovata una sottostringa in un'istanza di stringa.  
  
   
  
## Examples  
 Nell'esempio seguente determina se la stringa "volpe" è una sottostringa di una frase. Se viene trovati "volpe" nella stringa, vengono inoltre visualizzate la posizione iniziale.  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Stringa da copiare.</param>
        <summary>Crea una nuova istanza dell'oggetto <see cref="T:System.String" /> con lo stesso valore di un'istanza dell'oggetto <see cref="T:System.String" /> specificata.</summary>
        <returns>Nuova stringa con lo stesso valore di <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.Copy%2A> metodo restituisce un <xref:System.String> oggetto che ha lo stesso valore di stringa originale, ma rappresenta un riferimento a un oggetto diverso. Differisce da un'operazione di assegnazione, che assegna un riferimento di stringa esistente a una variabile oggetto aggiuntive. Nell'esempio viene illustrata la differenza.  
  
   
  
## Examples  
 L'esempio seguente crea due oggetti stringa con valori diversi. Quando chiama il <xref:System.String.Copy%2A> metodo a cui assegnare il primo valore per la seconda stringa, l'output indica che le stringhe rappresentano riferimenti a oggetti diversi, anche se i valori ora sono uguali. D'altra parte, quando la prima stringa è assegnata la seconda stringa, le due stringhe hanno valori identici in quanto rappresentano il riferimento all'oggetto stesso.  
  
 [!code-csharp[System.String.Copy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Indice del primo carattere nell'istanza da copiare.</param>
        <param name="destination">Matrice di caratteri Unicode in cui vengono copiati i caratteri di questa istanza.</param>
        <param name="destinationIndex">Indice in <c>destination</c> in corrispondenza del quale inizia l'operazione di copia.</param>
        <param name="count">Numero di caratteri dell'istanza da copiare in <c>destination</c>.</param>
        <summary>Copia un numero definito di caratteri da una posizione specificata in questa istanza in una posizione specificata in una matrice di caratteri Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo copia `count` caratteri dal `sourceIndex` posizione di questa istanza con il `destinationIndex` posizione `destination` matrice di caratteri. Questo metodo non viene ridimensionato il `destination` matrice di caratteri; deve contenere un numero sufficiente di elementi per contenere i caratteri copiati o il metodo genera un <xref:System.ArgumentOutOfRangeException>.  
  
 `sourceIndex` e `destinationIndex` sono a base zero.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.CopyTo%2A> metodo.  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />, <paramref name="destinationIndex" /> o <paramref name="count" /> è negativo  oppure  <paramref name="sourceIndex" /> non identifica una posizione nell'istanza corrente.  oppure  <paramref name="destinationIndex" /> non identifica un indice valido nella matrice <paramref name="destination" />.  oppure  <paramref name="count" /> è maggiore della lunghezza della sottostringa in <paramref name="sourceIndex" /> alla fine dell'istanza  oppure  <paramref name="count" /> è maggiore della lunghezza della matrice secondaria in <paramref name="destinationIndex" /> alla fine della matrice <paramref name="destination" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta la stringa vuota. Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di questo campo è la stringa di lunghezza zero, "".  
  
 Nel codice dell'applicazione, questo campo viene utilizzato più di frequente nelle assegnazioni per inizializzare una variabile di stringa in una stringa vuota. Per verificare se il valore di una stringa può essere `null` o <xref:System.String.Empty?displayProperty=nameWithType>, utilizzare il <xref:System.String.IsNullOrEmpty%2A> metodo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se la fine di questa istanza di stringa corrisponde a una stringa specificata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da confrontare con la sottostringa alla fine di questa istanza.</param>
        <summary>Determina se la fine di questa istanza di stringa corrisponde alla stringa specificata.</summary>
        <returns>
          <see langword="true" /> se la fine di questa istanza corrisponde al parametro <paramref name="value" />; in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo confronta `value` con la sottostringa alla fine di questa istanza è uguale alla lunghezza `value`e restituisce un'indicazione se sono uguali. Per essere uguali, `value` deve essere un riferimento alla stessa istanza o corrispondere alla fine di questa istanza.  
  
 Questo metodo esegue un confronto per parola (maiuscole/minuscole e distinzione delle impostazioni cultura) utilizzando le impostazioni cultura correnti.  
  
   
  
## Examples  
 Nell'esempio seguente indica se ogni stringa in una matrice termina con un punto (".").  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 L'esempio seguente definisce un `StripEndTags` metodo che utilizza il <xref:System.String.EndsWith%28System.String%29> metodo per rimuovere i tag di fine HTML dalla fine di una riga. Si noti che il `StripEndTags` metodo viene chiamato in modo ricorsivo per garantire che vengano rimossi più tag di fine HTML alla fine della riga.  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Come spiegato in [Best Practices for Strings](~/docs/standard/base-types/best-practices-strings.md) utilizzando, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e in alternativa, chiamano metodi che richiedono parametri per essere specificato in modo esplicito. Per determinare se una stringa termina con una particolare sottostringa utilizzando le regole di confronto delle impostazioni cultura correnti, chiamare il <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> overload del metodo con un valore di <see cref="F:System.StringComparison.CurrentCulture" /> per il relativo <paramref name="comparisonType" /> parametro.</para>
        </block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da confrontare con la sottostringa alla fine di questa istanza.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che determina la modalità di confronto tra questa stringa e <c>value</c>.</param>
        <summary>Determina se la fine di questa istanza di stringa corrisponde alla stringa specificata se confrontata mediante l'opzione di confronto specificata.</summary>
        <returns>
          <see langword="true" /> se il parametro <paramref name="value" /> corrisponde alla fine di questa stringa; in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.EndsWith%2A> metodo confronta il `value` parametro con la sottostringa alla fine di questa stringa e restituisce un valore che indica se sono uguali. Per essere uguali, `value` deve essere un riferimento a questa stessa stringa, deve essere una stringa vuota (""), o deve corrispondere alla fine di questa stringa. Il tipo di confronto eseguito dal <xref:System.String.EndsWith%2A> metodo dipende dal valore del `comparisonType` parametro.  
  
   
  
## Examples  
 Nell'esempio seguente determina se una stringa termina con una particolare sottostringa. I risultati sono interessati dalla scelta di impostazioni cultura, se è ignorare maiuscole/minuscole e se viene eseguito un confronto ordinale.  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore di <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da confrontare con la sottostringa alla fine di questa istanza.</param>
        <param name="ignoreCase">
          <see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole durante il confronto; in caso contrario, <see langword="false" />.</param>
        <param name="culture">Informazioni relative alle impostazioni cultura che determinano le modalità di confronto tra questa istanza e <c>value</c>. Se <c>culture</c> è <see langword="null" />, verranno usate le impostazioni cultura correnti.</param>
        <summary>Determina se la fine di questa istanza di stringa corrisponde alla stringa specificata se confrontata mediante le impostazioni cultura specificate.</summary>
        <returns>
          <see langword="true" /> se il parametro <paramref name="value" /> corrisponde alla fine di questa stringa; in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente di confrontare il `value` parametro con la sottostringa alla fine di questa stringa che rappresenta la stessa lunghezza `value`e restituisce un valore che indica se sono uguali. Per essere uguali, `value` deve essere un riferimento alla stessa istanza o corrispondere alla fine di questa stringa.  
  
 Questo metodo esegue un confronto per parola (specifiche delle impostazioni cultura) usando le maiuscole e minuscole specificata e impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente determina se una stringa si trova alla fine di un'altra stringa. Il <xref:System.String.EndsWith%2A> metodo viene chiamato più volte con distinzione maiuscole/minuscole, maiuscole e minuscole e diverse impostazioni cultura che determinano i risultati della ricerca.  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se due oggetti <see cref="T:System.String" /> hanno lo stesso valore.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Stringa da confrontare con questa istanza.</param>
        <summary>Determina se questa istanza e un oggetto specificato, che deve essere anche un oggetto <see cref="T:System.String" />, hanno lo stesso valore.</summary>
        <returns>
          <see langword="true" /> se il parametro <paramref name="obj" /> è un oggetto <see cref="T:System.String" /> e il relativo valore corrisponde a quello di questa istanza; in caso contrario <see langword="false" />.  Se <paramref name="obj" /> è <see langword="null" />, il metodo restituisce <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue un confronto ordinale (maiuscole/minuscole e senza distinzione di impostazioni cultura).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.Equals%2A> metodo.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da confrontare con questa istanza.</param>
        <summary>Determina se questa istanza e un altro oggetto <see cref="T:System.String" /> specificato hanno lo stesso valore.</summary>
        <returns>
          <see langword="true" /> se il valore del parametro <paramref name="value" /> è lo stesso di quello di questa istanza; in caso contrario, <see langword="false" />. Se <paramref name="value" /> è <see langword="null" />, il metodo restituisce <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue un confronto ordinale (maiuscole/minuscole e senza distinzione di impostazioni cultura).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.Equals%2A> metodo. Confronta la parola titolo le maiuscole/minuscole "File" con una parola equivalente, il relativo equivalente in caratteri minuscoli, equivalente maiuscolo e una parola che contiene LATIN SMALL lettera punto I (U + 0131) anziché LATIN SMALL lettera I (U + 0069). Poiché il <xref:System.String.Equals%28System.String%29> metodo esegue un confronto ordinale, restituisce solo il confronto con una parola identico `true`.  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Prima stringa da confrontare o <see langword="null" />.</param>
        <param name="b">Seconda stringa da confrontare o <see langword="null" />.</param>
        <summary>Determina se due oggetti <see cref="T:System.String" /> specificati hanno lo stesso valore.</summary>
        <returns>
          <see langword="true" /> se il valore di <paramref name="a" /> è uguale al valore di <paramref name="b" />; in caso contrario, <see langword="false" />. Se entrambi i parametri <paramref name="a" /> e <paramref name="b" /> sono <see langword="null" />, il metodo restituisce <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue un confronto ordinale (maiuscole/minuscole e senza distinzione di impostazioni cultura).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.Equals%2A> metodo.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da confrontare con questa istanza.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che specifica la modalità di confronto delle stringhe.</param>
        <summary>Determina se questa stringa e un oggetto <see cref="T:System.String" /> specificato hanno lo stesso valore. Un parametro specifica le impostazioni cultura, l'eventuale distinzione fra maiuscole e minuscole e le regole di ordinamento usate per effettuare il confronto.</summary>
        <returns>
          <see langword="true" /> se il valore del parametro <paramref name="value" /> corrisponde a quello di questa stringa; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `comparisonType` parametro indica se il confronto deve utilizzare le impostazioni cultura correnti o invarianti, rispettare o ignorare la distinzione tra le due stringhe da confrontare o utilizzare regole di ordinamento ordinali o word.  
  
   
  
## Examples  
 L'esempio seguente crea una matrice di stringhe che include una "I", "i" lettera minuscola e una "ı". Chiama quindi il <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> metodo confrontarli tramite ogni possibile <xref:System.StringComparison> valore di enumerazione.  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 L'esempio seguente confronta i quattro set di parole con ogni membro del <xref:System.StringComparison> enumerazione.  I confronti di utilizzano le convenzioni delle impostazioni cultura Sami (Svezia superiore) e inglese (Stati Uniti). Si noti che le stringhe "encyclopædia" e "Enciclopedia" sono considerati equivalenti nelle impostazioni cultura en-US, ma non nelle impostazioni cultura Sami (settentrionale Svezia).  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore di <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="a">Prima stringa da confrontare o <see langword="null" />.</param>
        <param name="b">Seconda stringa da confrontare o <see langword="null" />.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che specifica le regole di confronto.</param>
        <summary>Determina se due oggetti <see cref="T:System.String" /> specificati hanno lo stesso valore. Un parametro specifica le impostazioni cultura, l'eventuale distinzione fra maiuscole e minuscole e le regole di ordinamento usate per effettuare il confronto.</summary>
        <returns>
          <see langword="true" /> se il valore del parametro <paramref name="a" /> è uguale al valore del parametro <paramref name="b" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `comparisonType` parametro indica se il confronto deve utilizzare le impostazioni cultura correnti o invarianti, rispettare o ignorare la distinzione tra le due stringhe da confrontare o utilizzare regole di ordinamento ordinali o word.  
  
   
  
## Examples  
 L'esempio seguente confronta i quattro set di parole con ogni membro del <xref:System.StringComparison> enumerazione.  I confronti di utilizzano le convenzioni delle impostazioni cultura Sami (Svezia superiore) e inglese (Stati Uniti). Si noti che le stringhe "encyclopædia" e "Enciclopedia" sono considerati equivalenti nelle impostazioni cultura en-US, ma non nelle impostazioni cultura Sami (settentrionale Svezia).  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore di <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte il valore degli oggetti in stringhe in base ai formati specificati e le inserisce in un'altra stringa.  Se non si ha familiarità con il metodo "String.Format", vedere la sezione [Introduzione al metodo String. Format](#Starting) per una rapida panoramica.  Vedere la sezione Osservazioni per la documentazione generale per il metodo "String.Format".</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 Contenuto della sezione:  
  
 [Iniziare a utilizzare il metodo String. Format](#Starting)   
 [Quale metodo si chiama?](#FTaskList)   
 [Il metodo Format in breve](#Format_Brief)   
 [L'elemento di formato](#FormatItem)   
 [La formattazione di argomenti](#HowFormatted)   
 [Elementi di formato che hanno lo stesso indice](#SameIndex)   
 [Formattazione e le impostazioni cultura](#Format_Culture)   
 [Le operazioni di formattazione personalizzata](#Format_Custom)   
 [String. Format domande e risposte](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a>Iniziare a utilizzare il metodo String. Format  
 Utilizzare <xref:System.String.Format%2A?displayProperty=nameWithType> se è necessario inserire il valore di un oggetto, una variabile o espressione in un'altra stringa. Ad esempio, è possibile inserire il valore di un <xref:System.Decimal> valore in una stringa per visualizzarlo come una singola stringa:  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 Ed è possibile controllare la formattazione di tale valore:  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp-interactive[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 Oltre alla formattazione, è possibile controllare l'allineamento e spaziatura.  
  
 ### <a name="inserting-a-string"></a>Inserimento di una stringa  

 <xref:System.String.Format%2A?displayProperty=nameWithType> inizia con una stringa di formato, seguita da uno o più oggetti o le espressioni che verranno convertite in stringhe e inserite in una posizione specificata nella stringa di formato. Ad esempio:  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 Il `{0}` nel formato di stringa è un elemento di formato. `0` è l'indice dell'oggetto il cui valore di stringa verrà inserito in tale posizione. (Gli indici iniziano da 0). Se l'oggetto da inserire non è una stringa, il relativo `ToString` metodo viene chiamato per convertire uno prima di inserirlo nella stringa di risultato.  
  
 Ecco un altro esempio che utilizza due elementi di formato e due oggetti nell'elenco di oggetti:  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp-interactive[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 È possibile avere un numero di elementi di formato e il numero di oggetti nell'elenco di oggetti di come si desidera, purché l'indice di ogni elemento di formato è un oggetto corrispondente nell'elenco di oggetti. Inoltre, non è necessario sulla quale eseguire l'overload si chiama; il compilatore verrà selezionato quello più appropriato.  
  
 ### <a name="controlling-formatting"></a>Il controllo della formattazione  
 È possibile seguire l'indice in un elemento di formato con una stringa di formato per controllare la formattazione dell'oggetto. Ad esempio, `{0:d}` si applica la stringa di formato "d" per il primo oggetto nell'elenco di oggetti. Di seguito è riportato un esempio con un singolo oggetto e due elementi di formato:  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp-interactive[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 Un numero di supporto di tipi di formattare stringhe, inclusi tutti i tipi numerici (entrambi [standard](~/docs/standard/base-types/standard-numeric-format-strings.md) e [personalizzata](~/docs/standard/base-types/custom-numeric-format-strings.md) stringhe di formato), tutte le date e ore (entrambi [standard](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e[personalizzati](~/docs/standard/base-types/custom-date-and-time-format-strings.md) stringhe di formato) e gli intervalli di tempo (entrambi [standard](~/docs/standard/base-types/standard-timespan-format-strings.md) e [personalizzato](~/docs/standard/base-types/custom-timespan-format-strings.md) stringhe di formato), tutti i tipi di enumerazione [i tipi di enumerazione ](~/docs/standard/base-types/enumeration-format-strings.md), e [GUID](https://msdn.microsoft.com/library/97af8hh4.aspx). È anche possibile aggiungere supporto per le stringhe di formato per i tipi.  
  
 ### <a name="controlling-spacing"></a>Controllare la spaziatura  
 È possibile definire la larghezza della stringa inserita nella stringa di risultato tramite, ad esempio sintassi `{0,12}`, che inserisce una stringa di 12 caratteri. La rappresentazione di stringa del primo oggetto in questo caso, è allineato a destra del campo di 12 caratteri.  (Se la rappresentazione di stringa del primo oggetto è più di 12 caratteri, tuttavia, la larghezza preferita del campo viene ignorata e l'intera stringa viene inserita nella stringa di risultato.)  
  
 L'esempio seguente definisce un campo di 6 caratteri per contenere la stringa "Anno" e alcune stringhe di anno, nonché un campo di 15 caratteri per contenere la stringa "Popolazione" e alcuni dati della popolazione. Si noti che i caratteri sono allineati a destra del campo.  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp-interactive[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a>Controllo dell'allineamento  
 Per impostazione predefinita, le stringhe sono allineati a destra nel loro campo se si specifica una larghezza di campo. Per allineare le stringhe in un campo a sinistra, fare precedere la larghezza del campo con un segno negativo, ad esempio `{0,-12}` per definire un campo allineato a destra di 12 caratteri.  
  
 Nell'esempio seguente è simile a quello precedente, ad eccezione del fatto che Allinea a sinistra delle etichette e i dati.  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp-interactive[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType> utilizza la funzionalità di formattazione composta. Per altre informazioni, vedere [Formattazione composita](~/docs/standard/base-types/composite-formatting.md).  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>Quale metodo si chiama?  
  
|A|Call|  
|--------|----------|  
|Formattare uno o più oggetti utilizzando le convenzioni delle impostazioni cultura correnti.|Ad eccezione di overload che includono un `provider` parametro, il rimanente <xref:System.String.Format%2A> overload includono un <xref:System.String> parametro seguita da uno o più parametri di oggetto. Per questo motivo, non è necessario determinare quale <xref:System.String.Format%2A> overload si intende chiamare. Il compilatore di linguaggio seleziona overload appropriato tra gli overload che non hanno un `provider` parametro, in base all'elenco di argomenti. Ad esempio, se all'elenco di argomenti dispone di cinque argomenti, il compilatore chiama il <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> metodo.|  
|Formattare uno o più oggetti utilizzando le convenzioni delle impostazioni cultura specifiche.|Ogni <xref:System.String.Format%2A> overload che inizia con un `provider` parametro è seguito da un <xref:System.String> parametro e uno o più parametri dell'oggetto. Per questo motivo, non è necessario determinare quali specifiche <xref:System.String.Format%2A> overload si intende chiamare. Il compilatore di linguaggio seleziona overload appropriato tra gli overload che hanno un `provider` parametro, in base all'elenco di argomenti. Ad esempio, se all'elenco di argomenti dispone di cinque argomenti, il compilatore chiama il <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> metodo.|  
|Eseguire un'operazione di formattazione personalizzata con un <xref:System.ICustomFormatter> implementazione o <xref:System.IFormattable> implementazione.|Uno dei quattro overload con un `provider` parametro. Il compilatore seleziona overload appropriato tra gli overload che hanno un `provider` parametro, in base all'elenco di argomenti.|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>Il metodo Format in breve 

 Ogni overload del <xref:System.String.Format%2A> metodo utilizza il [funzionalità di formattazione composta](~/docs/standard/base-types/composite-formatting.md) da includere in base zero segnaposto indicizzati, denominati *formattare gli elementi*, in una stringa di formato composita. In fase di esecuzione, ogni elemento di formato viene sostituito con la rappresentazione di stringa dell'argomento corrispondente in un elenco di parametri. Se il valore dell'argomento è `null`, l'elemento di formato viene sostituito con <xref:System.String.Empty?displayProperty=nameWithType>. Ad esempio, la seguente chiamata per il <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> metodo include una stringa di formato con tre elementi di formato, {0}, {1}, e {2}e un elenco di argomenti con tre elementi.  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp-interactive[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>L'elemento di formato  
 Un elemento di formato presenta questa sintassi:  
  
```  
{index[,alignment][:formatString]}  
```  
 
 Le parentesi quadre indicano elementi facoltativi. L'apertura e parentesi graffe di chiusura sono necessarie. (Per includere un valore letterale di apertura o parentesi graffa chiusa nella stringa di formato, vedere la [escape delle parentesi graffe](~/docs/standard/base-types/composite-formatting.md#escaping-braces) sezione il [formattazione composita](~/docs/standard/base-types/composite-formatting.md) articolo.)  
  
 Un elemento di formato per formattare un valore di valuta, ad esempio, può sembrare simile al seguente:  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp-interactive[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 Un elemento di formato include gli elementi seguenti:  
  
 *index*  
 L'indice in base zero dell'argomento cui rappresentazione di stringa deve essere incluso in questa posizione nella stringa. Se questo argomento è `null`, una stringa vuota verrà inclusa in questa posizione nella stringa.  
  
 *Allineamento*  
 Facoltativo. Intero con segno che indica la lunghezza totale del campo in cui viene inserito l'argomento e se è allineato a destra (un numero intero positivo) o allineato a sinistra (un numero intero negativo). Se si omette *allineamento*, la rappresentazione di stringa dell'argomento corrispondente viene inserita in un campo senza spazi iniziali o finali.  
  
 Se il valore di *allineamento* è minore della lunghezza dell'argomento deve essere inserito *allineamento* viene ignorato e la lunghezza della rappresentazione di stringa dell'argomento viene utilizzata come la larghezza del campo.  
  
 *formatString*  
 Facoltativo. Stringa che specifica il formato della stringa di risultato dell'argomento corrispondente. Se si omette *formatString*, senza parametri dell'argomento corrispondente `ToString` metodo viene chiamato per generare la rappresentazione di stringa. Se si specifica *formatString*, l'argomento a cui fa riferimento l'elemento di formato deve implementare il <xref:System.IFormattable> interfaccia. I tipi che supportano le stringhe di formato includono:  
  
-   Tutti i tipi a virgola mobile e integrali. (Vedere [stringhe di formato numerico Standard](~/docs/standard/base-types/standard-numeric-format-strings.md) e [stringhe di formato numerico personalizzato](~/docs/standard/base-types/custom-numeric-format-strings.md).)  
  
-   <xref:System.DateTime> e <xref:System.DateTimeOffset>. (Vedere [stringhe di formato di data e ora Standard](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [stringhe di formato di data e ora personalizzato](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)  
  
-   Tutti i tipi di enumerazione. (Vedere [stringhe di formato di enumerazione](~/docs/standard/base-types/enumeration-format-strings.md).)  
  
-   valori <xref:System.TimeSpan>. (Vedere [stringhe di formato TimeSpan Standard](~/docs/standard/base-types/standard-timespan-format-strings.md) e [stringhe di formato TimeSpan personalizzate](~/docs/standard/base-types/custom-timespan-format-strings.md).)  
  
-   GUID. (Vedere il <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> metodo.)  
  
 Tuttavia, si noti che è possibile implementare qualsiasi tipo personalizzato <xref:System.IFormattable> o estendere un tipo esistente <xref:System.IFormattable> implementazione.  
  
 L'esempio seguente usa il `alignment` e `formatString` argomenti per produrre l'output formattato.  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp-interactive[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>La formattazione di argomenti  
 Elementi di formato vengono elaborati in sequenza dall'inizio della stringa. Ogni elemento di formato include un indice che corrisponde a un oggetto nell'elenco di argomenti del metodo. Il <xref:System.String.Format%2A> recupera l'argomento di metodo e deriva relativa rappresentazione di stringa, come indicato di seguito:  
  
-   Se l'argomento è `null`, il metodo inserisce <xref:System.String.Empty?displayProperty=nameWithType> nella stringa di risultato. Non è necessario essere interessati alla gestione un <xref:System.NullReferenceException> per gli argomenti null. 
  
-   Se si chiama il <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> rapporto di overload e il `provider` dell'oggetto <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementazione restituisce un valore non null <xref:System.ICustomFormatter> implementazione, l'argomento viene passato al relativo <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodo. Se l'elemento di formato include un *formatString* argomento, viene passato come primo argomento al metodo. Se il <xref:System.ICustomFormatter> implementazione sia disponibile e produce una stringa non null, che viene restituita come rappresentazione di stringa dell'argomento stringa; in caso contrario, viene eseguito il passaggio successivo.  
  
-   Se l'argomento implementa il <xref:System.IFormattable> interfaccia, il relativo <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> viene chiamata l'implementazione.  
  
-   L'argomento del senza parametri `ToString` , che esegue l'override o eredita da un'implementazione della classe base, viene chiamato.  
  
 Per un esempio che intercetta le chiamate al <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> metodo e consente di visualizzare le informazioni di <xref:System.String.Format%2A> metodo passa a un metodo di formattazione per ogni elemento di formato in una stringa di formato composita, vedere [esempio: un provider di intercept e Formattatore romano](#Format7_Example).  

 Per altre informazioni, vedere la [ordine di elaborazione](~/docs/standard/base-types/composite-formatting.md##processing-order) sezione il [formattazione composita](~/docs/standard/base-types/composite-formatting.md) articolo.  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>Elementi di formato che hanno lo stesso indice  
 Il <xref:System.String.Format%2A> metodo genera un <xref:System.FormatException> eccezione se l'indice di un elemento di indice è maggiore o uguale al numero di argomenti nell'elenco di argomenti. Tuttavia, `format` può includere più elementi di formato che non vi sono argomenti, a condizione che più elementi di formato hanno lo stesso indice. Nella chiamata al <xref:System.String.Format%28System.String%2CSystem.Object%29> nell'esempio seguente, l'elenco di argomenti metodo presenta un solo argomento, ma la stringa di formato include due elementi di formato: uno Visualizza il valore decimale di un numero e l'altro relativo valore esadecimale.  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>Formattazione e le impostazioni cultura  
 In genere, gli oggetti nell'elenco di argomenti vengono convertiti nelle rappresentazioni di stringa usando le convenzioni delle impostazioni cultura correnti, viene restituito dal <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> proprietà. È possibile controllare questo comportamento chiamando uno degli overload di <xref:System.String.Format%2A> che include un `provider` parametro. Il `provider` parametro è un <xref:System.IFormatProvider> implementazione che fornisce informazioni di formattazione specifiche delle impostazioni cultura e personalizzate che viene utilizzate per la formattazione di moderato elaborare.  
  
 Il <xref:System.IFormatProvider> interfaccia dispone di un singolo membro, <xref:System.IFormatProvider.GetFormat%2A>, che è responsabile di restituire l'oggetto che fornisce informazioni di formattazione. .NET Framework offre tre <xref:System.IFormatProvider> implementazioni che forniscono informazioni di formattazione specifiche delle impostazioni cultura:  
  
-   <xref:System.Globalization.CultureInfo>. Il relativo <xref:System.Globalization.CultureInfo.GetFormat%2A> il metodo restituisce un oggetto specifico delle impostazioni cultura <xref:System.Globalization.NumberFormatInfo> oggetto per la formattazione di valori numerici e impostazioni cultura specifiche <xref:System.Globalization.DateTimeFormatInfo> oggetto per la formattazione di valori di data e ora.  
  
-   <xref:System.Globalization.DateTimeFormatInfo>, che viene utilizzato per la formattazione specifiche delle impostazioni cultura di valori di data e ora. Il relativo <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> metodo restituisce se stesso.  
  
-   <xref:System.Globalization.NumberFormatInfo>, che viene utilizzato per la formattazione specifiche delle impostazioni cultura di valori numerici. Il relativo <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> proprietà restituisce se stesso. 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>Le operazioni di formattazione personalizzata  
 È inoltre possibile chiamare degli overload di <xref:System.String.Format%2A> metodo che presenta un `provider` parametro di tipo <xref:System.IFormatProvider> per eseguire operazioni di formattazione personalizzate. Ad esempio, è possibile formattare un numero intero come un numero di identificazione o un numero di telefono. Per eseguire la formattazione personalizzata del `provider` argomento deve implementare entrambe le <xref:System.IFormatProvider> e <xref:System.ICustomFormatter> interfacce. Quando il <xref:System.String.Format%2A> viene passato un <xref:System.ICustomFormatter> come implementazione di `provider` argomento, il <xref:System.String.Format%2A> chiamate al metodo relativo <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementazione e richiede un oggetto di tipo <xref:System.ICustomFormatter>. Chiama quindi l'oggetto restituito <xref:System.ICustomFormatter> dell'oggetto <xref:System.ICustomFormatter.Format%2A> per formattare ogni elemento di formato della stringa composto passato a esso.  
  
 Per ulteriori informazioni su come fornire soluzioni di formattazione personalizzate, vedere [procedura: definire e utilizzare provider formato numerico personalizzati](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) e <xref:System.ICustomFormatter>. Per un esempio che converte i numeri interi in formato numeri personalizzati, vedere [esempio: un'operazione di formattazione personalizzata](#Format6_Example). Per un esempio che converte i numeri romani byte senza segno, vedere [esempio: un provider intercetta e formattatore romano](#Format7_Example).  
  
<a name="Format6_Example" />  
### <a name="example-a-custom-formatting-operation"></a>Esempio: Un'operazione formattazione personalizzata  
 Questo esempio definisce un provider di formato che consenta di formattare un valore integer come un numero di account del cliente in formato x-xxxxx-xx.  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp-interactive[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example" />  
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a>Esempio: Un provider di intercettare e formattatore romano  
 In questo esempio definisce un provider di formato personalizzata che implementa il <xref:System.ICustomFormatter> e <xref:System.IFormatProvider> interfacce per eseguire due operazioni:  
  
-   Visualizza i parametri passati al relativo <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> implementazione. Ciò consente di vedere quali parametri il <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> metodo passa per l'implementazione di formattazione personalizzata per ogni oggetto che tenta di formattare. Può essere utile quando si esegue il debug dell'applicazione.  
  
-   Se l'oggetto da formattare è un valore di byte senza segno che deve essere formattata con la stringa di formato standard "R", il formattatore personalizzato il valore numerico viene formattato come un numero romano.  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp-interactive[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>String. Format domande e risposte  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a>Motivo per cui consigliabile interpolazione di stringhe tramite chiamate al `String.Format` metodo?

Interpolazione di stringhe è:

- Più flessibile. Può essere utilizzato qualsiasi stringa senza una chiamata a un metodo che supporta la formattazione composita. In caso contrario, è necessario chiamare il <xref:System.String.Format%2A> metodo o un altro metodo che supporta la formattazione composita, ad esempio <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> o <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>. 

- Più leggibile. Poiché l'espressione da inserire in una stringa viene visualizzato nell'espressione interpolata anziché in un elenco di argomenti, sono molto più semplice per codice e per leggere stringhe interpolate. A causa delle loro maggiore leggibilità, stringhe interpolate possono sostituire non solo le chiamate ai metodi di formattazione composta, ma possono anche essere utilizzati in operazioni di concatenazione di stringhe per produrre codice più conciso e più chiaro. 

Un confronto tra le seguenti due esempi di codice viene illustrato l'eccezionale di stringhe interpolate tramite la concatenazione di stringhe e le chiamate ai metodi di formattazione composita. L'utilizzo di più operazioni di concatenazione di stringa nell'esempio seguente genera codice dettagliato e difficile da leggere.

[!code-csharp-interactive[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

Al contrario, l'uso di stringhe interpolate nel seguente esempio producono codice molto più semplice, più concisa rispetto l'istruzione di concatenazione di stringa e la chiamata al <xref:System.String.Format%2A> metodo nell'esempio precedente.

[!code-csharp-interactive[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>Dove posso trovare un elenco delle stringhe di formato predefinito che può essere utilizzato con elementi di formato?  
  
-   Per tutti i tipi a virgola mobile e integrali, vedere [stringhe di formato numerico Standard](~/docs/standard/base-types/standard-numeric-format-strings.md) e [stringhe di formato numerico personalizzato](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Per i valori di data e ora, vedere [stringhe di formato di ora e data Standard](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [stringhe di formato di ora e Data personalizzata](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Per valori di enumerazione, vedere [stringhe di formato di enumerazione](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Per <xref:System.TimeSpan> valori, vedere [stringhe di formato TimeSpan Standard](~/docs/standard/base-types/standard-timespan-format-strings.md) e [stringhe di formato TimeSpan personalizzate](~/docs/standard/base-types/custom-timespan-format-strings.md).  
  
-   Per <xref:System.Guid> valori, vedere la sezione Note del <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> pagina di riferimento.  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>Come controllare l'allineamento delle stringhe di risultato che sostituiscono gli elementi di formato?  
 La sintassi generale di un elemento di formato è:  
  
```  
{index[,alignment][: formatString]}  
```  
  
 dove *allineamento* è un intero con segno che definisce la larghezza del campo. Se questo valore è negativo, nel campo di testo è allineato a sinistra. In caso positivo, il testo è allineato a destra.  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>Come controllare il numero di cifre dopo il separatore decimale  
 Tutti [stringhe di formato numerico standard](~/docs/standard/base-types/standard-numeric-format-strings.md) ad eccezione di "D" (che viene utilizzato con solo numeri interi), "G", "R" e "X" Consenti un identificatore di precisione che definisce il numero di cifre decimali nella stringa di risultato. L'esempio seguente usa le stringhe di formato numerico standard per controllare il numero di cifre decimali nella stringa di risultato.  
  
 [!code-csharp-interactive[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 Se si utilizza un [stringa di formato numerico personalizzata](~/docs/standard/base-types/custom-numeric-format-strings.md), utilizzare l'identificatore di formato "0" per controllare il numero di cifre decimali nella stringa di risultato, come illustrato nell'esempio seguente.  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>Come controllare il numero di cifre integrali  
 Per impostazione predefinita, le operazioni di formattazione vengono visualizzati solo cifre integrali diverso da zero. Se si desidera formattare numeri interi, è possibile utilizzare un identificatore di precisione con "D" e "X" stringhe di formato standard per controllare il numero di cifre.  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 È possibile aggiungere un numero intero o a virgola mobile e con zeri iniziali per produrre una stringa di risultato con un numero specificato di cifre integrali con "0" [identificatore di formato numerico personalizzato](~/docs/standard/base-types/custom-numeric-format-strings.md), come illustrato nell'esempio seguente.  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>Il numero di elementi è possibile includere nell'elenco formato?  
 Non sono previsti limiti pratici. Il secondo parametro del <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> metodo è contrassegnato con il <xref:System.ParamArrayAttribute> attributo, che consente di includere un elenco delimitato da virgole o una matrice di oggetti come elenco formato.  
  
<a name="braces" />
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>Come includere valori letterali parentesi graffe ("{" e "}") nella stringa di risultato?  
 Ad esempio, come si impedisce la seguente chiamata al metodo generi un <xref:System.FormatException> eccezione?  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 Un singolo apertura o la parentesi graffa di chiusura viene sempre interpretato come l'inizio o alla fine di un elemento di formato. Per essere interpretato letteralmente, deve essere codificata. Una parentesi graffa di escape mediante l'aggiunta di un'altra parentesi graffa ("{{" e "}}" anziché "{" e "}"), come nella chiamata al metodo seguente:  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 Tuttavia, anche con caratteri di escape delle parentesi graffe sono facilmente interpretate. È consigliabile che comprende parentesi graffe nell'elenco formato e utilizzare gli elementi di formato per inserirli nella stringa di risultato, come illustrato nell'esempio seguente.  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>Perché la chiamata al metodo String. Format genera un'eccezione FormatException?  
 La causa più comune dell'eccezione è che l'indice di un elemento di formato non corrisponde a un oggetto nell'elenco formato. In genere indica che è stata misnumbered gli indici degli elementi di formato o è stata dimenticata includere un oggetto nell'elenco formato. Tentativo di inserire una parentesi graffa di sinistra o destra senza caratteri escape di caratteri genera anche un <xref:System.FormatException>. In alcuni casi, l'eccezione è il risultato di un errore di digitazione; ad esempio, un errore tipico è digitata "[" (la parentesi quadra aperta) invece di "{" (la parentesi graffa sinistra).  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>Se il metodo Format(System.IFormatProvider,System.String,System.Object[]) supporta matrici di parametri, perché il codice genera un'eccezione quando si utilizza una matrice?  
 Ad esempio, il codice seguente genera un <xref:System.FormatException> eccezione:  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 Si tratta di un problema di risoluzione dell'overload del compilatore. Poiché il compilatore non è possibile convertire una matrice di interi in una matrice di oggetti, e la matrice di interi considera come un solo argomento, quindi chiama il <xref:System.String.Format%28System.String%2CSystem.Object%29> metodo. L'eccezione viene generata perché sono presenti quattro elementi di formato, ma solo un singolo elemento nell'elenco formato.  
  
 Poiché Visual Basic né in c# è possibile convertire una matrice di interi a una matrice di oggetti, è necessario eseguire la conversione prima di chiamare il <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> metodo. Nell'esempio seguente fornisce un'implementazione.  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

Numerosi esempi che chiamano il <xref:System.String.Format%2A> metodo vengono intercalati tramite il [osservazioni](#remarks) sezione di questo articolo.  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

È inoltre possibile scaricare un set completo di `String.Format` esempi, sono inclusi un [progetti .NET Core 2.0 per c#](https://github.com/dotnet/docs/raw/master/samples/snippets/csharp/downloads/api/System/String.Format.zip) e un [progetto .NET Core 2.0 per Visual Basic](https://github.com/dotnet/docs/raw/master/samples/snippets/visualbasic/downloads/api/System/String.Format.zip), dal [dotnet/docs Repository GitHub](https://github.com/dotnet/docs).

Di seguito sono indicati alcuni degli esempi inclusi nell'articolo:

### <a name="create-a-format-string"></a>Creare una stringa di formato

[Inserimento di una stringa](#inserting-a-string)  
[L'elemento di formato](#the-format-item)  
[Elementi di formato che hanno lo stesso indice](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a>Controllare l'output formattato

[Il controllo della formattazione](#controlling-formatting)  
[Controllare la spaziatura](#controlling-spacing)  
[Controllo dell'allineamento](#controlling-alignment)  
[Controllo del numero di cifre integrali](#how-do-i-control-the-number-of-integral-digits)  
[Controllo del numero di cifre dopo il separatore decimale](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[Tra parentesi graffe letterale in una stringa di risultato](#braces)  

### <a name="make-format-strings-culture-sensitive"></a>Verificare le stringhe di formato delle impostazioni cultura

[Formattazione delle impostazioni cultura](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a>Personalizzare l'operazione di formattazione

[Un'operazione di formattazione personalizzata](#example-a-custom-formatting-operation)  
[Un provider intercetta e formattatore romano](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[stringa in formato composito](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Oggetto da formattare.</param>
        <summary>Sostituisce uno o più elementi di formato in una stringa con la rappresentazione di stringa di un oggetto specificato.</summary>
        <returns>Copia di <paramref name="format" /> in cui qualsiasi elemento di formato viene sostituito dalla rappresentazione di stringa di <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Questo metodo Usa il [funzionalità di formattazione composta](~/docs/standard/base-types/composite-formatting.md) per convertire il valore di un'espressione nella relativa rappresentazione di stringa e incorporare tale rappresentazione in una stringa. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a>Esempio: Formattazione di un solo argomento  
 
 L'esempio seguente usa il <xref:System.String.Format%28System.String%2CSystem.Object%29> metodo per incorporare l'età dei singoli all'interno di una stringa.  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">L'elemento di formato nel parametro <paramref name="format" /> non è valido.  oppure  L'indice di un elemento di formato è diverso da zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">[stringa in formato composito](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Matrice di oggetti che contiene zero o più oggetti da formattare.</param>
        <summary>Sostituisce l'elemento di formato presente in una stringa specificata con la rappresentazione di stringa di un oggetto corrispondente in una matrice specificata.</summary>
        <returns>Copia di <paramref name="format" /> in cui gli elementi di formato sono stati sostituiti dalla rappresentazione di stringa degli oggetti corrispondenti in <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Questo metodo Usa il [funzionalità di formattazione composta](~/docs/standard/base-types/composite-formatting.md) per convertire il valore di quattro o più espressioni nelle rispettive rappresentazioni di stringa e incorporare tali rappresentazioni in una stringa. Poiché il `args` parametro è contrassegnato con il <xref:System.ParamArrayAttribute?displayProperty=nameWithType> attributo, è possibile passare gli oggetti al metodo come singoli argomenti o come un <xref:System.Object> matrice. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a>Esempio: Formattazione di più di tre argomenti  
 
 In questo esempio crea una stringa che contiene i dati sulla temperatura massima e minima in una determinata data. Stringa di formato composita ha cinque elementi di formato di esempio di c# e sei nell'esempio di Visual Basic. Due degli elementi di formato definire la larghezza della rappresentazione di stringa del valore corrispondente e il primo elemento di formato include anche una stringa di formato di ora e data standard.  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp-interactive[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 È inoltre possibile passare gli oggetti da formattare come una matrice anziché da un elenco di argomenti.  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp-interactive[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> o <paramref name="args" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  oppure  L'indice di un elemento di formato è minore di zero oppure maggiore o uguale alla lunghezza della matrice <paramref name="args" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <param name="format">[stringa in formato composito](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Oggetto da formattare.</param>
        <summary>Sostituisce uno o più elementi di formato presenti in una stringa specificata con la rappresentazione di stringa dell'oggetto corrispondente. Un parametro fornisce le informazioni di formattazione specifiche delle impostazioni cultura.</summary>
        <returns>Copia di <paramref name="format" /> in cui uno o più elementi di formato vengono sostituiti dalla rappresentazione di stringa di <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Questo metodo Usa il [funzionalità di formattazione composta](~/docs/standard/base-types/composite-formatting.md) per convertire il valore di un'espressione nella relativa rappresentazione di stringa e incorporare tale rappresentazione in una stringa. Eseguire la conversione, il metodo utilizza un formattatore personalizzato o formattazione delle impostazioni cultura. Il metodo converte `arg0` nella relativa rappresentazione di stringa chiamando il relativo **ToString (IFormatProvider)** (metodo) o, se l'oggetto corrispondente elemento di formato include una stringa di formato chiamando il relativo **ToString ( Stringa, IFormatProvider)** metodo. Se questi metodi non esistono, viene chiamato l'oggetto senza parametri **ToString** metodo.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  oppure  L'indice di un elemento di formato è diverso da zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <param name="format">[stringa in formato composito](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Matrice di oggetti che contiene zero o più oggetti da formattare.</param>
        <summary>Sostituisce gli elementi di formato presenti in una stringa con le rappresentazioni di stringa degli oggetti corrispondenti in una matrice specificata. Un parametro fornisce le informazioni di formattazione specifiche delle impostazioni cultura.</summary>
        <returns>Copia di <paramref name="format" /> in cui gli elementi di formato sono stati sostituiti dalla rappresentazione di stringa degli oggetti corrispondenti in <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Questo metodo Usa il [funzionalità di formattazione composta](~/docs/standard/base-types/composite-formatting.md) per convertire le rappresentazioni di stringa di quattro o più espressioni e incorporare tali rappresentazioni in una stringa. Eseguire la conversione, il metodo utilizza un formattatore personalizzato o formattazione delle impostazioni cultura. Il metodo converte ogni <xref:System.Object> argomento nella relativa rappresentazione di stringa chiamando il relativo **ToString (IFormatProvider)** metodo o, se l'oggetto corrispondente elemento di formato include una stringa di formato, chiamando il relativo **ToString(String,IFormatProvider)** metodo. Se questi metodi non esistono, viene chiamato l'oggetto senza parametri **ToString** metodo.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
## <a name="example-culture-sensitive-formatting"></a>Esempio: Cultura formattazione  
 Questo esempio viene utilizzato il <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> metodo per visualizzare la rappresentazione di stringa di alcuni valori di data e ora e i valori numerici con varie impostazioni cultura.  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> o <paramref name="args" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  oppure  L'indice di un elemento di formato è minore di zero oppure maggiore o uguale alla lunghezza della matrice <paramref name="args" />.</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[stringa in formato composito](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Primo oggetto da formattare.</param>
        <param name="arg1">Secondo oggetto da formattare.</param>
        <summary>Sostituisce gli elementi di formato presenti in una stringa con la rappresentazione di stringa di due oggetti specificati.</summary>
        <returns>Copia di <paramref name="format" /> in cui gli elementi di formato vengono sostituiti dalle rappresentazioni di stringa di <paramref name="arg0" /> e <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Questo metodo Usa il [funzionalità di formattazione composta](~/docs/standard/base-types/composite-formatting.md) per convertire il valore di due espressioni per le rappresentazioni di stringa e incorporare tali rappresentazioni in una stringa. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a>Esempio: Formattazione di due argomenti  
 
 Questo esempio viene utilizzato il <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> metodo per visualizzare l'ora e temperatura dati archiviati in un oggetto generico <xref:System.Collections.Generic.Dictionary%602> oggetto. Si noti che la stringa di formato include tre elementi di formato, anche se sono presenti solo due oggetti da formattare. Poiché il primo oggetto nell'elenco (un valore data e ora) viene utilizzato da due elementi di formato: il primo formato elemento sia indicato l'ora e il secondo Visualizza la data.  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp-interactive[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  oppure  L'indice di un elemento di formato è diverso da zero o uno.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <param name="format">[stringa in formato composito](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Primo oggetto da formattare.</param>
        <param name="arg1">Secondo oggetto da formattare.</param>
        <summary>Sostituisce gli elementi di formato presenti in una stringa con la rappresentazione di stringa di due oggetti specificati. Un parametro fornisce le informazioni di formattazione specifiche delle impostazioni cultura.</summary>
        <returns>Copia di <paramref name="format" /> in cui gli elementi di formato vengono sostituiti dalle rappresentazioni di stringa di <paramref name="arg0" /> e <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Questo metodo Usa il [funzionalità di formattazione composta](~/docs/standard/base-types/composite-formatting.md) per convertire le rappresentazioni di stringa di due espressioni e incorporare tali rappresentazioni in una stringa. Eseguire la conversione, il metodo utilizza un formattatore personalizzato o formattazione delle impostazioni cultura. Il metodo converte ogni <xref:System.Object> argomento nella relativa rappresentazione di stringa chiamando il relativo **ToString (IFormatProvider)** metodo o, se l'oggetto corrispondente elemento di formato include una stringa di formato, chiamando il relativo **ToString(String,IFormatProvider)** metodo. Se questi metodi non esistono, viene chiamato l'oggetto senza parametri **ToString** metodo.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  oppure  L'indice di un elemento di formato è diverso da zero o uno.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[stringa in formato composito](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Primo oggetto da formattare.</param>
        <param name="arg1">Secondo oggetto da formattare.</param>
        <param name="arg2">Terzo oggetto da formattare.</param>
        <summary>Sostituisce gli elementi di formato in una stringa con le rappresentazioni di stringa di tre oggetti specificati.</summary>
        <returns>Copia di <paramref name="format" /> in cui gli elementi di formato sono stati sostituiti dalle rappresentazioni di stringa di <paramref name="arg0" />, <paramref name="arg1" /> e <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Questo metodo Usa il [funzionalità di formattazione composta](~/docs/standard/base-types/composite-formatting.md) per convertire il valore di tre espressioni nelle rispettive rappresentazioni di stringa e incorporare tali rappresentazioni in una stringa. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a>Esempio: Formattazione di tre argomenti  
 
 Questo esempio viene utilizzato il <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> metodo per creare una stringa che illustra il risultato di un valore booleano `And` operazione con due valori integer. Si noti che la stringa di formato include sei elementi di formato, ma il metodo ha solo tre elementi nell'elenco dei parametri, perché ogni elemento è formattato in due modi diversi.  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  oppure  L'indice di un elemento di formato è minore di zero oppure maggiore di due.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <param name="format">[stringa in formato composito](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Primo oggetto da formattare.</param>
        <param name="arg1">Secondo oggetto da formattare.</param>
        <param name="arg2">Terzo oggetto da formattare.</param>
        <summary>Sostituisce gli elementi di formato in una stringa con le rappresentazioni di stringa di tre oggetti specificati. Un parametro fornisce le informazioni di formattazione specifiche delle impostazioni cultura.</summary>
        <returns>Copia di <paramref name="format" /> in cui gli elementi di formato sono stati sostituiti dalle rappresentazioni di stringa di <paramref name="arg0" />, <paramref name="arg1" /> e <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Questo metodo Usa il [funzionalità di formattazione composta](~/docs/standard/base-types/composite-formatting.md) per convertire le rappresentazioni di stringa di tre espressioni e incorporare tali rappresentazioni in una stringa. Eseguire la conversione, il metodo utilizza un formattatore personalizzato o formattazione delle impostazioni cultura. Il metodo converte ogni <xref:System.Object> argomento nella relativa rappresentazione di stringa chiamando il relativo **ToString (IFormatProvider)** metodo o, se l'oggetto corrispondente elemento di formato include una stringa di formato, chiamando il relativo **ToString(String,IFormatProvider)** metodo. Se questi metodi non esistono, viene chiamato l'oggetto senza parametri **ToString** metodo.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> è <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> non è valido.  oppure  L'indice di un elemento di formato è minore di zero oppure maggiore di due.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera un oggetto che può eseguire l'iterazione fra i singoli caratteri di questa stringa.</summary>
        <returns>Oggetto enumeratore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> Anziché chiamare le <xref:System.String.GetEnumerator%2A> metodo per recuperare un <xref:System.CharEnumerator> dell'oggetto che è quindi possibile utilizzare per enumerare una stringa, è consigliabile utilizzare il costrutto di iterazione del linguaggio (in c#, in C + c++ CLR e in Visual Basic). [foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) in c# [per ogni](/cpp/dotnet/for-each-in) in C + + CLR, e [per ogni](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) in Visual Basic).
  
 Questo metodo consente di scorrere i singoli caratteri in una stringa. Ad esempio, Visual Basic `For Each` e c# `foreach` istruzioni richiamano questo metodo per restituire un <xref:System.CharEnumerator> oggetto che può fornire accesso in sola lettura ai caratteri di questa istanza di stringa.  
  
   
  
## Examples  
 Nell'esempio seguente scorre i caratteri in diverse stringhe e visualizza le informazioni sui relativi caratteri singoli. Viene utilizzato il costrutto dell'iterazione di linguaggio anziché come una chiamata al <xref:System.String.GetEnumerator%2A> metodo.  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il codice hash di questa stringa.</summary>
        <returns>Codice hash di un intero con segno a 32 bit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il comportamento di <xref:System.String.GetHashCode%2A> dipende dalla relativa implementazione, che potrebbe cambiare da una versione di common language runtime. È un motivo per cui questa situazione può verificarsi per migliorare le prestazioni di <xref:System.String.GetHashCode%2A>.  
  
> [!IMPORTANT]
>  Se due oggetti string specificati sono uguali, il <xref:System.String.GetHashCode%2A> metodo restituisce valori identici. Tuttavia, non c'è un valore del codice hash univoco per ogni valore di stringa univoco. Stringhe diverse possono restituire lo stesso codice hash.  
>   
>  Non è necessariamente che il codice hash stabile. Codice hash per stringhe identiche possono variare tra le versioni di .NET Framework e su più piattaforme (ad esempio 32 bit e 64 bit) per una singola versione di .NET Framework. In alcuni casi, possono anche differire dal dominio applicazione. Ciò implica due esecuzioni successive dello stesso programma possono restituire i codici hash diverso.  
>   
>  Di conseguenza, hash codici non devono mai essere utilizzati di fuori del dominio applicazione in cui sono stati creati, non deve mai essere utilizzati come campi chiave in una raccolta e non deve essere mantenute.  
>   
>  Infine, non utilizzare il codice hash anziché un valore restituito da una funzione hash di crittografia, se è necessario un hash crittografico. Per gli hash di crittografia, utilizzare una classe derivata dal <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> o <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> classe.  
>   
>  Per ulteriori informazioni sui codici hash, vedere <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Nelle App desktop, è possibile utilizzare il [ \<UseRandomizedStringHashAlgorithm > elemento](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) per generare codice hash univoco in una base di un dominio di applicazione. Questo può ridurre il numero di conflitti e migliorare le prestazioni complessive di inserimenti e le ricerche che utilizzano le tabelle hash. Nell'esempio seguente viene illustrato come utilizzare il [ \<UseRandomizedStringHashAlgorithm > elemento](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md). Definisce un per generare codice hash univoco in una base di un dominio di applicazione. Questo può ridurre il numero di conflitti e migliorare le prestazioni complessive di inserimenti e le ricerche che utilizzano le tabelle hash. Nell'esempio seguente viene illustrato come utilizzare il. Definisce un `DisplayString` classe che include una costante di stringa privata, `s`, il cui valore è "This is a una stringa". Viene inoltre incluso un metodo `ShowStringHashCode` tramite cui vengono visualizzati il valore stringa e il codice hash con il nome del dominio applicazione in cui il metodo è in esecuzione.  
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 Quando si esegue l'esempio senza fornire un file di configurazione, restituisce un output analogo al seguente. Si noti che i codici hash per la stringa sono identici nei due domini applicazione.  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC  
  
```  
  
 Tuttavia, se si aggiunge il file di configurazione seguente alla directory di esempio e, successivamente, si esegue l'esempio, i codici hash per la stessa stringa risulteranno diversi dal dominio dell'applicazione.  
  
```xml  
  
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>  
  
```  
  
 Quando il file di configurazione è presente, l'esempio visualizza il seguente output:  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D  
String 'This is a string.' in domain 'NewDomain': 75CC8236  
  
```  
  
> [!IMPORTANT]
>  I codici hash vengono utilizzati per inserire e recuperare gli oggetti con chiavi da tabelle hash in modo efficiente. Tuttavia, i codici hash non identificano in modo univoco le stringhe. Stringhe identiche hanno i codici hash uguali, ma common language runtime può inoltre assegnare lo stesso codice hash di stringhe diverse. Inoltre, i codici hash possono variare da una versione di .NET Framework, dalla piattaforma all'interno di un'unica versione e dal dominio applicazione. Per questo motivo, è consigliabile non serializzare o mantenere i valori di codice hash, né utilizzare le chiavi in una tabella hash o un dizionario.  
  
 Per ulteriori informazioni sull'utilizzo dei codici hash e `GetHashCode` metodo, vedere <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.GetHashCode%2A> metodo utilizzando diverse stringhe di input.  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Il valore restituito da <see cref="M:System.String.GetHashCode" /> è dipendente dalla piattaforma. La differenza nelle versioni a 32 e 64 bit di .NET Framework. È anche possibile diverso tra le versioni di .NET Framework.</para>
        </block>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce l'oggetto <see cref="T:System.TypeCode" /> per la classe <see cref="T:System.String" />.</summary>
        <returns>Costante enumerata <see cref="F:System.TypeCode.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente mostra il <xref:System.TypeCode> costante enumerata per il <xref:System.String> tipo.  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce l'indice in base zero della prima occorrenza di un carattere Unicode specificato o di una stringa all'interno di questa istanza. Il metodo restituisce -1 se la stringa o il carattere non viene trovato nell'istanza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Carattere Unicode da cercare.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza del carattere Unicode specificato in questa stringa.</summary>
        <returns>Posizione dell'indice in base zero di <paramref name="value" /> se viene trovato il carattere; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero.  
  
 Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i relativi valori scalari Unicode sono uguali. Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come cercare un <xref:System.String> di un carattere utilizzando il <xref:System.String.IndexOf%2A> metodo.  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza della stringa specificata in questa istanza.</summary>
        <returns>Posizione dell'indice in base zero di <paramref name="value" /> se viene trovata la stringa; in caso contrario, -1. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito è 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero.  
  
 Questo metodo esegue una ricerca di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti. La ricerca inizia in corrispondenza della posizione del primo carattere contenuto di questa istanza e continua fino all'ultima posizione.  
  
 I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura. In una ricerca dipendente dalle impostazioni cultura, se `value` contiene un carattere ignorabile, il risultato è equivalente alla ricerca con il carattere rimosso. Se `value` è composta solo da uno o più caratteri ignorabili, il <xref:System.String.IndexOf%28System.String%29> metodo restituisce sempre 0 (zero) per indicare che è stata trovata la corrispondenza all'inizio dell'istanza corrente. Nell'esempio seguente, il <xref:System.String.IndexOf%28System.String%29> metodo viene utilizzato per individuare le sottostringhe di tre (un segno meno facoltativo (U + 00AD), un segno meno facoltativo seguito da "n" e un segno meno facoltativo seguito da "m") in due stringhe. Solo una delle stringhe contiene un segno meno facoltativo. Se viene eseguito l'esempio di [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o versioni successive, in ogni caso, poiché il segno meno facoltativo è un carattere ignorabile, il risultato è lo stesso come se il segno meno non era state incluse `value`. Quando si cerca solo un segno, il metodo restituisce 0 (zero) per indicare che ha trovato una corrispondenza all'inizio della stringa.  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 Nell'esempio seguente viene eseguita la ricerca di "n" in "animale". Poiché gli indici di stringa iniziano da zero, anziché uno, il <xref:System.String.IndexOf%28System.String%29> metodo indica che "n" è nella posizione 1.  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 L'esempio seguente usa il <xref:System.String.IndexOf%2A> metodo per determinare la posizione iniziale di un nome di polizia di una frase. Questa posizione viene quindi utilizzato per inserire un aggettivo che descrive l'animale nella frase.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Come spiegato in [Best Practices for Strings](~/docs/standard/base-types/best-practices-strings.md) utilizzando, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e in alternativa, chiamano metodi che richiedono parametri per essere specificato in modo esplicito. Per trovare il primo indice di una sottostringa all'interno di un'istanza di stringa usando le regole di confronto delle impostazioni cultura correnti, chiamare il <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> overload del metodo con un valore di <see cref="F:System.StringComparison.CurrentCulture" /> per il parametro 'comparisonType'.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Carattere Unicode da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza del carattere Unicode specificato in questa stringa. La ricerca ha inizio alla posizione del carattere specificata.</summary>
        <returns>Posizione dell'indice in base zero di <paramref name="value" /> dall'inizio della stringa se viene trovato il carattere oppure -1 in caso contrario.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da 0. Il parametro `startIndex` può avere un valore compreso tra 0 e la lunghezza dell'istanza della stringa. Se `startIndex` è uguale alla lunghezza dell'istanza di stringa, il metodo restituisce -1.  
  
 La ricerca ha inizio dal `startIndex` alla fine della stringa.  
  
 Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i relativi valori scalari Unicode sono uguali. Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.IndexOf%2A> metodo.  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> è minore di 0 (zero) o maggiore della lunghezza della stringa.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza della stringa specificata in questa istanza. La ricerca ha inizio alla posizione del carattere specificata.</summary>
        <returns>Posizione dell'indice in base zero di <paramref name="value" /> dall'inizio dell'istanza corrente se la stringa viene trovata oppure -1 in caso contrario. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito è <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da 0. Il parametro `startIndex` può avere un valore compreso tra 0 e la lunghezza dell'istanza della stringa. Se `startIndex` è uguale alla lunghezza dell'istanza di stringa, il metodo restituisce -1.  
  
 Questo metodo esegue una ricerca di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti. La ricerca inizia in corrispondenza di `startIndex` posizione di questa istanza di carattere e continua fino all'ultima posizione.  
  
 I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura. In una ricerca dipendente dalle impostazioni cultura, se `value` contiene un carattere ignorabile, il risultato è equivalente alla ricerca con il carattere rimosso. Se `value` è composta solo da uno o più caratteri ignorabili, il <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> metodo restituisce sempre `startIndex`, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca. Nell'esempio seguente, il <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> metodo viene utilizzato per trovare la posizione di un segno meno facoltativo (U + 00AD) seguita da una "m" in due stringhe. Solo una delle stringhe contiene la sottostringa richiesta. Se si esegue l'esempio [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o in un secondo momento, in entrambi i casi, poiché il segno meno facoltativo è un carattere ignorabile, il metodo restituisce l'indice di "m" nella stringa. Si noti che nel caso della prima stringa, che include il segno meno facoltativo seguito da una "m", il metodo non restituisce l'indice del segno meno facoltativo, ma l'indice di "m".  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 Nell'esempio seguente viene eseguita la ricerca di tutte le occorrenze di una stringa specificata all'interno di una stringa di destinazione.  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> è minore di 0 (zero) o maggiore della lunghezza di questa stringa.</exception>
        <block subset="none" type="usage">
          <para>Come spiegato in [Best Practices for Strings](~/docs/standard/base-types/best-practices-strings.md) utilizzando, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e in alternativa, chiamano metodi che richiedono parametri per essere specificato in modo esplicito. Per trovare il primo indice di una sottostringa che si verifica dopo una particolare posizione di carattere utilizzando le regole di confronto delle impostazioni cultura correnti, chiamare il <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> overload del metodo con un valore di <see cref="F:System.StringComparison.CurrentCulture" /> per il parametro 'comparisonType'.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che specifica le regole di ricerca.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza della stringa specificata nell'oggetto <see cref="T:System.String" /> corrente. Un parametro specifica il tipo di ricerca da usare per la stringa specificata.</summary>
        <returns>Posizione dell'indice del parametro <paramref name="value" /> se tale stringa viene trovata; in caso contrario, -1. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito è 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero.  
  
 Il `comparisonType` parametro consente di ricercare il `value` parametro utilizzando le impostazioni cultura correnti o invarianti, usando una ricerca con distinzione maiuscole/minuscole o minuscole e utilizzando regole di confronto ordinale o word.  
  
   
  
## Examples  
 Il seguente exampledemonstrates tre overload del <xref:System.String.IndexOf%2A> metodo che trova la prima occorrenza di una stringa all'interno di un'altra stringa utilizzando i diversi valori del <xref:System.StringComparison> enumerazione.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore valido di <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati quando si esegue un confronto linguistico o dipendente dalla lingua. In una ricerca dipendente dalle impostazioni cultura (ovvero se <paramref name="comparisonType" /> non è <see cref="F:System.StringComparison.Ordinal" /> o <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), se <paramref name="value" /> contiene un carattere ignorable, il risultato è equivalente alla ricerca con il carattere rimosso. Se <paramref name="value" /> costituito solo da uno o più caratteri ignorabili, il <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> metodo restituisce sempre 0 (zero) per indicare che si trova la corrispondenza all'inizio dell'istanza corrente.  Nell'esempio seguente, il <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> metodo viene utilizzato per individuare le sottostringhe di tre (un segno meno facoltativo (U + 00AD), un segno meno facoltativo seguito da "n" e un segno meno facoltativo seguito da "m") in due stringhe. Solo una delle stringhe contiene un segno meno facoltativo. Se viene eseguito l'esempio di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, poiché il segno meno facoltativo è un carattere ignorabile, una ricerca dipendente dalle impostazioni cultura restituisce lo stesso valore che il risultato restituito sarebbe se il segno meno non incluse nella stringa di ricerca. Una ricerca ordinale, tuttavia, correttamente individua il segno meno in un'unica stringa e segnala che è assente dalla seconda stringa.  [! codice csharp [System.String.IndexOf#26] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.IndexOf/CS/ignorable26.cs#26)] [! codice vb [System.String.IndexOf#26] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.IndexOf/VB/ignorable26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Carattere Unicode da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca.</param>
        <param name="count">Numero di posizioni dei caratteri da esaminare.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza del carattere specificato in questa istanza. La ricerca viene eseguita iniziando dalla posizione specificata dei caratteri ed esamina un determinato numero di posizioni.</summary>
        <returns>Posizione dell'indice in base zero di <paramref name="value" /> dall'inizio della stringa se viene trovato il carattere oppure -1 in caso contrario.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La ricerca inizia in corrispondenza `startIndex` e continua a `startIndex`  +  `count` -1. Il carattere alla `startIndex`  +  `count` non è incluso nella ricerca.  
  
 Numerazione dell'indice inizia da 0 (zero). Il parametro `startIndex` può avere un valore compreso tra 0 e la lunghezza dell'istanza della stringa.  
  
 Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i relativi valori scalari Unicode sono uguali. Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.IndexOf%2A> metodo.  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> o <paramref name="startIndex" /> è negativo.  oppure  <paramref name="startIndex" /> è maggiore della lunghezza di questa stringa.  oppure  <paramref name="count" /> è maggiore della lunghezza di questa stringa meno <paramref name="startIndex" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca.</param>
        <param name="count">Numero di posizioni dei caratteri da esaminare.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza della stringa specificata in questa istanza. La ricerca viene eseguita iniziando dalla posizione specificata dei caratteri ed esamina un determinato numero di posizioni.</summary>
        <returns>Posizione dell'indice in base zero di <paramref name="value" /> dall'inizio dell'istanza corrente se la stringa viene trovata oppure -1 in caso contrario. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito è <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da 0 (zero). Il parametro `startIndex` può avere un valore compreso tra 0 e la lunghezza dell'istanza della stringa.  
  
 Questo metodo esegue una ricerca di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti. La ricerca inizia in corrispondenza `startIndex` e continua a `startIndex`  +  `count` -1. Il carattere alla `startIndex`  +  `count` non è incluso nella ricerca.  
  
 I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura. In una ricerca dipendente dalle impostazioni cultura, se `value` contiene un carattere ignorabile, il risultato è equivalente alla ricerca con il carattere rimosso. Se `value` è composta solo da uno o più caratteri ignorabili, il <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> metodo restituisce sempre `startIndex`, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca. Nell'esempio seguente, il <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> metodo viene utilizzato per trovare la posizione di un segno meno facoltativo (U + 00AD) seguita da una "m" a partire dal terzo sesto posizioni dei caratteri in due stringhe. Solo una delle stringhe contiene la sottostringa richiesta. Se viene eseguito l'esempio di [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o in un secondo momento, in entrambi i casi, poiché il segno meno facoltativo è un carattere ignorabile, il metodo restituisce l'indice di "m" nella stringa quando viene eseguito un confronto con distinzione delle impostazioni cultura. Si noti che nel caso della prima stringa, che include il segno meno facoltativo seguito da una "m", il metodo non restituisce l'indice del segno meno facoltativo, ma l'indice di "m".  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 Nell'esempio seguente trova l'indice di tutte le occorrenze della stringa "he" all'interno di una sottostringa di un'altra stringa. Si noti che per ogni iterazione di ricerca è necessario ricalcolare il numero di caratteri da cercare.  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> o <paramref name="startIndex" /> è negativo.  oppure  <paramref name="startIndex" /> è maggiore della lunghezza di questa stringa.  oppure  <paramref name="count" /> è maggiore della lunghezza di questa stringa meno <paramref name="startIndex" />.</exception>
        <block subset="none" type="usage">
          <para>Come spiegato in [Best Practices for Strings](~/docs/standard/base-types/best-practices-strings.md) utilizzando, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e in alternativa, chiamano metodi che richiedono parametri per essere specificato in modo esplicito. Per utilizzare le regole di confronto della lingua corrente per eseguire questa operazione, chiamare il <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> overload del metodo con un valore di <see cref="F:System.StringComparison.CurrentCulture" /> per il parametro 'comparisonType'.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che specifica le regole di ricerca.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza della stringa specificata nell'oggetto <see cref="T:System.String" /> corrente. I parametri specificano la posizione iniziale della ricerca nella stringa corrente e il tipo di ricerca da usare per la stringa specificata.</summary>
        <returns>Posizione dell'indice in base zero del parametro <paramref name="value" /> dall'inizio dell'istanza corrente se la stringa viene trovata oppure -1 in caso contrario. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito è <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da 0. Il parametro `startIndex` può avere un valore compreso tra 0 e la lunghezza dell'istanza della stringa. Se `startIndex` è uguale alla lunghezza dell'istanza di stringa, il metodo restituisce -1.  
  
 Il `comparisonType` parametro consente di ricercare il `value` parametro utilizzando le impostazioni cultura correnti o invarianti, usando una ricerca con distinzione maiuscole/minuscole o minuscole e utilizzando regole di confronto ordinale o word.  
  
   
  
## Examples  
 Il seguente exampledemonstrates tre overload del <xref:System.String.IndexOf%2A> metodo che trova la prima occorrenza di una stringa all'interno di un'altra stringa utilizzando i diversi valori del <xref:System.StringComparison> enumerazione.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> è minore di 0 (zero) o maggiore della lunghezza di questa stringa.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore valido di <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati quando si esegue un confronto linguistico o dipendente dalla lingua. In una ricerca dipendente dalle impostazioni cultura (ovvero se <paramref name="comparisonType" /> non è <see cref="F:System.StringComparison.Ordinal" /> o <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), se <paramref name="value" /> contiene un carattere ignorable, il risultato è equivalente alla ricerca con il carattere rimosso. Se <paramref name="value" /> costituito solo da uno o più caratteri ignorabili, il <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> metodo restituisce sempre <paramref name="startIndex" />, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca.  Nell'esempio seguente, il <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> metodo viene utilizzato per trovare la posizione di un segno meno facoltativo (U + 00AD) seguita da una "m" inizia con la terza posizione del carattere in due stringhe. Solo una delle stringhe contiene la sottostringa richiesta. Se viene eseguito l'esempio di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, in entrambi i casi, poiché il segno meno facoltativo è un carattere ignorabile, il metodo restituisce l'indice di "m" nella stringa di quando viene eseguito un confronto dipendente dalle impostazioni cultura. Si noti che nel caso della prima stringa, che include il segno meno facoltativo seguito da una "m", il metodo non restituisce l'indice del segno meno facoltativo, ma l'indice di "m". Il metodo restituisce l'indice del segno nella prima stringa solo quando si esegue un confronto ordinale.  [! codice csharp [System.String.IndexOf#25] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.IndexOf/CS/ignorable25.cs#25)] [! codice vb [System.String.IndexOf#25] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.IndexOf/VB/ignorable25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca.</param>
        <param name="count">Numero di posizioni dei caratteri da esaminare.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che specifica le regole di ricerca.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza della stringa specificata nell'oggetto <see cref="T:System.String" /> corrente. I parametri specificano la posizione di ricerca iniziale nella stringa corrente, il numero di caratteri nella stringa corrente in cui eseguire la ricerca e il tipo di ricerca da usare per la stringa specificata.</summary>
        <returns>Posizione dell'indice in base zero del parametro <paramref name="value" /> dall'inizio dell'istanza corrente se la stringa viene trovata oppure -1 in caso contrario. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito è <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da 0 (zero). Il parametro `startIndex` può avere un valore compreso tra 0 e la lunghezza dell'istanza della stringa.  
  
 La ricerca inizia in corrispondenza `startIndex` e continua a `startIndex`  +  `count` -1. Il carattere alla `startIndex`  +  `count` non è incluso nella ricerca.  
  
 Il `comparisonType` parametro consente di ricercare il `value` parametro utilizzando le impostazioni cultura correnti o invarianti, usando una ricerca con distinzione maiuscole/minuscole o minuscole e utilizzando regole di confronto ordinale o word.  
  
   
  
## Examples  
 Il seguente exampledemonstrates tre overload del <xref:System.String.IndexOf%2A> metodo che trova la prima occorrenza di una stringa all'interno di un'altra stringa utilizzando i diversi valori del <xref:System.StringComparison> enumerazione.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> o <paramref name="startIndex" /> è negativo.  oppure <paramref name="startIndex" /> è maggiore della lunghezza di questa istanza.  oppure  <paramref name="count" /> è maggiore della lunghezza di questa stringa meno <paramref name="startIndex" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore valido di <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati quando si esegue un confronto linguistico o dipendente dalla lingua. In una ricerca dipendente dalle impostazioni cultura (ovvero se <paramref name="comparisonType" /> non è <see cref="F:System.StringComparison.Ordinal" /> o <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), se <paramref name="value" /> contiene un carattere ignorable, il risultato è equivalente alla ricerca con il carattere rimosso. Se <paramref name="value" /> costituito solo da uno o più caratteri ignorabili, il <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> metodo restituisce sempre <paramref name="startIndex" />, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca.  Nell'esempio seguente, il <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> metodo viene utilizzato per trovare la posizione di un segno meno facoltativo (U + 00AD) seguita da una "m" a partire dal terzo sesto posizioni dei caratteri in due stringhe. Solo una delle stringhe contiene la sottostringa richiesta. Se viene eseguito l'esempio di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, in entrambi i casi, poiché il segno meno facoltativo è un carattere ignorabile, il metodo restituisce l'indice di "m" nella stringa di quando viene eseguito un confronto dipendente dalle impostazioni cultura. Quando esegue un confronto ordinale, tuttavia, trova la sottostringa solo nella prima stringa. Si noti che nel caso della prima stringa, che include il segno meno facoltativo seguito da una "m", il metodo non restituisce l'indice del segno, ma l'indice di "m" quando si esegue un confronto con distinzione delle impostazioni cultura. Il metodo restituisce l'indice del segno nella prima stringa solo quando si esegue un confronto ordinale.  [! codice csharp [System.String.IndexOf#24] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.IndexOf/CS/ignorable24.cs#24)] [! codice vb [System.String.IndexOf#24] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.IndexOf/VB/ignorable24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce l'indice della prima occorrenza in questa istanza di qualsiasi carattere presente in una matrice di caratteri Unicode specificata. Il metodo restituisce -1 se i caratteri nella matrice non vengono trovati nell'istanza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Matrice di caratteri Unicode contenente uno o più caratteri da cercare.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza in questa istanza di qualsiasi carattere presente in una matrice di caratteri Unicode specificata.</summary>
        <returns>Posizione dell'indice in base zero della prima occorrenza di questa istanza in cui è stato trovato un carattere in <paramref name="anyOf" />; -1 se non è stato trovato alcun carattere in <paramref name="anyOf" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero.  
  
 La ricerca di `anyOf` tra maiuscole e minuscole. Se `anyOf` è una matrice vuota, il metodo trova una corrispondenza all'inizio della stringa (ovvero, in corrispondenza dell'indice zero).  
  
 Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i relativi valori scalari Unicode sono uguali. Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente vengono vocale prima in una stringa.  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Matrice di caratteri Unicode contenente uno o più caratteri da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza in questa istanza di qualsiasi carattere presente in una matrice di caratteri Unicode specificata. La ricerca ha inizio alla posizione del carattere specificata.</summary>
        <returns>Posizione dell'indice in base zero della prima occorrenza di questa istanza in cui è stato trovato un carattere in <paramref name="anyOf" />; -1 se non è stato trovato alcun carattere in <paramref name="anyOf" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero. Il `startIndex` parametro possibile compreso tra 0 e minore della lunghezza dell'istanza di stringa di uno.  
  
 La ricerca ha inizio dal `startIndex` alla fine della stringa.  
  
 La ricerca di `anyOf` tra maiuscole e minuscole.  
  
 Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i rispettivi valori scalari Unicode sono uguali. Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente consente di trovare l'indice dell'occorrenza di qualsiasi carattere della stringa "is" all'interno di una sottostringa di un'altra stringa.  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> è negativo.  oppure  <paramref name="startIndex" /> è maggiore del numero di caratteri in questa istanza.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Matrice di caratteri Unicode contenente uno o più caratteri da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca.</param>
        <param name="count">Numero di posizioni dei caratteri da esaminare.</param>
        <summary>Restituisce l'indice in base zero della prima occorrenza in questa istanza di qualsiasi carattere presente in una matrice di caratteri Unicode specificata. La ricerca viene eseguita iniziando dalla posizione specificata dei caratteri ed esamina un determinato numero di posizioni.</summary>
        <returns>Posizione dell'indice in base zero della prima occorrenza di questa istanza in cui è stato trovato un carattere in <paramref name="anyOf" />; -1 se non è stato trovato alcun carattere in <paramref name="anyOf" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La ricerca inizia in corrispondenza `startIndex` e continua a `startIndex`  +  `count` -1. Il carattere alla `startIndex`  +  `count` non è incluso nella ricerca.  
  
 Numerazione dell'indice inizia da zero. Il `startIndex` parametro possibile compreso tra 0 e minore della lunghezza dell'istanza di stringa di uno.  
  
 La ricerca di `anyOf` tra maiuscole e minuscole.  
  
 Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i rispettivi valori scalari Unicode sono uguali. Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente viene trovato l'indice dell'occorrenza di qualsiasi carattere della stringa "aid" all'interno di una sottostringa di un'altra stringa.  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> o <paramref name="startIndex" /> è negativo.  oppure <paramref name="count" /> + <paramref name="startIndex" /> è maggiore del numero di caratteri in questa istanza.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">La posizione dell'indice in base zero dell'inserimento.</param>
        <param name="value">Stringa da inserire.</param>
        <summary>Restituisce una nuova stringa in cui una stringa specificata viene inserita in una posizione di indice specificata in questa istanza.</summary>
        <returns>Nuova stringa equivalente a questa istanza, ma con <paramref name="value" /> inserito in corrispondenza della posizione <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `startIndex` è uguale alla lunghezza di questa istanza, `value` viene aggiunto alla fine di questa istanza.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui `value` viene inserito nell'istanza corrente.  
  
 Ad esempio, il valore restituito di `"abc".Insert(2, "XYZ")` è "abXYZc".  
  
   
  
## Examples  
 L'esempio seguente inserisce un carattere di spazio nella posizione del quarto carattere (il carattere in corrispondenza dell'indice 3) di una stringa.  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 La seguente applicazione console richiede agli utenti di immettere uno o più degli aggettivi per descrivere due animali. Chiama quindi il <xref:System.String.Insert%2A> per inserire il testo immesso dall'utente in una stringa.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="startIndex" /> è negativo o maggiore della lunghezza di questa istanza.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Stringa da cercare nel pool di centralizzazione.</param>
        <summary>Recupera il riferimento del sistema all'oggetto <see cref="T:System.String" /> specificato.</summary>
        <returns>Riferimento del sistema a <paramref name="str" />, se è centralizzato; in caso contrario, nuovo riferimento a una stringa con il valore di <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Common language runtime gestisce l'archiviazione delle stringhe mediante una tabella, denominata pool interno, che contiene un solo riferimento a ogni valore letterale stringa univoca dichiarata o creata a livello di codice nel programma. Di conseguenza, un'istanza di una stringa letterale con un valore specifico è presente una sola volta nel sistema.  
  
 Ad esempio, se si assegna la stessa stringa letterale a più variabili, il runtime recupera lo stesso riferimento per la stringa letterale dal pool di centralizzazione e assegna a ogni variabile.  
  
 Il <xref:System.String.Intern%2A> metodo utilizza il pool interno per cercare una stringa uguale al valore di `str`. Se tale stringa esiste, viene restituito il relativo riferimento nel pool di centralizzazione. Se la stringa non esiste, un riferimento a `str` viene aggiunto al pool interno, che quindi viene restituito.  
  
 Nell'esempio seguente, la stringa s1, che ha un valore "MyTest", è già inserita perché è un valore letterale nel programma. La <xref:System.Text.StringBuilder?displayProperty=nameWithType> classe genera un nuovo oggetto stringa con lo stesso valore di s1. Un riferimento a tale stringa viene assegnato a s2. Il <xref:System.String.Intern%2A> metodo cerca una stringa che contiene lo stesso valore di s2. Poiché tale stringa esiste, il metodo restituisce lo stesso riferimento assegnato a s1. Tale riferimento viene quindi assegnato a s3. I riferimenti s1 e S2 risultano diversi perché fanno riferimento a oggetti diversi. i riferimenti s1 e s3 risultano uguali perché fanno riferimento alla stessa stringa.  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 Questo metodo per confrontare il <xref:System.String.IsInterned%2A> metodo.  
  
## <a name="version-considerations"></a>Considerazioni sulla versione  
 Nel [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], <xref:System.String.Intern%2A> metodo verrà ripristinato il comportamento in .NET Framework 1.0 e 1.1 relativamente all'inserimento di una stringa vuota. Nell'esempio seguente, la variabile `str1` viene assegnato un riferimento a <xref:System.String.Empty>, mentre la variabile `str2` è assegnato il riferimento a <xref:System.String.Empty> restituito chiamando il <xref:System.String.Intern%2A> metodo dopo aver convertito un <xref:System.Text.StringBuilder>oggetto il cui valore è <xref:System.String.Empty> in una stringa. Quindi, i riferimenti contenuti `str1` e `str2` vengono confrontati per verificarne l'uguaglianza.  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 Nel [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], e [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` e `str2` sono uguali. Nel [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] e [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` e `str2` non sono uguali.  
  
## <a name="performance-considerations"></a>Considerazioni sulle prestazioni  
 Se si sta tentando di ridurre la quantità totale di memoria allocata dall'applicazione, tenere presente che l'inserimento di una stringa ha due effetti collaterali indesiderati. In primo luogo, la memoria allocata per centralizzati <xref:System.String> oggetti non viene probabilmente essere rilasciata finché non termina con common language runtime (CLR). Il motivo è che il riferimento del CLR per inserito <xref:System.String> oggetto può persistere anche dopo l'applicazione o persino del dominio applicazione, viene terminato. In secondo luogo, per collaterale di una stringa, è innanzitutto necessario creare la stringa. La memoria utilizzata dal <xref:System.String> oggetto deve essere comunque allocato, anche se la memoria verrà infine sottoposte a garbage collection.  
  
 .NET Framework versione 2.0 introduce il <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> membro di enumerazione. Il <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> membro contrassegna un assembly che non richiedono stringhe letterali. È possibile applicare <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> a un assembly utilizzando il <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> attributo. Inoltre, quando si utilizza il [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) per compilare un assembly prima della fase di esecuzione, le stringhe non sono inserite in tutti i moduli.  
  
   
  
## Examples  
 L'esempio seguente usa tre stringhe hanno lo stesso valore per determinare se una stringa appena creata e una stringa inserita sono uguali.  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Stringa da cercare nel pool di centralizzazione.</param>
        <summary>Recupera un riferimento a un oggetto <see cref="T:System.String" /> specificato.</summary>
        <returns>Riferimento a <paramref name="str" />, se è presente nel pool di centralizzazione di Common Language Runtime; in caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Common language runtime gestisce automaticamente una tabella, denominata pool interno, che contiene una singola istanza di ogni costante di stringa letterale univoca dichiarata in un programma, nonché qualsiasi istanza univoca di <xref:System.String> per aggiungere a livello di programmazione, chiamare il <xref:System.String.Intern%2A> metodo.  
  
 Nel pool di archiviazione di stringhe. Se si assegna una costante di valore letterale stringa a più variabili, ogni variabile è impostata per fare riferimento alla stessa costante nel pool di centralizzazione invece che fanno riferimento a diverse istanze di <xref:System.String> che hanno valori identici.  
  
 Questo metodo cerca `str` nel pool di centralizzazione. Se `str` è già stato inserito, un riferimento a tale istanza sia restituito; in caso contrario, `null` viene restituito.  
  
 Questo metodo per confrontare il <xref:System.String.Intern%2A> metodo.  
  
 Questo metodo non restituisce un valore booleano. Se si chiama il metodo perché si vuole che un valore booleano che indica se una determinata stringa è stata inserita, è possibile utilizzare codice analogo al seguente.  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  A partire da .NET Framework versione 2.0, è possibile eseguire l'override del pool interno quando si utilizza il [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) per installare un assembly nella cache delle immagini native in un computer locale. Per ulteriori informazioni, vedere Considerazioni sulle prestazioni nella sezione Osservazioni per il <xref:System.String.Intern%2A> proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato che le stringhe letterali vengono inserite automaticamente dal compilatore.  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Specifica se la stringa è in un particolare formato di normalizzazione Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Specifica se la stringa è nel formato di normalizzazione Unicode C.</summary>
        <returns>
          <see langword="true" /> se la stringa è in formato di normalizzazione C; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcuni caratteri Unicode hanno più rappresentazioni binarie equivalenti formate da set di combinazione e/o i caratteri Unicode composti. L'esistenza di più rappresentazioni di un singolo carattere complica la ricerca, ordinamento, corrispondenza e altre operazioni.  
  
 Lo standard Unicode definisce un processo denominato normalizzazione che restituisce una rappresentazione binaria quando viene fornito qualsiasi rappresentazione binaria equivalente di un carattere. La normalizzazione può essere eseguita con diversi algoritmi, denominati normalizzazione, che sono conformi alle regole diverse. .NET Framework supporta attualmente i formati di normalizzazione C, D, KC e KD.  
  
 Per una descrizione dei formati di normalizzazione Unicode, vedere <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente determina se una stringa è normalizzata correttamente in varie forme di normalizzazione.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'istanza corrente contiene caratteri Unicode non validi.</exception>
        <block subset="none" type="usage">
          <para>Il <see cref="Overload:System.String.IsNormalized" /> metodo <see langword="false" /> appena incontra il primo carattere non normalizzato in una stringa. Pertanto, se una stringa contiene caratteri non normalizzato seguiti da caratteri Unicode non validi, il <see cref="Overload:System.String.Normalize" /> metodo genererà un' <see cref="T:System.ArgumentException" /> Sebbene <see cref="Overload:System.String.IsNormalized" /> restituisce <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Formato di normalizzazione Unicode.</param>
        <summary>Specifica se la stringa è nel formato di normalizzazione Unicode indicato.</summary>
        <returns>
          <see langword="true" /> se la stringa è nel formato di normalizzazione specificato dal parametro <paramref name="normalizationForm" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcuni caratteri Unicode hanno più rappresentazioni binarie equivalenti formate da set di combinazione e/o i caratteri Unicode composti. L'esistenza di più rappresentazioni di un singolo carattere complica la ricerca, ordinamento, corrispondenza e altre operazioni.  
  
 Lo standard Unicode definisce un processo denominato normalizzazione che restituisce una rappresentazione binaria quando viene fornito qualsiasi rappresentazione binaria equivalente di un carattere. La normalizzazione può essere eseguita con diversi algoritmi, denominati normalizzazione, che sono conformi alle regole diverse. .NET Framework supporta attualmente i formati di normalizzazione C, D, KC e KD.  
  
 Per una descrizione dei formati di normalizzazione Unicode, vedere <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.IsNormalized%2A> e <xref:System.String.Normalize%2A> metodi.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'istanza corrente contiene caratteri Unicode non validi.</exception>
        <block subset="none" type="usage">
          <para>Il <see cref="Overload:System.String.IsNormalized" /> metodo <see langword="false" /> appena incontra il primo carattere non normalizzato in una stringa. Pertanto, se una stringa contiene caratteri non normalizzato seguiti da caratteri Unicode non validi, il <see cref="Overload:System.String.Normalize" /> metodo genererà un' <see cref="T:System.ArgumentException" /> Sebbene <see cref="Overload:System.String.IsNormalized" /> restituisce <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da testare.</param>
        <summary>Indica se la stringa specificata è <see langword="null" /> o una stringa <see cref="F:System.String.Empty" />.</summary>
        <returns>
          <see langword="true" /> se il parametro <paramref name="value" /> è <see langword="null" /> o una stringa vuota (""); in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A> è un metodo pratico che consente di testare simultaneamente se un <xref:System.String> è `null` o il relativo valore è <xref:System.String.Empty>. È equivalente al codice seguente:  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 È possibile utilizzare il <xref:System.String.IsNullOrWhiteSpace%2A> metodo per verificare se è una stringa `null`, il relativo valore è <xref:System.String.Empty?displayProperty=nameWithType>, o è costituito solo da spazi vuoti.  
  
## <a name="what-is-a-null-string"></a>Che cos'è una stringa null?  
 È una stringa `null` se non è stato assegnato un valore (in C++ e Visual Basic) o in modo esplicito è stato assegnato un valore di `null`. Sebbene il [formattazione composita](~/docs/standard/base-types/composite-formatting.md) funzionalità è possibile gestire correttamente una stringa null, come illustrato nell'esempio seguente, il tentativo di chiamare uno se i relativi membri genera un <xref:System.NullReferenceException>.  
  
 [!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
 [!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
 [!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>Che cos'è una stringa vuota?  
 Una stringa è vuota se è stato assegnato in modo esplicito una stringa vuota ("") o <xref:System.String.Empty?displayProperty=nameWithType>. Una stringa vuota è un <xref:System.String.Length%2A> pari a 0.  Nell'esempio seguente crea una stringa vuota e visualizza il relativo valore e la relativa lunghezza.  
  
 [!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
 [!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
 [!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
   
  
## Examples  
 Nell'esempio seguente vengono esaminati tre stringhe e determina se ogni stringa è un valore, è una stringa vuota o è `null`.  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da testare.</param>
        <summary>Indica se una stringa specificata è <see langword="null" />, vuota o è composta solo da spazi vuoti.</summary>
        <returns>
          <see langword="true" /> se il parametro <paramref name="value" /> è <see langword="null" /> o <see cref="F:System.String.Empty" /> oppure se <paramref name="value" /> è composto solo da spazi vuoti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A> è un metodo pratico che è simile al codice seguente, ad eccezione del fatto che offre prestazioni migliori:  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 Gli spazi vuoti sono definiti dallo standard Unicode. Il <xref:System.String.IsNullOrWhiteSpace%2A> metodo interpreta qualsiasi carattere che restituisce un valore di `true` quando viene passato per il <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metodo come un carattere di spazio vuoto.  
  
   
  
## Examples  
 Nell'esempio seguente crea una matrice di stringhe e quindi passa ogni elemento della matrice di <xref:System.String.IsNullOrWhiteSpace%2A> metodo.  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatena gli elementi di una matrice specificata o i membri di una raccolta, usando tra gli elementi o i membri il separatore specificato.</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="separator">Stringa da usare come separatore. <c>separator</c> è incluso nella stringa restituita solo se <c>values</c> ha più di un elemento.</param>
        <param name="values">Raccolta che contiene le stringhe da concatenare.</param>
        <summary>Concatena i membri di una raccolta <see cref="T:System.Collections.Generic.IEnumerable`1" /> costruita di tipo <see cref="T:System.String" />, usando tra i membri il separatore specificato.</summary>
        <returns>Stringa costituita dai membri di <paramref name="values" /> delimitati dalla stringa <paramref name="separator" />. Se <paramref name="values" /> non dispone di membri, il metodo restituisce <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `separator` è `null`, una stringa vuota (<xref:System.String.Empty?displayProperty=nameWithType>) viene invece utilizzato. Se qualsiasi membro del `values` è `null`, invece, viene utilizzata una stringa vuota.  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> è un metodo pratico che consente di concatenare ogni elemento in un `IEnumerable(Of String)` insieme senza prima di convertire gli elementi in una matrice di stringhe. È particolarmente utile con le espressioni di query Language-Integrated Query (LINQ). Nell'esempio seguente viene passato un `List(Of String)` oggetto contenente le lettere maiuscole o minuscole dell'alfabeto in un'espressione lambda che consente di selezionare lettere uguale a o maggiore di una determinata lettera (ovvero, nell'esempio, "M"). Il `IEnumerable(Of String)` raccolta restituita dal <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> viene passato per il <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metodo per visualizzare il risultato come stringa singola.  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 L'esempio seguente usa l'algoritmo del crivello di Eratostene per calcolare i numeri primi che sono minori o uguali a 100. Assegna il risultato a un <xref:System.Collections.Generic.List%601> oggetto di tipo <xref:System.String>, che passa quindi il <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> (metodo).  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Stringa da usare come separatore. <c>separator</c> è incluso nella stringa restituita solo se <c>value</c> ha più di un elemento.</param>
        <param name="values">Matrice contenente gli elementi da concatenare.</param>
        <summary>Concatena gli elementi di una matrice di oggetti, usando tra gli elementi il separatore specificato.</summary>
        <returns>Stringa costituita dagli elementi di <paramref name="values" /> delimitati dalla stringa <paramref name="separator" />. Se <paramref name="values" /> è una matrice vuota, il metodo restituisce <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `separator` è `null` o se qualsiasi elemento di `values` è superiore al primo elemento `null`, una stringa vuota (<xref:System.String.Empty?displayProperty=nameWithType>) viene invece utilizzato. Vedere la sezione Note per i chiamanti se il primo elemento della `values` è `null`.  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> è un metodo pratico che consente di concatenare ogni elemento in una matrice di oggetti senza conversione in modo esplicito gli elementi in stringhe. La rappresentazione di stringa di ogni oggetto nella matrice è derivata mediante la chiamata di tale oggetto `ToString` metodo.  
  
   
  
## Examples  
 L'esempio seguente usa l'algoritmo del crivello di Eratostene per calcolare i numeri primi che sono minori o uguali a 100. Assegna il risultato a una matrice di interi, passa quindi il <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> metodo.  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> è <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Se il primo elemento della <paramref name="values" /> viene <see langword="null" />, la <see cref="M:System.String.Join(System.String,System.Object[])" /> metodo concatenare gli elementi in <paramref name="values" /> ma restituisce <see cref="F:System.String.Empty" />. Un numero di possibili soluzioni al problema è disponibile. Il più semplice consiste nell'assegnare un valore di <see cref="F:System.String.Empty" /> al primo elemento della matrice, come nell'esempio seguente viene illustrato.  [! code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [! code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para>
        </block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Stringa da usare come separatore. <c>separator</c> è incluso nella stringa restituita solo se <c>value</c> ha più di un elemento.</param>
        <param name="value">Matrice contenente gli elementi da concatenare.</param>
        <summary>Concatena tutti gli elementi di una matrice di stringhe, usando tra gli elementi il separatore specificato.</summary>
        <returns>Stringa costituita dagli elementi di <paramref name="value" /> delimitati dalla stringa <paramref name="separator" />. Se <paramref name="value" /> è una matrice vuota, il metodo restituisce <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ad esempio, se `separator` è "," e gli elementi di `value` sono "apple", "arancione", "uva" e "pera", `Join(separator, value)` restituisce "apple, arancione, uva, pera".  
  
 Se `separator` è `null`, una stringa vuota (<xref:System.String.Empty?displayProperty=nameWithType>) viene invece utilizzato. Se qualsiasi elemento in `value` è `null`, invece, viene utilizzata una stringa vuota.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.Join%2A> metodo.  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Stringa da usare come separatore. <c>separator</c> è incluso nella stringa restituita solo se <c>value</c> ha più di un elemento.</param>
        <param name="value">Matrice contenente gli elementi da concatenare.</param>
        <param name="startIndex">Primo elemento di <c>value</c> da usare.</param>
        <param name="count">Numero di elementi di <c>value</c> da usare.</param>
        <summary>Concatena gli elementi specificati di una matrice di stringhe, usando tra gli elementi il separatore specificato.</summary>
        <returns>Stringa costituita dalle stringhe di <paramref name="value" /> delimitate dalla stringa <paramref name="separator" />.  oppure  <see cref="F:System.String.Empty" /> se <paramref name="count" /> è zero, se <paramref name="value" /> non ha elementi o se <paramref name="separator" /> e tutti gli elementi di <paramref name="value" /> sono <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ad esempio, se `separator` è "," e gli elementi di `value` sono "apple", "arancione", "uva" e "pera", `Join(separator, value, 1, 2)` restituisce "arancione, uva".  
  
 Se `separator` è `null`, una stringa vuota (<xref:System.String.Empty?displayProperty=nameWithType>) viene invece utilizzato. Se qualsiasi elemento in `value` è `null`, invece, viene utilizzata una stringa vuota.  
  
   
  
## Examples  
 Nell'esempio seguente consente di concatenare due elementi da una matrice di nomi di frutta.  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> o <paramref name="count" /> è minore di 0.  oppure  La somma di <paramref name="startIndex" /> e <paramref name="count" /> è maggiore del numero di elementi in <paramref name="value" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insufficiente.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Il tipo dei membri di <c>valori</c>.</typeparam>
        <param name="separator">Stringa da usare come separatore. <c>separator</c> è incluso nella stringa restituita solo se <c>values</c> ha più di un elemento.</param>
        <param name="values">Raccolta che contiene gli oggetti da concatenare.</param>
        <summary>Concatena i membri di una raccolta, usando tra i membri il separatore specificato.</summary>
        <returns>Stringa costituita dai membri di <paramref name="values" /> delimitati dalla stringa <paramref name="separator" />. Se <paramref name="values" /> non dispone di membri, il metodo restituisce <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `separator` è `null`, una stringa vuota (<xref:System.String.Empty?displayProperty=nameWithType>) viene invece utilizzato. Se qualsiasi membro del `values` è `null`, invece, viene utilizzata una stringa vuota.  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> è un metodo pratico che consente di concatenare ogni membro di un <xref:System.Collections.Generic.IEnumerable%601> insieme senza prima convertirli in stringhe. La rappresentazione di stringa di ogni oggetto di <xref:System.Collections.Generic.IEnumerable%601> raccolta derivata mediante la chiamata di tale oggetto `ToString` (metodo).  
  
 Questo metodo è determinato utile con le espressioni di query Language-Integrated Query (LINQ). Ad esempio, il codice seguente definisce un semplice `Animal` classe che contiene il nome di un animale e l'ordine a cui appartiene. Definisce quindi un <xref:System.Collections.Generic.List%601> oggetto che contiene un numero di `Animal` oggetti. Il <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> viene chiamato il metodo di estensione per estrarre il `Animal` oggetti la cui proprietà `Order` proprietà è uguale a "Roditori". Il risultato viene passato per il <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> metodo.  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 L'esempio seguente usa l'algoritmo del crivello di Eratostene per calcolare i numeri primi che sono minori o uguali a 100. Assegna il risultato a un <xref:System.Collections.Generic.List%601> oggetto di tipo integer, che passa quindi il <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> (metodo).  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza di un carattere Unicode specificato o di una stringa all'interno di questa istanza. Il metodo restituisce -1 se la stringa o il carattere non viene trovato nell'istanza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Carattere Unicode da cercare.</param>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza di un carattere Unicode specificato all'interno di questa istanza.</summary>
        <returns>Posizione dell'indice in base zero di <paramref name="value" /> se viene trovato il carattere; in caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero. Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <xref:System.String.Length%2A> - 1.  
  
 Questo metodo inizia la ricerca dalla posizione dell'ultimo carattere di questa istanza e continua all'indietro verso l'inizio fino a quando non `value` viene trovato o viene esaminata la posizione del primo carattere. La ricerca prevede la distinzione tra maiuscole e minuscole.  
  
 Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i relativi valori scalari Unicode sono uguali. Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 L'esempio seguente definisce un `ExtractFilename` metodo che utilizza il <xref:System.String.LastIndexOf%28System.Char%29> metodo per trovare l'ultimo carattere separatore di directory in una stringa e per estrarre il nome del file della stringa. Se il file esiste, il metodo restituisce il nome del file senza il relativo percorso.  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza di una stringa specificata all'interno di questa istanza.</summary>
        <returns>Posizione iniziale nell'indice in base zero di <paramref name="value" /> se viene trovata la stringa; in caso contrario, -1. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito è l'ultima posizione dell'indice in questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero. Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <xref:System.String.Length%2A> - 1.  
  
 La ricerca inizia in corrispondenza di questa istanza l'ultima posizione di carattere e continua all'indietro verso l'inizio fino a quando non `value` viene trovato o viene esaminata la posizione del primo carattere.  
  
 Questo metodo esegue una ricerca di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti.  
  
 I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura. In una ricerca dipendente dalle impostazioni cultura, se `value` contiene un carattere ignorabile, il risultato è equivalente alla ricerca con il carattere rimosso. Se `value` è composta solo da uno o più caratteri ignorabili, il <xref:System.String.LastIndexOf%28System.String%29> metodo restituisce sempre <xref:System.String.Length%2A?displayProperty=nameWithType> – 1, che rappresenta l'ultima posizione di indice nell'istanza corrente. Nell'esempio seguente, il <xref:System.String.LastIndexOf%28System.String%29> metodo viene utilizzato per individuare le sottostringhe di tre (un segno meno facoltativo (U + 00AD), un segno meno facoltativo seguito da "n" e un segno meno facoltativo seguito da "m") in due stringhe. Solo una delle stringhe contiene un segno meno facoltativo. Se viene eseguito l'esempio di [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o versioni successive, in ogni caso, poiché il segno meno facoltativo è un carattere ignorabile, il risultato è lo stesso come se il segno meno non era state incluse `value`. Quando si cerca solo un segno, il metodo restituisce 6 e 5. Questi valori corrispondono all'indice dell'ultimo carattere nelle due stringhe.  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 Nell'esempio seguente rimuove i tag HTML da una stringa, se i tag di iniziano e fine della stringa. Se una stringa termina con una chiusura parentesi (">"), nell'esempio viene utilizzato il <xref:System.String.LastIndexOf%2A> metodo per individuare l'inizio del tag di fine.  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Come spiegato in [Best Practices for Strings](~/docs/standard/base-types/best-practices-strings.md) utilizzando, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e in alternativa, chiamano metodi che richiedono parametri per essere specificato in modo esplicito. Per trovare l'ultimo indice di una sottostringa all'interno di un'istanza di stringa usando le regole di confronto delle impostazioni cultura correnti, chiamare il <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> overload del metodo con un valore di <see cref="F:System.StringComparison.CurrentCulture" /> per il relativo <paramref name="comparisonType" /> parametro.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Carattere Unicode da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca. La ricerca procede da <c>startIndex</c> verso l'inizio dell'istanza.</param>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza di un carattere Unicode specificato all'interno di questa istanza. La ricerca inizia in corrispondenza di una posizione di carattere specificata e continua all'indietro verso l'inizio della stringa.</summary>
        <returns>Posizione dell'indice in base zero di <paramref name="value" /> se tale carattere viene trovato oppure –1 se non viene trovato o se l'istanza corrente è uguale a <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero. Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <xref:System.String.Length%2A> -1. questo metodo inizia la ricerca di `startIndex` posizione di questa istanza e procede a ritroso verso l'inizio dell'istanza corrente fino al carattere `value` viene trovato o viene esaminata la posizione del primo carattere. Ad esempio, se `startIndex` è <xref:System.String.Length%2A> - 1, il metodo esegue ricerche in ogni carattere dall'ultimo carattere della stringa all'inizio. La ricerca prevede la distinzione tra maiuscole e minuscole.  
  
 Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i relativi valori scalari Unicode sono uguali. Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente trova l'indice di tutte le occorrenze di un carattere in una stringa, a partire dalla fine della stringa all'inizio della stringa.  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> è minore di zero oppure maggiore o uguale alla lunghezza di questa istanza.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca. La ricerca procede da <c>startIndex</c> verso l'inizio dell'istanza.</param>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza di una stringa specificata all'interno di questa istanza. La ricerca inizia in corrispondenza di una posizione di carattere specificata e continua all'indietro verso l'inizio della stringa.</summary>
        <returns>Posizione dell'indice iniziale in base zero di <paramref name="value" /> se tale stringa viene trovata oppure -1 se non viene trovata o se l'istanza corrente è uguale a <see cref="F:System.String.Empty" />. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito sarà il più piccolo tra <paramref name="startIndex" /> e l'ultima posizione dell'indice in questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero. Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <xref:System.String.Length%2A> - 1.  
  
 La ricerca inizia in corrispondenza di `startIndex` posizione di questa istanza e procede a ritroso verso l'inizio fino al carattere `value` viene trovato o viene esaminata la posizione del primo carattere. Ad esempio, se `startIndex` è <xref:System.String.Length%2A> - 1, il metodo esegue ricerche in ogni carattere dall'ultimo carattere della stringa all'inizio.  
  
 Questo metodo esegue una ricerca di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti.  
  
 I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura. In una ricerca dipendente dalle impostazioni cultura, se `value` contiene un carattere ignorabile, il risultato è equivalente alla ricerca con il carattere rimosso. Se `value` è composta solo da uno o più caratteri ignorabili, il <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> metodo restituisce sempre `startIndex`, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca. Nell'esempio seguente, il <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> metodo viene utilizzato per trovare una sottostringa che include un segno meno facoltativo (U + 00AD) e che precede o che include la "m" finale in una stringa. Se viene eseguito l'esempio di [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o versione successiva, perché viene ignorato il segno meno facoltativo nella stringa di ricerca, la chiamata al metodo per trovare una sottostringa che include il segno meno facoltativo e "m" restituisce la posizione di "m" nella stringa, mentre questo viene chiamato per trovare un substrin g che include il segno meno facoltativo e "n" restituisce la posizione di "n". Quando la stringa di ricerca contiene solo il segno, il metodo restituisce l'indice di "m", che rappresenta il valore di `startIndex`.  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 Nell'esempio seguente trova l'indice di tutte le occorrenze di una stringa nella stringa di destinazione, a partire dalla fine della stringa di destinazione fino all'inizio della stringa di destinazione.  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> è minore di zero oppure maggiore della lunghezza dell'istanza corrente.  oppure  L'istanza corrente è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> è minore di -1 o maggiore di zero.</exception>
        <block subset="none" type="usage">
          <para>Come spiegato in [Best Practices for Strings](~/docs/standard/base-types/best-practices-strings.md) utilizzando, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e in alternativa, chiamano metodi che richiedono parametri per essere specificato in modo esplicito. Per trovare l'indice di una sottostringa che precede una particolare posizione di carattere utilizzando le regole di confronto delle impostazioni cultura correnti, chiamare il <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> overload del metodo con un valore di <see cref="F:System.StringComparison.CurrentCulture" /> per il relativo <paramref name="comparisonType" /> parametro.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che specifica le regole di ricerca.</param>
        <summary>Restituisce l'indice in base zero dell'ultima occorrenza di una stringa specificata all'interno dell'oggetto <see cref="T:System.String" /> corrente. Un parametro specifica il tipo di ricerca da usare per la stringa specificata.</summary>
        <returns>Posizione iniziale dell'indice in base zero del parametro <paramref name="value" /> se tale stringa viene trovata; in caso contrario, -1. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito è l'ultima posizione dell'indice in questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero. Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <xref:System.String.Length%2A> - 1.  
  
 Il `comparisonType` parametro consente di ricercare il `value` parametro utilizzando le impostazioni cultura correnti o invarianti, usando una ricerca con distinzione maiuscole/minuscole o minuscole e utilizzando regole di confronto ordinale o word.  
  
 La ricerca inizia in corrispondenza di questa istanza l'ultima posizione di carattere e continua all'indietro verso l'inizio fino a quando non `value` viene trovato o viene esaminata la posizione del primo carattere.  
  
   
  
## Examples  
 Il seguente exampledemonstrates tre overload del <xref:System.String.LastIndexOf%2A> metodo trovare l'ultima occorrenza di una stringa all'interno di un'altra stringa utilizzando i diversi valori del <xref:System.StringComparison> enumerazione.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore valido di <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati quando si esegue un confronto linguistico o dipendente dalla lingua. In una ricerca dipendente dalle impostazioni cultura (ovvero se <paramref name="options" /> non è <see cref="F:System.StringComparison.Ordinal" /> o <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), se <paramref name="value" /> contiene un carattere ignorable, il risultato è equivalente alla ricerca con il carattere rimosso. Se <paramref name="value" /> costituito solo da uno o più caratteri ignorabili, il <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> metodo restituisce sempre <see cref="P:System.String.Length" /> – 1, che rappresenta l'ultima posizione dell'indice nell'istanza corrente.  Nell'esempio seguente, il <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> metodo viene utilizzato per individuare le sottostringhe di tre (un segno meno facoltativo (U + 00AD), un segno meno facoltativo seguito da "n" e un segno meno facoltativo seguito da "m") in due stringhe. Solo una delle stringhe contiene un segno meno facoltativo. Se viene eseguito l'esempio di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, poiché il segno meno facoltativo è un carattere ignorabile, una ricerca dipendente dalle impostazioni cultura restituisce lo stesso valore che il risultato restituito sarebbe se il segno meno non incluse nella stringa di ricerca. Una ricerca ordinale, tuttavia, correttamente individua il segno meno in un'unica stringa e segnala che è assente dalla seconda stringa.  [! codice csharp [System.String.LastIndexOf#26] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.LastIndexOf/cs/lastindexof26.cs#26)] [! codice vb [System.String.LastIndexOf#26] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.LastIndexOf/vb/lastindexof26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Carattere Unicode da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca. La ricerca procede da <c>startIndex</c> verso l'inizio dell'istanza.</param>
        <param name="count">Numero di posizioni dei caratteri da esaminare.</param>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza del carattere Unicode specificato in una sottostringa all'interno di questa istanza. La ricerca inizia in una posizione di carattere specificata e continua all'indietro verso l'inizio della stringa per un determinato numero di posizioni dei caratteri.</summary>
        <returns>Posizione dell'indice in base zero di <paramref name="value" /> se tale carattere viene trovato oppure –1 se non viene trovato o se l'istanza corrente è uguale a <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero. Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <xref:System.String.Length%2A> - 1.  
  
 Questo metodo inizia la ricerca di `startIndex` i caratteri di posizione e procede a ritroso verso l'inizio di questa istanza fino a quando non `value` viene trovato o `count` sono state esaminate le posizioni dei caratteri. Ad esempio, se `startIndex` è <xref:System.String.Length%2A> - 1, il metodo esegue la ricerca all'indietro `count` l'ultimo carattere nella stringa di caratteri. La ricerca prevede la distinzione tra maiuscole e minuscole.  
  
 Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i rispettivi valori scalari Unicode sono uguali. Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente trova l'indice di tutte le occorrenze di un carattere in una sottostringa, a partire dalla fine della sottostringa all'inizio della sottostringa.  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> è minore di zero oppure maggiore o uguale alla lunghezza di questa istanza.  oppure  L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> - <paramref name="count" /> + 1 è minore di zero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca. La ricerca procede da <c>startIndex</c> verso l'inizio dell'istanza.</param>
        <param name="count">Numero di posizioni dei caratteri da esaminare.</param>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza di una stringa specificata all'interno di questa istanza. La ricerca inizia in una posizione di carattere specificata e continua all'indietro verso l'inizio della stringa per un determinato numero di posizioni dei caratteri.</summary>
        <returns>Posizione dell'indice iniziale in base zero di <paramref name="value" /> se tale stringa viene trovata oppure -1 se non viene trovata o se l'istanza corrente è uguale a <see cref="F:System.String.Empty" />. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito sarà il più piccolo tra <paramref name="startIndex" /> e l'ultima posizione dell'indice in questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero. Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <xref:System.String.Length%2A> - 1.  
  
 La ricerca inizia in corrispondenza di `startIndex` posizione di questa istanza e procede a ritroso verso l'inizio fino al carattere `value` viene trovato o `count` sono state esaminate le posizioni dei caratteri. Ad esempio, se `startIndex` è <xref:System.String.Length%2A> - 1, il metodo esegue la ricerca all'indietro `count` l'ultimo carattere nella stringa di caratteri.  
  
 Questo metodo esegue una ricerca di word (maiuscole/minuscole e distinzione delle impostazioni cultura) usando le impostazioni cultura correnti.  
  
 I set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati durante l'esecuzione di un confronto linguistico o dipendente dalle impostazioni cultura. In una ricerca dipendente dalle impostazioni cultura, se `value` contiene un carattere ignorabile, il risultato è equivalente alla ricerca con il carattere rimosso. Se `value` è composta solo da uno o più caratteri ignorabili, il <xref:System.String.LastIndexOf%2A> metodo restituisce sempre `startIndex`, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca. Nell'esempio seguente, il <xref:System.String.LastIndexOf%2A> metodo viene utilizzato per trovare la posizione di un segno meno facoltativo (U + 00AD) nei due caratteri che precedono l'elemento finale "m" di due stringhe. Solo una delle stringhe contiene la sottostringa richiesta. Se viene eseguito l'esempio di [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] o in un secondo momento, in entrambi i casi, poiché il segno meno facoltativo è un carattere ignorabile, il metodo restituisce l'indice di "m" nella stringa quando viene eseguito un confronto con distinzione delle impostazioni cultura. Si noti che nel caso della prima stringa, che include il segno meno facoltativo seguito da una "m", il metodo non restituisce l'indice del segno meno facoltativo, ma l'indice di "m".  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 Nell'esempio seguente trova l'indice di tutte le occorrenze di una stringa in una sottostringa, a partire dalla fine della sottostringa all'inizio della sottostringa.  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è negativo.  oppure  L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> è negativo.  oppure  L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> è maggiore della lunghezza di questa istanza.  oppure  L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> - <paramref name="count" />+ 1 specifica una posizione non inclusa in questa istanza.  oppure  L'istanza corrente è uguale a <see cref="F:System.String.Empty" /> e <paramref name="start" /> è minore di -1 o maggiore di zero.  oppure  L'istanza corrente è uguale a <see cref="F:System.String.Empty" /> e <paramref name="count" /> è maggiore di 1.</exception>
        <block subset="none" type="usage">
          <para>Come spiegato in [Best Practices for Strings](~/docs/standard/base-types/best-practices-strings.md) utilizzando, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e in alternativa, chiamano metodi che richiedono parametri per essere specificato in modo esplicito. Per eseguire questa operazione utilizzando le regole di confronto delle impostazioni cultura correnti, chiamare il <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> overload del metodo con un valore di <see cref="F:System.StringComparison.CurrentCulture" /> per il relativo <paramref name="comparisonType" /> parametro.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca. La ricerca procede da <c>startIndex</c> verso l'inizio dell'istanza.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che specifica le regole di ricerca.</param>
        <summary>Restituisce l'indice in base zero dell'ultima occorrenza di una stringa specificata all'interno dell'oggetto <see cref="T:System.String" /> corrente. La ricerca inizia in corrispondenza di una posizione di carattere specificata e continua all'indietro verso l'inizio della stringa. Un parametro specifica il tipo di confronto da effettuare durante la ricerca della stringa specificata.</summary>
        <returns>Posizione dell'indice iniziale in base zero del parametro <paramref name="value" /> se tale stringa viene trovata oppure -1 se non viene trovata o se l'istanza corrente è uguale a <see cref="F:System.String.Empty" />. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito sarà il più piccolo tra <paramref name="startIndex" /> e l'ultima posizione dell'indice in questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero. Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <xref:System.String.Length%2A> - 1.  
  
 La ricerca inizia in corrispondenza di `startIndex` i caratteri di posizione e procede a ritroso fino a quando non `value` viene trovato o viene esaminata la posizione del primo carattere. Ad esempio, se `startIndex` è <xref:System.String.Length%2A> - 1, il metodo esegue ricerche in ogni carattere dall'ultimo carattere della stringa all'inizio.  
  
 Il `comparisonType` parametro consente di ricercare il `value` parametro utilizzando le impostazioni cultura correnti o invarianti, usando una ricerca con distinzione maiuscole/minuscole o minuscole e utilizzando regole di confronto ordinale o word.  
  
   
  
## Examples  
 Il seguente exampledemonstrates tre overload del <xref:System.String.LastIndexOf%2A> metodo trovare l'ultima occorrenza di una stringa all'interno di un'altra stringa utilizzando i diversi valori del <xref:System.StringComparison> enumerazione.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> è minore di zero oppure maggiore della lunghezza dell'istanza corrente.  oppure  L'istanza corrente è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> è minore di -1 o maggiore di zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore valido di <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati quando si esegue un confronto linguistico o dipendente dalla lingua. In una ricerca dipendente dalle impostazioni cultura (ovvero se <paramref name="comparisonType" /> non è <see cref="F:System.StringComparison.Ordinal" /> o <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), se <paramref name="value" /> contiene un carattere ignorable, il risultato è equivalente alla ricerca con il carattere rimosso. Se <paramref name="value" /> costituito solo da uno o più caratteri ignorabili, il <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> metodo restituisce sempre <paramref name="startIndex" />, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca.  Nell'esempio seguente, il <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> metodo viene utilizzato per trovare la posizione di un segno meno facoltativo (U + 00AD) seguita da una "m", a partire da finale "m" in due stringhe. Solo una delle stringhe contiene la sottostringa richiesta. Se viene eseguito l'esempio di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, in entrambi i casi, poiché il segno meno facoltativo è un carattere ignorabile, il metodo restituisce l'indice di "m" nella stringa di quando viene eseguito un confronto dipendente dalle impostazioni cultura. Si noti che nel caso della prima stringa, che include il segno meno facoltativo seguito da una "m", il metodo non restituisce l'indice del segno meno facoltativo, ma l'indice di "m". Il metodo restituisce l'indice del segno nella prima stringa solo quando si esegue un confronto ordinale.  [! codice csharp [System.String.LastIndexOf#25] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.LastIndexOf/cs/lastindexof25.cs#25)] [! codice vb [System.String.LastIndexOf#25] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.LastIndexOf/vb/lastindexof25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca. La ricerca procede da <c>startIndex</c> verso l'inizio dell'istanza.</param>
        <param name="count">Numero di posizioni dei caratteri da esaminare.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che specifica le regole di ricerca.</param>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza di una stringa specificata all'interno di questa istanza. La ricerca inizia in una posizione del carattere specificata e continua all'indietro verso l'inizio della stringa per il numero di posizioni dei caratteri indicato. Un parametro specifica il tipo di confronto da effettuare durante la ricerca della stringa specificata.</summary>
        <returns>Posizione dell'indice iniziale in base zero del parametro <paramref name="value" /> se tale stringa viene trovata oppure -1 se non viene trovata o se l'istanza corrente è uguale a <see cref="F:System.String.Empty" />. Se <paramref name="value" /> è <see cref="F:System.String.Empty" />, il valore restituito sarà il più piccolo tra <paramref name="startIndex" /> e l'ultima posizione dell'indice in questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero. Vale a dire il primo carattere nella stringa è in corrispondenza dell'indice zero e l'ultimo si trova in <xref:System.String.Length%2A> - 1.  
  
 La ricerca inizia in corrispondenza di `startIndex` i caratteri di posizione e procede a ritroso fino a quando non `value` viene trovato o `count` sono state esaminate le posizioni dei caratteri. Ad esempio, se `startIndex` è <xref:System.String.Length%2A> - 1, il metodo esegue la ricerca all'indietro `count` l'ultimo carattere nella stringa di caratteri.  
  
 Il `comparisonType` parametro consente di ricercare il `value` parametro utilizzando le impostazioni cultura correnti o invarianti, usando una ricerca con distinzione maiuscole/minuscole o minuscole e utilizzando regole di confronto ordinale o word.  
  
   
  
## Examples  
 Il seguente exampledemonstrates tre overload del <xref:System.String.LastIndexOf%2A> metodo trovare l'ultima occorrenza di una stringa all'interno di un'altra stringa utilizzando i diversi valori del <xref:System.StringComparison> enumerazione.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è negativo.  oppure  L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> è negativo.  oppure  L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> è maggiore della lunghezza di questa istanza.  oppure  L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> + 1 - <paramref name="count" /> specifica una posizione non inclusa in questa istanza.  oppure  L'istanza corrente è uguale a <see cref="F:System.String.Empty" /> e <paramref name="start" /> è minore di -1 o maggiore di zero.  oppure  L'istanza corrente è uguale a <see cref="F:System.String.Empty" /> e <paramref name="count" /> è maggiore di 1.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore valido di <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage">
          <para>Set di caratteri includono caratteri ignorabili, ovvero caratteri che non sono considerati quando si esegue un confronto linguistico o dipendente dalla lingua. In una ricerca dipendente dalle impostazioni cultura (ovvero se <paramref name="comparisonType" /> non è <see cref="F:System.StringComparison.Ordinal" /> o <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), se <paramref name="value" /> contiene un carattere ignorable, il risultato è equivalente alla ricerca con il carattere rimosso. Se <paramref name="value" /> costituito solo da uno o più caratteri ignorabili, il <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> metodo restituisce sempre <paramref name="startIndex" />, ovvero la posizione del carattere in corrispondenza del quale inizia la ricerca.  Nell'esempio seguente, il <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> metodo viene utilizzato per trovare la posizione di un segno meno facoltativo (U + 00AD) seguito da una "m" in tutti, ma la prima posizione di carattere prima finale "m" in due stringhe. Solo una delle stringhe contiene la sottostringa richiesta. Se viene eseguito l'esempio di [! INCLUDE[netfx40_short](~/Includes/netfx40-short-MD.MD)] o versione successiva, in entrambi i casi, poiché il segno meno facoltativo è un carattere ignorabile, il metodo restituisce l'indice di "m" nella stringa di quando viene eseguito un confronto dipendente dalle impostazioni cultura. Quando esegue un confronto ordinale, tuttavia, trova la sottostringa solo nella prima stringa. Si noti che nel caso della prima stringa, che include il segno meno facoltativo seguito da una "m", il metodo non restituisce l'indice del segno, ma l'indice di "m" quando si esegue un confronto con distinzione delle impostazioni cultura. Il metodo restituisce l'indice del segno nella prima stringa solo quando si esegue un confronto ordinale.  [! codice csharp [System.String.LastIndexOf#24] (~/samples/snippets/csharp/VS_Snippets_CLR_System/system. String.LastIndexOf/cs/lastindexof24.cs#24)] [! codice vb [System.String.LastIndexOf#24] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system. String.LastIndexOf/vb/lastindexof24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza in questa istanza di uno o più caratteri specificati in una matrice di caratteri Unicode. Il metodo restituisce -1 se i caratteri nella matrice non vengono trovati nell'istanza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Matrice di caratteri Unicode contenente uno o più caratteri da cercare.</param>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza in questa istanza di uno o più caratteri specificati in una matrice di caratteri Unicode.</summary>
        <returns>Posizione dell'indice dell'ultima occorrenza di questa istanza in cui è stato trovato un carattere in <paramref name="anyOf" />; -1 se non è stato trovato alcun carattere in <paramref name="anyOf" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero.  
  
 Questo metodo inizia la ricerca dalla posizione dell'ultimo carattere di questa istanza e continua all'indietro verso l'inizio fino a un carattere nel `anyOf` viene trovato o viene esaminata la posizione del primo carattere. La ricerca prevede la distinzione tra maiuscole e minuscole.  
  
 Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i relativi valori scalari Unicode sono uguali. Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente consente di trovare l'indice dell'ultima occorrenza di qualsiasi carattere nella stringa "is" all'interno di un'altra stringa.  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Matrice di caratteri Unicode contenente uno o più caratteri da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca. La ricerca procede da <c>startIndex</c> verso l'inizio dell'istanza.</param>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza in questa istanza di uno o più caratteri specificati in una matrice di caratteri Unicode. La ricerca inizia in corrispondenza di una posizione di carattere specificata e continua all'indietro verso l'inizio della stringa.</summary>
        <returns>Posizione dell'indice dell'ultima occorrenza di questa istanza in cui è stato trovato un carattere in <paramref name="anyOf" />; -1 se non è stato trovato alcun carattere in <paramref name="anyOf" /> oppure se l'istanza corrente è uguale a <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero.  
  
 Questo metodo inizia la ricerca di `startIndex` posizione di questa istanza e procede a ritroso verso l'inizio fino a un carattere nel carattere `anyOf` viene trovato o viene esaminata la posizione del primo carattere. La ricerca prevede la distinzione tra maiuscole e minuscole.  
  
 Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i relativi valori scalari Unicode sono uguali. Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente consente di trovare l'indice dell'ultima occorrenza di qualsiasi carattere nella stringa "is" all'interno di una sottostringa di un'altra stringa.  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> specifica una posizione non inclusa in questa istanza.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Matrice di caratteri Unicode contenente uno o più caratteri da cercare.</param>
        <param name="startIndex">Posizione iniziale della ricerca. La ricerca procede da <c>startIndex</c> verso l'inizio dell'istanza.</param>
        <param name="count">Numero di posizioni dei caratteri da esaminare.</param>
        <summary>Restituisce la posizione nell'indice in base zero dell'ultima occorrenza in questa istanza di uno o più caratteri specificati in una matrice di caratteri Unicode. La ricerca inizia in una posizione di carattere specificata e continua all'indietro verso l'inizio della stringa per un determinato numero di posizioni dei caratteri.</summary>
        <returns>Posizione dell'indice dell'ultima occorrenza di questa istanza in cui è stato trovato un carattere in <paramref name="anyOf" />; -1 se non è stato trovato alcun carattere in <paramref name="anyOf" /> oppure se l'istanza corrente è uguale a <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numerazione dell'indice inizia da zero.  
  
 Questo metodo inizia la ricerca di `startIndex` posizione di questa istanza e procede a ritroso verso l'inizio fino a un carattere nel carattere `anyOf` viene trovato o `count` sono state esaminate le posizioni dei caratteri. La ricerca prevede la distinzione tra maiuscole e minuscole.  
  
 Questo metodo esegue una ricerca ordinale (senza distinzione delle impostazioni cultura), in un carattere viene considerato equivalente a un altro carattere solo se i relativi valori scalari Unicode sono uguali. Per eseguire una ricerca con distinzione delle impostazioni cultura, utilizzare il <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> (metodo), in cui un valore scalare Unicode che rappresenta un carattere precomposto, ad esempio "æ" (U + 00 C 6), può essere considerato equivalente a qualsiasi occorrenza dei componenti del carattere di correggere sequenza, ad esempio "AE" (U + 0041, U + 0045), in base alle impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente viene trovato l'indice dell'ultima occorrenza di qualsiasi carattere della stringa "Aid" all'interno di una sottostringa di un'altra stringa.  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e <paramref name="count" /> o <paramref name="startIndex" /> è negativo.  oppure  L'istanza corrente non è uguale a <see cref="F:System.String.Empty" /> e il risultato dell'operazione <paramref name="startIndex" /> meno <paramref name="count" /> + 1 è minore di zero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di caratteri nell'oggetto <see cref="T:System.String" /> corrente.</summary>
        <value>Numero di caratteri nella stringa corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.Length%2A> proprietà restituisce il numero di <xref:System.Char> oggetti in questa istanza, non il numero di caratteri Unicode. Il motivo è che un carattere Unicode può essere rappresentato da più <xref:System.Char>. Utilizzare il <xref:System.Globalization.StringInfo?displayProperty=nameWithType> classe per funzionare con ogni carattere Unicode anziché ogni <xref:System.Char>.  
  
 In alcune lingue, ad esempio C e C++, un carattere null indica la fine di una stringa. In .NET Framework, un carattere null possono essere incorporato in una stringa. Quando una stringa include uno o più caratteri null, queste vengono incluse nella lunghezza della stringa totale. Ad esempio, nella stringa di seguito, le sottostringhe "abc" e "def" sono separati da un carattere null. Il <xref:System.String.Length%2A> proprietà restituisce 7, a indicare che include i sei caratteri alfabetici, nonché il carattere null.  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.Length%2A> proprietà.  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una nuova stringa la cui rappresentazione binaria è in un formato di normalizzazione Unicode specifico.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una nuova stringa il cui valore testuale è lo stesso di questa stringa ma la cui rappresentazione binaria è nel formato di normalizzazione Unicode C.</summary>
        <returns>Nuova stringa normalizzata il cui valore testuale è lo stesso di questa stringa ma la cui rappresentazione binaria è nel formato di normalizzazione Unicode C.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcuni caratteri Unicode hanno più rappresentazioni binarie equivalenti formate da set di combinazione e/o i caratteri Unicode composti. Uno dei punti di codice seguente, ad esempio, può rappresentare la lettera "ắ":  
  
-   U + 1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 L'esistenza di più rappresentazioni di un singolo carattere complica la ricerca, ordinamento, corrispondenza e altre operazioni.  
  
 Lo standard Unicode definisce un processo denominato normalizzazione che restituisce una rappresentazione binaria quando viene fornito qualsiasi rappresentazione binaria equivalente di un carattere. La normalizzazione può essere eseguita con diversi algoritmi, denominati normalizzazione, che sono conformi alle regole diverse. .NET Framework supporta quattro forme di normalizzazione (C, D, KC e KD) che sono definite dallo standard Unicode. Quando due stringhe sono rappresentate nello stesso formato di normalizzazione, theycan essere confrontati utilizzando il confronto ordinale.  
  
 Per normalizzare e confrontare due stringhe, eseguire le operazioni seguenti:  
  
1.  Ottenere le stringhe da confrontare da un'origine di input, ad esempio un file o un dispositivo di input dell'utente.  
  
2.  Chiamare il <xref:System.String.Normalize> metodo normalizzare le stringhe di formato di normalizzazione Unicode C.  
  
3.  Per confrontare due stringhe, chiamare un metodo che supporta il confronto ordinale tra stringhe, ad esempio il <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> (metodo), quindi specificare un valore di <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> o <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> come il <xref:System.StringComparison> argomento. Per ordinare una matrice di stringhe normalizzate, passare un `comparer` valore <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> o <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> a un overload appropriato del <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Generare le stringhe nell'output ordinato in base all'ordine indicato nel passaggio precedente.  
  
 Per una descrizione dei formati di normalizzazione Unicode, vedere <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente una stringa in ognuno dei quattro normalizzazione Normalizza, conferma che la stringa di formato di normalizzazione specificato e quindi vengono elencati i punti di codice nella stringa normalizzata.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'istanza corrente contiene caratteri Unicode non validi.</exception>
        <block subset="none" type="usage">
          <para>Il <see cref="Overload:System.String.IsNormalized" /> metodo <see langword="false" /> appena incontra il primo carattere non normalizzato in una stringa. Pertanto, se una stringa contiene caratteri non normalizzato seguiti da caratteri Unicode non validi, il <see cref="Overload:System.String.Normalize" /> metodo genererà un' <see cref="T:System.ArgumentException" /> Sebbene <see cref="Overload:System.String.IsNormalized" /> restituisce <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Formato di normalizzazione Unicode.</param>
        <summary>Restituisce una nuova stringa il cui valore testuale è lo stesso di questa stringa ma la cui rappresentazione binaria è nel formato di normalizzazione Unicode specificato.</summary>
        <returns>Nuova stringa il cui valore testuale è lo stesso di questa stringa ma la cui rappresentazione binaria è nel formato di normalizzazione specificato nel parametro <paramref name="normalizationForm" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcuni caratteri Unicode hanno più rappresentazioni binarie equivalenti formate da set di combinazione e/o i caratteri Unicode composti. L'esistenza di più rappresentazioni di un singolo carattere complica la ricerca, ordinamento, corrispondenza e altre operazioni.  
  
 Lo standard Unicode definisce un processo denominato normalizzazione che restituisce una rappresentazione binaria quando viene fornito qualsiasi rappresentazione binaria equivalente di un carattere. La normalizzazione può essere eseguita con diversi algoritmi, denominati normalizzazione, che sono conformi alle regole diverse. .NET Framework supporta quattro forme di normalizzazione (C, D, KC e KD) che sono definite dallo standard Unicode. Quando due stringhe sono rappresentate nel formato di normalizzazione stesso, gli possono essere confrontati utilizzando il confronto ordinale.  
  
 Per normalizzare e confrontare due stringhe, eseguire le operazioni seguenti:  
  
1.  Ottenere le stringhe da confrontare da un'origine di input, ad esempio un file o un dispositivo di input dell'utente.  
  
2.  Chiamare il <xref:System.String.Normalize%28System.Text.NormalizationForm%29> metodo normalizzare le stringhe in un formato di normalizzazione specificato.  
  
3.  Per confrontare due stringhe, chiamare un metodo che supporta il confronto ordinale tra stringhe, ad esempio il <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> (metodo), quindi specificare un valore di <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> o <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> come il <xref:System.StringComparison> argomento. Per ordinare una matrice di stringhe normalizzate, passare un `comparer` valore <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> o <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> a un overload appropriato del <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Generare le stringhe nell'output ordinato in base all'ordine indicato nel passaggio precedente.  
  
 Per una descrizione dei formati di normalizzazione Unicode, vedere <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente una stringa in ognuno dei quattro normalizzazione Normalizza, conferma che la stringa di formato di normalizzazione specificato e quindi vengono elencati i punti di codice nella stringa normalizzata.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'istanza corrente contiene caratteri Unicode non validi.</exception>
        <block subset="none" type="usage">
          <para>Il <see cref="Overload:System.String.IsNormalized" /> metodo <see langword="false" /> appena incontra il primo carattere non normalizzato in una stringa. Pertanto, se una stringa contiene caratteri non normalizzato seguiti da caratteri Unicode non validi, il <see cref="Overload:System.String.Normalize" /> metodo potrebbe generare un' <see cref="T:System.ArgumentException" /> Sebbene <see cref="Overload:System.String.IsNormalized" /> restituisce <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Prima stringa da confrontare o <see langword="null" />.</param>
        <param name="b">Seconda stringa da confrontare o <see langword="null" />.</param>
        <summary>Determina se due stringhe specificate hanno lo stesso valore.</summary>
        <returns>
          <see langword="true" /> se il valore di <paramref name="a" /> è uguale al valore di <paramref name="b" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.op_Equality%2A> metodo definisce il funzionamento dell'operatore di uguaglianza per il <xref:System.String> classe. Consente di codice, ad esempio illustrato nella sezione esempio. L'operatore, chiama a sua volta, il metodo statico <xref:System.String.Equals%28System.String%2CSystem.String%29> metodo, che esegue un confronto ordinale (maiuscole/minuscole e senza distinzione di impostazioni cultura).  
  
> [!NOTE]
>  Il compilatore Visual Basic non risolve l'operatore di uguaglianza come una chiamata al <xref:System.String.op_Equality%2A> metodo. L'operatore di uguaglianza esegue invece il wrapping di una chiamata al <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'operatore di uguaglianza.  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Prima stringa da confrontare o <see langword="null" />.</param>
        <param name="b">Seconda stringa da confrontare o <see langword="null" />.</param>
        <summary>Determina se due stringhe specificate hanno valori diversi.</summary>
        <returns>
          <see langword="true" /> se il valore del parametro <paramref name="a" /> è diverso dal valore del parametro <paramref name="b" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.op_Inequality%2A> metodo definisce il funzionamento dell'operatore di disuguaglianza per la <xref:System.String> classe.   Consente di codice, ad esempio illustrato nella sezione esempi.  
  
 Il <xref:System.String.op_Inequality%2A> operatore a sua volta chiama il metodo statico <xref:System.String.Equals%28System.String%2CSystem.String%29> metodo, che esegue un confronto ordinale (maiuscole/minuscole e senza distinzione di impostazioni cultura).  
  
> [!NOTE]
>  Il compilatore Visual Basic non risolve l'operatore di disuguaglianza come una chiamata al <xref:System.String.op_Inequality%2A> metodo. L'operatore di disuguaglianza esegue invece il wrapping di una chiamata al <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'operatore di disuguaglianza.  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una nuova stringa di lunghezza specificata in cui la parte iniziale della stringa corrente viene riempita con spazi o con un carattere Unicode specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Numero di caratteri nella stringa risultante che corrisponde alla somma del numero di caratteri originali e dei caratteri di riempimento aggiuntivi.</param>
        <summary>Restituisce una nuova stringa che allinea a destra i caratteri in questa istanza mediante l'aggiunta a sinistra di un numero di spazi tale da ottenere la lunghezza totale specificata.</summary>
        <returns>Nuova stringa equivalente a questa istanza, ma allineata a destra mediante l'aggiunta a sinistra di un numero di spazi tale da ottenere la lunghezza <paramref name="totalWidth" />. Tuttavia, se <paramref name="totalWidth" /> è minore della lunghezza di questa istanza, il metodo restituisce un riferimento all'istanza esistente. Se <paramref name="totalWidth" /> è uguale alla lunghezza di questa istanza, il metodo restituisce una nuova stringa identica a questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spazio Unicode è definito come 0x0020 esadecimale.  
  
 Il <xref:System.String.PadLeft%28System.Int32%29> metodo riempie l'inizio della stringa restituita. Ciò significa che, se utilizzato con le lingue da destra a sinistra, aggiunge la parte destra della stringa.  
  
> [!NOTE]
>  Se il <xref:System.String.PadLeft%2A> metodo aggiunge l'istanza corrente con spazi vuoti, questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa che viene riempita con spazi vuoti iniziali in modo che la lunghezza totale è `totalWidth` caratteri.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.PadLeft%2A> metodo.  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> è minore di zero.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Numero di caratteri nella stringa risultante che corrisponde alla somma del numero di caratteri originali e dei caratteri di riempimento aggiuntivi.</param>
        <param name="paddingChar">Carattere di riempimento Unicode.</param>
        <summary>Restituisce una nuova stringa che allinea a destra i caratteri in questa istanza mediante l'aggiunta a sinistra di una sequenza di elementi pari al carattere Unicode specificato, in modo da ottenere la lunghezza totale specificata.</summary>
        <returns>Nuova stringa equivalente a questa istanza, ma allineata a destra mediante l'aggiunta a sinistra di un numero di caratteri <paramref name="paddingChar" /> tale da ottenere la lunghezza <paramref name="totalWidth" />. Tuttavia, se <paramref name="totalWidth" /> è minore della lunghezza di questa istanza, il metodo restituisce un riferimento all'istanza esistente. Se <paramref name="totalWidth" /> è uguale alla lunghezza di questa istanza, il metodo restituisce una nuova stringa identica a questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> metodo riempie l'inizio della stringa restituita. Ciò significa che, se utilizzato con le lingue da destra a sinistra, aggiunge la parte destra della stringa.  
  
> [!NOTE]
>  Se il <xref:System.String.PadLeft%2A> metodo aggiunge l'istanza corrente con spazi vuoti, questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa che viene riempita con iniziali `paddingChar` caratteri in modo che la lunghezza totale è `totalWidth` caratteri.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.PadLeft%2A> metodo.  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> è minore di zero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una nuova stringa di lunghezza specificata in cui la parte finale della stringa corrente è riempita con spazi o con una sequenza di elementi pari a un carattere Unicode specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Numero di caratteri nella stringa risultante che corrisponde alla somma del numero di caratteri originali e dei caratteri di riempimento aggiuntivi.</param>
        <summary>Restituisce una nuova stringa che allinea a sinistra i caratteri in questa stringa mediante l'aggiunta a destra di un numero di spazi tale da ottenere la lunghezza totale specificata.</summary>
        <returns>Nuova stringa equivalente a questa istanza, ma allineata a sinistra mediante l'aggiunta a destra di un numero di spazi tale da ottenere la lunghezza <paramref name="totalWidth" />. Tuttavia, se <paramref name="totalWidth" /> è minore della lunghezza di questa istanza, il metodo restituisce un riferimento all'istanza esistente. Se <paramref name="totalWidth" /> è uguale alla lunghezza di questa istanza, il metodo restituisce una nuova stringa identica a questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Spazio Unicode è definito come 0x0020 esadecimale.  
  
 Il <xref:System.String.PadRight%28System.Int32%29> metodo riempie la fine della stringa restituita. Ciò significa che, se utilizzato con le lingue da destra a sinistra, aggiunge la parte sinistra della stringa.  
  
> [!NOTE]
>  Se il <xref:System.String.PadRight%2A> metodo aggiunge l'istanza corrente con spazi vuoti, questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa che viene riempita con spazi vuoti finali in modo che la lunghezza totale è `totalWidth` caratteri.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.PadRight%2A> metodo.  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> è minore di zero.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Numero di caratteri nella stringa risultante che corrisponde alla somma del numero di caratteri originali e dei caratteri di riempimento aggiuntivi.</param>
        <param name="paddingChar">Carattere di riempimento Unicode.</param>
        <summary>Restituisce una nuova stringa che allinea a sinistra i caratteri in questa stringa mediante l'aggiunta a destra di un carattere Unicode specificato, in modo da ottenere la lunghezza totale specificata.</summary>
        <returns>Nuova stringa equivalente a questa istanza, ma allineata a sinistra mediante l'aggiunta a destra di un numero di caratteri <paramref name="paddingChar" /> tale da ottenere la lunghezza <paramref name="totalWidth" />. Tuttavia, se <paramref name="totalWidth" /> è minore della lunghezza di questa istanza, il metodo restituisce un riferimento all'istanza esistente. Se <paramref name="totalWidth" /> è uguale alla lunghezza di questa istanza, il metodo restituisce una nuova stringa identica a questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> metodo riempie la fine della stringa restituita. Ciò significa che, se utilizzato con le lingue da destra a sinistra, aggiunge la parte sinistra della stringa.  
  
> [!NOTE]
>  Se il <xref:System.String.PadRight%2A> metodo aggiunge l'istanza corrente con spazi vuoti, questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa che viene riempita con finali `paddingChar` caratteri in modo che la lunghezza totale è `totalWidth` caratteri.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.PadRight%2A> metodo.  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> è minore di zero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una nuova stringa in cui dalla stringa corrente viene eliminato un numero specificato di caratteri.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Posizione in base zero da cui iniziare l'eliminazione dei caratteri.</param>
        <summary>Restituisce una nuova stringa in cui sono stati eliminati tutti i caratteri dell'istanza corrente a partire da una posizione specificata fino all'ultima posizione.</summary>
        <returns>Nuova stringa equivalente a questa stringa tranne che per i caratteri eliminati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nel [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], le stringhe sono in base zero. Il valore di `startIndex` parametro può essere compreso tra zero e uno minore della lunghezza dell'istanza di stringa.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa nella quale tutti i caratteri dalla posizione `startIndex` alla fine della stringa originale sono stati rimossi.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.Remove%2A> metodo. Nel caso di penultimo rimuove tutto il testo a partire dall'indice specificato fino alla fine della stringa. Nell'ultimo caso rimuove tre caratteri a partire dall'indice specificato.  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> è minore di zero.  oppure  <paramref name="startIndex" /> specifica una posizione esterna a questa stringa.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Posizione in base zero da cui iniziare l'eliminazione dei caratteri.</param>
        <param name="count">Numero di caratteri da eliminare.</param>
        <summary>Restituisce una nuova stringa in cui è stato eliminato un numero specificato di caratteri nell'istanza corrente a partire da una posizione specificata.</summary>
        <returns>Nuova stringa equivalente a questa istanza tranne che per i caratteri eliminati.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nel [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], le stringhe sono in base zero. Il valore di `startIndex` parametro può essere compreso tra zero e uno minore della lunghezza dell'istanza di stringa.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui il numero di caratteri specificato da di `count` parametro sono state rimosse. La rimozione di caratteri in corrispondenza della posizione specificata da `startIndex`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come è possibile rimuovere il secondo nome da un nome completo.  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> o <paramref name="count" /> è minore di zero.  oppure  La somma di <paramref name="startIndex" /> e <paramref name="count" /> specifica una posizione esterna a questa istanza.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una nuova stringa in cui tutte le occorrenze di un carattere Unicode o di un oggetto <see cref="T:System.String" /> specificati presenti nella stringa corrente vengono sostituite con un altro carattere Unicode o oggetto <see cref="T:System.String" /> specificati.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Carattere Unicode da sostituire.</param>
        <param name="newChar">Carattere Unicode con cui sostituire tutte le occorrenze di <c>oldChar</c>.</param>
        <summary>Restituisce una nuova stringa in cui tutte le occorrenze di un carattere Unicode specificato presenti in questa istanza vengono sostituite con un altro carattere Unicode specificato.</summary>
        <returns>Stringa equivalente a questa istanza, salvo per il fatto che tutte le istanze di <paramref name="oldChar" /> vengono sostituite con <paramref name="newChar" />. Se <paramref name="oldChar" /> non viene trovato nell'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo esegue una ricerca ordinale (maiuscole/minuscole e senza distinzione di impostazioni cultura) per trovare `oldChar`.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui tutte le occorrenze di `oldChar` vengono sostituiti da `newChar`.  
  
 Poiché questo metodo restituisce la stringa modificata, è possibile concatenare le chiamate successive al <xref:System.String.Replace%2A> metodo per eseguire più sostituzioni sulla stringa originale. Chiamate al metodo vengono eseguite da sinistra a destra. Nell'esempio seguente viene illustrato questo concetto.  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 L'esempio seguente crea un elenco di valori separati da virgole, sostituendo con virgole per gli spazi vuoti tra una serie di numeri.  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Stringa da sostituire.</param>
        <param name="newValue">Stringa con cui sostituire tutte le occorrenze di <c>oldValue</c>.</param>
        <summary>Restituisce una nuova stringa in cui tutte le occorrenze di una stringa specificata nell'istanza corrente vengono sostituite con un'altra stringa specificata.</summary>
        <returns>Stringa equivalente alla stringa corrente, salvo per il fatto che tutte le istanze di <paramref name="oldValue" /> vengono sostituite con <paramref name="newValue" />. Se <paramref name="oldValue" /> non viene trovato nell'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `newValue` è `null`, tutte le occorrenze di `oldValue` vengono rimossi.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui tutte le occorrenze di `oldValue` vengono sostituiti da `newValue`.  
  
 Questo metodo esegue una ricerca ordinale (maiuscole/minuscole e senza distinzione di impostazioni cultura) per trovare `oldValue`.  
  
 Poiché questo metodo restituisce la stringa modificata, è possibile concatenare le chiamate successive al <xref:System.String.Replace%2A> metodo per eseguire più sostituzioni sulla stringa originale. Chiamate al metodo vengono eseguite da sinistra a destra. Nell'esempio seguente viene illustrato questo concetto.  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.String.Replace%2A> metodo per correggere un errore di ortografia.  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" /> è la stringa vuota ("").</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una matrice di stringhe contenente le sottostringhe di questa istanza delimitate dagli elementi di una stringa o matrice di caratteri Unicode specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A> viene utilizzato per suddividere una stringa delimitata in sottostringhe. È possibile utilizzare una matrice di caratteri per specificare nessuno, uno o più caratteri di delimitazione (il <xref:System.String.Split%28System.Char%5B%5D%29> metodo), oppure è possibile utilizzare una matrice di caratteri per specificare zero, uno o più stringhe di delimitazione. Gli overload del <xref:System.String.Split%2A> metodo consente di limitare il numero di sottostringhe restituito dal metodo (il <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> (metodo)), per determinare se le stringhe vuote vengono inclusi nelle sottostringhe restituite (il <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> e <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> metodi, o entrambe le opzioni (il <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> e <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> metodi).  
  
> [!IMPORTANT]
>  Per ulteriori informazioni sul <xref:System.String.Split%2A> (metodo), come anche per esempi che chiamano ogni overload, vedere la documentazione per i singoli overload del <xref:System.String.Split%2A>.  
  
 Il <xref:System.String.Split%2A> metodo non è sempre il modo migliore per suddividere una stringa delimitata in sottostringhe. Se non si desidera estrarre le sottostringhe di una stringa delimitata, o se si desidera analizzare una stringa in base a un criterio anziché un set di caratteri di delimitazione, considerare le seguenti alternative.  
  
## <a name="regular-expressions"></a>Espressioni regolari  
 Se le stringhe conforme a un modello predefinito, è possibile utilizzare un'espressione regolare per estrarre e gestire i relativi elementi. Ad esempio, se le stringhe di assumono la forma "*numero* *operando* *numero*" è possibile utilizzare un [espressione regolare](~/docs/standard/base-types/regular-expressions.md) per estrarre e gestire il elementi della stringa. Di seguito è riportato un esempio:  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 Criterio di espressione regolare `(\d+)\s+([-+*/])\s+(\d+)` è definito come segue:  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`(\d+)`|Trova la corrispondenza con una o più cifre decimali. Equivale al primo gruppo di acquisizione.|  
|`\s+`|Corrisponde a uno o più spazi vuoti.|  
|`([-+*/])`|Corrisponde a un segno di operatori aritmetici (+, -, *, o /). Equivale al secondo gruppo di acquisizione.|  
|`\s+`|Corrisponde a uno o più spazi vuoti.|  
|`(\d+)`|Trova la corrispondenza con una o più cifre decimali. Equivale al terzo gruppo di acquisizione.|  
  
 È inoltre possibile utilizzare un'espressione regolare per estrarre le sottostringhe da una stringa basata su un modello, anziché un set fisso di caratteri. Si tratta di uno scenario comune quando una di queste condizioni si verifica:  
  
-   Uno o più i caratteri di delimitazione non sempre essere utilizzato come un delimitatore di <xref:System.String> istanza.  
  
-   La sequenza e il numero di caratteri di delimitazione è sconosciuto o variabile.  
  
 Ad esempio, il <xref:System.String.Split%2A> metodo non può essere utilizzato per suddividere la stringa seguente, perché il numero di `\n` (in c#) o `vbCrLf` (in Visual Basic) di caratteri è variabile, e vengono sempre non utilizzati come delimitatori.  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 Un'espressione regolare è possibile suddividere la stringa semplice, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 Criterio di espressione regolare `\[([^\[\]]+)\]` è definito come segue:  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\[`|Corrisponde a una parentesi di apertura.|  
|`([^\[\]]+)`|Corrisponde a qualsiasi carattere che non è una parentesi o una parentesi di chiusura una o più volte. Equivale al primo gruppo di acquisizione.|  
|`\]`|Corrisponde a una parentesi di chiusura.|  
  
 Il <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> è pressoché identico al metodo <xref:System.String.Split%2A?displayProperty=nameWithType>, ad eccezione del fatto che suddivide una stringa in base a un criterio di espressione regolare invece di un set di caratteri predefinito. Ad esempio, l'esempio seguente usa il <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> metodo per suddividere una stringa contenente le sottostringhe delimitate da varie combinazioni di trattini e altri caratteri.  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 Criterio di espressione regolare `\s-\s?[+*]?\s?-\s` è definito come segue:  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\s-`|Corrisponde a uno spazio vuoto seguito da un trattino.|  
|`\s?`|Trova la corrispondenza zero o uno spazio vuoto.|  
|`[+*]?`|Corrisponde a zero o una occorrenza di uno il + o * carattere.|  
|`\s?`|Trova la corrispondenza zero o uno spazio vuoto.|  
|`-\s`|Corrisponde a un trattino seguito da uno spazio vuoto.|  
  
## <a name="search-methods-and-the-substring-method"></a>Metodi di ricerca e il metodo Substring  
 Se non si è interessati in tutte le sottostringhe in una stringa, è preferibile usare uno dei metodi di confronto tra stringhe che restituisce l'indice in corrispondenza del quale inizia la corrispondenza. È quindi possibile chiamare il <xref:System.String.Substring%2A> metodo per estrarre la sottostringa che si desidera. I metodi di confronto di stringhe includono:  
  
-   <xref:System.String.IndexOf%2A>, che restituisce l'indice in base zero della prima occorrenza di un carattere o una stringa in un'istanza di stringa.  
  
-   <xref:System.String.IndexOfAny%2A>, che restituisce l'indice in base zero nell'istanza della stringa corrente della prima occorrenza di qualsiasi carattere presente in una matrice di caratteri.  
  
-   <xref:System.String.LastIndexOf%2A>, che restituisce l'indice in base zero dell'ultima occorrenza di un carattere o una stringa in un'istanza di stringa.  
  
-   <xref:System.String.LastIndexOfAny%2A>, che restituisce un indice in base zero nell'istanza corrente di stringa dell'ultima occorrenza di qualsiasi carattere presente in una matrice di caratteri.  
  
 L'esempio seguente usa il <xref:System.String.IndexOf%2A> metodo per individuare i periodi in una stringa. Viene quindi utilizzato il <xref:System.String.Substring%2A> per restituire frasi intere.  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Matrice di caratteri che delimita le sottostringhe di questa stringa, matrice vuota senza delimitatori o <see langword="null" />.</param>
        <summary>Suddivide una stringa in sottostringhe basate sui caratteri in una matrice.</summary>
        <returns>Matrice i cui elementi contengono le sottostringhe da questa istanza delimitate da uno o più caratteri in <paramref name="separator" />. Per altre informazioni, vedere la sezione Osservazioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando una stringa è delimitata da un set di caratteri noto, è possibile utilizzare il <xref:System.String.Split%28System.Char%5B%5D%29> metodo per separarlo in sottostringhe. Per altri modi per estrarre le sottostringhe da una stringa, vedere il [alternative a String. Split](#Alternatives) sezione.  
  
## <a name="return-value-details"></a>Dettagli sul valore restituito  
 Caratteri di delimitazione non sono inclusi gli elementi della matrice restituita. Ad esempio, se la matrice separatore include il carattere "-" e il valore dell'istanza della stringa corrente è "aa-bb-cc", il metodo restituisce una matrice che contiene tre elementi: "aa", "bb" e "cc".  
  
 Se questa istanza non contiene i caratteri in `separator`, la matrice restituita è costituito da un unico elemento che contiene questa istanza.  
  
 Ogni elemento di `separator` definisce un carattere di delimitazione separato. Se due delimitatori sono adiacenti o un delimitatore si trova all'inizio o alla fine di questa istanza, l'elemento corrispondente nella matrice restituita contiene <xref:System.String.Empty>. Ecco alcuni esempi:  
  
|Valore stringa|Separatore|Matrice restituita|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|nuovo Char [] {',', ' '} (c#)<br /><br /> Char () = {"," c "" c}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|nuovo Char [] {'. '} (C#)<br /><br /> Char () = {"." c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|"Banana"|nuovo Char [] {'. '} (C#)<br /><br /> Char () = {"." c} (Visual Basic)|{"Banana"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf "Smarba" (Visual Basic)|nuovo Char [] {} (c#)<br /><br /> Char () = {} (Visual Basic)|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf "Smarba" (Visual Basic)|null (C#)<br /><br /> Nothing (Visual Basic)|{"Darb", "Smarba"}|  
  
## <a name="the-separator-array"></a>La matrice separatore  
 Ogni elemento del separatore definisce un delimitatore separato costituito da un singolo carattere. Se il `separator` argomento `null` o non contiene caratteri, il metodo considera gli spazi vuoti come delimitatori. Gli spazi vuoti sono definiti da Unicode standard; restituiscono `true` se vengono passati il <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metodo.  
  
## <a name="stringsplitchar-and-compiler-overload-resolution"></a>Risoluzione dell'overload String.Split(Char[]) e compilatore  
 Anche se il singolo parametro per questo overload di <xref:System.String.Split%2A?displayProperty=nameWithType> è una matrice di caratteri, è possibile chiamare con un singolo carattere, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 Poiché il `separator` parametro è decorato con il <xref:System.ParamArrayAttribute> attributo, compilatori interpreterà un singolo carattere come una matrice di caratteri a singolo elemento. Questo non avviene per altri <xref:System.String.Split%2A?displayProperty=nameWithType> overload che includono un `separator` parametro; è necessario passare in modo esplicito questi overload una matrice di caratteri come il `separator` argomento.  
  
## <a name="comparison-details"></a>Dettagli di confronto  
 Il <xref:System.String.Split%28System.Char%5B%5D%29> metodo estrae le sottostringhe di questa stringa delimitate da uno o più dei caratteri di `separator` di matrice e restituisce tali sottostringhe come elementi di una matrice.  
  
 Il <xref:System.String.Split%28System.Char%5B%5D%29> metodo cerca i delimitatori eseguendo confronti utilizzando regole di ordinamento ordinali tra maiuscole e minuscole. Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere il <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumerazione.  
  
<a name="Alternatives"></a>   
## <a name="alternatives-to-stringsplit"></a>Alternative a String. Split  
 Il <xref:System.String.Split%2A> metodo non è sempre il modo migliore per suddividere una stringa delimitata in sottostringhe. Se non si desidera estrarre le sottostringhe di una stringa delimitata, o se si desidera analizzare una stringa in base a un criterio anziché un set di caratteri di delimitazione, considerare le seguenti alternative.  
  
### <a name="regular-expressions"></a>Espressioni regolari  
 Se le stringhe conforme a un modello predefinito, è possibile utilizzare un'espressione regolare per estrarre e gestire i relativi elementi. Ad esempio, se le stringhe di assumono la forma "*numero* *operando* *numero*" è possibile utilizzare un [espressione regolare](~/docs/standard/base-types/regular-expressions.md) per estrarre e gestire il elementi della stringa. Di seguito è riportato un esempio:  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 Criterio di espressione regolare `(\d+)\s+([-+*/])\s+(\d+)` è definito come segue:  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`(\d+)`|Trova la corrispondenza con una o più cifre decimali. Equivale al primo gruppo di acquisizione.|  
|`\s+`|Corrisponde a uno o più spazi vuoti.|  
|`([-+*/])`|Corrisponde a un segno di operatori aritmetici (+, -, *, o /). Equivale al secondo gruppo di acquisizione.|  
|`\s+`|Corrisponde a uno o più spazi vuoti.|  
|`(\d+)`|Trova la corrispondenza con una o più cifre decimali. Equivale al terzo gruppo di acquisizione.|  
  
 È inoltre possibile utilizzare un'espressione regolare per estrarre le sottostringhe da una stringa basata su un modello, anziché un set fisso di caratteri. Si tratta di uno scenario comune quando una di queste condizioni si verifica:  
  
-   Uno o più i caratteri di delimitazione non sempre essere utilizzato come un delimitatore di <xref:System.String> istanza.  
  
-   La sequenza e il numero di caratteri di delimitazione è sconosciuto o variabile.  
  
 Ad esempio, il <xref:System.String.Split%2A> metodo non può essere utilizzato per suddividere la stringa seguente, perché il numero di `\n` (in c#) o `vbCrLf` (in Visual Basic) di caratteri è variabile, e vengono sempre non utilizzati come delimitatori.  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 Un'espressione regolare è possibile suddividere la stringa semplice, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 Criterio di espressione regolare `\[([^\[\]]+)\]` è definito come segue:  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\[`|Corrisponde a una parentesi di apertura.|  
|`([^\[\]]+)`|Corrisponde a qualsiasi carattere che non è una parentesi o una parentesi di chiusura una o più volte. Equivale al primo gruppo di acquisizione.|  
|`\]`|Corrisponde a una parentesi di chiusura.|  
  
 Il <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> è pressoché identico al metodo <xref:System.String.Split%2A?displayProperty=nameWithType>, ad eccezione del fatto che suddivide una stringa in base a un criterio di espressione regolare invece di un set di caratteri predefinito. Ad esempio, l'esempio seguente usa il <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> metodo per suddividere una stringa contenente le sottostringhe delimitate da varie combinazioni di trattini e altri caratteri.  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 Criterio di espressione regolare `\s-\s?[+*]?\s?-\s` è definito come segue:  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\s-`|Corrisponde a uno spazio vuoto seguito da un trattino.|  
|`\s?`|Trova la corrispondenza zero o uno spazio vuoto.|  
|`[+*]?`|Corrisponde a zero o una occorrenza di uno il + o * carattere.|  
|`\s?`|Trova la corrispondenza zero o uno spazio vuoto.|  
|`-\s`|Corrisponde a un trattino seguito da uno spazio vuoto.|  
  
### <a name="search-methods-and-the-substring-method"></a>Metodi di ricerca e il metodo Substring  
 Se non si è interessati in tutte le sottostringhe in una stringa, è preferibile usare uno dei metodi di confronto tra stringhe che restituisce l'indice in corrispondenza del quale inizia la corrispondenza. È quindi possibile chiamare il <xref:System.String.Substring%2A> metodo per estrarre la sottostringa che si desidera. I metodi di confronto di stringhe includono:  
  
-   <xref:System.String.IndexOf%2A>, che restituisce l'indice in base zero della prima occorrenza di un carattere o una stringa in un'istanza di stringa.  
  
-   <xref:System.String.IndexOfAny%2A>, che restituisce l'indice in base zero nell'istanza della stringa corrente della prima occorrenza di qualsiasi carattere presente in una matrice di caratteri.  
  
-   <xref:System.String.LastIndexOf%2A>, che restituisce l'indice in base zero dell'ultima occorrenza di un carattere o una stringa in un'istanza di stringa.  
  
-   <xref:System.String.LastIndexOfAny%2A>, che restituisce un indice in base zero nell'istanza corrente di stringa dell'ultima occorrenza di qualsiasi carattere presente in una matrice di caratteri.  
  
 L'esempio seguente usa il <xref:System.String.IndexOf%2A> metodo per individuare i periodi in una stringa. Viene quindi utilizzato il <xref:System.String.Substring%2A> per restituire frasi intere.  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
## <a name="performance-considerations"></a>Considerazioni sulle prestazioni  
 Il <xref:System.String.Split%2A> metodi allocano memoria per l'oggetto matrice restituito e un <xref:System.String> oggetto per ogni elemento della matrice. Se l'applicazione richiede di ottenere prestazioni ottimali, o se la gestione dell'allocazione di memoria critico dell'applicazione, è possibile utilizzare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo. È inoltre la possibilità di usare il <xref:System.String.Compare%2A> metodo per individuare una sottostringa all'interno di una stringa.  
  
 Per suddividere una stringa in un carattere separatore, utilizzare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare un carattere di separazione della stringa. Per suddividere una stringa in una stringa di separazione, utilizzare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare il primo carattere della stringa di separazione. Utilizzare quindi la <xref:System.String.Compare%2A> metodo per determinare se i caratteri successivi al primo carattere sono uguali ai caratteri rimanenti della stringa di separazione.  
  
 Inoltre, se lo stesso set di caratteri viene utilizzato per suddividere in più stringhe <xref:System.String.Split%2A> chiamate al metodo, prendere in considerazione la creazione di una matrice e farvi riferimento in ogni chiamata al metodo. Questo riduce notevolmente l'overhead aggiuntivo di ogni chiamata al metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come estrarre singole parole da un blocco di testo trattando spazi e segni di punteggiatura come delimitatori. Passata la matrice di caratteri di `separator` parametro del <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> metodo è costituito da uno spazio e un carattere di tabulazione, con alcuni simboli di punteggiatura comuni.  
  
 [!code-csharp[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Nel [! INCLUDE[net_v35_short](~/Includes/NET-v35-short-MD.MD)] e le versioni precedenti, se il <see cref="M:System.String.Split(System.Char[])" /> viene passato un <paramref name="separator" /> vale a dire <see langword="null" /> o non contenga caratteri, il metodo utilizza un set di caratteri leggermente diverso per suddividere il stringa rispetto al <see cref="M:System.String.Trim(System.Char[])" /> metodo consente di tagliare la stringa. Nel [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)], entrambi i metodi utilizzano un set identico di spazi vuoti Unicode.</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Matrice di caratteri che delimita le sottostringhe di questa stringa, matrice vuota senza delimitatori o <see langword="null" />.</param>
        <param name="count">Numero massimo di sottostringhe da restituire.</param>
        <summary>Suddivide una stringa in un numero massimo di sottostringhe in base ai caratteri in una matrice. Numero massimo di sottostringhe da restituire.</summary>
        <returns>Matrice i cui elementi contengono le sottostringhe in questa istanza delimitate da uno o più caratteri in <paramref name="separator" />. Per altre informazioni, vedere la sezione Osservazioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caratteri di delimitazione non sono inclusi gli elementi della matrice restituita.  
  
 Se questa istanza non contiene i caratteri in `separator`, la matrice restituita è costituito da un unico elemento che contiene questa istanza. Se `count` è zero, viene restituita una matrice vuota.  
  
 Se il `separator` parametro `null` o non contiene caratteri, spazi vuoti vengono considerati come delimitatori. Gli spazi vuoti sono definiti dallo standard Unicode e restituito `true` se vengono passati il <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metodo.  
  
 Ogni elemento di `separator` definisce un carattere di delimitazione separato. Se due delimitatori sono adiacenti o un delimitatore si trova all'inizio o alla fine di questa istanza, l'elemento corrispondente della matrice contiene <xref:System.String.Empty>.  
  
 Se sono presenti più di `count` sottostringhe di questa istanza, il primo `count` -1 sottostringhe vengono restituiti nel primo `count` -1 elementi del valore restituito e i caratteri rimanenti in questa istanza, vengono restituiti nell'ultimo elemento del valore restituito.  
  
 Se `count` è maggiore del numero di sottostringhe, vengono restituite le sottostringhe disponibili e viene generata alcuna eccezione.  
  
 Nella tabella seguente vengono forniti esempi.  
  
|Valore stringa|Separatore|Conteggio|Matrice restituita|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|nuovo Char [] {',', ' '} (c#)<br /><br /> Char () = {"," c "" c} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|nuovo Char [] {'. '} (C#)<br /><br /> Char () = {"." c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|"Banana"|nuovo Char [] {'. '} (C#)<br /><br /> Char () = {"." c} (Visual Basic)|2|{"Banana"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf "Smarba" (Visual Basic)|nuovo Char [] {} (c#)<br /><br /> Char () = {} (Visual Basic)|1|{"Darb\nSmarba"} (C#)<br /><br /> "Darb" & vbLf "Smarba" (Visual Basic)|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf "Smarba" (Visual Basic)|nuovo Char [] null (c#)<br /><br /> Char () = Nothing|2|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf "Smarba" (Visual Basic)|nuovo Char [] null (c#)<br /><br /> Char () = Nothing|100|{"Darb", "Smarba"}|  
  
## <a name="performance-considerations"></a>Considerazioni sulle prestazioni  
 Il <xref:System.String.Split%2A> metodi allocano memoria per l'oggetto matrice restituito e un <xref:System.String> oggetto per ogni elemento della matrice. Se l'applicazione richiede di ottenere prestazioni ottimali, o se la gestione dell'allocazione di memoria critico dell'applicazione, è possibile utilizzare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> (metodo) e facoltativamente la <xref:System.String.Compare%2A> metodo, per individuare una sottostringa all'interno di una stringa.  
  
 Se si divide una stringa in un carattere separatore, utilizzare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare un carattere di separazione della stringa. Se si divide una stringa in una stringa di separazione, utilizzare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare il primo carattere della stringa di separazione. Utilizzare quindi la <xref:System.String.Compare%2A> metodo per determinare se i caratteri successivi al primo carattere sono uguali ai caratteri rimanenti della stringa di separazione.  
  
 Inoltre, se lo stesso set di caratteri viene utilizzato per suddividere in più stringhe <xref:System.String.Split%2A> chiamate al metodo, prendere in considerazione la creazione di una matrice e farvi riferimento in ogni chiamata al metodo. Questo riduce notevolmente l'overhead aggiuntivo di ogni chiamata al metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come `count` influisce sul numero di stringhe restituito dal <xref:System.String.Split%2A>.  
  
 [!code-csharp[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è negativo.</exception>
        <block subset="none" type="usage">
          <para>Nel [! INCLUDE[net_v35_short](~/Includes/NET-v35-short-MD.MD)] e le versioni precedenti, se il <see cref="M:System.String.Split(System.Char[])" /> viene passato un <paramref name="separator" /> vale a dire <see langword="null" /> o non contenga caratteri, il metodo utilizza un set di caratteri leggermente diverso per suddividere il stringa rispetto al <see cref="M:System.String.Trim(System.Char[])" /> metodo consente di tagliare la stringa. Nel [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)], entrambi i metodi utilizzano un set identico di spazi vuoti Unicode.</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Matrice di caratteri che delimita le sottostringhe di questa stringa, matrice vuota senza delimitatori o <see langword="null" />.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> per omettere gli elementi di matrice vuoti dalla matrice restituita; <see cref="F:System.StringSplitOptions.None" /> per includere tali elementi.</param>
        <summary>Suddivide una stringa in sottostringhe in base ai caratteri in una matrice. È possibile specificare se le sottostringhe includono elementi della matrice vuota.</summary>
        <returns>Matrice i cui elementi contengono le sottostringhe in questa stringa delimitate da uno o più caratteri in <paramref name="separator" />. Per altre informazioni, vedere la sezione Osservazioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a>Dettagli sul valore restituito  
 Caratteri di delimitazione (i caratteri di `separator` matrice) non sono inclusi gli elementi della matrice restituita. Ad esempio, se il `separator` matrice include il carattere "-" e il valore dell'istanza della stringa corrente è "aa-bb-cc", il metodo restituisce una matrice che contiene tre elementi: "aa", "bb" e "cc".  
  
 Se questa istanza non contiene i caratteri in `separator`, la matrice restituita è costituito da un unico elemento che contiene questa istanza.  
  
 Se il `options` parametro <xref:System.StringSplitOptions.RemoveEmptyEntries> e la lunghezza di questa istanza è uguale a zero, il metodo restituisce una matrice vuota.  
  
 Ogni elemento di `separator` definisce un delimitatore separato costituito da un singolo carattere. Se il `options` argomento <xref:System.StringSplitOptions.None>e due i delimitatori sono adiacenti o un delimitatore si trova all'inizio o alla fine di questa istanza, l'elemento corrispondente della matrice contiene <xref:System.String.Empty?displayProperty=nameWithType>. Ad esempio, se `separator` include due elementi, "-" e "\_", il valore dell'istanza di stringa è "-\_aa -\_" e il valore della `options` argomento è <xref:System.StringSplitOptions.None>, il metodo restituisce una matrice di stringhe i seguenti cinque elementi:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, che rappresenta una stringa vuota che precede il "-" carattere in corrispondenza dell'indice 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, che rappresenta la stringa vuota tra il "-" carattere in corrispondenza dell'indice 0 e il carattere "_" in corrispondenza dell'indice 1.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, che rappresenta la stringa vuota che segue il carattere "_" in corrispondenza dell'indice 4.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, che rappresenta la stringa vuota che segue il "-" carattere in corrispondenza dell'indice 5.  
  
## <a name="the-separator-array"></a>La matrice separatore  
 Se il `separator` parametro `null` o non contiene caratteri, spazi vuoti vengono considerati come delimitatori. Gli spazi vuoti sono definiti dallo standard Unicode e restituito `true` se vengono passati il <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metodo.  
  
 Se il `separator` parametro nella chiamata a questo overload del metodo è `null`, la risoluzione dell'overload del compilatore non riesce. Per identificare in modo univoco il metodo chiamato, il codice deve indicare il tipo di `null`. Nell'esempio seguente mostra i diversi modi per identificare in modo univoco questo overload.  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
## <a name="comparison-details"></a>Dettagli di confronto  
 Il <xref:System.String.Split%2A> metodo estrae le sottostringhe di questa stringa delimitate da uno o più dei caratteri di `separator` parametro e restituisce le sottostringhe come elementi di una matrice.  
  
 Il <xref:System.String.Split%2A> metodo cerca i delimitatori eseguendo confronti utilizzando regole di ordinamento ordinali tra maiuscole e minuscole. Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere il <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumerazione.  
  
## <a name="performance-considerations"></a>Considerazioni sulle prestazioni  
 Il <xref:System.String.Split%2A> metodi allocano memoria per l'oggetto matrice restituito e un <xref:System.String> oggetto per ogni elemento della matrice. Se l'applicazione richiede di ottenere prestazioni ottimali, o se la gestione dell'allocazione di memoria critico dell'applicazione, è possibile utilizzare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> (metodo) e facoltativamente la <xref:System.String.Compare%2A> metodo, per individuare una sottostringa all'interno di una stringa.  
  
 Se si divide una stringa in un carattere separatore, utilizzare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare un carattere di separazione della stringa. Se si divide una stringa in una stringa di separazione, utilizzare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare il primo carattere della stringa di separazione. Utilizzare quindi la <xref:System.String.Compare%2A> metodo per determinare se i caratteri successivi al primo carattere sono uguali ai caratteri rimanenti della stringa di separazione.  
  
 Inoltre, se lo stesso set di caratteri viene utilizzato per suddividere in più stringhe <xref:System.String.Split%2A> chiamate al metodo, prendere in considerazione la creazione di una matrice e farvi riferimento in ogni chiamata al metodo. Questo riduce notevolmente l'overhead aggiuntivo di ogni chiamata al metodo.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.StringSplitOptions> enumerazione per includere o escludere le sottostringhe generate dal <xref:System.String.Split%2A> metodo.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> non è uno dei valori di <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Nel [! INCLUDE[net_v35_short](~/Includes/NET-v35-short-MD.MD)] e le versioni precedenti, se il <see cref="M:System.String.Split(System.Char[])" /> viene passato un <paramref name="separator" /> vale a dire <see langword="null" /> o non contenga caratteri, il metodo utilizza un set di caratteri leggermente diverso per suddividere il stringa rispetto al <see cref="M:System.String.Trim(System.Char[])" /> metodo consente di tagliare la stringa. Nel [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)], entrambi i metodi utilizzano un set identico di spazi vuoti Unicode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Matrice di stringhe che delimita le sottostringhe di questa stringa, matrice vuota senza delimitatori o <see langword="null" />.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> per omettere gli elementi di matrice vuoti dalla matrice restituita; <see cref="F:System.StringSplitOptions.None" /> per includere tali elementi.</param>
        <summary>Suddivide una stringa in sottostringhe in base alle stringhe in una matrice. È possibile specificare se le sottostringhe includono elementi della matrice vuota.</summary>
        <returns>Matrice i cui elementi contengono le sottostringhe in questa stringa delimitate da una o più stringhe indicate in <paramref name="separator" />. Per altre informazioni, vedere la sezione Osservazioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando una stringa è delimitata da un set noto di stringhe, è possibile utilizzare il <xref:System.String.Split%2A> metodo per separarlo in sottostringhe.  
  
## <a name="return-value-details"></a>Dettagli sul valore restituito  
 Le stringhe di delimitazione non sono inclusi gli elementi della matrice restituita. Ad esempio, se il `separator` matrice include la stringa "-" e il valore dell'istanza della stringa corrente è "aa - bb-cc", il metodo restituisce una matrice che contiene tre elementi: "aa", "bb" e "cc".  
  
 Se questa istanza non contiene una delle stringhe in `separator`, la matrice restituita è costituito da un unico elemento che contiene questa istanza.  
  
 Se il `options` parametro <xref:System.StringSplitOptions.RemoveEmptyEntries> e la lunghezza di questa istanza è uguale a zero, il metodo restituisce una matrice vuota.  
  
 Ogni elemento di `separator` definisce un delimitatore separato costituito da uno o più caratteri. Se il `options` argomento <xref:System.StringSplitOptions.None>e due i delimitatori sono adiacenti o un delimitatore si trova all'inizio o alla fine di questa istanza, l'elemento corrispondente della matrice contiene <xref:System.String.Empty?displayProperty=nameWithType>. Ad esempio, se `separator` include due elementi, "-" e "_", il valore dell'istanza di stringa è "- _aa -\_" e il valore della `options` argomento <xref:System.StringSplitOptions.None>, il metodo restituisce una matrice di stringa con i seguenti cinque elementi:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, che rappresenta una stringa vuota che precede il "-" sottostringa in corrispondenza dell'indice 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, che rappresenta la stringa vuota tra il "-" sottostringa in corrispondenza dell'indice 0 e la sottostringa "_" in corrispondenza dell'indice 1.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, che rappresenta la stringa vuota che segue la sottostringa "_" in corrispondenza dell'indice 4.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, che rappresenta la stringa vuota che segue il "-" sottostringa in corrispondenza dell'indice 5.  
  
## <a name="the-separator-array"></a>La matrice separatore  
 Se uno degli elementi in `separator` costituito da più caratteri, la sottostringa intera viene considerata un delimitatore. Ad esempio, se uno degli elementi in `separator` è "10", il tentativo di suddividere la stringa "This10is10a10string". Restituisce la matrice di quattro elementi seguente: {"This", "is", "a", "string". }.  
  
 Se il `separator` parametro `null` o non contiene caratteri, spazi vuoti vengono considerati come delimitatori. Gli spazi vuoti sono definiti dallo standard Unicode e restituito `true` se vengono passati il <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metodo.  
  
 Se il `separator` parametro nella chiamata a questo overload del metodo è `null`, la risoluzione dell'overload del compilatore non riesce. Per identificare in modo univoco il metodo chiamato, il codice deve indicare il tipo di `null`. Nell'esempio seguente mostra i diversi modi per identificare in modo univoco questo overload.  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
## <a name="comparison-details"></a>Dettagli di confronto  
 Il <xref:System.String.Split%2A> metodo estrae le sottostringhe di questa stringa delimitate da uno o più delle stringhe di `separator` parametro e restituisce le sottostringhe come elementi di una matrice.  
  
 Il <xref:System.String.Split%2A> metodo cerca i delimitatori eseguendo confronti utilizzando regole di ordinamento ordinali tra maiuscole e minuscole. Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere il <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumerazione.  
  
 Il <xref:System.String.Split%2A> metodo ignora qualsiasi elemento di `separator` il cui valore è `null` o una stringa vuota ("").  
  
 Per evitare risultati ambigui quando le stringhe nel `separator` hanno in comune, i caratteri di <xref:System.String.Split%2A> operazione procede dall'inizio alla fine del valore dell'istanza e corrisponde al primo elemento `separator` che è uguale a un delimitatore nel istanza. L'ordine in cui le sottostringhe sono rilevate nell'istanza ha la precedenza sull'ordine degli elementi in `separator`.  
  
 Si consideri ad esempio un'istanza il cui valore è "abcdef". Se il primo elemento in `separator` è "ef" e il secondo elemento è stato "bcde", il risultato dell'operazione di divisione sarà una matrice di stringhe che contiene due elementi, "a" e "f". In questo modo la sottostringa nell'istanza, "bcde", viene rilevata e corrisponde a un elemento in `separator` prima che venga rilevata la sottostringa "f".  
  
 Tuttavia, se il primo elemento della `separator` è "bcd" e il secondo elemento è "bc", il risultato dell'operazione di divisione sarà una matrice di stringhe che contiene due elementi, "a" e "ef". Perché "bcd" è il primo delimitatore del `separator` che corrisponde a un delimitatore nell'istanza. Se il primo elemento è "bc" è stato annullato. l'ordine dei separatori e il secondo elemento è stato "bcd", il risultato sarebbe una matrice di stringhe che contiene due elementi, "a" e "def".  
  
## <a name="performance-considerations"></a>Considerazioni sulle prestazioni  
 Il <xref:System.String.Split%2A> metodi allocano memoria per l'oggetto matrice restituito e un <xref:System.String> oggetto per ogni elemento della matrice. Se l'applicazione richiede di ottenere prestazioni ottimali, o se la gestione dell'allocazione di memoria critico dell'applicazione, è possibile utilizzare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> (metodo) e facoltativamente la <xref:System.String.Compare%2A> metodo, per individuare una sottostringa all'interno di una stringa.  
  
 Se si divide una stringa in un carattere separatore, utilizzare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare un carattere di separazione della stringa. Se si divide una stringa in una stringa di separazione, utilizzare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare il primo carattere della stringa di separazione. Utilizzare quindi la <xref:System.String.Compare%2A> metodo per determinare se i caratteri successivi al primo carattere sono uguali ai caratteri rimanenti della stringa di separazione.  
  
 Inoltre, se lo stesso set di caratteri viene utilizzato per suddividere in più stringhe <xref:System.String.Split%2A> chiamate al metodo, prendere in considerazione la creazione di una matrice e farvi riferimento in ogni chiamata al metodo. Questo riduce notevolmente l'overhead aggiuntivo di ogni chiamata al metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrata la differenza matrici restituite chiamando una stringa <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> metodo con il relativo `options` uguale al parametro <xref:System.StringSplitOptions.None?displayProperty=nameWithType> e <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.  
  
 [!code-csharp[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 L'esempio seguente definisce una matrice di separatori che includono la punteggiatura e caratteri di spazio vuoto. Il passaggio di questa matrice insieme a un valore di <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> per il <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> metodo restituisce una matrice costituita da singole parole dalla stringa.  
  
 [!code-csharp[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 Si noti che il metodo viene chiamato con il `options` argomento impostato su <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>. Ciò impedisce la matrice restituita inclusi <xref:System.String.Empty?displayProperty=nameWithType> valori che rappresentano le corrispondenze tra segni di punteggiatura e caratteri di spazio vuoto sottostringa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> non è uno dei valori di <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Nel [! INCLUDE[net_v35_short](~/Includes/NET-v35-short-MD.MD)] e le versioni precedenti, se il <see cref="M:System.String.Split(System.Char[])" /> viene passato un <paramref name="separator" /> vale a dire <see langword="null" /> o non contenga caratteri, il metodo utilizza un set di caratteri leggermente diverso per suddividere il stringa rispetto al <see cref="M:System.String.Trim(System.Char[])" /> metodo consente di tagliare la stringa. Nel [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)], entrambi i metodi utilizzano un set identico di spazi vuoti Unicode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Matrice di caratteri che delimita le sottostringhe di questa stringa, matrice vuota senza delimitatori o <see langword="null" />.</param>
        <param name="count">Numero massimo di sottostringhe da restituire.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> per omettere gli elementi di matrice vuoti dalla matrice restituita; <see cref="F:System.StringSplitOptions.None" /> per includere tali elementi.</param>
        <summary>Suddivide una stringa in un numero massimo di sottostringhe in base ai caratteri in una matrice.</summary>
        <returns>Matrice i cui elementi contengono le sottostringhe in questa stringa delimitate da uno o più caratteri in <paramref name="separator" />. Per altre informazioni, vedere la sezione Osservazioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caratteri di delimitazione non sono inclusi gli elementi della matrice restituita.  
  
 Se questa istanza non contiene i caratteri in `separator`, o `count` parametro è 1, la matrice restituita è costituita da un unico elemento che contiene questa istanza. Se il `separator` parametro `null` o non contiene caratteri, spazi vuoti vengono considerati come delimitatori. Gli spazi vuoti sono definiti dallo standard Unicode e restituito `true` se vengono passati il <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metodo. Tuttavia, se il `separator` parametro nella chiamata a questo overload del metodo è `null`, la risoluzione dell'overload del compilatore non riesce. Per identificare in modo univoco il metodo chiamato, il codice deve indicare il tipo di null. Nell'esempio seguente mostra i diversi modi per identificare in modo univoco questo overload.  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 Se il `count` parametro è uguale a zero, o `options` parametro <xref:System.StringSplitOptions.RemoveEmptyEntries> e la lunghezza di questa istanza è uguale a zero, viene restituita una matrice vuota.  
  
 Ogni elemento di `separator` definisce un carattere di delimitazione separato. Se il `options` parametro <xref:System.StringSplitOptions.None>e due i delimitatori sono adiacenti o un delimitatore si trova all'inizio o alla fine di questa istanza, l'elemento corrispondente della matrice contiene <xref:System.String.Empty>.  
  
 Se sono presenti più di `count` sottostringhe di questa istanza, il primo `count` -1 sottostringhe vengono restituiti nel primo `count` -1 elementi del valore restituito e i caratteri rimanenti in questa istanza, vengono restituiti nell'ultimo elemento del valore restituito.  
  
 Se `count` è maggiore del numero di sottostringhe, vengono restituite le sottostringhe disponibili e viene generata alcuna eccezione.  
  
## <a name="performance-considerations"></a>Considerazioni sulle prestazioni  
 Il <xref:System.String.Split%2A> metodi allocano memoria per l'oggetto matrice restituito e un <xref:System.String> oggetto per ogni elemento della matrice. Se l'applicazione richiede di ottenere prestazioni ottimali, o se la gestione dell'allocazione di memoria critico dell'applicazione, è possibile utilizzare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> (metodo) e facoltativamente la <xref:System.String.Compare%2A> metodo, per individuare una sottostringa all'interno di una stringa.  
  
 Se si divide una stringa in un carattere separatore, utilizzare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare un carattere di separazione della stringa. Se si divide una stringa in una stringa di separazione, utilizzare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare il primo carattere della stringa di separazione. Utilizzare quindi la <xref:System.String.Compare%2A> metodo per determinare se i caratteri successivi al primo carattere sono uguali ai caratteri rimanenti della stringa di separazione.  
  
 Inoltre, se lo stesso set di caratteri viene utilizzato per suddividere in più stringhe <xref:System.String.Split%2A> chiamate al metodo, prendere in considerazione la creazione di una matrice e farvi riferimento in ogni chiamata al metodo. Questo riduce notevolmente l'overhead aggiuntivo di ogni chiamata al metodo.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.StringSplitOptions> enumerazione per includere o escludere le sottostringhe generate dal <xref:System.String.Split%2A> metodo.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> non è uno dei valori di <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Nel [! INCLUDE[net_v35_short](~/Includes/NET-v35-short-MD.MD)] e le versioni precedenti, se il <see cref="M:System.String.Split(System.Char[])" /> viene passato un <paramref name="separator" /> vale a dire <see langword="null" /> o non contenga caratteri, il metodo utilizza un set di caratteri leggermente diverso per suddividere il stringa rispetto al <see cref="M:System.String.Trim(System.Char[])" /> metodo consente di tagliare la stringa. Nel [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)], entrambi i metodi utilizzano un set identico di spazi vuoti Unicode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Matrice di stringhe che delimita le sottostringhe di questa stringa, matrice vuota senza delimitatori o <see langword="null" />.</param>
        <param name="count">Numero massimo di sottostringhe da restituire.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> per omettere gli elementi di matrice vuoti dalla matrice restituita; <see cref="F:System.StringSplitOptions.None" /> per includere tali elementi.</param>
        <summary>Suddivide una stringa in un numero massimo di sottostringhe in base alle stringe in una matrice. È possibile specificare se le sottostringhe includono elementi della matrice vuota.</summary>
        <returns>Matrice i cui elementi contengono le sottostringhe in questa stringa delimitate da una o più stringhe indicate in <paramref name="separator" />. Per altre informazioni, vedere la sezione Osservazioni.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a>Dettagli sul valore restituito  
 Le stringhe di delimitazione non sono inclusi gli elementi della matrice restituita.  
  
 Se questa istanza non contiene una delle stringhe in `separator`, o `count` parametro è 1, la matrice restituita è costituita da un unico elemento che contiene questa istanza. Se il `separator` parametro `null` o non contiene caratteri, spazi vuoti vengono considerati come delimitatori. Gli spazi vuoti sono definiti dallo standard Unicode e restituito `true` se vengono passati il <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metodo. Tuttavia, se il `separator` parametro nella chiamata a questo overload del metodo è `null`, la risoluzione dell'overload del compilatore non riesce. Per identificare in modo univoco il metodo chiamato, il codice deve indicare il tipo di `null`. Nell'esempio seguente mostra i diversi modi per identificare in modo univoco questo overload.  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 Se il `count` parametro è uguale a zero, o `options` parametro <xref:System.StringSplitOptions.RemoveEmptyEntries> e la lunghezza di questa istanza è uguale a zero, viene restituita una matrice vuota.  
  
 Ogni elemento di `separator` definisce un delimitatore separato costituito da uno o più caratteri. Se il `options` parametro <xref:System.StringSplitOptions.None>e due i delimitatori sono adiacenti o un delimitatore si trova all'inizio o alla fine di questa istanza, l'elemento corrispondente della matrice contiene <xref:System.String.Empty>.  
  
 Se sono presenti più di `count` sottostringhe di questa istanza, il primo `count` -1 sottostringhe vengono restituiti nel primo `count` -1 elementi del valore restituito e i caratteri rimanenti in questa istanza, vengono restituiti nell'ultimo elemento del valore restituito.  
  
 Se `count` è maggiore del numero di sottostringhe, vengono restituite le sottostringhe disponibili e viene generata alcuna eccezione.  
  
## <a name="the-separator-array"></a>La matrice separatore  
 Se uno degli elementi in `separator` costituito da più caratteri, la sottostringa intera viene considerata un delimitatore. Ad esempio, se uno degli elementi in `separator` è "10", il tentativo di suddividere la stringa "This10is10a10string". Restituisce la matrice di quattro elementi: {"This", "is", "a", "string". }.  
  
## <a name="comparison-details"></a>Dettagli di confronto  
 Il <xref:System.String.Split%2A> metodo estrae le sottostringhe di questa stringa delimitate da uno o più delle stringhe di `separator` parametro e restituisce le sottostringhe come elementi di una matrice.  
  
 Il <xref:System.String.Split%2A> metodo cerca i delimitatori eseguendo confronti utilizzando regole di ordinamento ordinali tra maiuscole e minuscole. Per ulteriori informazioni sulla parola, stringa e ordinale ordinamenti, vedere il <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumerazione.  
  
 Il <xref:System.String.Split%2A> metodo ignora qualsiasi elemento di `separator` il cui valore è `null` o una stringa vuota ("").  
  
 Per evitare risultati ambigui quando le stringhe nel `separator` hanno in comune, i caratteri di <xref:System.String.Split%2A> procede dall'inizio alla fine del valore dell'istanza del metodo e corrisponde al primo elemento `separator` che è uguale a un delimitatore nel istanza. L'ordine in cui le sottostringhe sono rilevate nell'istanza ha la precedenza sull'ordine degli elementi in `separator`.  
  
 Si consideri ad esempio un'istanza il cui valore è "abcdef". Se il primo elemento in `separator` è "ef" e il secondo elemento è stato "bcde", il risultato dell'operazione di divisione sarà "a" e "f". In questo modo la sottostringa nell'istanza, "bcde", viene rilevata e corrisponde a un elemento in `separator` prima che venga rilevata la sottostringa "f".  
  
 Tuttavia, se il primo elemento della `separator` è "bcd" e il secondo elemento è "bc", il risultato dell'operazione di divisione sarà "a" e "ef". Perché "bcd" è il primo delimitatore del `separator` che corrisponde a un delimitatore nell'istanza. Se il primo elemento è "bc" è stato annullato. l'ordine dei separatori e il secondo elemento è stato "bcd", il risultato sarebbe "a" e "def".  
  
## <a name="performance-considerations"></a>Considerazioni sulle prestazioni  
 Il <xref:System.String.Split%2A> metodi allocano memoria per l'oggetto matrice restituito e un <xref:System.String> oggetto per ogni elemento della matrice. Se l'applicazione richiede di ottenere prestazioni ottimali, o se la gestione dell'allocazione di memoria critico dell'applicazione, è possibile utilizzare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> (metodo) e facoltativamente la <xref:System.String.Compare%2A> metodo, per individuare una sottostringa all'interno di una stringa.  
  
 Se si divide una stringa in un carattere separatore, utilizzare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare un carattere di separazione della stringa. Se si divide una stringa in una stringa di separazione, utilizzare il <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOfAny%2A> metodo per individuare il primo carattere della stringa di separazione. Utilizzare quindi la <xref:System.String.Compare%2A> metodo per determinare se i caratteri successivi al primo carattere sono uguali ai caratteri rimanenti della stringa di separazione.  
  
 Inoltre, se lo stesso set di caratteri viene utilizzato per suddividere in più stringhe <xref:System.String.Split%2A> chiamate al metodo, prendere in considerazione la creazione di una matrice e farvi riferimento in ogni chiamata al metodo. Questo riduce notevolmente l'overhead aggiuntivo di ogni chiamata al metodo.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.StringSplitOptions> enumerazione per includere o escludere le sottostringhe generate dal <xref:System.String.Split%2A> metodo.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> è negativo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> non è uno dei valori di <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Nel [! INCLUDE[net_v35_short](~/Includes/NET-v35-short-MD.MD)] e le versioni precedenti, se il <see cref="M:System.String.Split(System.Char[])" /> viene passato un <paramref name="separator" /> vale a dire <see langword="null" /> o non contenga caratteri, il metodo utilizza un set di caratteri leggermente diverso per suddividere il stringa rispetto al <see cref="M:System.String.Trim(System.Char[])" /> metodo consente di tagliare la stringa. Nel [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)], entrambi i metodi utilizzano un set identico di spazi vuoti Unicode.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se l'inizio di questa istanza di stringa corrisponde a una stringa specificata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da confrontare.</param>
        <summary>Determina se l'inizio di questa istanza di stringa corrisponde alla stringa specificata.</summary>
        <returns>
          <see langword="true" /> se l'inizio di questa stringa corrisponde al parametro <paramref name="value" />; in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo confronta `value` con la sottostringa all'inizio di questa istanza è uguale alla lunghezza `value`e restituisce un'indicazione se sono uguali. Per essere uguali, `value` deve essere una stringa vuota (<xref:System.String.Empty?displayProperty=nameWithType>), deve essere un riferimento alla stessa istanza o deve corrispondere all'inizio di questa istanza.  
  
 Questo metodo esegue un confronto per parola (maiuscole/minuscole e distinzione delle impostazioni cultura) utilizzando le impostazioni cultura correnti.  
  
   
  
## Examples  
 L'esempio seguente definisce un `StripStartTags` metodo che utilizza il <xref:System.String.StartsWith%28System.String%29> tag di inizio del metodo per rimuovere HTML dall'inizio di una stringa. Si noti che il `StripStartTags` metodo viene chiamato in modo ricorsivo per garantire che vengano rimossi più tag di inizio HTML all'inizio della riga. L'esempio non rimuove i tag HTML incorporati in una stringa.  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Come spiegato in [Best Practices for Strings](~/docs/standard/base-types/best-practices-strings.md) utilizzando, è consigliabile evitare di chiamare i metodi di confronto tra stringhe che sostituiscono i valori predefiniti e in alternativa, chiamano metodi che richiedono parametri per essere specificato in modo esplicito. Per determinare se una stringa inizia con una particolare sottostringa utilizzando le regole di confronto delle impostazioni cultura correnti, chiamare il <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> overload del metodo con un valore di <see cref="F:System.StringComparison.CurrentCulture" /> per il relativo <paramref name="comparisonType" /> parametro.</para>
        </block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da confrontare.</param>
        <param name="comparisonType">Uno dei valori di enumerazione che determina la modalità di confronto tra questa stringa e <c>value</c>.</param>
        <summary>Determina se l'inizio di questa istanza di stringa corrisponde alla stringa specificata se confrontata usando l'opzione di confronto specificata.</summary>
        <returns>
          <see langword="true" /> se l'istanza inizia con <paramref name="value" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.StartsWith%2A> metodo confronta il `value` parametro con la sottostringa all'inizio di questa stringa e restituisce un valore che indica se sono uguali. Per essere uguali, `value` deve essere un riferimento a questa stessa stringa, deve essere una stringa vuota (""), o deve corrispondere all'inizio di questa stringa. Il tipo di confronto eseguito dal <xref:System.String.StartsWith%2A> metodo dipende dal valore del `comparisonType` parametro. Il confronto è possibile utilizzare le convenzioni delle impostazioni cultura correnti (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> e <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) o le impostazioni cultura invarianti (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> e <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>), o può essere costituito da un confronto carattere per carattere dei punti di codice (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> o <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>). Il confronto può anche essere distinzione maiuscole/minuscole (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, o <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), o ignorarla (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).  
  
   
  
## Examples  
 Nell'esempio seguente viene cercata la stringa "the" all'inizio di una stringa più lunga che inizia con la parola "The". Come illustrato nell'esempio, una chiamata a dall'output di <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> metodo che esegue un confronto tra maiuscole e minuscole, ma indipendenti dalle impostazioni cultura non riesce a trovare la stringa, mentre una chiamata che esegue un confronto delle impostazioni cultura e case insensitive corrisponde alla stringa.  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 Nell'esempio seguente determina se una stringa inizia con una particolare sottostringa. Inizializza una matrice di stringhe bidimensionale. Il primo elemento della seconda dimensione contiene una stringa e il secondo elemento contiene la stringa di ricerca all'inizio della prima stringa. I risultati sono interessati dalla scelta di impostazioni cultura, se è ignorare maiuscole/minuscole e se viene eseguito un confronto ordinale. Si noti che quando l'istanza di stringa contiene un alfabeto, i confronti dipendenti dalle impostazioni cultura con relativi caratteri consecutivi corrispondano correttamente.  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> non è un valore di <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da confrontare.</param>
        <param name="ignoreCase">
          <see langword="true" /> per ignorare la distinzione tra maiuscole e minuscole durante il confronto; in caso contrario, <see langword="false" />.</param>
        <param name="culture">Informazioni relative alle impostazioni cultura che determinano le modalità di confronto tra questa stringa e <c>value</c>. Se <c>culture</c> è <see langword="null" />, verranno usate le impostazioni cultura correnti.</param>
        <summary>Determina se l'inizio di questa istanza di stringa corrisponde alla stringa specificata se confrontata mediante le impostazioni cultura specificate.</summary>
        <returns>
          <see langword="true" /> se il parametro <paramref name="value" /> corrisponde all'inizio di questa stringa; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente di confrontare il `value` parametro con la sottostringa all'inizio di questa stringa che rappresenta la stessa lunghezza `value`e restituisce un valore che indica se sono uguali. Per essere uguali, `value` deve essere una stringa vuota (<xref:System.String.Empty?displayProperty=nameWithType>), deve essere un riferimento alla stessa istanza o deve corrispondere all'inizio di questa istanza.  
  
 Questo metodo esegue un confronto usando le maiuscole e minuscole specificata e le impostazioni cultura.  
  
   
  
## Examples  
 Nell'esempio seguente determina se una stringa si verifica all'inizio di un'altra stringa. Il <xref:System.String.StartsWith%2A> metodo viene chiamato più volte con distinzione maiuscole/minuscole, maiuscole e minuscole e diverse impostazioni cultura che determinano i risultati della ricerca.  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera una sottostringa da questa istanza.  Si tratta di un membro di overload. Per informazioni complete su questo membro, inclusi la sintassi, l'uso e gli esempi, fare clic su un nome nell'elenco degli overload.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Posizione iniziale in base zero del carattere di una sottostringa in questa istanza.</param>
        <summary>Recupera una sottostringa da questa istanza. La sottostringa inizia in corrispondenza di un carattere specificato e continua fino alla fine della stringa.</summary>
        <returns>Stringa equivalente alla sottostringa che inizia in corrispondenza di <paramref name="startIndex" /> in questa istanza oppure <see cref="F:System.String.Empty" /> se <paramref name="startIndex" /> è uguale alla lunghezza di questa istanza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il <xref:System.String.Substring%2A> metodo per estrarre una sottostringa da una stringa che inizia alla posizione del carattere specificato e termina alla fine della stringa. La posizione iniziale del carattere è un'in base zero. in altre parole, il primo carattere nella stringa è in corrispondenza dell'indice 0, non di indice 1. Per estrarre una sottostringa che inizia alla posizione del carattere specificato e termina prima alla fine della stringa, chiamare il <xref:System.String.Substring%2A> metodo.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa che inizia in corrispondenza di `startIndex` posizione nella stringa corrente.  
  
 Per estrarre una sottostringa che inizia con un determinato carattere o sequenza di caratteri, chiamare un metodo, ad esempio <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOf%2A> per ottenere il valore di `startIndex`. Il secondo esempio viene illustrato questo oggetto. estrae un valore di chiave che inizia una posizione di carattere dopo il carattere "=".  
  
 Se `startIndex` è uguale a zero, il metodo restituisce la stringa originale invariata.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come ottenere una sottostringa da una stringa.  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 L'esempio seguente usa il <xref:System.String.Substring%2A> (metodo) per separare le coppie chiave/valore delimitate da è uguale a un carattere ("=").  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 Il <xref:System.String.IndexOf%2A> metodo viene utilizzato per ottenere la posizione del carattere è uguale a nella stringa. La chiamata ai <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metodo estrae il nome della chiave, che inizia dal primo carattere nella stringa di e si estende per il numero di caratteri restituito dalla chiamata al <xref:System.String.IndexOf%2A> metodo. La chiamata al <xref:System.String.Substring%28System.Int32%29> metodo quindi estrae il valore assegnato alla chiave. Una posizione di carattere oltre il carattere di uguale e alla fine della stringa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> è minore di zero o maggiore della lunghezza di questa istanza.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Posizione iniziale in base zero del carattere di una sottostringa in questa istanza.</param>
        <param name="length">Numero di caratteri nella sottostringa.</param>
        <summary>Recupera una sottostringa da questa istanza. La sottostringa inizia in corrispondenza della posizione del carattere specificata e ha la lunghezza specificata.</summary>
        <returns>Stringa equivalente alla sottostringa di lunghezza <paramref name="length" /> che inizia in corrispondenza di <paramref name="startIndex" /> in questa istanza oppure <see cref="F:System.String.Empty" /> se <paramref name="startIndex" /> è uguale alla lunghezza di questa istanza e <paramref name="length" /> è zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metodo per estrarre una sottostringa da una stringa che inizia alla posizione del carattere specificato e termina prima della fine della stringa. La posizione iniziale del carattere è un'in base zero. in altre parole, il primo carattere nella stringa è in corrispondenza dell'indice 0, non di indice 1. Per estrarre una sottostringa che inizia alla posizione del carattere specificata e continua fino alla fine della stringa, chiamare il <xref:System.String.Substring%28System.Int32%29> metodo.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa con `length` caratteri a partire dal `startIndex` posizione nella stringa corrente.  
  
 Il `length` parametro rappresenta il numero totale di caratteri da estrarre dall'istanza di stringa corrente. Ciò include il carattere iniziale nell'indice `startIndex`.  In altre parole, il <xref:System.String.Substring%2A> metodo tenta di estrarre i caratteri dall'indice `startIndex` all'indice `startIndex`  +  `length` - 1.  
  
 Per estrarre una sottostringa che inizia con un determinato carattere o sequenza di caratteri, chiamare un metodo, ad esempio <xref:System.String.IndexOf%2A> o <xref:System.String.LastIndexOf%2A> per ottenere il valore di `startIndex`.  
  
 Se si estende la sottostringa da `startIndex` una sequenza di caratteri specificato, è possibile chiamare un metodo, ad esempio <xref:System.String.IndexOf%2A> o <xref:System.String.LastIndexOf%2A> per ottenere l'indice del carattere finale o sequenza di caratteri.  È possibile convertire tale valore in una posizione di indice nella stringa come indicato di seguito:  
  
-   Se è cercato un singolo carattere che deve contrassegnare la fine della sottostringa, il `length` parametro è uguale a `endIndex`  -  `startIndex` + 1, dove `endIndex` è il valore restituito del <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOf%2A> metodo. Nell'esempio seguente estrae un blocco continuo di caratteri "b" da una stringa.  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   Se è cercato di più caratteri per contrassegnare la fine della sottostringa, il `length` parametro è uguale a `endIndex`  +  `endMatchLength`  -  `startIndex`, dove `endIndex` è il valore restituito di <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOf%2A> metodo. e `endMatchLength` è la lunghezza della sequenza di caratteri che contrassegna la fine della sottostringa. L'esempio seguente estrae un blocco di testo che contiene un file XML `<definition>` elemento.  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   Se non è incluso il carattere o sequenza di caratteri alla fine della sottostringa, il `length` parametro è uguale a `endIndex`  -  `startIndex`, dove `endIndex` è il valore restituito del <xref:System.String.IndexOf%2A> o <xref:System.String.IndexOf%2A> metodo.  
  
 Se `startIndex` è uguale a zero e uguale la lunghezza della stringa corrente, il metodo restituisce la stringa originale senza modificata.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrata una semplice chiamata al <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metodo che estrae i due caratteri da una stringa a partire dalla sesta posizione di carattere (ovvero, in corrispondenza dell'indice 5).  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 L'esempio seguente usa il <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metodo nei tre casi seguenti per isolare le sottostringhe in una stringa. Nei due casi vengono utilizzate le sottostringhe nei confronti e nel terzo caso viene generata un'eccezione perché sono stati specificati parametri non validi.  
  
-   Estrae il singolo carattere e la terza posizione nella stringa (corrispondenza dell'indice 2) e lo confronta con "c". Questo confronto restituisce `true`.  
  
-   Estrae zero caratteri a partire dalla posizione del quarto presenti nella stringa (in corrispondenza dell'indice 3) e lo passa al <xref:System.String.IsNullOrEmpty%2A> metodo. Restituisce true perché la chiamata al <xref:System.String.Substring%2A> restituisce <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Tenta di estrarre un carattere a partire dalla posizione nella stringa di quarto. Poiché non è presente alcun carattere in tale posizione, la chiamata al metodo genera un <xref:System.ArgumentOutOfRangeException> eccezione.  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 L'esempio seguente usa il <xref:System.String.Substring%2A> (metodo) per separare le coppie chiave/valore delimitate da è uguale a un carattere ("=").  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 Il <xref:System.String.IndexOf%2A> metodo viene utilizzato per ottenere la posizione del carattere è uguale a nella stringa. La chiamata ai <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> metodo estrae il nome della chiave, che inizia dal primo carattere nella stringa di e si estende per il numero di caratteri restituito dalla chiamata al <xref:System.String.IndexOf%2A> metodo. La chiamata al <xref:System.String.Substring%28System.Int32%29> metodo quindi estrae il valore assegnato alla chiave. Una posizione di carattere oltre il carattere di uguale e alla fine della stringa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La somma di <paramref name="startIndex" /> e <paramref name="length" /> indica una posizione non all'interno di questa istanza.  oppure  <paramref name="startIndex" /> o <paramref name="length" /> è minore di zero.</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che esegue l'iterazione dell'oggetto <see cref="T:System.String" /> corrente.</summary>
        <returns>Enumeratore fortemente tipizzato che può essere usato per eseguire l'iterazione nell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. E può essere utilizzato solo quando il <xref:System.String> esegue il cast dell'istanza di un <xref:System.Collections.Generic.IEnumerable%601> oggetto di interfaccia. Per altre informazioni, vedere il metodo <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un enumeratore che esegue l'iterazione dell'oggetto <see cref="T:System.String" /> corrente.</summary>
        <returns>Enumeratore utilizzabile per eseguire l'iterazione degli elementi della stringa corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.Collections.IEnumerable>. Per altre informazioni, vedere il metodo <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Questo parametro viene ignorato.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" /> se il valore della stringa corrente è <see cref="F:System.Boolean.TrueString" />; <see langword="false" /> se il valore della stringa corrente è <see cref="F:System.Boolean.FalseString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Il valore della stringa corrente non è <see cref="F:System.Boolean.TrueString" /> o <see cref="F:System.Boolean.FalseString" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Non è possibile analizzare il valore dell'oggetto <see cref="T:System.String" /> corrente.</exception>
        <exception cref="T:System.OverflowException">Il valore dell'oggetto <see cref="T:System.String" /> corrente è un numero maggiore di <see cref="F:System.Byte.MaxValue" /> o minore di <see cref="F:System.Byte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>Carattere in corrispondenza dell'indice 0 nell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Non è possibile analizzare il valore dell'oggetto <see cref="T:System.String" /> corrente.</exception>
        <exception cref="T:System.OverflowException">Il valore dell'oggetto <see cref="T:System.String" /> corrente è un numero minore di <see cref="F:System.Decimal.MinValue" /> o maggiore di <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Non è possibile analizzare il valore dell'oggetto <see cref="T:System.String" /> corrente.</exception>
        <exception cref="T:System.OverflowException">Il valore dell'oggetto <see cref="T:System.String" /> corrente è un numero minore di <see cref="F:System.Double.MinValue" /> o maggiore di <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Non è possibile analizzare il valore dell'oggetto <see cref="T:System.String" /> corrente.</exception>
        <exception cref="T:System.OverflowException">Il valore dell'oggetto <see cref="T:System.String" /> corrente è un numero maggiore di <see cref="F:System.Int16.MaxValue" /> o minore di <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Non è possibile analizzare il valore dell'oggetto <see cref="T:System.String" /> corrente.</exception>
        <exception cref="T:System.OverflowException">Il valore dell'oggetto <see cref="T:System.String" /> corrente è un numero maggiore di <see cref="F:System.SByte.MaxValue" /> o minore di <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Tipo dell'oggetto restituito.</param>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ChangeType%2A> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Non è possibile convertire il valore dell'oggetto <see cref="T:System.String" /> corrente nel tipo specificato dal parametro <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Non è possibile analizzare il valore dell'oggetto <see cref="T:System.String" /> corrente.</exception>
        <exception cref="T:System.OverflowException">Il valore dell'oggetto <see cref="T:System.String" /> corrente è un numero maggiore di <see cref="F:System.UInt16.MaxValue" /> o minore di <see cref="F:System.UInt16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Non è possibile analizzare il valore dell'oggetto <see cref="T:System.String" /> corrente.</exception>
        <exception cref="T:System.OverflowException">Il valore dell'oggetto <see cref="T:System.String" /> corrente è un numero maggiore di  <see cref="F:System.UInt32.MaxValue" /> o minore di <see cref="F:System.UInt32.MinValue" /></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Per una descrizione di questo membro, vedere <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Valore convertito dell'oggetto <see cref="T:System.String" /> corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo membro è un’implementazione esplicita di un membro di interfaccia. Può essere utilizzato solo quando si esegue il cast dell'istanza <xref:System.String> a un'interfaccia <xref:System.IConvertible>. L'alternativa consigliata consiste nel chiamare il <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia i caratteri di questa istanza in una matrice di caratteri Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia i caratteri di questa istanza in una matrice di caratteri Unicode.</summary>
        <returns>Matrice di caratteri Unicode i cui elementi sono i singoli caratteri di questa istanza. Se l'istanza è una stringa vuota, la matrice restituita sarà vuota e di lunghezza zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo copia ogni carattere (ovvero, ogni <xref:System.Char> oggetto) in una stringa in una matrice di caratteri. È il primo carattere copiato in corrispondenza dell'indice zero della matrice di caratteri restituiti; è l'ultimo carattere copiato in corrispondenza dell'indice <xref:System.Array.Length%2A?displayProperty=nameWithType> – 1.  
  
 Per creare una stringa di caratteri in una matrice di caratteri, chiamare il <xref:System.String.%23ctor%28System.Char%5B%5D%29> costruttore.  
  
 Per creare una matrice di byte che contiene i caratteri codificati in una stringa, creare un'istanza appropriata <xref:System.Text.Encoding> oggetto e chiamare il relativo <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> metodo. Alcune delle codifiche standard disponibili in .NET Framework includono quanto segue:  
  
|Codifica|Object|  
|--------------|------------|  
|non|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Per ulteriori informazioni, vedere [codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.String.ToCharArray%2A> metodo per estrarre i caratteri in una stringa in una matrice di caratteri. Visualizza quindi la stringa originale e gli elementi nella matrice.  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 L'esempio seguente definisce una stringa contenente i caratteri utilizzati come delimitatori di una stringa delimitata. Chiama quindi il <xref:System.String.ToCharArray%2A> metodo per creare una matrice di caratteri che può essere passata al <xref:System.String.Split%28System.Char%5B%5D%29> metodo per suddividere la stringa delimitata in relative sottostringhe singoli.  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Posizione iniziale di una sottostringa in questa istanza.</param>
        <param name="length">Lunghezza della sottostringa in questa istanza.</param>
        <summary>Copia i caratteri di una determinata sottostringa di questa istanza in una matrice di caratteri Unicode.</summary>
        <returns>Matrice di caratteri Unicode i cui elementi sono il numero <paramref name="length" /> di caratteri di questa istanza a partire dalla posizione <paramref name="startIndex" /> del carattere.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo copia i caratteri in una parte di una stringa in una matrice di caratteri. Per creare una stringa di un intervallo di caratteri in una matrice di caratteri, chiamare il <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> costruttore.  
  
 Il `startIndex` in base zero. Ovvero, l'indice del primo carattere nell'istanza della stringa è zero.  
  
 Se `length` è zero, la matrice restituita è vuota e ha una lunghezza zero. Se questa istanza è `null` o una stringa vuota (""), la matrice restituita è vuota e ha una lunghezza zero.  
  
 Per creare una matrice di byte che contiene i caratteri codificati in una parte di una stringa, creare un'istanza appropriata <xref:System.Text.Encoding> oggetto e chiamare il relativo <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> metodo. Alcune delle codifiche standard disponibili in .NET Framework includono quanto segue:  
  
|Codifica|Object|  
|--------------|------------|  
|non|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Per ulteriori informazioni, vedere [codifica dei caratteri in .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Nell'esempio seguente converte una sottostringa all'interno di una stringa in una matrice di caratteri, quindi enumera e visualizza gli elementi della matrice.  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> o <paramref name="length" /> è minore di zero.  oppure  La somma di <paramref name="startIndex" /> e <paramref name="length" /> è maggiore della lunghezza di questa istanza.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una copia di questa stringa convertita in caratteri minuscoli.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una copia di questa stringa convertita in caratteri minuscoli.</summary>
        <returns>Stringa di caratteri minuscoli.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo prende in considerazione le regole di maiuscole e minuscole delle impostazioni cultura correnti.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui tutti i caratteri nell'istanza corrente vengono convertiti in minuscolo.  
  
## <a name="security-considerations"></a>Considerazioni sulla sicurezza  
 L'operazione di maiuscole e minuscole risultante dalla chiamata di <xref:System.String.ToLower> metodo considerando le convenzioni delle impostazioni cultura correnti. Se è necessaria la versione maiuscola o minuscola di un identificatore di sistema operativo, ad esempio un nome file, named pipe o una chiave del Registro di sistema, utilizzare il <xref:System.String.ToLowerInvariant%2A> o <xref:System.String.ToUpperInvariant%2A> metodi. Ciò produce lo stesso risultato in tutte le impostazioni cultura (a differenza di <xref:System.String.ToLower> metodo) ed esegue in modo più efficiente.  
  
   
  
## Examples  
 Nell'esempio seguente converte misti di alcune stringhe in caratteri minuscoli.  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Come spiegato in [Best Practices for Strings](~/docs/standard/base-types/best-practices-strings.md) utilizzando, è consigliabile evitare di chiamare metodi di maiuscole e minuscole delle stringhe che sostituiscono i valori predefiniti e in alternativa, chiamano metodi che richiedono parametri per essere specificato in modo esplicito. Per convertire un carattere in minuscolo utilizzando le convenzioni delle impostazioni cultura correnti, chiamare il <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> overload del metodo con un valore di <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> per il relativo <paramref name="culture" /> parametro.</para>
        </block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Oggetto che fornisce le regole specifiche delle impostazioni cultura sull'uso di maiuscole e minuscole.</param>
        <summary>Restituisce una copia di questa stringa convertita in caratteri minuscoli, usando le regole relative all'utilizzo di maiuscole e minuscole proprie delle impostazioni cultura specificate.</summary>
        <returns>Equivalente in caratteri minuscoli della stringa corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le regole di maiuscole e minuscole delle impostazioni cultura specificate per il `culture` parametro determinano la modalità di formattazione della stringa verrà modificata.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui tutti i caratteri nell'istanza corrente vengono convertiti in minuscolo.  
  
## <a name="security-considerations"></a>Considerazioni sulla sicurezza  
 Se si passa il <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> metodo un <xref:System.Globalization.CultureInfo> oggetto diverso da <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, l'operazione di maiuscole e minuscole per considerare le regole specifiche delle impostazioni cultura. Se è necessaria la versione maiuscola o minuscola di un identificatore di sistema operativo, ad esempio un nome file, named pipe o una chiave del Registro di sistema, utilizzare il <xref:System.String.ToLowerInvariant%2A> o <xref:System.String.ToUpperInvariant%2A> metodo. Questo produce lo stesso risultato in tutte le impostazioni cultura e lo esegue in modo più efficiente.  
  
   
  
## Examples  
 Nell'esempio seguente converte le due stringhe di caratteri maiuscoli in caratteri minuscoli utilizzando le impostazioni cultura italiano e turco (Turchia), quindi confronta le stringhe di caratteri minuscole. Le stringhe in maiuscolo sono identiche ad eccezione del fatto che per ogni occorrenza del Unicode LATIN CAPITAL LETTER I in una stringa, l'altra stringa contiene LATIN CAPITAL LETTER I con punto sopra.  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una copia dell'oggetto <see cref="T:System.String" /> convertito in caratteri minuscoli mediante le regole relative all'utilizzo di maiuscole e minuscole proprie delle impostazioni cultura invariabili.</summary>
        <returns>Equivalente in caratteri minuscoli della stringa corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La lingua inglese rappresenta impostazioni cultura che sono indipendente dalle impostazioni cultura. È associato con la lingua inglese, ma non con un paese o area. Per altre informazioni, vedere la proprietà <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.  
  
 Se l'applicazione dipende da nel caso di una stringa che cambia in modo prevedibile che è indipendente dalle impostazioni cultura correnti, utilizzare il <xref:System.String.ToLowerInvariant%2A> metodo. Il <xref:System.String.ToLowerInvariant%2A> metodo è equivalente a `ToLower(CultureInfo.InvariantCulture)`. Il metodo è consigliato per una raccolta di stringhe deve trovarsi in un ordine prestabilito in un controllo dell'interfaccia utente.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui tutti i caratteri nell'istanza corrente vengono convertiti in minuscolo.  
  
## <a name="security-considerations"></a>Considerazioni sulla sicurezza  
 Se è necessaria la versione maiuscola o minuscola di un identificatore di sistema operativo, ad esempio un nome file, named pipe o una chiave del Registro di sistema, utilizzare il <xref:System.String.ToLowerInvariant%2A> o <xref:System.String.ToUpperInvariant%2A> metodi.  
  
   
  
## Examples  
 L'esempio seguente definisce una matrice di stringhe che contiene una singola parola in un numero di lingue. Il <xref:System.String.ToLowerInvariant%2A> metodo viene utilizzato per compilare gli elementi di una matrice parallela con la versione di ogni parola tra maiuscole e minuscole. Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> metodo viene utilizzato per ordinare la matrice di distinzione maiuscole/minuscole in base all'ordine di elementi nella matrice di caratteri minuscolo per garantire che gli elementi vengono visualizzati nello stesso ordine indipendentemente dal linguaggio.  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte il valore di questa istanza in un oggetto <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce questa istanza di <see cref="T:System.String" />. Non viene eseguita alcuna conversione effettiva.</summary>
        <returns>Stringa corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poiché questo metodo restituisce semplicemente la stringa corrente invariata, non è necessario chiamarlo direttamente. Viene in genere chiamato in modo implicito in un'operazione, come illustrato nell'esempio di formattazione composita.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.String.ToString%2A> metodo. Si noti che nell'esempio viene chiamato in modo esplicito il <xref:System.String.ToString%2A> metodo. Al contrario, il metodo viene chiamato in modo implicito dal [formattazione composita](~/docs/standard/base-types/composite-formatting.md) funzionalità.  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(Riservato) Oggetto che fornisce informazioni di formattazione specifiche delle impostazioni cultura.</param>
        <summary>Restituisce questa istanza di <see cref="T:System.String" />. Non viene eseguita alcuna conversione effettiva.</summary>
        <returns>Stringa corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` è riservato e attualmente non fa parte di questa operazione.  
  
 Poiché questo metodo restituisce semplicemente la stringa corrente invariata, non è necessario chiamarlo direttamente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una copia di questa stringa convertita in caratteri maiuscoli.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una copia di questa stringa convertita in caratteri maiuscoli.</summary>
        <returns>Equivalente in caratteri maiuscoli della stringa corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo utilizza le regole di maiuscole e minuscole delle impostazioni cultura correnti per convertire ogni carattere nell'istanza corrente nell'equivalente maiuscolo. Se un carattere non ha un equivalente maiuscolo, viene incluso invariato nella stringa restituita.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui tutti i caratteri nell'istanza corrente vengono convertiti in maiuscolo.  
  
 Il <xref:System.String.ToUpper%2A> metodo viene spesso utilizzato per convertire una stringa in lettere maiuscole, in modo che può essere utilizzato in un confronto tra maiuscole e minuscole. Un metodo migliore per eseguire un confronto tra maiuscole e minuscole consiste nel chiamare un metodo di confronto tra stringhe con un <xref:System.StringComparison> parametro il cui valore è impostato su <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> per un confronto con distinzione delle impostazioni cultura senza distinzione tra maiuscole e minuscole.  
  
## <a name="security-considerations"></a>Considerazioni sulla sicurezza  
 L'operazione di maiuscole e minuscole risultante dalla chiamata di <xref:System.String.ToUpper> metodo considerando le convenzioni delle impostazioni cultura correnti. Se è necessaria la versione maiuscola o minuscola di un identificatore di sistema operativo, ad esempio un nome file, named pipe o una chiave del Registro di sistema, utilizzare il <xref:System.String.ToLowerInvariant%2A> o <xref:System.String.ToUpperInvariant%2A> metodo. Ciò produce lo stesso risultato in tutte le impostazioni cultura (a differenza di <xref:System.String.ToUpper> metodo) ed esegue in modo più efficiente.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.String.ToUpper%2A> metodo per convertire una serie di stringhe di un carattere che contengono ogni carattere nei set di caratteri esteso latino di base, Supplemento latino 1 e latina. Visualizza quindi ogni stringa i cui caratteri maiuscoli in caratteri è diverso dal carattere minuscolo.  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Come spiegato in [Best Practices for Strings](~/docs/standard/base-types/best-practices-strings.md) utilizzando, è consigliabile evitare di chiamare metodi di maiuscole e minuscole delle stringhe che sostituiscono i valori predefiniti e in alternativa, chiamano metodi che richiedono parametri per essere specificato in modo esplicito. Per convertire una stringa in lettere maiuscole utilizzando le convenzioni delle impostazioni cultura correnti, chiamare il <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> overload del metodo con un valore di <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> per il relativo <paramref name="culture" /> parametro.</para>
        </block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Oggetto che fornisce le regole specifiche delle impostazioni cultura sull'uso di maiuscole e minuscole.</param>
        <summary>Restituisce una copia di questa stringa convertita in caratteri maiuscoli, usando le regole relative all'utilizzo di maiuscole e minuscole proprie delle impostazioni cultura specificate.</summary>
        <returns>Equivalente in caratteri maiuscoli della stringa corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le regole di maiuscole e minuscole delle impostazioni cultura specificate per il `culture` parametro determinano il modo nel caso di una stringa vengono modificati.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui tutti i caratteri nell'istanza corrente vengono convertiti in maiuscolo.  
  
## <a name="security-considerations"></a>Considerazioni sulla sicurezza  
 Se si passa il <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> metodo un <xref:System.Globalization.CultureInfo> oggetto diverso da <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, l'operazione di maiuscole e minuscole per considerare le regole specifiche delle impostazioni cultura. Se è necessaria la versione maiuscola o minuscola di un identificatore di sistema operativo, ad esempio un nome file, named pipe o una chiave del Registro di sistema, utilizzare il <xref:System.String.ToLowerInvariant%2A> o <xref:System.String.ToUpperInvariant%2A> metodo. Questo produce lo stesso risultato in tutte le impostazioni cultura e lo esegue in modo più efficiente.  
  
   
  
## Examples  
 Nell'esempio seguente converte una stringa di caratteri minuscoli in due stringhe di caratteri maiuscoli utilizzando le impostazioni cultura italiano e turco (Turchia), quindi confronta le stringhe in maiuscolo. Le stringhe in maiuscolo sono identiche ad eccezione del fatto che per ogni occorrenza del Unicode LATIN CAPITAL LETTER I in una stringa, l'altra stringa contiene LATIN CAPITAL LETTER I con punto sopra.  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una copia dell'oggetto <see cref="T:System.String" /> convertito in caratteri maiuscoli mediante le regole relative all'utilizzo di maiuscole e minuscole proprie delle impostazioni cultura invariabili.</summary>
        <returns>Equivalente in caratteri maiuscoli della stringa corrente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La lingua inglese rappresenta impostazioni cultura che sono indipendente dalle impostazioni cultura. È associato con la lingua inglese, ma non con un paese o area. Per altre informazioni, vedere la proprietà <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.  
  
 Se l'applicazione dipende da nel caso di una stringa che cambia in modo prevedibile che è indipendente dalle impostazioni cultura correnti, utilizzare il <xref:System.String.ToUpperInvariant%2A> metodo. Il <xref:System.String.ToUpperInvariant%2A> metodo è equivalente a `ToUpper(CultureInfo.InvariantCulture)`. Il metodo è consigliato per una raccolta di stringhe deve trovarsi in un ordine prestabilito in un controllo dell'interfaccia utente.  
  
> [!NOTE]
>  Questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui tutti i caratteri nell'istanza corrente vengono convertiti in maiuscolo.  
  
## <a name="security-considerations"></a>Considerazioni sulla sicurezza  
 Se è necessaria la versione maiuscola o minuscola di un identificatore di sistema operativo, ad esempio un nome file, named pipe o una chiave del Registro di sistema, utilizzare il <xref:System.String.ToLowerInvariant%2A> o <xref:System.String.ToUpperInvariant%2A> metodi.  
  
   
  
## Examples  
 L'esempio seguente definisce una matrice di stringhe che contiene una singola parola in un numero di lingue. Il <xref:System.String.ToUpperInvariant%2A> metodo viene utilizzato per compilare gli elementi di una matrice parallela con la versione di ogni parola tra maiuscole e minuscole. Il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> metodo viene utilizzato per ordinare la matrice di distinzione maiuscole/minuscole in base all'ordine di elementi nella matrice in maiuscolo per assicurarsi che gli elementi vengono visualizzati nello stesso ordine indipendentemente dal linguaggio.  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una nuova stringa in cui vengono rimosse tutte le occorrenze iniziali e finali di un set di caratteri specificati contenuti nell'oggetto <see cref="T:System.String" /> corrente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove tutti gli spazi vuoti iniziali e finali dall'oggetto <see cref="T:System.String" /> corrente.</summary>
        <returns>Stringa risultante dopo che tutti gli spazi vuoti sono stati rimossi dall'inizio e dalla fine della stringa corrente. Se non è possibile rimuovere alcun carattere dall'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.Trim%2A> metodo rimuove dalla stringa corrente tutti i caratteri spazi vuoti iniziali e finali. Ogni operazione di taglio iniziali e finali si interrompe quando viene rilevato uno spazio vuoto. Se la stringa corrente è "abc xyz", ad esempio il <xref:System.String.Trim%2A> metodo restituisce "abc xyz". Per rimuovere i caratteri di spazio tra le parole in una stringa, utilizzare un [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
> [!NOTE]
>  Se il <xref:System.String.Trim%2A> metodo rimuove qualsiasi carattere dall'istanza corrente, questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui vengono rimossi tutti i caratteri spazi vuoti iniziali e finali trovati nell'istanza corrente.  
  
 Se la stringa corrente è uguale a <xref:System.String.Empty> o tutti i caratteri nell'istanza corrente è costituito da spazi vuoti, il metodo restituisce <xref:System.String.Empty>.  
  
 Gli spazi vuoti sono definiti dallo standard Unicode. Il <xref:System.String.Trim> metodo rimuove qualsiasi carattere iniziali e finali che producono un valore restituito di `true` quando vengono passati al <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> metodo.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.String.Trim?displayProperty=nameWithType> per rimuovere qualsiasi spazio vuoto aggiuntivo da immessi dall'utente prima della concatenazione di stringhe.  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Il [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e versioni precedenti viene mantenuto un elenco interno di spazi vuoti rimossi da questo metodo. A partire da di [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)], il metodo elimina tutti gli spazi vuoti Unicode (ovvero caratteri che producono un <see langword="true" /> valore restituito, se vengono passati al <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> (metodo)). Grazie a questa modifica, la <see cref="M:System.String.Trim" /> metodo di [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e versioni precedenti rimuove due caratteri, spazio di larghezza ZERO (U + 200B) e spazio unificatore di larghezza ZERO (U + FEFF), che il <see cref="M:System.String.Trim" /> metodo di [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)] e versioni successive non vengono rimossi. Inoltre, il <see cref="M:System.String.Trim" /> metodo di [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e le versioni precedenti non trim spazi vuoti Unicode: MONGOLO vocale separatore (U + 180E), "narrow" senza interruzione spazio (U + 202F) e MEDIUM MATHEMATICAL SPACE (U + 205F).</para>
        </block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Matrice di caratteri Unicode da rimuovere oppure <see langword="null" />.</param>
        <summary>Rimuove dall'oggetto <see cref="T:System.String" /> corrente tutte le occorrenze iniziali e finali di un set di caratteri specificati in una matrice.</summary>
        <returns>Stringa risultante dopo che tutte le occorrenze dei caratteri specificati nel parametro <paramref name="trimChars" /> sono state rimosse dall'inizio e dalla fine della stringa corrente. Se <paramref name="trimChars" /> è <see langword="null" /> o una matrice vuota, verranno rimossi invece gli spazi vuoti. Se non è possibile rimuovere alcun carattere dall'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.Trim%2A> metodo rimuove dalla stringa corrente tutti i caratteri iniziali e finali presenti il `trimChars` parametro. Ogni iniziali e finali trim operazione si arresta un carattere che non si trova in `trimChars` viene rilevato. Ad esempio, se la stringa corrente è "123abc456xyz789" e `trimChars` contiene le cifre da "1" e "9", il <xref:System.String.Trim%2A> metodo restituisce "abc456xyz".  
  
> [!NOTE]
>  Se il <xref:System.String.Trim%2A> metodo rimuove qualsiasi carattere dall'istanza corrente, questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui tutte le iniziali e finali `trimChars` caratteri trovati nell'istanza corrente vengono rimossi.  
  
 Se la stringa corrente è uguale a <xref:System.String.Empty> o tutti i caratteri nell'istanza corrente è costituito da caratteri di `trimChars` matrice, il metodo restituisce <xref:System.String.Empty>.  
  
 Se `trimChars` è `null` o una matrice vuota, questo metodo rimuove qualsiasi carattere iniziali o finali che comporta la restituzione del metodo `true` quando vengono passati al <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> , metodo  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> metodo per rimuovere i caratteri apostrofo ('), asterisco (*) e lo spazio da una stringa.  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Il [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e le versioni precedenti mantiene un elenco di spazi vuoti rimossi da questo metodo se interno <paramref name="trimChars" /> è <see langword="null" /> o una matrice vuota. A partire da di [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)], se <paramref name="trimChars" /> viene <see langword="null" /> o una matrice vuota, il metodo elimina tutti gli spazi vuoti Unicode (caratteri che producono un <see langword="true" /> valore restituito, se vengono passati al <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> (metodo)). Grazie a questa modifica, la <see cref="M:System.String.Trim" /> metodo di [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e versioni precedenti rimuove due caratteri, spazio di larghezza ZERO (U + 200B) e spazio unificatore di larghezza ZERO (U + FEFF), che il <see cref="M:System.String.Trim" /> metodo di [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)] e versioni successive non vengono rimossi. Inoltre, il <see cref="M:System.String.Trim" /> metodo di [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e le versioni precedenti non trim spazi vuoti Unicode: MONGOLO vocale separatore (U + 180E), "narrow" senza interruzione spazio (U + 202F) e MEDIUM MATHEMATICAL SPACE (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Matrice di caratteri Unicode da rimuovere oppure <see langword="null" />.</param>
        <summary>Rimuove dall'oggetto <see cref="T:System.String" /> corrente tutte le occorrenze finali di un set di caratteri specificati in una matrice.</summary>
        <returns>Stringa risultante dopo che tutte le occorrenze dei caratteri specificati nel parametro <paramref name="trimChars" /> sono state rimosse dalla fine della stringa corrente. Se <paramref name="trimChars" /> è <see langword="null" /> o se è una matrice vuota, verranno rimossi invece gli spazi vuoti Unicode. Se non è possibile rimuovere alcun carattere dall'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.TrimEnd%2A> metodo rimuove dalla stringa corrente tutti i caratteri finali presenti il `trimChars` parametro. L'operazione di taglio si interrompe quando il primo carattere che non è in `trimChars` viene rilevato alla fine della stringa. Ad esempio, se la stringa corrente è "123abc456xyz789" e `trimChars` contiene le cifre da "1" e "9", il <xref:System.String.TrimEnd%2A> metodo restituirà "123abc456xyz".  
  
> [!NOTE]
>  Se il <xref:System.String.TrimEnd%2A> metodo rimuove qualsiasi carattere dall'istanza corrente, questo metodo non modifica il valore dell'istanza corrente. Restituisce invece una nuova stringa in cui tutti i caratteri finali trovati `trimChars` vengono rimosse dalla stringa corrente.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.String.TrimEnd%28System.Char%5B%5D%29> metodo per eliminare gli spazi o segni di punteggiatura dalla fine di una stringa.  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Il [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e le versioni precedenti mantiene un elenco di spazi vuoti rimossi da questo metodo se interno <paramref name="trimChars" /> è <see langword="null" /> o una matrice vuota. A partire da di [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)], se <paramref name="trimChars" /> viene <see langword="null" /> o una matrice vuota, il metodo elimina tutti gli spazi vuoti Unicode (caratteri che producono un <see langword="true" /> valore restituito, se vengono passati al <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> (metodo)). Grazie a questa modifica, la <see cref="M:System.String.Trim" /> metodo di [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e versioni precedenti rimuove due caratteri, spazio di larghezza ZERO (U + 200B) e spazio unificatore di larghezza ZERO (U + FEFF), che il <see cref="M:System.String.Trim" /> metodo di [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)] e versioni successive non vengono rimossi. Inoltre, il <see cref="M:System.String.Trim" /> metodo di [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e le versioni precedenti non trim spazi vuoti Unicode: MONGOLO vocale separatore (U + 180E), "narrow" senza interruzione spazio (U + 202F) e MEDIUM MATHEMATICAL SPACE (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Matrice di caratteri Unicode da rimuovere oppure <see langword="null" />.</param>
        <summary>Rimuove dall'oggetto <see cref="T:System.String" /> corrente tutte le occorrenze iniziali di un set di caratteri specificati in una matrice.</summary>
        <returns>Stringa risultante dopo che tutte le occorrenze dei caratteri specificati nel parametro <paramref name="trimChars" /> sono state rimosse dall'inizio della stringa corrente. Se <paramref name="trimChars" /> è <see langword="null" /> o una matrice vuota, verranno rimossi invece gli spazi vuoti.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.String.TrimStart%2A> metodo rimuove dalla stringa corrente in tutti i caratteri iniziali di `trimChars` parametro. L'operazione di taglio si arresta quando un carattere che non si trova in `trimChars` viene rilevato. Ad esempio, se la stringa corrente è "123abc456xyz789" e `trimChars` contiene le cifre da "1" e "9", il <xref:System.String.TrimStart%2A> metodo restituisce "abc456xyz789".  
  
> [!NOTE]
>  Se il <xref:System.String.TrimStart%2A> metodo rimuove qualsiasi carattere dall'istanza corrente, questo metodo non modifica il valore dell'istanza corrente. Al contrario, restituisce una nuova stringa in cui vengono rimossi tutti i caratteri spazi vuoti iniziali trovati nell'istanza corrente.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.String.TrimStart%2A> metodo per rimuovere gli spazi vuoti e caratteri di commento dalle righe del codice sorgente. Il `StripComments` metodo esegue il wrapping di una chiamata a <xref:System.String.TrimStart%2A> e passa una matrice di caratteri che contiene uno spazio e il carattere di commento, ovvero un apostrofo (') in Visual Basic e una barra (/) in c#. Il <xref:System.String.TrimStart%2A> metodo viene chiamato anche per rimuovere gli spazi vuoti iniziali quando si valuta se una stringa è un commento.  
  
 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]  
  
 Nell'esempio seguente viene illustrata una chiamata al metodo `StripComments`.  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Il [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e le versioni precedenti mantiene un elenco di spazi vuoti rimossi da questo metodo se interno <paramref name="trimChars" /> è <see langword="null" /> o una matrice vuota. A partire da di [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)], se <paramref name="trimChars" /> viene <see langword="null" /> o una matrice vuota, il metodo elimina tutti gli spazi vuoti Unicode (caratteri che producono un <see langword="true" /> valore restituito, se vengono passati al <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> (metodo)). Grazie a questa modifica, la <see cref="M:System.String.Trim" /> metodo di [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e versioni precedenti rimuove due caratteri, spazio di larghezza ZERO (U + 200B) e spazio unificatore di larghezza ZERO (U + FEFF), che il <see cref="M:System.String.Trim" /> metodo di [! INCLUDE[net_v40_short](~/Includes/NET-v40-short-MD.MD)] e versioni successive non vengono rimossi. Inoltre, il <see cref="M:System.String.Trim" /> metodo di [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-short-MD.MD)] e le versioni precedenti non trim spazi vuoti Unicode: MONGOLO vocale separatore (U + 180E), "narrow" senza interruzione spazio (U + 202F) e MEDIUM MATHEMATICAL SPACE (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>